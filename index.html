<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="google-site-verification" content="E2yuICa6eKYqirbpWGXo9DtwvVG9mlCf_g56Qzpse2M" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keycap Generator V63.3.1</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 306.06 217.55'%3E%3Cstyle%3E.a%7Bstroke:%23ccc;stroke-miterlimit:10;fill:none%7D.b%7Bfill:aqua;stroke:aqua;stroke-miterlimit:10%7D.c%7Bstroke:aqua;stroke-miterlimit:10;fill:none;stroke-width:4px%7D.d%7Bfill:%23b3b3b3%7D%3C/style%3E%3Cpolygon class='d' points='273.2 41.92 305.59 144.63 149.26 216.93 148.91 216.18 151.25 80.26 273.2 41.92'/%3E%3Cpolygon class='d' points='273.2 41.92 151.25 80.26 35.16 29.06 152.73 .49 273.2 41.92'/%3E%3Cpolygon class='d' points='151.25 80.26 148.91 216.18 .25 136.62 .61 135.77 35.16 29.06 151.25 80.26'/%3E%3Cline class='a' x1='35.16' y1='29.06' x2='.61' y2='135.77'/%3E%3Cline class='a' x1='.25' y1='136.62' x2='148.91' y2='216.18'/%3E%3Cline class='a' x1='151.25' y1='80.26' x2='35.16' y2='29.06'/%3E%3Cline class='a' x1='148.91' y1='216.18' x2='151.25' y2='80.26'/%3E%3Cline class='a' x1='273.2' y1='41.92' x2='151.25' y2='80.26'/%3E%3Cline class='a' x1='305.59' y1='144.63' x2='273.2' y2='41.92'/%3E%3Cpolyline class='a' points='148.91 217.1 149.26 216.93 305.59 144.63'/%3E%3Cline class='a' x1='152.73' y1='.49' x2='273.2' y2='41.92'/%3E%3Cline class='a' x1='152.73' y1='.49' x2='35.16' y2='29.06'/%3E%3Cline class='c' x1='86.1' y1='30.23' x2='119.97' y2='22'/%3E%3Cline class='c' x1='155.68' y1='60.92' x2='86.1' y2='30.23'/%3E%3Cline class='c' x1='224.32' y1='40.72' x2='154.45' y2='60.92'/%3E%3Cline class='c' x1='224.32' y1='41.22' x2='198.07' y2='32.19'/%3E%3Cpath class='b' d='M167.62,24.24s-20.08-4.1-28.79,0c-8.7,4.1,7.85-6.02,3.19-9.13s11.8,5.35,23.8.19c12-5.15-13.25,5.77,1.79,8.94Z'/%3E%3Cpath class='b' d='M169.51,46.26s-18.64-3.8-26.72,0c-8.08,3.8,7.29-5.59,2.96-8.48-4.32-2.88,10.96,4.96,22.1.18,11.14-4.78-12.3,5.36,1.66,8.3Z'/%3E%3Cpath class='b' d='M134.59,37.59s-10.53-2.15-15.09,0,4.12-3.16,1.67-4.79c-2.44-1.63,6.19,2.8,12.48.1,6.29-2.7-6.94,3.03.94,4.69Z'/%3E%3C/svg%3E">
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: rgba(30, 30, 30, 0.98);
            --text-main: #e0f7fa;
            --text-muted: #80deea;
            --accent: #00e5ff;
            --accent-hover: #84ffff;
            --border: #444;
            --input-bg: #263238;
            --danger: #ff5252;
            --sub-bg: rgba(0, 229, 255, 0.05); 
            --import-bg: rgba(255, 152, 0, 0.05);
            --texture-bg: rgba(233, 30, 99, 0.05);
            --highlight: rgba(255, 235, 59, 0.3);
        }

        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: var(--bg-color); color: var(--text-main); }
        
        #canvas-container { 
            position: absolute; left: 400px; width: calc(100% - 400px); height: 100%; top: 0; z-index: 1; 
            transition: all 0.3s ease; 
        }
        
        #ui-panel {
            position: absolute; left: 0; top: 0; width: 400px; height: 100%;
            background: var(--panel-bg); border-right: 1px solid var(--border);
            box-sizing: border-box; 
            display: flex; flex-direction: column; 
            box-shadow: 4px 0 15px rgba(0,0,0,0.6); z-index: 2;
            padding: 0; transition: transform 0.3s ease;
        }

        body.ui-closed #ui-panel { transform: translateX(-400px); }
        body.ui-closed #canvas-container { left: 0 !important; width: 100% !important; }

        #ui-header-area { flex: 0 0 auto; padding: 15px 15px 5px 15px; background: var(--panel-bg); border-bottom: 1px solid #333; z-index: 10; }
        #ui-scroll-area { flex: 1; overflow-y: auto; padding: 10px 15px 30px 15px; scroll-behavior: smooth; }
        #ui-scroll-area::-webkit-scrollbar { width: 6px; }
        #ui-scroll-area::-webkit-scrollbar-thumb { background: #006064; border-radius: 3px; }

        #top-right-panel {
            position: absolute; top: 10px; right: 10px; width: 260px;
            background: rgba(20, 20, 20, 0.95); border: 1px solid var(--accent);
            padding: 12px 12px 12px 50px; border-radius: 6px; z-index: 10;
            box-shadow: -4px 4px 15px rgba(0,0,0,0.5); font-family: monospace; transition: all 0.3s ease;
        }
        #top-right-panel:hover { background: rgba(30, 30, 30, 0.98); box-shadow: -4px 4px 20px rgba(0,229,255,0.2); }
        #top-right-panel.stats-collapsed { height: 36px; width: 36px; min-width: 0; padding: 0; overflow: hidden; border: none; background: transparent; box-shadow: none; }
        #top-right-panel.stats-collapsed .cost-row, #top-right-panel.stats-collapsed .fil-control, #top-right-panel.stats-collapsed #btn-toggle-fil, #top-right-panel.stats-collapsed #info-fil-name, #top-right-panel.stats-collapsed #fil-details-panel { display: none; }

        .cost-row { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 1.0rem; border-bottom: 1px solid #333; padding-bottom: 4px; }
        .cost-val { color: var(--accent); font-weight: bold; }
        .cost-sub { font-size: 0.75rem; color: #aaa; text-align: right; margin-bottom: 10px; }
        .fil-control { margin-top: 8px; }
        .fil-control label { color: #b2ff59; font-size: 0.75rem; margin-bottom: 2px; display: block; }
        .fil-control select { width: 100%; padding: 5px; font-size: 0.85rem; background: #111; border: 1px solid #555; color: #fff; margin-bottom: 5px; border-radius: 4px; cursor: pointer; }
        .fil-details { display: none; margin-top: 8px; padding-top: 8px; border-top: 1px dashed #444; background: rgba(255,255,255,0.02); padding: 5px; border-radius: 4px; }
        .fil-details.open { display: block; animation: fadeIn 0.2s; }
        .fil-input-row { display: flex; gap: 5px; margin-bottom: 5px; align-items: center; }
        .fil-input-row label { width: 45px; color: #aaa; font-size: 0.7rem; margin: 0; }
        .fil-input-row input { flex: 1; min-width: 0; background: #222; border: 1px solid #444; color: #fff; padding: 4px; font-size: 0.8rem; text-align: right; border-radius: 2px; }
        #btn-toggle-fil { width: 100%; padding: 4px; font-size: 0.75rem; background: transparent; border: 1px solid #333; color: #aaa; cursor: pointer; border-radius: 4px; transition: 0.2s; margin-top: 5px; }
        #btn-toggle-fil:hover { color: #fff; border-color: #777; background: rgba(255,255,255,0.05); }

        .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .title-block { display: flex; align-items: center; gap: 10px; }
        #app-logo { height: 45px; width: auto; cursor: pointer; transition: transform 0.2s, filter 0.2s; filter: drop-shadow(0 0 2px rgba(0, 229, 255, 0.3)); }
        #app-logo:hover { transform: scale(1.1); filter: drop-shadow(0 0 5px rgba(0, 229, 255, 0.8)); }
        h2 { margin: 0; color: var(--accent); font-size: 1.3rem; line-height: 1.1; }
        .ver { font-size: 0.65rem; color: var(--text-muted); opacity: 0.8; display: block; }
        #language-select { background: var(--input-bg); border: 1px solid var(--border); color: var(--text-main); padding: 4px 8px; border-radius: 4px; font-size: 0.85rem; cursor: pointer; }

        #nav-bar { display: flex; flex-direction: column; gap: 5px; margin-bottom: 5px; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px; border: 1px solid #333; }
        .nav-row { display: flex; gap: 5px; }
        #section-select { flex: 1; background: #222; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 4px; font-size: 0.85rem; cursor: pointer; }
        #section-select:hover { border-color: var(--accent); }
        #search-box { flex: 1; background: #222; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 4px 8px; font-size: 0.85rem; }
        #search-box:focus { border-color: var(--accent); outline: none; }
        .search-highlight { background-color: var(--highlight); color: #000 !important; border-radius: 2px; padding: 0 2px; transition: 0.3s; }

        h3 { font-size: 0.85rem; border-bottom: 1px solid var(--accent); margin-top: 15px; padding-bottom: 3px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; scroll-margin-top: 10px; }
        .control-group { margin-bottom: 6px; }
        .control-row { display: flex; gap: 8px; align-items: center; margin-bottom: 4px; }
        label { font-size: 0.75rem; display: flex; justify-content: space-between; color: #b2ebf2; margin-bottom: 2px; align-items: center; white-space: nowrap; }
        span.val { color: var(--accent); font-family: monospace; font-size: 0.9rem; font-weight: bold; min-width: 35px; text-align: right; display: inline-block; }
        
        input.direct-input { width: 50px; background: #000; border: 1px solid var(--accent); color: var(--accent); font-family: monospace; font-size: 0.9rem; text-align: right; padding: 2px 4px; display: none; z-index:100; }
        input[type="range"] { width: 100%; margin: 4px 0; cursor: pointer; appearance: none; background: transparent; }
        input[type="range"]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #006064; border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: var(--accent); margin-top: -5px; box-shadow: 0 0 5px var(--accent); transition: 0.2s; }
        input[type="range"]:disabled { opacity: 0.3; cursor: not-allowed; }
        select, input[type="text"], textarea { width: 100%; background: var(--input-bg); border: 1px solid #00838f; color: white; padding: 6px; border-radius: 4px; font-size: 0.85rem; font-family: sans-serif; box-sizing: border-box; }
        textarea { resize: vertical; min-height: 40px; }
        
        .toggle-switch { display: flex; align-items: center; gap: 8px; cursor: pointer; justify-content: start; width: 100%; margin-bottom: 4px; }
        .toggle-input { display: none; }
        .toggle-knob { width: 36px; height: 18px; background: #444; border-radius: 9px; position: relative; transition: 0.3s; border:1px solid #666; flex-shrink: 0; }
        .toggle-knob::after { content:''; position:absolute; left:2px; top:2px; width:12px; height:12px; background:white; border-radius:50%; transition:0.3s; }
        .toggle-input:checked + .toggle-knob { background: var(--accent); border-color:var(--accent); }
        .toggle-input:checked + .toggle-knob::after { left: 20px; background: black; }
        .toggle-label { color: #e0f7fa; font-size: 0.8rem; user-select: none; }

        .file-upload { position: relative; display: inline-block; width: 100%; }
        .file-upload input[type="file"] { display: none; }
        .file-upload-label { display: block; width: 100%; padding: 8px; background: #004d40; border: 1px dashed #00e5ff; color: #e0f7fa; text-align: center; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: 0.3s; box-sizing: border-box; }
        .file-upload-label:hover { background: #006064; }
        .file-upload-label.preset { background: #37474f; border-color: #90a4ae; color: #eceff1; }
        .file-upload-label.preset:hover { background: #455a64; }

        button { width: 100%; background: transparent; border: 1px solid var(--accent); padding: 10px; color: var(--accent); font-weight: bold; cursor: pointer; border-radius: 4px; margin-top: 5px; transition: 0.2s; text-transform: uppercase; font-size: 0.8rem; }
        button:hover { background: var(--accent); color: #000; box-shadow: 0 0 10px var(--accent); }
        button:disabled { border-color: #555; color: #555; background: rgba(0,0,0,0.5); cursor: not-allowed; box-shadow: none; }
        button.secondary { border-color: #555; color: #aaa; }
        button.secondary:hover { background: #555; color: white; }
        button.danger { border-color: var(--danger); color: var(--danger); margin-top:0; padding: 0; }
        button.danger:hover { background: var(--danger); color: white; }
        button.accent { background: rgba(0, 229, 255, 0.1); }
        button.accent:hover { background: var(--accent); color: black; }
        button.primary-3mf { border-color: #4caf50; color: #4caf50; background: rgba(76, 175, 80, 0.1); }
        button.primary-3mf:hover { background: #4caf50; color: white; }
        .btn-square { width: 34px; height: 34px; display: flex; justify-content: center; align-items: center; font-size: 1.2rem; margin: 0; flex-shrink: 0; }
        .btn-small { padding: 6px; font-size: 0.75rem; margin-top: 0; }

        .color-input { -webkit-appearance: none; border: none; width: 100%; height: 30px; cursor: pointer; padding: 0; background: none; }
        .palette-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-top: 6px; }
        .palette-swatch { width: 100%; padding-bottom: 60%; border-radius: 3px; cursor: pointer; border: 1px solid #555; transition: transform 0.1s; }
        .palette-swatch:hover { transform: scale(1.1); border-color: white; z-index: 10; box-shadow: 0 0 8px rgba(255,255,255,0.5); }

        #history-controls { position: absolute; top: 10px; left: 450px; z-index: 10; display: flex; gap: 5px; transition: all 0.3s ease; }
        .hist-btn { background: rgba(0,0,0,0.8); border: 1px solid var(--accent); color: var(--accent); width: 40px; height: 40px; border-radius: 4px; font-size: 1.2rem; cursor: pointer; display: flex; justify-content: center; align-items: center; padding: 0; margin: 0; }
        .hist-btn:hover { background: var(--accent); color: #000; }
        .hist-btn:disabled { border-color: #555; color: #555; background: rgba(0,0,0,0.5); }
        #render-mode-controls { position: absolute; top: 60px; left: 450px; z-index: 10; width: 120px; transition: all 0.3s ease; }
        #render-mode-controls select { background: rgba(0,0,0,0.8); border: 1px solid var(--accent); color: var(--accent); padding: 5px; cursor: pointer; width: 100%; }
        body.ui-closed #history-controls { left: 50px; top: 10px; }
        body.ui-closed #render-mode-controls { left: 50px; top: 60px; }

        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; color: var(--accent); font-size: 1.5rem; transition: opacity 0.5s; }
        #force-start-btn { margin-top: 20px; padding: 10px 20px; border: 1px solid white; color: white; background: transparent; cursor: pointer; display: none; }
        #error-log { color:#ff5252; font-size:0.9rem; margin-top:10px; max-width:80%; font-family:monospace; white-space: pre-wrap; }
        #batch-progress { margin-top: 20px; font-size: 1rem; color: var(--text-main); display: none; }

        .info-link { font-size: 0.75rem; color: #aaa; margin-bottom: 6px; line-height: 1.3; }
        .info-link a { color: var(--accent); text-decoration: none; }
        .custom-select-container { position: relative; width: 100%; }
        .custom-select-head { background: var(--input-bg); border: 1px solid #00838f; color: white; padding: 8px; border-radius: 4px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; }
        .custom-select-list { position: absolute; top: 100%; left: 0; right: 0; background: #1e272c; border: 1px solid var(--accent); border-top: none; z-index: 999; max-height: 200px; overflow-y: auto; display: none; border-radius: 0 0 4px 4px; }
        .custom-select-list.open { display: block; }
        .custom-option { padding: 8px; cursor: pointer; font-size: 0.85rem; border-bottom: 1px solid #333; }
        .custom-option:hover { background: rgba(0, 229, 255, 0.2); color: white; }
        .custom-option.selected { background: var(--accent); color: black; font-weight: bold; }

        .section-sep { border-top: 1px solid #333; margin: 15px 0 5px 0; }
        .v60-sub-panel { background: var(--sub-bg); padding: 8px; border-radius: 4px; border: 1px dashed #444; margin-top: 5px; }
        .v60-import-panel { background: var(--import-bg); padding: 8px; border-radius: 4px; border: 1px dashed #ff9800; margin-top: 5px; }
        .v60-label { color: #ffeb3b; font-weight: bold; }
        .v60-label-side { color: #b2ff59; font-weight: bold; }
        .v61-texture-panel { background: var(--texture-bg); padding: 8px; border-radius: 4px; border: 1px dashed #e91e63; margin-top: 5px; }
        .v63-texture-map-panel { background: rgba(156, 39, 176, 0.05); padding: 8px; border-radius: 4px; border: 1px dashed #ba68c8; margin-top: 5px; }

        #btn-toggle-ui { position: absolute; left: 400px; top: 10px; z-index: 20; width: 30px; height: 40px; border-radius: 0 4px 4px 0; background: var(--panel-bg); color: var(--accent); border: 1px solid var(--border); border-left: none; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: all 0.3s ease; font-weight: bold; font-size: 1.2rem; font-family: "Segoe UI Symbol", sans-serif; }
        #btn-toggle-ui:hover { background: #333; color: #fff; }
        body.ui-closed #btn-toggle-ui { left: 0; background: rgba(0,0,0,0.5); }
        #btn-toggle-stats { position: absolute; top: 5px; left: 5px; width: 36px; height: 36px; border: 1px solid var(--accent); background: rgba(0, 0, 0, 0.5); color: var(--accent); cursor: pointer; font-weight: bold; z-index: 11; font-size: 1.2rem; line-height: 1; padding: 0; border-radius: 4px; display: flex; justify-content: center; align-items: center; transition: all 0.2s ease; font-family: "Segoe UI Symbol", sans-serif; }
        #btn-toggle-stats:hover { background: var(--accent); color: #000; }
        #top-right-panel.stats-collapsed #btn-toggle-stats { top: 0; left: 0; border-color: #555; color: #aaa; background: rgba(0,0,0,0.8); }
        #top-right-panel.stats-collapsed #btn-toggle-stats:hover { border-color: var(--accent); color: var(--accent); }
        .social-links { display: flex; gap: 10px; align-items: center; margin-right: 10px; }
        .social-icon { width: 32px; height: 32px; cursor: pointer; transition: transform 0.2s, filter 0.2s; fill: var(--text-muted); }
        .social-icon:hover { transform: scale(1.2); filter: drop-shadow(0 0 5px var(--accent)); fill: var(--accent); }
        .social-icon.github-icon path { fill: var(--text-muted); transition: fill 0.2s; }
        .social-icon.github-icon:hover path { fill: var(--accent); }

        #toast-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 2000; display: flex; flex-direction: column; gap: 10px; pointer-events: none; }
        .toast { background: rgba(0, 0, 0, 0.85); color: #e0f7fa; padding: 10px 20px; border-radius: 4px; border: 1px solid var(--accent); box-shadow: 0 4px 15px rgba(0,0,0,0.5); font-size: 0.9rem; opacity: 0; transform: translateY(20px); transition: all 0.3s ease; pointer-events: auto; text-align: center; }
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.error { border-color: var(--danger); color: #ffeb3b; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "three-bvh-csg": "https://unpkg.com/three-bvh-csg@0.0.16/build/index.module.js",
                "three-mesh-bvh": "https://unpkg.com/three-mesh-bvh@0.7.3/build/index.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="toast-container"></div>
    <div id="loading">
        <div>Initializing V63.3.1...</div>
        <div id="error-log"></div>
        <div id="batch-progress"></div>
        <button id="force-start-btn">FORCE START</button>
    </div>

    <div id="top-right-panel">
        <button id="btn-toggle-stats" title="Toggle Stats">ï¼</button> 
        <div class="cost-row"><span data-i18n="lbl_weight">Est. Weight:</span><span class="cost-val"><span id="info-weight">0.00</span> g</span></div>
        <div class="cost-row"><span data-i18n="lbl_cost">Est. Cost:</span><span class="cost-val"><span id="info-currency">Â¥</span> <span id="info-cost">0</span></span></div>
        <div class="cost-sub" id="info-fil-name" style="margin-bottom:10px;">Select Material</div>
        <div class="fil-control"><label data-i18n="lbl_vendor">Vendor:</label><select id="fil-vendor"></select></div>
        <div class="fil-control"><label data-i18n="lbl_material">Material:</label><select id="fil-material"></select></div>
        <button id="btn-toggle-fil" data-i18n="btn_details">â–¼ Details / Edit</button>
        <div class="fil-details" id="fil-details-panel">
            <div style="font-size:0.7rem; color:#80deea; margin-bottom:5px;" data-i18n="lbl_manual_override">Manual Override</div>
            <div class="fil-input-row"><label data-i18n="lbl_price">Price</label><input type="number" id="fil-price" placeholder="Price"></div>
            <div class="fil-input-row"><label data-i18n="lbl_spool">Spool</label><input type="number" id="fil-capacity" placeholder="g"></div>
            <div class="fil-input-row"><label data-i18n="lbl_density">Dens.</label><input type="number" id="fil-density" placeholder="g/cm3" step="0.01"></div>
            <div style="text-align:right; font-size:0.65rem; color:#555; margin-top:2px;">*Updates calculations instantly</div>
        </div>
    </div>

    <div id="history-controls">
        <button class="hist-btn" id="btn-undo" title="Undo" disabled>â†©</button>
        <button class="hist-btn" id="btn-redo" title="Redo" disabled>â†ª</button>
    </div>

    <div id="render-mode-controls">
        <select id="render-mode">
            <option value="standard">Standard</option>
            <option value="wireframe">Wireframe</option>
        </select>
    </div>

    <div id="canvas-container"></div>
    <button id="btn-toggle-ui" title="Toggle Sidebar">â—€</button>

    <div id="ui-panel">
        <div id="ui-header-area">
            <div class="header-row">
                <div class="title-block">
                    <svg id="app-logo" onclick="location.reload()" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 306.06 217.55">
                         <defs><style>.cls-1{stroke:#ccc;}.cls-1,.cls-2,.cls-3{stroke-miterlimit:10;}.cls-1,.cls-3{fill:none;}.cls-2{fill:aqua;}.cls-2,.cls-3{stroke:aqua;}.cls-3{stroke-width:4px;}.cls-4{fill:#b3b3b3;}</style></defs><g><g><polygon class="cls-4" points="273.2 41.92 305.59 144.63 149.26 216.93 148.91 216.18 151.25 80.26 273.2 41.92"/><polygon class="cls-4" points="273.2 41.92 151.25 80.26 35.16 29.06 152.73 .49 273.2 41.92"/><polygon class="cls-4" points="151.25 80.26 148.91 216.18 .25 136.62 .61 135.77 35.16 29.06 151.25 80.26"/></g><g><line class="cls-1" x1="35.16" y1="29.06" x2=".61" y2="135.77"/><line class="cls-1" x1=".25" y1="136.62" x2="148.91" y2="216.18"/><line class="cls-1" x1="151.25" y1="80.26" x2="35.16" y2="29.06"/><line class="cls-1" x1="148.91" y1="216.18" x2="151.25" y2="80.26"/><line class="cls-1" x1="273.2" y1="41.92" x2="151.25" y2="80.26"/><line class="cls-1" x1="305.59" y1="144.63" x2="273.2" y2="41.92"/><polyline class="cls-1" points="148.91 217.1 149.26 216.93 305.59 144.63"/><line class="cls-1" x1="152.73" y1=".49" x2="273.2" y2="41.92"/><line class="cls-1" x1="152.73" y1=".49" x2="35.16" y2="29.06"/></g></g><g><line class="cls-3" x1="86.1" y1="30.23" x2="119.97" y2="22"/><line class="cls-3" x1="155.68" y1="60.92" x2="86.1" y2="30.23"/><line class="cls-3" x1="224.32" y1="40.72" x2="154.45" y2="60.92"/><line class="cls-3" x1="224.32" y1="41.22" x2="198.07" y2="32.19"/><path class="cls-2" d="M167.62,24.24s-20.08-4.1-28.79,0c-8.7,4.1,7.85-6.02,3.19-9.13s11.8,5.35,23.8.19c12-5.15-13.25,5.77,1.79,8.94Z"/><path class="cls-2" d="M169.51,46.26s-18.64-3.8-26.72,0c-8.08,3.8,7.29-5.59,2.96-8.48-4.32-2.88,10.96,4.96,22.1.18,11.14-4.78-12.3,5.36,1.66,8.3Z"/></g>
                    </svg>
                    <div><h2>Keycap Gen</h2><span class="ver">V63.3.1</span></div>
                </div>
                <div style="display:flex; align-items:center;">
                    <div class="social-links">
                        <a href="https://keycapgeneratorwiki.com/" target="_blank" id="link-wiki" title="Go to Wiki"><svg class="social-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 306.06 217.55"><defs><style>.cls-1{stroke:#ccc;}.cls-1,.cls-2,.cls-3{stroke-miterlimit:10;}.cls-1,.cls-3{fill:none;}.cls-2{fill:aqua;}.cls-2,.cls-3{stroke:aqua;}.cls-3{stroke-width:4px;}.cls-4{fill:#b3b3b3;}</style></defs><g><g><polygon class="cls-4" points="273.2 41.92 305.59 144.63 149.26 216.93 148.91 216.18 151.25 80.26 273.2 41.92"/><polygon class="cls-4" points="273.2 41.92 151.25 80.26 35.16 29.06 152.73 .49 273.2 41.92"/><polygon class="cls-4" points="151.25 80.26 148.91 216.18 .25 136.62 .61 135.77 35.16 29.06 151.25 80.26"/></g><g><line class="cls-1" x1="35.16" y1="29.06" x2=".61" y2="135.77"/><line class="cls-1" x1=".25" y1="136.62" x2="148.91" y2="216.18"/><line class="cls-1" x1="151.25" y1="80.26" x2="35.16" y2="29.06"/><line class="cls-1" x1="148.91" y1="216.18" x2="151.25" y2="80.26"/><line class="cls-1" x1="273.2" y1="41.92" x2="151.25" y2="80.26"/><line class="cls-1" x1="305.59" y1="144.63" x2="273.2" y2="41.92"/><polyline class="cls-1" points="148.91 217.1 149.26 216.93 305.59 144.63"/><line class="cls-1" x1="152.73" y1=".49" x2="273.2" y2="41.92"/><line class="cls-1" x1="152.73" y1=".49" x2="35.16" y2="29.06"/></g></g><g><line class="cls-3" x1="86.1" y1="30.23" x2="119.97" y2="22"/><line class="cls-3" x1="155.68" y1="60.92" x2="86.1" y2="30.23"/><line class="cls-3" x1="224.32" y1="40.72" x2="154.45" y2="60.92"/><line class="cls-3" x1="224.32" y1="41.22" x2="198.07" y2="32.19"/><path class="cls-2" d="M167.62,24.24s-20.08-4.1-28.79,0c-8.7,4.1,7.85-6.02,3.19-9.13s11.8,5.35,23.8.19c12-5.15-13.25,5.77,1.79,8.94Z"/><path class="cls-2" d="M169.51,46.26s-18.64-3.8-26.72,0c-8.08,3.8,7.29-5.59,2.96-8.48-4.32-2.88,10.96,4.96,22.1.18,11.14-4.78-12.3,5.36,1.66,8.3Z"/><path class="cls-2" d="M134.59,37.59s-10.53-2.15-15.09,0,4.12-3.16,1.67-4.79c-2.44-1.63,6.19,2.8,12.48.1,6.29-2.7-6.94,3.03.94,4.69Z"/></g></svg></a>
                        <a href="https://github.com/hololocheck/Keycap_Generator" target="_blank" id="link-github" title="Go to GitHub"><svg class="social-icon github-icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M512 0C229.12 0 0 229.12 0 512C0 738.56 146.56 930.56 349.44 997.76C375.04 1002.24 384.64 986.88 384.64 973.44C384.64 961.28 384 920.96 384 878.08C256 901.12 222.72 846.72 212.48 817.92C206.72 803.2 181.76 757.76 159.36 745.6C140.8 735.36 114.56 710.4 158.72 709.12C199.68 707.84 228.48 748.8 238.08 764.16C284.16 840.96 357.76 819.84 387.2 806.4C391.68 773.76 405.12 751.36 419.84 737.92C300.16 724.48 174.08 678.4 174.08 472.96C174.08 414.08 195.2 366.08 229.76 328.32C224 314.88 205.44 259.84 234.88 184.96C234.88 184.96 280.32 170.88 383.36 240.64C426.24 228.48 472.32 222.72 517.76 222.72C563.2 222.72 609.28 228.48 652.8 240.64C755.2 170.24 800 184.96 800 184.96C829.44 259.84 810.88 314.88 805.76 328.32C840.32 366.08 860.8 414.08 860.8 472.96C860.8 679.04 734.08 723.84 613.76 737.92C633.6 753.92 650.88 786.56 650.88 837.12C650.88 908.8 650.24 967.04 650.24 973.44C650.24 987.52 659.84 1002.88 686.08 997.76C888.32 930.56 1033.6 738.56 1033.6 512C1033.6 229.12 804.48 0 512 0Z"/></svg></a>
                    </div>
                    <select id="language-select"><option value="ja">ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª</option><option value="en">ğŸ‡ºğŸ‡¸ English</option></select>
                </div>
            </div>

            <div id="nav-bar">
                <div class="nav-row"><select id="section-select"><option value="" data-i18n="nav_jump">--- Jump to Section ---</option><option value="sec-basic" data-i18n="nav_basic">Basic Size</option><option value="sec-structure" data-i18n="nav_structure">Structure</option><option value="sec-shape" data-i18n="nav_shape">Shape</option><option value="sec-texture" data-i18n="nav_texture">Texture Map</option><option value="sec-utility" data-i18n="nav_utility">Utility</option><option value="sec-import" data-i18n="nav_import">Import 3D</option><option value="sec-stem" data-i18n="nav_stem">Stem</option><option value="sec-text" data-i18n="nav_text">Text / Legend</option><option value="sec-svg" data-i18n="nav_svg">SVG Icon</option><option value="sec-color" data-i18n="nav_color">Colors</option><option value="sec-preset" data-i18n="nav_preset">Presets</option><option value="sec-export" data-i18n="nav_export">Export</option></select></div>
                <div class="nav-row"><input type="text" id="search-box" placeholder="ğŸ” Search settings..."></div>
            </div>
        </div>
        <div id="ui-scroll-area">
            <h3 id="sec-basic" data-i18n="h_basic" style="margin-top:0;">åŸºæœ¬ã‚µã‚¤ã‚º</h3>
            <div class="control-group"><label data-i18n="lbl_unit_size">åŸºæœ¬ãƒ”ãƒƒãƒ (Unit Size)</label><select id="unit-size-select"><option value="19.05">19.05mm (Standard MX)</option><option value="19.00">19.00mm (Just)</option><option value="18.00">18.00mm</option><option value="17.00">17.00mm (Choc/Narrow)</option><option value="16.00">16.00mm (Mini)</option></select></div>
            <div class="control-group"><label><span data-i18n="lbl_u_size">ã‚­ãƒ¼ã‚µã‚¤ã‚º (U)</span> <span id="v-u-size" class="val" data-target="u-size">1.0</span></label><input type="range" id="u-size" min="1.0" max="10.0" step="0.25" value="1.0"></div>
            <div class="control-group" style="margin-top:5px; padding-top:5px; border-top:1px dashed #333;"><label>ã‚¹ã‚¿ãƒ“ãƒ©ã‚¤ã‚¶ãƒ¼ (Stabilizer)</label><select id="stabilizer-type"><option value="auto">Auto (è‡ªå‹•)</option><option value="custom">Custom (æ‰‹å‹•è¨­å®š)</option></select><div id="stabilizer-custom-ui" style="display:none; margin-top:5px;"><label>Pitch (Center Offset) <span id="v-stabilizer-offset" class="val">0.0</span>mm</label><input type="range" id="stabilizer-offset" min="0" max="150" step="0.1" value="0"><div style="font-size:0.7em; color:#aaa;">â€»ä¸­å¿ƒã‹ã‚‰ã‚¹ãƒ†ãƒ ä¸­å¿ƒã¾ã§ã®è·é›¢</div></div></div>
            <div class="control-group"><label data-i18n="lbl_profile">ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«</label><select id="profile-select"><option value="cherry">Cherry Profile</option><option value="oem">OEM Profile</option><option value="sa">SA Profile</option><option value="xda">XDA Profile</option><option value="dsa">DSA Profile</option></select></div>
            <div class="control-group" id="row-group"><label data-i18n="lbl_row">è¡Œ (Row)</label><select id="row-select"><option value="R4">R4 (ESC/Num)</option><option value="R3">R3 (QWERTY)</option><option value="R2">R2 (ASDF)</option><option value="R1">R1 (ZXCV/Space)</option></select></div>
            
            <h3 id="sec-structure" data-i18n="h_structure">æ§‹é€ ãƒ»ãƒœãƒƒãƒ</h3>
            <div class="control-group"><label style="color:#00e5ff; font-weight:bold;"><span data-i18n="lbl_round_corner">è§’ã®ä¸¸ã¿ (Fillet)</span> <span><span id="v-round-corner" class="val" data-target="round-corner">0.0</span>mm</span></label><input type="range" id="round-corner" min="0.0" max="7.0" step="0.1" value="0.0"><div style="font-size:0.7em; color:#aaa;" data-i18n="note_round">â€»Squircle Mapping (é«˜é€Ÿãƒ»å®‰å®š)</div></div>
            <div class="control-group"><label><span data-i18n="lbl_wall_thick">å£ã®åšã¿</span> <span><span id="v-wall-thick" class="val" data-target="wall-thick">1.5</span>mm</span></label><input type="range" id="wall-thick" min="0.8" max="4.0" step="0.1" value="1.5"></div>
            <div class="control-group"><label style="color:#ff80ab;"><span data-i18n="lbl_rib_shorten">ãƒªãƒ–çŸ­ç¸® (åº•ä¸Šã’)</span> <span><span id="v-rib-shorten" class="val" data-target="rib-shorten">4.3</span>mm</span></label><input type="range" id="rib-shorten" min="0.0" max="10.0" step="0.1" value="4.3"></div>
            <label class="toggle-switch"><input type="checkbox" id="enable-ribs" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_enable_ribs">è£œå¼·ãƒªãƒ– (åå­—)</span></label>
            <div class="control-group" style="margin-top:5px; border-top:1px solid #333; padding-top:5px;">
                <label class="toggle-switch"><input type="checkbox" id="homing-bump" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" style="color:#ff4081;" data-i18n="lbl_homing_bump">ãƒ›ãƒ¼ãƒ ãƒã‚¸ã‚·ãƒ§ãƒ³çªèµ·</span></label>
                <select id="homing-type" style="margin-bottom: 5px;"><option value="round" data-i18n="opt_bump_round">ä¸¸å‹ (Round)</option><option value="bar" data-i18n="opt_bump_bar">é•·æ–¹å½¢ (Bar)</option></select>
                <div class="control-row"><div style="flex:1"><label><span data-i18n="lbl_pos_x">ä½ç½® X</span> <span id="v-bump-x" class="val" data-target="bump-x">0.0</span></label><input type="range" id="bump-x" min="-10" max="10" step="0.1" value="0.0"></div><div style="flex:1"><label><span data-i18n="lbl_pos_z">ä½ç½® Z</span> <span id="v-bump-z" class="val" data-target="bump-z">0.0</span></label><input type="range" id="bump-z" min="-10" max="10" step="0.1" value="0.0"></div></div>
                <div class="control-group"><label><span data-i18n="lbl_bump_offset">é«˜ã•å¾®èª¿æ•´ (Offset)</span> <span><span id="v-bump-offset-y" class="val" data-target="bump-offset-y">0.0</span>mm</span></label><input type="range" id="bump-offset-y" min="-5.0" max="5.0" step="0.1" value="0.0"></div>
            </div>
            
            <h3 id="sec-shape" data-i18n="h_shape">å½¢çŠ¶</h3>
            <div class="control-group"><label><span data-i18n="lbl_top_scale">ä¸Šé¢ã‚µã‚¤ã‚º (Taper)</span> <span id="v-top-scale" class="val" data-target="top-scale">1.00</span></label><input type="range" id="top-scale" min="0.5" max="1.0" step="0.01" value="1.0"></div>
            <div class="control-group"><label data-i18n="lbl_dish_type">ä¸Šé¢å½¢çŠ¶ (Dish Type)</label><select id="dish-type"><option value="cylindrical" data-i18n="opt_dish_cyl">Cylindrical (å††ç­’)</option><option value="spherical" data-i18n="opt_dish_sph">Spherical (çƒ)</option><option value="flat" data-i18n="opt_dish_flat">Flat (å¹³)</option></select></div>
            
            <div class="v61-texture-panel">
                <label style="color:#e91e63; font-weight:bold;" data-i18n="lbl_texture">è¡¨é¢ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£ãƒ« (Procedural)</label>
                <select id="texture-type" style="margin-bottom:5px;">
                    <option value="none" data-i18n="opt_tex_none">None (ãªã—)</option>
                    <option value="noise" data-i18n="opt_tex_noise">Noise (æ¢¨åœ°/Sand)</option>
                    <option value="grid" data-i18n="opt_tex_grid">Grid (ã‚°ãƒªãƒƒãƒ—/Studs)</option>
                    <option value="knurling">Knurling (ãƒ­ãƒ¼ãƒ¬ãƒƒãƒˆ/Diamond)</option>
                    <option value="stripes">Stripes (ã‚¹ãƒˆãƒ©ã‚¤ãƒ—)</option>
                    <option value="ripple">Ripple (æ³¢ç´‹/Water)</option>
                    <option value="wood">Wood Grain (æœ¨ç›®)</option>
                    <option value="hammered">Hammered (æ‰“ç—•)</option>
                    <option value="hexagon">Hexagon (ãƒãƒ‹ã‚«ãƒ )</option>
                    <option value="bricks">Bricks (ãƒ¬ãƒ³ã‚¬)</option>
                </select>
                <div class="control-row">
                    <div style="flex:1"><label><span data-i18n="lbl_tex_scale">Scale</span> <span id="v-tex-scale" class="val">50</span></label><input type="range" id="tex-scale" min="1" max="100" step="1" value="50"></div>
                    <div style="flex:1"><label><span data-i18n="lbl_tex_strength">Strength</span> <span id="v-tex-strength" class="val">0.05</span></label><input type="range" id="tex-strength" min="0.01" max="0.5" step="0.01" value="0.05"></div>
                </div>
                 <label class="toggle-switch" style="margin-top:5px;">
                    <input type="checkbox" id="texture-global" class="toggle-input">
                    <span class="toggle-knob"></span>
                    <span class="toggle-label">å…¨ä½“ã«é©ç”¨ (Global Apply)</span>
                </label>
            </div>

            <h3 id="sec-texture" data-i18n="h_texture_map" style="color:#ba68c8; border-color:#ba68c8;">ç”»åƒãƒ†ã‚¯ã‚¹ãƒãƒ£ (Image Map)</h3>
            <div class="v63-texture-map-panel">
                <div class="file-upload"><label for="img-texture-input" class="file-upload-label" style="border-color:#ba68c8; color:#e1bee7;" data-i18n="btn_upload_img">ğŸ“ ç”»åƒèª­è¾¼ (PNG/JPG)</label><input type="file" id="img-texture-input" accept="image/*"></div>
                <div class="control-row" style="margin-top:5px; align-items:center;">
                    <label class="toggle-switch" style="flex:1; margin:0;"><input type="checkbox" id="img-texture-visible" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_visible">è¡¨ç¤º (Visible)</span></label>
                    <button class="danger btn-small" id="btn-clear-img-texture" style="width:30px; margin:0;">Ã—</button>
                </div>
                <div class="control-group" style="margin-top:5px;"><label>Scale <span id="v-img-scale" class="val">1.0</span></label><input type="range" id="img-scale" min="0.1" max="3.0" step="0.1" value="1.0"></div>
                <div class="control-row"><div style="flex:1"><label>Pos X <span id="v-img-pos-x" class="val">0.0</span></label><input type="range" id="img-pos-x" min="-0.5" max="0.5" step="0.01" value="0.0"></div><div style="flex:1"><label>Pos Y <span id="v-img-pos-y" class="val">0.0</span></label><input type="range" id="img-pos-y" min="-0.5" max="0.5" step="0.01" value="0.0"></div></div>
                <div class="control-group"><label>Rotation <span id="v-img-rot" class="val">0</span>Â°</label><input type="range" id="img-rot" min="-180" max="180" step="1" value="0"></div>
            </div>

            <div class="control-group" style="border-top:1px dashed #555; margin-top:5px; padding-top:5px;">
                <label style="color:#b2ff59;">Twist (ã­ã˜ã‚Š)</label><input type="range" id="twist-factor" min="-90" max="90" step="1" value="0">
                <label style="color:#b2ff59; margin-top:5px;">Tilt (å¤©é¢è§’åº¦èª¿æ•´)</label><div class="control-row"><div style="flex:1"><label>X-Tilt</label><input type="range" id="tilt-x" min="-20" max="20" step="0.5" value="0"></div><div style="flex:1"><label>Z-Tilt</label><input type="range" id="tilt-z" min="-20" max="20" step="0.5" value="0"></div></div>
            </div>

            <h3 id="sec-stem" data-i18n="h_stem">ã‚¹ãƒ†ãƒ è¨­å®š</h3>
            <div class="control-group"><label style="color:#80deea;" data-i18n="lbl_stem_type">è»¸ã‚¿ã‚¤ãƒ—: Cherry MX (å›ºå®š)</label></div>
            <div class="control-group"><label style="color:#ffeb3b;"><span data-i18n="lbl_stem_diameter">ã‚¹ãƒ†ãƒ å¤–å¾„ (Diameter)</span> <span><span id="v-stem-diameter" class="val" data-target="stem-diameter">5.50</span>mm</span></label><input type="range" id="stem-diameter" min="5.0" max="7.0" step="0.05" value="5.50"></div>
            <div class="control-group"><label style="color:#ffeb3b;"><span data-i18n="lbl_clearance">ã‚¯ãƒªã‚¢ãƒ©ãƒ³ã‚¹</span> <span><span id="v-stem-clearance" class="val" data-target="stem-clearance">0.30</span>mm</span></label><input type="range" id="stem-clearance" min="0.0" max="1.0" step="0.01" value="0.30"></div>
            <div class="control-group" style="border-top:1px solid #333; margin-top:5px; padding-top:5px;">
                <label class="toggle-switch"><input type="checkbox" id="enable-stem-extension" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" style="color:#80deea;">é•·ã•ã‚’æ‹¡å¼µ (Stem Extension)</span></label>
                <div id="stem-ext-control" style="display:none; margin-top:5px;"><label>Extension <span id="v-stem-extension" class="val">1.0</span>mm</label><input type="range" id="stem-extension" min="0.0" max="5.0" step="0.1" value="1.0"></div>
            </div>
            <label class="toggle-switch" style="margin-top:5px;"><input type="checkbox" id="box-stem" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" style="color:#ffeb3b;">Box Stem (ãƒœãƒƒã‚¯ã‚¹è»¸)</span></label>
            <label class="toggle-switch"><input type="checkbox" id="lego-stud" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" style="color:#ff5722;">Lego Stud (å¤©é¢ãƒãƒƒãƒ)</span></label>
            <div id="lego-adj-panel" style="display:none; background:rgba(255,87,34,0.1); padding:5px; border-radius:4px; margin-bottom:5px; border:1px dashed #ff5722;">
                <div class="control-row"><div style="flex:1"><label>Pos X <span id="v-lego-x" class="val">0.0</span></label><input type="range" id="lego-x" min="-10" max="10" step="0.1" value="0.0"></div><div style="flex:1"><label>Pos Z <span id="v-lego-z" class="val">0.0</span></label><input type="range" id="lego-z" min="-10" max="10" step="0.1" value="0.0"></div></div>
                <div class="control-row"><div style="flex:1"><label>Pos Y <span id="v-lego-y" class="val">0.0</span></label><input type="range" id="lego-y" min="-5" max="5" step="0.1" value="0.0"></div><div style="flex:1"><label>Clearance <span id="v-lego-clear" class="val">0.0</span></label><input type="range" id="lego-clear" min="-0.5" max="0.5" step="0.05" value="0.0"></div></div>
            </div>

            <div class="section-sep"></div>
            <h3 id="sec-utility" style="color:#00e5ff;">Utility</h3>
            <div class="control-group" style="display:flex; gap:5px; align-items:center;">
                <button id="btn-random" class="accent" style="border-color:#e040fb; color:#e040fb; flex:1;">ğŸ² Randomizer</button>
                <button id="btn-reset-params" class="danger btn-square" title="Reset Params to Default" style="width:40px; margin-top:5px;">Ã—</button>
            </div>
            
            <h3 id="sec-import" style="color:#ff9800; margin-top:10px; border-bottom:1px solid #ff9800;" data-i18n="h_import">å¤–éƒ¨ãƒ¢ãƒ‡ãƒ« (Import 3D)</h3>
            <div class="v60-import-panel">
                <div class="control-group" style="display:flex; gap:5px; align-items: flex-end;">
                    <div class="file-upload" style="flex:1;"><label for="model-file-input" class="file-upload-label" style="border-color:#ff9800; color:#ff9800;">ğŸ“ STLãƒ¢ãƒ‡ãƒ«èª­è¾¼</label><input type="file" id="model-file-input" accept=".stl"></div>
                    <button class="danger btn-square" id="btn-clear-model" title="ãƒ¢ãƒ‡ãƒ«å‰Šé™¤">Ã—</button>
                </div>
                <label class="toggle-switch" style="margin-top:5px;"><input type="checkbox" id="model-visible" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_visible">è¡¨ç¤º (Visible)</span></label>
                <div class="control-group" style="margin-top:5px; background:rgba(0,0,0,0.2); padding:5px; border-radius:4px;"><label style="color:#ff9800;">åˆæˆãƒ¢ãƒ¼ãƒ‰ (Operation)</label><select id="model-operation"><option value="union">Union (çµåˆ - è¿½åŠ )</option><option value="subtract">Subtract (å‹æŠœã - å½«åˆ»)</option></select><div style="font-size:0.7em; color:#aaa; margin-top:2px;">â€»Subtractã¯å‡¦ç†ã«æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™</div></div>
                <div class="control-group"><label>Pivot / Transform (ä½ç½®/å›è»¢)</label><div class="control-row"><div style="flex:1"><label>Scale <span id="v-model-scale" class="val">1.0</span></label><input type="range" id="model-scale" min="0.1" max="5.0" step="0.1" value="1.0"></div></div><div class="control-row"><div style="flex:1"><label>X <span id="v-model-x" class="val">0.0</span></label><input type="range" id="model-x" min="-15" max="15" step="0.5" value="0"></div><div style="flex:1"><label>Z <span id="v-model-z" class="val">0.0</span></label><input type="range" id="model-z" min="-15" max="15" step="0.5" value="0"></div></div><div class="control-row"><div style="flex:1"><label>Y-Pos <span id="v-model-y" class="val">0.0</span></label><input type="range" id="model-y" min="-10" max="20" step="0.5" value="0"></div></div><div class="control-row"><div style="flex:1"><label>Rot X <span id="v-model-rx" class="val">0</span>Â°</label><input type="range" id="model-rx" min="-180" max="180" step="15" value="0"></div><div style="flex:1"><label>Rot Y <span id="v-model-ry" class="val">0</span>Â°</label><input type="range" id="model-ry" min="-180" max="180" step="15" value="0"></div><div style="flex:1"><label>Rot Z <span id="v-model-rz" class="val">0</span>Â°</label><input type="range" id="model-rz" min="-180" max="180" step="15" value="0"></div></div></div>
            </div>

            <h3 id="sec-text" data-i18n="h_text">æ–‡å­—è¨­å®š</h3>
            <div class="control-group">
                <label class="toggle-switch"><input type="checkbox" id="enable-text" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_enable_text">æ–‡å­—ã‚’ç”Ÿæˆã™ã‚‹</span></label>
                <textarea id="text-content" rows="2" placeholder="ä¾‹: A&#13;&#10;{&#13;&#10;["></textarea><div style="font-size:0.7em; color:#aaa; text-align:right;" data-i18n="note_multiline">â€»æ”¹è¡Œã§2æ®µå°å­—ãŒå¯èƒ½</div>
            </div>
            
            <div class="control-group"><label data-i18n="lbl_font">ãƒ•ã‚©ãƒ³ãƒˆ</label><select id="font-family" style="display:none;"><option value="helvetiker">Helvetiker</option><option value="helvetiker_bold">Helvetiker Bold</option><option value="optimer">Optimer</option><option value="optimer_bold">Optimer Bold</option><option value="gentilis">Gentilis</option><option value="gentilis_bold">Gentilis Bold</option><option value="droid_sans">Droid Sans</option><option value="droid_sans_bold">Droid Sans Bold</option><option value="droid_serif">Droid Serif</option><option value="droid_serif_bold">Droid Serif Bold</option></select><div class="custom-select-container" id="custom-font-ui"><div class="custom-select-head" id="custom-font-head">Helvetiker â–¼</div><div class="custom-select-list" id="custom-font-list"></div></div></div>
            <div class="control-group" style="border: 1px dashed #555; padding: 8px; border-radius: 4px; background: rgba(0,0,0,0.3); margin-top: 5px;"><div class="info-link" data-i18n="note_font_upload">â€».ttf ãªã©ã‚’ãã®ã¾ã¾èª­ã¿è¾¼ã‚€ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚<br><a href="http://gero3.github.io/facetype.js/" target="_blank">Facetype.js</a> ãªã©ã§JSONã«å¤‰æ›ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚</div><div class="file-upload"><label for="font-file-input" class="file-upload-label" data-i18n="btn_upload_font">ğŸ“ ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚©ãƒ³ãƒˆ (.json)</label><input type="file" id="font-file-input" accept=".json"></div></div>

            <div class="control-group" style="background:rgba(0,229,255,0.1); padding:5px; border-radius:4px; margin-bottom:5px; margin-top:5px;">
                <label data-i18n="lbl_text_mode" style="color:#00e5ff; font-weight:bold;">ç”Ÿæˆãƒ¢ãƒ¼ãƒ‰ (Mode)</label>
                <select id="text-mode">
                    <option value="emboss" data-i18n="opt_mode_emboss">Emboss (æµ®ãå‡ºã—)</option>
                    <option value="engrave" data-i18n="opt_mode_engrave">Engrave (åˆ»å°/æ˜ã‚Šè¾¼ã¿)</option>
                    <option value="doubleshot" data-i18n="opt_mode_doubleshot">Double-Shot (åŸ‹ã‚è¾¼ã¿)</option>
                </select>
                <div style="font-size:0.7em; color:#aaa; margin-top:3px;" data-i18n="note_engrave">â€»Engraveã¯è¨ˆç®—å‡¦ç†ã«æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™</div>
            </div>

            <div class="control-group">
                <div class="control-row">
                    <div style="flex:1"><label><span data-i18n="lbl_size">ã‚µã‚¤ã‚º</span> <span id="v-font-size" class="val" data-target="font-size">8.0</span></label><input type="range" id="font-size" min="3" max="20" step="0.5" value="8.0"></div>
                    <div style="flex:1">
                        <label><span data-i18n="lbl_thickness">æ·±ã•/é«˜ã•</span> <span id="v-text-height" class="val" data-target="text-height">0.5</span></label>
                        <div style="display:flex; align-items:center; gap:5px;"><input type="range" id="text-height" min="0.1" max="5.0" step="0.1" value="0.5" disabled><label class="toggle-switch" style="margin:0; width:auto;" title="åšã¿ã‚’å›ºå®š"><input type="checkbox" id="lock-thickness" checked class="toggle-input"><span class="toggle-knob" style="width:28px; height:14px;"></span></label></div>
                    </div>
                </div>
            </div>
            
            <label class="toggle-switch"><input type="checkbox" id="text-conform" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_conform">æ›²é¢ã«åˆã‚ã›ã‚‹ (Conform)</span></label>
            <div class="control-group"><label data-i18n="lbl_align_preset">æ–‡å­—é…ç½® (ãƒ—ãƒªã‚»ãƒƒãƒˆ)</label>
                <div class="control-row" style="margin-bottom:2px;">
                    <button id="btn-align-tl" class="secondary btn-small" style="margin:0;" data-i18n="btn_align_tl">â†– TL</button>
                    <button id="btn-align-tr" class="secondary btn-small" style="margin:0;" data-i18n="btn_align_tr">â†— TR</button>
                </div>
                <div class="control-row">
                    <button id="btn-align-bl" class="secondary btn-small" style="margin:0;" data-i18n="btn_align_bl">â†™ BL</button>
                    <button id="btn-align-br" class="secondary btn-small" style="margin:0;" data-i18n="btn_align_br">â†˜ BR</button>
                </div>
                <button id="btn-align-center" class="secondary btn-small" style="margin-top:4px;" data-i18n="btn_align_center">Center (ä¸­å¤®)</button>
            </div>
            <div class="control-group"><label data-i18n="lbl_pos_xz_fine">ä½ç½® X / Z (å¾®èª¿æ•´)</label><div class="control-row"><input type="range" id="pos-x" min="-15" max="15" step="0.5" value="0" title="X Position"><input type="range" id="pos-z" min="-15" max="15" step="0.5" value="0" title="Z Position"></div><div style="display:flex; justify-content:space-between; font-size:0.7em; color:#aaa;"><span>X: <span id="v-pos-x">0.0</span></span><span>Z: <span id="v-pos-z">0.0</span></span></div></div>
            <div class="control-group"><label style="color:#aaa; font-size:0.7rem;"><span data-i18n="lbl_offset_y">é«˜ã•å¾®èª¿æ•´ (Offset Y)</span> <span id="v-text-offset-y" class="val">0.0</span></label><input type="range" id="text-offset-y" min="-5.0" max="5.0" step="0.01" value="0.0"></div>
            <div class="v60-sub-panel">
                <label class="toggle-switch"><input type="checkbox" id="enable-text2" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" class="v60-label">ã‚µãƒ–æ–‡å­— (Legend 2)</span></label>
                <div class="control-group"><select id="text2-mode" style="margin-bottom:5px; font-size:0.75rem; padding:3px;"><option value="emboss">Emboss</option><option value="engrave">Engrave</option><option value="doubleshot">Double-Shot</option></select></div>
                <textarea id="text2-content" rows="1" placeholder="ä¾‹: ã‚ / @" style="margin-bottom:5px;"></textarea>
                <div class="control-row"><div style="flex:1"><label>Size <span id="v-text2-size" class="val">4.0</span></label><input type="range" id="text2-size" min="2" max="15" step="0.1" value="4.0"></div></div>
                <div class="control-row"><div style="flex:1"><label>X <span id="v-text2-x" class="val">3.5</span></label><input type="range" id="text2-x" min="-10" max="10" step="0.1" value="3.5"></div><div style="flex:1"><label>Z <span id="v-text2-z" class="val">3.5</span></label><input type="range" id="text2-z" min="-10" max="10" step="0.1" value="3.5"></div></div>
            </div>

            <div class="v60-sub-panel">
                <label class="toggle-switch"><input type="checkbox" id="enable-side" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" class="v60-label-side">ã‚µã‚¤ãƒ‰å°å­— (Side Print)</span></label>
                <div class="control-group"><select id="side-mode" style="margin-bottom:5px; font-size:0.75rem; padding:3px;"><option value="emboss">Emboss</option><option value="engrave">Engrave</option><option value="doubleshot">Double-Shot</option></select></div>
                <input type="text" id="side-text" placeholder="FRONT TEXT" style="margin-bottom:5px;">
                <div class="control-row"><div style="flex:1"><label>Size <span id="v-side-size" class="val">3.0</span></label><input type="range" id="side-size" min="1" max="10" step="0.1" value="3.0"></div><div style="flex:1"><label>Y-Ofs <span id="v-side-y" class="val">-2.0</span></label><input type="range" id="side-y" min="-10" max="5" step="0.1" value="-2.0"></div></div>
                <div class="control-group"><label>Rotate X <span id="v-side-rot" class="val">0</span>Â°</label><input type="range" id="side-rot" min="-45" max="45" step="1" value="0"></div>
            </div>

            <h3 id="sec-svg" data-i18n="h_svg">SVG (ã‚¢ã‚¤ã‚³ãƒ³) è¨­å®š</h3>
            <div class="control-group" style="display:flex; gap:5px; align-items: flex-end;">
                <div class="file-upload" style="flex:1;"><label for="svg-file-input" class="file-upload-label" style="border-color:#ffeb3b; color:#ffeb3b;" data-i18n="btn_upload_svg">ğŸ“ SVGèª­è¾¼</label><input type="file" id="svg-file-input" accept=".svg"></div>
                <button class="danger btn-square" id="btn-clear-svg" title="SVGã‚’å‰Šé™¤">Ã—</button>
            </div>
            
            <label class="toggle-switch" style="margin-top:5px;"><input type="checkbox" id="svg-visible" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_visible">è¡¨ç¤ºã™ã‚‹</span></label>
            
            <div class="control-group" style="background:rgba(0,229,255,0.1); padding:5px; border-radius:4px; margin-bottom:5px;">
                <label data-i18n="lbl_text_mode" style="color:#00e5ff; font-weight:bold;">ç”Ÿæˆãƒ¢ãƒ¼ãƒ‰ (Mode)</label>
                <select id="svg-mode">
                    <option value="emboss">Emboss</option>
                    <option value="engrave">Engrave</option>
                    <option value="doubleshot">Double-Shot</option>
                </select>
            </div>

            <div class="control-row"><div style="flex:1"><label><span data-i18n="lbl_size">ã‚µã‚¤ã‚º</span> <span id="v-svg-scale" class="val" data-target="svg-scale">1.0</span></label><input type="range" id="svg-scale" min="0.1" max="5.0" step="0.1" value="1.0"></div><div style="flex:1"><label><span data-i18n="lbl_thickness">åšã¿</span> <span id="v-svg-thickness" class="val" data-target="svg-thickness">0.6</span></label><input type="range" id="svg-thickness" min="0.1" max="5.0" step="0.1" value="0.6"></div></div>
            <label class="toggle-switch"><input type="checkbox" id="svg-conform" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_conform">æ›²é¢ã«åˆã‚ã›ã‚‹ (Conform)</span></label>
            <div class="control-group"><label data-i18n="lbl_rotation">å›è»¢ (XYZ) </label><div class="control-row"><div style="flex:1"><label>X <span id="v-svg-rot-x" class="val" data-target="svg-rot-x">0</span>Â°</label><input type="range" id="svg-rot-x" min="-180" max="180" step="5" value="0"></div><div style="flex:1"><label>Y <span id="v-svg-rot-y" class="val" data-target="svg-rot-y">0</span>Â°</label><input type="range" id="svg-rot-y" min="-180" max="180" step="5" value="0"></div><div style="flex:1"><label>Z <span id="v-svg-rot-z" class="val" data-target="svg-rot-z">0</span>Â°</label><input type="range" id="svg-rot-z" min="-180" max="180" step="5" value="0"></div></div></div>
            <div class="control-group"><div class="control-row"><div style="flex:1"><label><span data-i18n="lbl_pos_x">ä½ç½® X</span> <span id="v-svg-pos-x" class="val" data-target="svg-pos-x">0.0</span></label><input type="range" id="svg-pos-x" min="-15" max="15" step="0.5" value="0"></div><div style="flex:1"><label><span data-i18n="lbl_pos_z">ä½ç½® Z</span> <span id="v-svg-pos-z" class="val" data-target="svg-pos-z">0.0</span></label><input type="range" id="svg-pos-z" min="-15" max="15" step="0.5" value="0"></div></div></div>
            <div class="control-group"><label style="color:#aaa; font-size:0.7rem;"><span data-i18n="lbl_offset_y">é«˜ã•å¾®èª¿æ•´ (Offset Y)</span> <span id="v-svg-offset-y" class="val">0.0</span></label><input type="range" id="svg-offset-y" min="-5.0" max="5.0" step="0.01" value="0.0"></div>

            <h3 id="sec-color" data-i18n="h_colors">è‰²è¨­å®š</h3>
            <div class="control-group"><label data-i18n="lbl_col_body">æœ¬ä½“è‰²</label><input type="color" id="col-body" value="#333333" class="color-input"><div class="palette-grid" id="palette-body"></div></div>
            <div class="control-group" style="margin-top:15px;"><label data-i18n="lbl_col_text">æ–‡å­—ãƒ»SVGè‰²</label><input type="color" id="col-text" value="#00e5ff" class="color-input"><div class="palette-grid" id="palette-text"></div></div>

            <div class="section-sep"></div>
            <h3 id="sec-preset" data-i18n="h_preset">ãƒ—ãƒªã‚»ãƒƒãƒˆç®¡ç†</h3>
            <div class="control-group"><label data-i18n="lbl_browser_storage">ãƒ–ãƒ©ã‚¦ã‚¶ã«ä¿å­˜ (Quick Save/Load)</label><div class="control-row"><button id="btn-quick-save" class="secondary btn-small" data-i18n="btn_quick_save">ä¸€æ™‚ä¿å­˜ (Save)</button><button id="btn-quick-load" class="secondary btn-small" data-i18n="btn_quick_load">å¾©å…ƒ (Load)</button></div></div>
            <div class="control-group"><label data-i18n="lbl_file_storage">ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ (File I/O)</label><div class="control-row"><button id="btn-export-preset" class="secondary btn-small" data-i18n="btn_export_file">æ›¸ãå‡ºã— (.json)</button><div class="file-upload" style="flex:1;"><label for="preset-file-input" class="file-upload-label preset btn-small" data-i18n="btn_import_file">èª­ã¿è¾¼ã¿ (.json)</label><input type="file" id="preset-file-input" accept=".json"></div></div></div>

            <div class="section-sep"></div>
            <h3 id="sec-export" data-i18n="h_export">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ (STL/OBJ/3MF)</h3>
            <div class="control-group"><label>å…¨ä½“å›è»¢ (Print Orientation)</label><div class="control-row"><div style="flex:1"><label>Rot X</label><input type="range" id="global-rot-x" min="-180" max="180" step="15" value="0" title="Global Rot X"></div><div style="flex:1"><label>Rot Y</label><input type="range" id="global-rot-y" min="-180" max="180" step="15" value="0" title="Global Rot Y"></div></div></div>
            <div class="control-group" style="margin-bottom:10px;"><label data-i18n="lbl_filename">ãƒ•ã‚¡ã‚¤ãƒ«åè¨­å®š (è‡ªå‹•ã§[æ–‡å­—]ãŒä»˜ä¸ã•ã‚Œã¾ã™)</label><input type="text" id="export-name" value="keycap" style="text-align:left;"></div>
            <button id="btn-export-all" data-i18n="btn_export_all">å…¨ä½“ã‚’STLã§ä¿å­˜</button>
            <button id="btn-export-3mf" class="primary-3mf" style="margin-top:5px;" data-i18n="btn_export_3mf">å…¨ä½“ã‚’3MFã§ä¿å­˜ (Color)</button>
            <button id="btn-export-obj" class="accent" style="margin-top:5px; color:#ff9800; border-color:#ff9800;" data-i18n="btn_export_obj">å…¨ä½“ã‚’OBJã§ä¿å­˜ (Color)</button>
            <div class="control-row"><button class="secondary" id="btn-export-body" data-i18n="btn_export_body">æœ¬ä½“ã®ã¿ (STL)</button><button class="secondary" id="btn-export-text" data-i18n="btn_export_text">æ–‡å­—ã®ã¿ (STL)</button></div>

            <div class="section-sep"></div>
            <h3 id="sec-batch" data-i18n="h_batch">ãƒãƒƒãƒå‡ºåŠ› (Batch Export)</h3>
            <div class="control-group"><label data-i18n="lbl_batch_list">æ–‡å­—ãƒªã‚¹ãƒˆ (ã‚«ãƒ³ãƒ/æ”¹è¡ŒåŒºåˆ‡ã‚Š)</label><textarea id="batch-list" rows="3" placeholder="Q,W,E,R,T,Y..."></textarea><div style="font-size:0.7em; color:#aaa; text-align:right;" data-i18n="note_batch">â€»ç¾åœ¨ã®è¨­å®šã§é€£ç¶šç”Ÿæˆã—ã¾ã™</div></div>
            <div class="control-group">
                <label data-i18n="lbl_batch_format">å‡ºåŠ›å½¢å¼</label>
                <select id="batch-format">
                    <option value="stl">STL</option>
                    <option value="3mf">3MF (Color)</option>
                </select>
            </div>
            <button id="btn-batch-export" class="accent" data-i18n="btn_batch_run">ä¸€æ‹¬ç”Ÿæˆ</button>
        </div>
    </div>

    <script type="module">
import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLExporter } from 'three/addons/exporters/STLExporter.js';
        import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        import { ViewHelper } from 'three/addons/helpers/ViewHelper.js';
        import { SUBTRACTION, ADDITION, Brush, Evaluator } from 'three-bvh-csg';
        
        let manifoldModule = null;
        let Manifold = null;
        
        async function initManifold() {
            try {
                const Module = await import('https://cdn.jsdelivr.net/npm/manifold-3d@3.0.0/manifold.js');
                manifoldModule = await Module.default();
                manifoldModule.setup();
                Manifold = manifoldModule.Manifold;
                console.log('Manifold WASM initialized successfully');
                return true;
            } catch (e) {
                console.warn('Manifold WASM failed to load:', e);
                return false;
            }
        }
        
        function geometryToManifold(geometry) {
            if (!Manifold || !geometry) return null;
            
            try {
                let geo = geometry.clone();
                
                if (!geo.index) {
                    geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
                }
                
                const position = geo.attributes.position;
                const index = geo.index;
                
                if (!position || !index) return null;
                
                const vertProperties = [];
                for (let i = 0; i < position.count; i++) {
                    vertProperties.push(position.getX(i), position.getY(i), position.getZ(i));
                }
                
                const triVerts = [];
                const indexArray = index.array;
                for (let i = 0; i < indexArray.length; i++) {
                    triVerts.push(indexArray[i]);
                }
                
                const mesh = new manifoldModule.Mesh({
                    numProp: 3,
                    vertProperties: new Float32Array(vertProperties),
                    triVerts: new Uint32Array(triVerts)
                });
                
                const manifold = new Manifold(mesh);
                mesh.delete();
                
                return manifold;
            } catch (e) {
                console.warn('geometryToManifold failed:', e);
                return null;
            }
        }
        
        function manifoldToGeometry(manifold) {
            if (!manifold) return null;
            
            try {
                const mesh = manifold.getMesh();
                
                const vertices = [];
                const indices = [];
                
                const vertProps = mesh.vertProperties;
                const numProp = mesh.numProp;
                
                for (let i = 0; i < vertProps.length; i += numProp) {
                    vertices.push(vertProps[i], vertProps[i + 1], vertProps[i + 2]);
                }
                
                const triVerts = mesh.triVerts;
                for (let i = 0; i < triVerts.length; i++) {
                    indices.push(triVerts[i]);
                }
                
                mesh.delete();
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                return geometry;
            } catch (e) {
                console.warn('manifoldToGeometry failed:', e);
                return null;
            }
        }
        
        function makeManifold(geometry) {
            if (!Manifold || !geometry) return geometry;
            
            try {
                const manifold = geometryToManifold(geometry);
                if (!manifold) return geometry;
                
                const status = manifold.status();
                if (status !== 0) {
                    console.log('Mesh is not manifold, status:', status);
                    manifold.delete();
                    return geometry;
                }
                
                const result = manifoldToGeometry(manifold);
                manifold.delete();
                
                return result || geometry;
            } catch (e) {
                console.warn('makeManifold failed:', e);
                return geometry;
            }
        }
        
        function repairSVGMesh(geometry) {
            if (!geometry) return null;
            
            try {
                let geo = BufferGeometryUtils.mergeVertices(geometry, 0.001);
                
                if (geo.index) {
                    geo = geo.toNonIndexed();
                }
                
                const position = geo.attributes.position;
                const triangles = [];
                const epsilon = 0.0001;
                
                for (let i = 0; i < position.count; i += 3) {
                    const v0 = new THREE.Vector3(position.getX(i), position.getY(i), position.getZ(i));
                    const v1 = new THREE.Vector3(position.getX(i+1), position.getY(i+1), position.getZ(i+1));
                    const v2 = new THREE.Vector3(position.getX(i+2), position.getY(i+2), position.getZ(i+2));
                    
                    const e0 = v0.distanceTo(v1);
                    const e1 = v1.distanceTo(v2);
                    const e2 = v2.distanceTo(v0);
                    
                    if (e0 < epsilon || e1 < epsilon || e2 < epsilon) continue;
                    
                    const ab = new THREE.Vector3().subVectors(v1, v0);
                    const ac = new THREE.Vector3().subVectors(v2, v0);
                    const cross = new THREE.Vector3().crossVectors(ab, ac);
                    const area = cross.length() * 0.5;
                    
                    if (area < epsilon * epsilon) continue;
                    
                    triangles.push({ v0, v1, v2, area });
                }
                
                const uniqueTriangles = [];
                const seen = new Set();
                
                for (const tri of triangles) {
                    const vertices = [tri.v0, tri.v1, tri.v2].map(v => 
                        `${v.x.toFixed(4)},${v.y.toFixed(4)},${v.z.toFixed(4)}`
                    ).sort().join('|');
                    
                    if (!seen.has(vertices)) {
                        seen.add(vertices);
                        uniqueTriangles.push(tri);
                    }
                }
                
                const newPositions = [];
                for (const tri of uniqueTriangles) {
                    newPositions.push(tri.v0.x, tri.v0.y, tri.v0.z);
                    newPositions.push(tri.v1.x, tri.v1.y, tri.v1.z);
                    newPositions.push(tri.v2.x, tri.v2.y, tri.v2.z);
                }
                
                const newGeo = new THREE.BufferGeometry();
                newGeo.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
                
                const mergedGeo = BufferGeometryUtils.mergeVertices(newGeo, 0.08);
                mergedGeo.computeVertexNormals();
                
                console.log(`SVG Repair: ${position.count/3} -> ${uniqueTriangles.length} triangles`);
                
                return mergedGeo;
            } catch (e) {
                console.warn('repairSVGMesh failed:', e);
                return geometry;
            }
        }

        const translations = {
            ja: {
                nav_jump: "--- ã‚»ã‚¯ã‚·ãƒ§ãƒ³ç§»å‹• ---", nav_basic: "åŸºæœ¬ã‚µã‚¤ã‚º (Basic)", nav_structure: "æ§‹é€ ãƒ»ãƒœãƒƒãƒ (Structure)", nav_shape: "å½¢çŠ¶ (Shape)",
                nav_texture: "ç”»åƒãƒ†ã‚¯ã‚¹ãƒãƒ£ (Map)", nav_utility: "ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ (Utility)", nav_import: "å¤–éƒ¨ãƒ¢ãƒ‡ãƒ« (Import)", 
                nav_stem: "ã‚¹ãƒ†ãƒ  (Stem)", nav_text: "æ–‡å­—ãƒ»åˆ»å° (Text)", nav_svg: "SVGã‚¢ã‚¤ã‚³ãƒ³ (Icon)", nav_color: "è‰²è¨­å®š (Colors)",
                nav_preset: "ãƒ—ãƒªã‚»ãƒƒãƒˆ (Presets)", nav_export: "æ›¸ãå‡ºã— (Export)",
                h_basic: "åŸºæœ¬ã‚µã‚¤ã‚º", lbl_u_size: "ã‚­ãƒ¼ã‚µã‚¤ã‚º (U)", lbl_profile: "ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«", lbl_row: "è¡Œ (Row)", lbl_unit_size: "åŸºæœ¬ãƒ”ãƒƒãƒ (Unit Size)", 
                h_structure: "æ§‹é€ ãƒ»ãƒœãƒƒãƒ", lbl_wall_thick: "å£ã®åšã¿", lbl_rib_shorten: "ãƒªãƒ–çŸ­ç¸® (åº•ä¸Šã’)", lbl_enable_ribs: "è£œå¼·ãƒªãƒ– (åå­—)",
                lbl_homing_bump: "ãƒ›ãƒ¼ãƒ ãƒã‚¸ã‚·ãƒ§ãƒ³çªèµ·", opt_bump_round: "ä¸¸å‹ (Round)", opt_bump_bar: "é•·æ–¹å½¢ (Bar)",
                lbl_pos_x: "ä½ç½® X", lbl_pos_z: "ä½ç½® Z", lbl_bump_offset: "é«˜ã•å¾®èª¿æ•´ (Offset)",
                lbl_round_corner: "è§’ã®ä¸¸ã¿ (Fillet)", note_round: "â€»Squircle Mapping (é«˜é€Ÿãƒ»å®‰å®š)",
                h_shape: "å½¢çŠ¶ (ãƒ†ãƒ¼ãƒ‘ãƒ¼ãƒ»Dish)", lbl_top_scale: "ä¸Šé¢ã‚µã‚¤ã‚º (Taper)", lbl_dish_type: "ä¸Šé¢å½¢çŠ¶ (Dish Type)",
                opt_dish_cyl: "Cylindrical (å††ç­’)", opt_dish_sph: "Spherical (çƒ)", opt_dish_flat: "Flat (å¹³)",
                lbl_texture: "è¡¨é¢ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£ãƒ« (Procedural)", opt_tex_none: "None (ãªã—)", opt_tex_noise: "Noise (æ¢¨åœ°/Sand)", opt_tex_grid: "Grid (ã‚°ãƒªãƒƒãƒ—/Studs)",
                lbl_tex_scale: "Scale (ç´°ã‹ã•)", lbl_tex_strength: "Strength (æ·±ã•)",
                h_texture_map: "ç”»åƒãƒ†ã‚¯ã‚¹ãƒãƒ£ (Image Map)", btn_upload_img: "ğŸ“ ç”»åƒèª­è¾¼ (PNG/JPG)", 
                h_stem: "ã‚¹ãƒ†ãƒ è¨­å®š", lbl_stem_type: "è»¸ã‚¿ã‚¤ãƒ—: Cherry MX (å›ºå®š)", lbl_clearance: "ã‚¯ãƒªã‚¢ãƒ©ãƒ³ã‚¹", lbl_stem_diameter: "ã‚¹ãƒ†ãƒ å¤–å¾„ (Diameter)", 
                h_text: "æ–‡å­—è¨­å®š", lbl_enable_text: "æ–‡å­—ã‚’ç”Ÿæˆã™ã‚‹", pl_text: "ä¾‹: A\n{\n[", note_multiline: "â€»æ”¹è¡Œã§2æ®µå°å­—ãŒå¯èƒ½",
                lbl_font: "ãƒ•ã‚©ãƒ³ãƒˆ", note_font_upload: "â€».ttf ãªã©ã‚’ãã®ã¾ã¾èª­ã¿è¾¼ã‚€ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚<br><a href='http://gero3.github.io/facetype.js/' target='_blank'>Facetype.js</a> ãªã©ã§JSONã«å¤‰æ›ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚",
                btn_upload_font: "ğŸ“ ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚©ãƒ³ãƒˆ (.json)", lbl_size: "ã‚µã‚¤ã‚º", lbl_thickness: "æ·±ã•/é«˜ã•", lbl_conform: "æ›²é¢ã«åˆã‚ã›ã‚‹ (Conform)",
                lbl_align_preset: "æ–‡å­—é…ç½® (ãƒ—ãƒªã‚»ãƒƒãƒˆ)", btn_align_center: "Center (ä¸­å¤®)", btn_align_tl: "Top-Left (å·¦ä¸Š)",
                btn_align_tr: "Top-Right (å³ä¸Š)", btn_align_bl: "Bottom-Left (å·¦ä¸‹)", btn_align_br: "Bottom-Right (å³ä¸‹)",
                lbl_pos_xz_fine: "ä½ç½® X / Z (å¾®èª¿æ•´)", lbl_offset_y: "é«˜ã•å¾®èª¿æ•´ (Offset Y)",
                lbl_text_mode: "ç”Ÿæˆãƒ¢ãƒ¼ãƒ‰ (Mode)", opt_mode_emboss: "Emboss (æµ®ãå‡ºã—)", opt_mode_engrave: "Engrave (åˆ»å°/æ˜ã‚Šè¾¼ã¿)", opt_mode_doubleshot: "Double-Shot (åŸ‹ã‚è¾¼ã¿)",
                note_engrave: "â€»Engraveã¯è¨ˆç®—å‡¦ç†ã«æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™",
                h_svg: "SVG (ã‚¢ã‚¤ã‚³ãƒ³) è¨­å®š", btn_upload_svg: "ğŸ“ SVGèª­è¾¼", lbl_visible: "è¡¨ç¤º (Visible)", lbl_rotation: "å›è»¢ (XYZ)",
                h_colors: "è‰²è¨­å®š", lbl_col_body: "æœ¬ä½“è‰²", lbl_col_text: "æ–‡å­—ãƒ»SVGè‰²",
                h_preset: "ãƒ—ãƒªã‚»ãƒƒãƒˆç®¡ç†", lbl_browser_storage: "ãƒ–ãƒ©ã‚¦ã‚¶ã«ä¿å­˜ (Quick Save/Load)", btn_quick_save: "ä¸€æ™‚ä¿å­˜ (Save)", btn_quick_load: "å¾©å…ƒ (Load)",
                lbl_file_storage: "ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ (File I/O)", btn_export_file: "æ›¸ãå‡ºã— (.json)", btn_import_file: "èª­ã¿è¾¼ã¿ (.json)",
                h_export: "ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ (STL/OBJ/3MF)", lbl_filename: "ãƒ•ã‚¡ã‚¤ãƒ«åè¨­å®š (è‡ªå‹•ã§[æ–‡å­—]ãŒä»˜ä¸ã•ã‚Œã¾ã™)", btn_export_all: "å…¨ä½“ã‚’STLã§ä¿å­˜", btn_export_obj: "å…¨ä½“ã‚’OBJã§ä¿å­˜ (Color)",
                btn_export_3mf: "å…¨ä½“ã‚’3MFã§ä¿å­˜ (Color)", btn_export_body: "æœ¬ä½“ã®ã¿ (STL)", btn_export_text: "æ–‡å­—ã®ã¿ (STL)",
                h_batch: "ãƒãƒƒãƒå‡ºåŠ› (Batch Export)", lbl_batch_list: "æ–‡å­—ãƒªã‚¹ãƒˆ (ã‚«ãƒ³ãƒ/æ”¹è¡ŒåŒºåˆ‡ã‚Š)", pl_batch: "Q,W,E,R,T,Y...",
                lbl_batch_format: "å‡ºåŠ›å½¢å¼",
                note_batch: "â€»ç¾åœ¨ã®è¨­å®šã§é€£ç¶šç”Ÿæˆã—ã¾ã™", btn_batch_run: "ä¸€æ‹¬ç”Ÿæˆ", 
                batch_processing: "å‡¦ç†ä¸­: ", batch_complete: "å®Œäº†ï¼",
                msg_save_ok: "è¨­å®šã‚’ãƒ–ãƒ©ã‚¦ã‚¶ã«ä¸€æ™‚ä¿å­˜ã—ã¾ã—ãŸã€‚", msg_load_ok: "è¨­å®šã‚’å¾©å…ƒã—ã¾ã—ãŸã€‚", msg_load_err: "ä¿å­˜ã•ã‚ŒãŸè¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚",
                msg_import_err: "ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: æ­£ã—ã„JSONå½¢å¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚", msg_batch_empty: "æ–‡å­—ãƒªã‚¹ãƒˆãŒç©ºã§ã™ã€‚",
                toast_generating: "ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ç”Ÿæˆä¸­...", toast_stl_exported: "STLã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸï¼", 
                toast_obj_exported: "OBJã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸï¼", toast_3mf_exported: "3MFã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸï¼",
                toast_export_failed: "ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå¤±æ•—: ", toast_no_body: "ã‚¨ãƒ©ãƒ¼: ãƒœãƒ‡ã‚£ã‚¸ã‚ªãƒ¡ãƒˆãƒªãŒç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ",
                h_import: "å¤–éƒ¨ãƒ¢ãƒ‡ãƒ« (Import)", lbl_weight: "äºˆæƒ³é‡é‡:", lbl_cost: "äºˆæƒ³ã‚³ã‚¹ãƒˆ:", 
                lbl_vendor: "ãƒ™ãƒ³ãƒ€ãƒ¼:", lbl_material: "ææ–™:", btn_details: "â–¼ è©³ç´° / ç·¨é›†",
                lbl_manual_override: "æ‰‹å‹•è¨­å®š (Manual Override)", lbl_price: "ä¾¡æ ¼", lbl_spool: "ãƒªãƒ¼ãƒ«(g)", lbl_density: "å¯†åº¦",
                link_wiki: "Wikiã¸ç§»å‹•", link_github: "GitHubã¸ç§»å‹•"
            },
            en: {
                nav_jump: "--- Jump to Section ---", nav_basic: "Basic Size", nav_structure: "Structure", nav_shape: "Shape",
                nav_texture: "Texture Map", nav_utility: "Utility", nav_import: "Import 3D", nav_stem: "Stem",
                nav_text: "Text / Legend", nav_svg: "SVG Icon", nav_color: "Colors", nav_preset: "Presets", nav_export: "Export",
                h_basic: "Basic Size", lbl_u_size: "Key Size (U)", lbl_profile: "Profile", lbl_row: "Row", lbl_unit_size: "Unit Size (Pitch)",
                h_structure: "Structure & Stem", lbl_wall_thick: "Wall Thickness", lbl_rib_shorten: "Rib Shorten (Lift)", lbl_enable_ribs: "Reinforcement Ribs",
                lbl_homing_bump: "Homing Bump", opt_bump_round: "Round", opt_bump_bar: "Bar",
                lbl_pos_x: "Pos X", lbl_pos_z: "Pos Z", lbl_bump_offset: "Bump Offset Y",
                lbl_round_corner: "Round Corner (Fillet)", note_round: "*Squircle Mapping (Fast & Stable)",
                h_shape: "Shape (Taper/Dish)", lbl_top_scale: "Top Scale (Taper)", lbl_dish_type: "Dish Type",
                opt_dish_cyl: "Cylindrical", opt_dish_sph: "Spherical", opt_dish_flat: "Flat",
                lbl_texture: "Surface Procedural", opt_tex_none: "None", opt_tex_noise: "Noise (Sand)", opt_tex_grid: "Grid (Studs)",
                lbl_tex_scale: "Scale", lbl_tex_strength: "Strength",
                h_texture_map: "Image Texture (Image Map)", btn_upload_img: "ğŸ“ Load Image (PNG/JPG)",
                h_stem: "Stem Settings", lbl_stem_type: "Stem Type: Cherry MX (Fixed)", lbl_clearance: "Clearance", lbl_stem_diameter: "Stem Diameter", 
                h_text: "Legend Settings", lbl_enable_text: "Enable Text", pl_text: "Ex: A\n{\n[", note_multiline: "*Use line breaks for multi-line.",
                lbl_font: "Font", note_font_upload: "*Cannot import .ttf directly. Convert to JSON using <a href='http://gero3.github.io/facetype.js/' target='_blank'>Facetype.js</a>.",
                btn_upload_font: "ğŸ“ Custom Font (.json)", lbl_size: "Size", lbl_thickness: "Thickness", lbl_conform: "Conform to Surface",
                lbl_align_preset: "Alignment Presets", btn_align_center: "Center", btn_align_tl: "Top-Left",
                btn_align_tr: "Top-Right", btn_align_bl: "Bottom-Left", btn_align_br: "Bottom-Right",
                lbl_pos_xz_fine: "Position X / Z (Fine)", lbl_offset_y: "Y Offset (Fine)",
                lbl_text_mode: "Generation Mode", opt_mode_emboss: "Emboss (Raised)", opt_mode_engrave: "Engrave (Inset)", opt_mode_doubleshot: "Double-Shot (Inlay)",
                note_engrave: "*Engrave requires more processing time.",
                h_svg: "SVG Icon Settings", btn_upload_svg: "ğŸ“ Load SVG", lbl_visible: "Visible", lbl_rotation: "Rotation (XYZ)",
                h_colors: "Color Settings", lbl_col_body: "Body Color", lbl_col_text: "Text/SVG Color",
                h_preset: "Preset Management", lbl_browser_storage: "Browser Storage (Quick)", btn_quick_save: "Quick Save", btn_quick_load: "Quick Load",
                lbl_file_storage: "File Storage", btn_export_file: "Export (.json)", btn_import_file: "Import (.json)",
                h_export: "Export (STL/OBJ/3MF)", lbl_filename: "File Name", btn_export_all: "Export All (STL)", btn_export_obj: "Export All (OBJ w/ Color)",
                btn_export_3mf: "Export All (3MF w/ Color)", btn_export_body: "Body Only (STL)", btn_export_text: "Text Only (STL)",
                h_batch: "Batch Export", lbl_batch_list: "Character List (comma/newline)", pl_batch: "Q,W,E,R,T,Y...",
                lbl_batch_format: "Output Format",
                note_batch: "*Generate using current settings.", btn_batch_run: "Run Batch",
                batch_processing: "Processing: ", batch_complete: "Done!",
                msg_save_ok: "Settings saved to browser.", msg_load_ok: "Settings loaded.", msg_load_err: "No saved settings found.",
                msg_import_err: "Import Error: Invalid JSON format.", msg_batch_empty: "Character list is empty.",
                toast_generating: "Generating mesh...", toast_stl_exported: "STL exported!", 
                toast_obj_exported: "OBJ exported!", toast_3mf_exported: "3MF exported!",
                toast_export_failed: "Export failed: ", toast_no_body: "Error: No body geometry generated",
                h_import: "Import 3D", lbl_weight: "Est. Weight:", lbl_cost: "Est. Cost:", 
                lbl_vendor: "Vendor:", lbl_material: "Material:", btn_details: "â–¼ Details / Edit",
                lbl_manual_override: "Manual Override", lbl_price: "Price", lbl_spool: "Spool(g)", lbl_density: "Dens.",
                link_wiki: "Go to Wiki", link_github: "Go to GitHub"
            }
        };
        let currentLang = 'ja';
        function updateLanguageUI() {
            const t = translations[currentLang];
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (t[key]) {
                    if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') { if (el.placeholder) el.placeholder = t[key]; } 
                    else if (el.tagName === 'OPTION') { el.textContent = t[key]; } 
                    else { el.innerHTML = t[key]; }
                }
            });
            document.getElementById('text-content').placeholder = t.pl_text;
            updateFilamentDisplay(); updateCustomDropdownHead(); 
            const linkWiki = document.getElementById('link-wiki');
            const linkGithub = document.getElementById('link-github');
            if(linkWiki) linkWiki.title = t.link_wiki || "Wiki";
            if(linkGithub) linkGithub.title = t.link_github || "GitHub";
        }

        document.getElementById('language-select').addEventListener('change', (e) => { currentLang = e.target.value; updateLanguageUI(); });
        window.onerror = (msg) => { document.getElementById('error-log').textContent += msg + "\n"; };
        setTimeout(() => { const b=document.getElementById('force-start-btn'); if(b)b.click(); }, 1000);

        function showToast(message, isError = false) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast' + (isError ? ' error' : '');
            toast.textContent = message;
            container.appendChild(toast);
            requestAnimationFrame(() => toast.classList.add('show'));
            setTimeout(() => { toast.classList.remove('show'); setTimeout(() => toast.remove(), 300); }, 3000);
        }

        const SimpleNoise = {
            fract: (x) => x - Math.floor(x),
            hash: (x, z) => { return SimpleNoise.fract(Math.sin(x * 12.9898 + z * 78.233) * 43758.5453); },
            noise: (x, z) => {
                const iX = Math.floor(x); const iZ = Math.floor(z);
                const fX = SimpleNoise.fract(x); const fZ = SimpleNoise.fract(z);
                const a = SimpleNoise.hash(iX, iZ); const b = SimpleNoise.hash(iX + 1, iZ);
                const c = SimpleNoise.hash(iX, iZ + 1); const d = SimpleNoise.hash(iX + 1, iZ + 1);
                const uX = fX * fX * (3.0 - 2.0 * fX); const uZ = fZ * fZ * (3.0 - 2.0 * fZ);
                return (a * (1.0 - uX) + b * uX) * (1.0 - uZ) + (c * (1.0 - uX) + d * uX) * uZ;
            }
        };

        const initialState = {
            uSize: 1.0, profile: 'cherry', row: 'R3', unitSize: 19.05, topScale: 1.0, dishType: 'cylindrical',
            textureType: 'none', textureScale: 50, textureStrength: 0.05, textureGlobal: false,
            imgTextureVisible: false, imgScale: 1.0, imgPosX: 0.0, imgPosY: 0.0, imgRot: 0, imgContent: null,
            enableStemExtension: false, stemExtension: 1.0, stabilizerType: 'auto', stabilizerOffset: 0.0,
            twist: 0, tiltX: 0, tiltZ: 0, boxStem: false, legoStud: false, legoX: 0.0, legoY: 0.0, legoZ: 0.0, legoClear: 0.0,
            wallThickness: 1.5, ribShorten: 4.3, enableRibs: true,
            homingBump: false, homingType: 'round', bumpX: 0, bumpZ: 0, bumpOffsetY: 0.0, roundCorner: 0.0, 
            stemType: 'mx', stemDiameter: 5.50, stemClearance: 0.3,
            enableText: true, text: 'A', font: 'helvetiker', fontSize: 8.0, textHeight: 0.5, textMode: 'emboss',
            textThicknessLocked: true, textConform: true, posX: 0, posZ: 0, textOffsetY: 0.0,
            enableText2: false, text2: 'ã‚', text2Size: 4.0, text2X: 3.5, text2Z: 3.5, text2Mode: 'emboss',
            enableSide: false, sideText: 'FRONT', sideSize: 3.0, sideY: -2.0, sideRot: 0, sideMode: 'emboss',
            renderMode: 'standard', 
            modelVisible: true, modelScale: 1.0, modelX: 0, modelY: 0, modelZ: 0, modelRX: 0, modelRY: 0, modelRZ: 0, modelOperation: 'union', 
            globalRotX: 0, globalRotY: 0,
            svgContent: null, svgVisible: true, svgScale: 1.0, svgThickness: 0.6, svgMode: 'emboss', svgConform: true, 
            svgRotX: 0, svgRotY: 0, svgRotZ: 0, svgOffsetY: 0.0, svgPosX: 0, svgPosZ: 0,
            colBody: '#333333', colText: '#00e5ff'
        };
        let state = JSON.parse(JSON.stringify(initialState));
        let importedModelBuffer = null;
        const csgEvaluator = new Evaluator();
        const history = [JSON.parse(JSON.stringify(initialState))];
        let historyIndex = 0;

        const paramMap = {
            'u-size':'uSize', 'wall-thick':'wallThickness', 'rib-shorten':'ribShorten', 'top-scale':'topScale',
            'stem-clearance':'stemClearance', 'font-size':'fontSize', 'text-height':'textHeight',
            'text-offset-y':'textOffsetY', 'pos-x':'posX', 'pos-z':'posZ',
            'profile-select':'profile', 'row-select':'row', 'homing-type':'homingType', 'dish-type':'dishType', 'font-family':'font',
            'bump-x':'bumpX', 'bump-z':'bumpZ', 'bump-offset-y':'bumpOffsetY',
            'svg-scale':'svgScale', 'svg-thickness':'svgThickness', 
            'svg-rot-x':'svgRotX', 'svg-rot-y':'svgRotY', 'svg-rot-z':'svgRotZ',
            'svg-offset-y':'svgOffsetY', 'svg-pos-x':'svgPosX', 'svg-pos-z':'svgPosZ',
            'text2-size':'text2Size', 'text2-x':'text2X', 'text2-z':'text2Z',
            'side-size':'sideSize', 'side-y':'sideY', 'side-rot':'sideRot',
            'render-mode':'renderMode', 'side-text':'sideText',
            'model-scale':'modelScale', 'model-x':'modelX', 'model-y':'modelY', 'model-z':'modelZ',
            'model-rx':'modelRX', 'model-ry':'modelRY', 'model-rz':'modelRZ',
            'global-rot-x':'globalRotX', 'global-rot-y':'globalRotY', 'model-operation':'modelOperation',
            'texture-type':'textureType', 'tex-scale':'textureScale', 'tex-strength':'textureStrength',
            'stem-extension':'stemExtension', 'stabilizer-type':'stabilizerType', 'stabilizer-offset':'stabilizerOffset',
            'twist-factor': 'twist', 'tilt-x': 'tiltX', 'tilt-z': 'tiltZ', 'unit-size-select': 'unitSize', 'round-corner': 'roundCorner',
            'stem-diameter': 'stemDiameter', 'text-mode': 'textMode', 'text2-mode': 'text2Mode', 'side-mode': 'sideMode', 'svg-mode': 'svgMode',
            'img-scale': 'imgScale', 'img-pos-x': 'imgPosX', 'img-pos-y': 'imgPosY', 'img-rot': 'imgRot',
            'lego-x': 'legoX', 'lego-y': 'legoY', 'lego-z': 'legoZ', 'lego-clear': 'legoClear'
        };
        const boolMap = { 
            'enable-ribs':'enableRibs', 'homing-bump':'homingBump', 'enable-text':'enableText', 'svg-visible':'svgVisible', 
            'lock-thickness':'textThicknessLocked', 'text-conform':'textConform', 'svg-conform':'svgConform',
            'enable-text2':'enableText2', 'enable-side':'enableSide', 'model-visible':'modelVisible',
            'enable-stem-extension':'enableStemExtension', 'box-stem': 'boxStem', 'lego-stud': 'legoStud',
            'img-texture-visible': 'imgTextureVisible', 'texture-global': 'textureGlobal'
        };

        function commitHistory() { if (historyIndex < history.length - 1) history.splice(historyIndex + 1); history.push(JSON.parse(JSON.stringify(state))); historyIndex++; if (history.length > 50) { history.shift(); historyIndex--; } updateHistoryBtns(); }
        function undo() { if(historyIndex>0) { historyIndex--; state=JSON.parse(JSON.stringify(history[historyIndex])); syncUI(); updateCustomDropdown(); requestUpdate(); updateHistoryBtns(); } }
        function redo() { if(historyIndex<history.length-1) { historyIndex++; state=JSON.parse(JSON.stringify(history[historyIndex])); syncUI(); updateCustomDropdown(); requestUpdate(); updateHistoryBtns(); } }
        function updateHistoryBtns() { document.getElementById('btn-undo').disabled = historyIndex === 0; document.getElementById('btn-redo').disabled = historyIndex === history.length - 1; }
        
        function syncUI() {
            for (const [id, key] of Object.entries(paramMap)) { const el = document.getElementById(id); if(el) { el.value = state[key]; const span = document.getElementById('v-' + id); if(span) span.textContent = typeof state[key] === 'number' ? state[key].toFixed(2) : state[key]; if(id === 'tex-scale') if(span) span.textContent = parseInt(state[key]); } }
            for (const [id, key] of Object.entries(boolMap)) { const el = document.getElementById(id); if(el) el.checked = state[key]; }
            const tHeight = document.getElementById('text-height'); if(tHeight) tHeight.disabled = state.textThicknessLocked;
            document.getElementById('stem-ext-control').style.display = state.enableStemExtension ? 'block' : 'none';
            document.getElementById('stabilizer-custom-ui').style.display = state.stabilizerType === 'custom' ? 'block' : 'none';
            document.getElementById('lego-adj-panel').style.display = state.legoStud ? 'block' : 'none';
            const colB = document.getElementById('col-body'); if(colB) colB.value = state.colBody;
            const colT = document.getElementById('col-text'); if(colT) colT.value = state.colText;
            const txt = document.getElementById('text-content'); if(txt) txt.value = state.text;
            const txt2 = document.getElementById('text2-content'); if(txt2) txt2.value = state.text2;
            const sideT = document.getElementById('side-text'); if(sideT) sideT.value = state.sideText;
            updateLanguageUI();
        }

        const filamentData = {
            'polymaker': { name: 'Polymaker', materials: { 'pla': { name: 'PolyLite PLA', d: 1.24, price_jp: 3800, price_us: 25 }, 'pla_matte': { name: 'PolyTerra PLA', d: 1.22, price_jp: 3800, price_us: 25 }, 'abs': { name: 'PolyLite ABS', d: 1.04, price_jp: 4000, price_us: 27 }, 'petg': { name: 'PolyLite PETG', d: 1.27, price_jp: 3800, price_us: 25 }, 'asa': { name: 'PolyLite ASA', d: 1.07, price_jp: 5500, price_us: 36 } } },
            'bambulab': { name: 'Bambu Lab', materials: { 'pla': { name: 'PLA Basic', d: 1.24, price_jp: 2240, price_us: 22 }, 'pla_matte': { name: 'PLA Matte', d: 1.22, price_jp: 2240, price_us: 22 }, 'abs': { name: 'Bambu ABS', d: 1.05, price_jp: 3300, price_us: 25 }, 'petg': { name: 'PETG Basic', d: 1.27, price_jp: 3000, price_us: 20 }, 'asa': { name: 'Bambu ASA', d: 1.07, price_jp: 4200, price_us: 30 } } },
            'elegoo': { name: 'Elegoo', materials: { 'pla': { name: 'Elegoo PLA', d: 1.24, price_jp: 2200, price_us: 14 }, 'pla_matte': { name: 'Elegoo Matte', d: 1.24, price_jp: 2800, price_us: 18 }, 'abs': { name: 'Elegoo ABS', d: 1.04, price_jp: 3000, price_us: 19 }, 'petg': { name: 'Elegoo PETG', d: 1.27, price_jp: 2400, price_us: 15 }, 'asa': null } },
            'esun': { name: 'eSun', materials: { 'pla': { name: 'PLA+', d: 1.24, price_jp: 3200, price_us: 23 }, 'pla_matte': { name: 'ePLA-Matte', d: 1.24, price_jp: 3500, price_us: 25 }, 'abs': { name: 'ABS+', d: 1.04, price_jp: 3200, price_us: 23 }, 'petg': { name: 'PETG', d: 1.27, price_jp: 3200, price_us: 23 }, 'asa': { name: 'eASA', d: 1.07, price_jp: 4000, price_us: 28 } } },
            'sunlu': { name: 'Sunlu', materials: { 'pla': { name: 'Sunlu PLA', d: 1.24, price_jp: 2500, price_us: 19 }, 'pla_matte': { name: 'Sunlu Matte', d: 1.24, price_jp: 2500, price_us: 19 }, 'abs': { name: 'Sunlu ABS', d: 1.04, price_jp: 2800, price_us: 20 }, 'petg': { name: 'Sunlu PETG', d: 1.27, price_jp: 2500, price_us: 18 }, 'asa': { name: 'Sunlu ASA', d: 1.07, price_jp: 3500, price_us: 25 } } },
            'overture': { name: 'Overture', materials: { 'pla': { name: 'Overture PLA', d: 1.24, price_jp: 2800, price_us: 19 }, 'pla_matte': { name: 'Matte PLA', d: 1.24, price_jp: 2800, price_us: 19 }, 'abs': { name: 'Overture ABS', d: 1.04, price_jp: 3000, price_us: 21 }, 'petg': { name: 'Overture PETG', d: 1.27, price_jp: 2800, price_us: 18 }, 'asa': { name: 'Overture ASA', d: 1.07, price_jp: 4500, price_us: 31 } } },
            'generic': { name: 'Generic (Manual)', materials: { 'pla': { name: 'Generic PLA', d: 1.24, price_jp: 2500, price_us: 20 }, 'pla_matte': { name: 'Generic Matte', d: 1.24, price_jp: 2500, price_us: 20 }, 'abs': { name: 'Generic ABS', d: 1.04, price_jp: 2500, price_us: 20 }, 'petg': { name: 'Generic PETG', d: 1.27, price_jp: 2500, price_us: 20 }, 'asa': { name: 'Generic ASA', d: 1.07, price_jp: 3000, price_us: 25 } } }
        };
        let selectedVendor = 'bambulab'; let selectedMaterial = 'pla';
        function initFilamentManager() {
            const vSel = document.getElementById('fil-vendor'); const mSel = document.getElementById('fil-material');
            Object.keys(filamentData).forEach(key => { const opt = document.createElement('option'); opt.value = key; opt.textContent = filamentData[key].name; vSel.appendChild(opt); });
            vSel.value = selectedVendor;
            const materials = [{id:'pla', label:'PLA'},{id:'pla_matte', label:'PLA Matte'},{id:'abs', label:'ABS'},{id:'petg', label:'PETG'},{id:'asa', label:'ASA'}];
            materials.forEach(m => { const opt = document.createElement('option'); opt.value = m.id; opt.textContent = m.label; mSel.appendChild(opt); });
            mSel.value = selectedMaterial;
            vSel.addEventListener('change', e => { selectedVendor = e.target.value; updateFilamentDisplay(); });
            mSel.addEventListener('change', e => { selectedMaterial = e.target.value; updateFilamentDisplay(); });
            const btn = document.getElementById('btn-toggle-fil'); const panel = document.getElementById('fil-details-panel');
            btn.addEventListener('click', () => { panel.classList.toggle('open'); });
            ['fil-price','fil-capacity','fil-density'].forEach(id => { document.getElementById(id).addEventListener('input', calculateStats); });
            updateFilamentDisplay();
        }
        function updateFilamentDisplay() {
            const data = filamentData[selectedVendor].materials[selectedMaterial];
            const nameEl = document.getElementById('info-fil-name'); const priceIn = document.getElementById('fil-price'); const denIn = document.getElementById('fil-density'); const currEl = document.getElementById('info-currency');
            const isJP = currentLang === 'ja'; currEl.textContent = isJP ? 'Â¥' : '$';
            if (!data) { nameEl.textContent = "N/A"; priceIn.value = ""; denIn.value = ""; calculateStats(); return; }
            nameEl.textContent = data.name; priceIn.value = isJP ? data.price_jp : data.price_us; denIn.value = data.d; document.getElementById('fil-capacity').value = 1000; calculateStats();
        }
        function calculateStats() {
            const price = parseFloat(document.getElementById('fil-price').value); const capacity = parseFloat(document.getElementById('fil-capacity').value); const density = parseFloat(document.getElementById('fil-density').value);
            const wEl = document.getElementById('info-weight'); const cEl = document.getElementById('info-cost');
            if (isNaN(price) || isNaN(capacity) || isNaN(density) || capacity <= 0) { wEl.textContent = "--"; cEl.textContent = "--"; return; }
            const p = getParams(); const baseVol = p.baseW * p.baseD * p.h; let fillFactor = 0.22 + (state.wallThickness - 1.5) * 0.1; if(state.boxStem) fillFactor += 0.05;
            const volCm3 = (baseVol * fillFactor) / 1000; const weight = volCm3 * density; const totalCost = weight * (price / capacity);
            wEl.textContent = weight.toFixed(2); cEl.textContent = (currentLang === 'ja') ? Math.ceil(totalCost) : totalCost.toFixed(2);
        }
        function randomizeParams() {
            state.uSize = 1.0; state.profile = ['cherry','oem','sa','xda','dsa'][Math.floor(Math.random()*5)];
            state.topScale = 0.6 + Math.random() * 0.4; state.dishType = ['cylindrical','spherical','flat'][Math.floor(Math.random()*3)];
            state.textureType = ['none','noise','grid','knurling','stripes','ripple','wood','hammered','hexagon','bricks'][Math.floor(Math.random()*10)];
            state.textureScale = 10 + Math.random() * 80; state.twist = Math.floor(Math.random() * 60) - 30; state.tiltX = Math.floor(Math.random() * 20) - 10;
            state.colBody = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'); state.colText = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            syncUI(); updateModel();
        }
        function resetParams() { if(confirm("Reset all parameters?")) { state = JSON.parse(JSON.stringify(initialState)); syncUI(); updateModel(); } }

        let committedFont = state.font;
        function setupCustomDropdown() {
            const head = document.getElementById('custom-font-head'); const list = document.getElementById('custom-font-list'); const hiddenSelect = document.getElementById('font-family');
            if(!head || !list || !hiddenSelect) return;
            function populate() {
                list.innerHTML = ''; Array.from(hiddenSelect.options).forEach(opt => {
                    const div = document.createElement('div'); div.className = 'custom-option'; div.textContent = opt.text; if(opt.value === state.font) div.classList.add('selected');
                    div.addEventListener('mouseenter', () => { state.font = opt.value; requestUpdate(); });
                    div.addEventListener('click', () => { committedFont = opt.value; state.font = committedFont; hiddenSelect.value = committedFont; list.classList.remove('open'); updateCustomDropdownHead(); commitHistory(); requestUpdate(); });
                    list.appendChild(div);
                });
            }
            head.addEventListener('click', () => { if(!list.classList.contains('open')) { committedFont = state.font; populate(); list.classList.add('open'); } else { list.classList.remove('open'); } });
            list.addEventListener('mouseleave', () => { state.font = committedFont; requestUpdate(); });
            document.addEventListener('click', (e) => { const ui = document.getElementById('custom-font-ui'); if(ui && !ui.contains(e.target) && list.classList.contains('open')) { list.classList.remove('open'); state.font = committedFont; requestUpdate(); } });
            updateCustomDropdownHead();
        }
        function updateCustomDropdown() { committedFont = state.font; updateCustomDropdownHead(); }
        function updateCustomDropdownHead() { const hiddenSelect = document.getElementById('font-family'); const head = document.getElementById('custom-font-head'); if(hiddenSelect && head) { const opt = hiddenSelect.querySelector(`option[value="${state.font}"]`); if(opt) head.textContent = opt.text + " â–¼"; } }

        function initNavigation() {
            const select = document.getElementById('section-select'); select.addEventListener('change', (e) => { const id = e.target.value; if(id) { const el = document.getElementById(id); if(el) { el.scrollIntoView({ behavior: 'smooth' }); el.style.color = '#fff'; setTimeout(() => el.style.color = '', 1000); } select.value = ""; } });
            const search = document.getElementById('search-box'); search.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase(); const labels = document.querySelectorAll('#ui-panel label, #ui-panel h3'); document.querySelectorAll('.search-highlight').forEach(el => el.classList.remove('search-highlight'));
                if(!query) return; let firstMatch = null; labels.forEach(lbl => { const text = lbl.textContent.toLowerCase(); if(text.includes(query)) { lbl.classList.add('search-highlight'); if(!firstMatch) firstMatch = lbl; } });
                if(firstMatch) firstMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
        }
        
        const PROFILES = { cherry: { R4: {h:11.5, a:6}, R3: {h:9.5, a:3}, R2: {h:8.5, a:-3}, R1: {h:9.5, a:-6}, dish:'cylindrical' }, oem: { R4: {h:12.5, a:8}, R3: {h:11.0, a:4}, R2: {h:10.0, a:-4}, R1: {h:11.0, a:-8}, dish:'cylindrical' }, sa: { R4: {h:16.5, a:7}, R3: {h:14.0, a:0}, R2: {h:14.0, a:0}, R1: {h:14.0, a:-7}, dish:'spherical' }, xda: { all:{h:9.0, a:0}, dish:'spherical' }, dsa: { all:{h:7.5, a:0}, dish:'spherical' } };
        const HTML_COLORS = ['#000000','#333333','#666666','#ffffff','#ff0000','#ff8000','#ffff00','#00ff00','#00ffff','#0000ff','#8000ff','#ff00ff','#800000','#008000','#000080','#808000'];
        const container = document.getElementById('canvas-container'); const scene = new THREE.Scene(); scene.background = new THREE.Color(0x121212);
        const camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 1000); camera.position.set(20, 30, 30);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(container.clientWidth, container.clientHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.autoClear = false; container.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; const viewHelper = new ViewHelper(camera, renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 0.4)); const dl = new THREE.DirectionalLight(0xffffff, 1.0); dl.position.set(10,50,20); dl.castShadow=true; scene.add(dl); const bl = new THREE.DirectionalLight(0x00bcd4, 0.5); bl.position.set(0,-20,0); scene.add(bl); scene.add(new THREE.GridHelper(200, 200, 0x444444, 0x222222));
        const mainGroup = new THREE.Group(); scene.add(mainGroup); const fontLoader = new FontLoader(); const loadedFonts = {}; const textureLoader = new THREE.TextureLoader();

        function getParams() { const p = PROFILES[state.profile]; const r = p.all ? p.all : p[state.row]; const unit = parseFloat(state.unitSize) || 19.05; return { h: r.h, angle: r.a, baseW: (unit * state.uSize) - 0.5, baseD: unit - 0.5 }; }
        function getStabilizerOffset(u) { if (state.stabilizerType === 'custom') return state.stabilizerOffset; if (u < 2.0) return 0; if (u < 3.0) return 11.9; if (u < 6.0) return 19.05; if (u == 6.25) return 50.0; if (u >= 7.0) return 57.15; return 38.1; }
        const DISH_DEPTH = 0.8; 
        function getDishOffset(x, z, p) { const wHalf = p.baseW * state.topScale * 0.5; const dHalf = p.baseD * state.topScale * 0.5; const nx = x / (wHalf || 1); const nz = z / (dHalf || 1); let offset = 0; const type = state.dishType; if(type === 'flat') offset = 0; else if(type === 'cylindrical') { if(Math.abs(nx) < 2.0) offset = DISH_DEPTH * (Math.pow(nx, 2) - 1.0); } else { const dist = Math.sqrt(nx*nx + nz*nz); if(dist < 2.0) offset = DISH_DEPTH * (Math.pow(dist, 2) - 1.0); } return offset; }
        function getSurfaceHeight(x, z, p) { const tiltXRad = THREE.MathUtils.degToRad(state.tiltX); const tiltZRad = THREE.MathUtils.degToRad(state.tiltZ); const baseTilt = Math.tan(THREE.MathUtils.degToRad(p.angle)) * z; const customTilt = (Math.tan(tiltXRad) * z) + (Math.tan(tiltZRad) * x); return (p.h - baseTilt - customTilt) + getDishOffset(x, z, p); }
        
        function safeMerge(geometries) { const clean = []; geometries.forEach(g => { if(g) { if(g.index) g = g.toNonIndexed(); clean.push(g); } }); if(clean.length === 0) return null; return BufferGeometryUtils.mergeGeometries(clean, false); }
        
        function csgUnion(geometries) {
            const valid = geometries.filter(g => g !== null && g !== undefined);
            if (valid.length === 0) return null;
            if (valid.length === 1) {
                let geo = valid[0].clone();
                if (geo.index) geo = geo.toNonIndexed();
                geo = BufferGeometryUtils.mergeVertices(geo, 0.001);
                geo.computeVertexNormals();
                return geo;
            }
            
            try {
                let resultBrush = new Brush(valid[0]);
                resultBrush.updateMatrixWorld();
                
                for (let i = 1; i < valid.length; i++) {
                    const brush = new Brush(valid[i]);
                    brush.updateMatrixWorld();
                    const result = csgEvaluator.evaluate(resultBrush, brush, ADDITION);
                    resultBrush = result;
                }
                
                let finalGeo = resultBrush.geometry;
                finalGeo = BufferGeometryUtils.mergeVertices(finalGeo, 0.001);
                finalGeo.computeVertexNormals();
                return finalGeo;
            } catch (e) {
                console.warn("CSG Union failed, falling back to safeMerge:", e);
                return safeMerge(geometries);
            }
        }
        
        function applySquircle(x, z, w, d, r) { 
            if (r <= 0.01) return {x, z}; 
            
            const halfW = w / 2;
            const halfD = d / 2;
            const innerW = halfW - r; 
            const innerD = halfD - r; 
            const absX = Math.abs(x); 
            const absZ = Math.abs(z);
            
            if (absX > innerW && absZ > innerD) { 
                const dx = absX - innerW; 
                const dz = absZ - innerD; 
                const dist = Math.sqrt(dx*dx + dz*dz); 
                if (dist > 0) { 
                    const clampedDist = Math.min(dist, r);
                    const newX = innerW + (dx / dist) * clampedDist; 
                    const newZ = innerD + (dz / dist) * clampedDist; 
                    return { x: Math.sign(x) * newX, z: Math.sign(z) * newZ }; 
                } 
            }
            else if (absX > innerW) {
                const edgeDist = absZ / innerD; // 0ï½1
                if (edgeDist > 0.9) {
                    const blend = (edgeDist - 0.9) / 0.1;
                    const maxX = halfW - (1 - Math.sqrt(1 - blend*blend)) * r * 0.1;
                    if (absX > maxX) {
                        return { x: Math.sign(x) * maxX, z };
                    }
                }
            }
            else if (absZ > innerD) {
                const edgeDist = absX / innerW;
                if (edgeDist > 0.9) {
                    const blend = (edgeDist - 0.9) / 0.1;
                    const maxZ = halfD - (1 - Math.sqrt(1 - blend*blend)) * r * 0.1;
                    if (absZ > maxZ) {
                        return { x, z: Math.sign(z) * maxZ };
                    }
                }
            }
            
            return {x, z}; 
        }
        
        function createBodyParts(p, useCSG = false) {
            const thick = state.wallThickness; 
            const segXZ = 32;  
            const segY = 32;   
            
            const topBox = new THREE.BoxGeometry(p.baseW, thick, p.baseD, segXZ, 2, segXZ); 
            topBox.translate(0, p.h - thick/2, 0);
            
            const wH = p.h - thick;
            
            const front = new THREE.BoxGeometry(p.baseW, wH, thick, segXZ, segY, 2); 
            front.translate(0, wH/2, p.baseD/2 - thick/2);
            
            const back = new THREE.BoxGeometry(p.baseW, wH, thick, segXZ, segY, 2); 
            back.translate(0, wH/2, -(p.baseD/2 - thick/2));
            
            const sideDepth = p.baseD - thick * 2;
            const left = new THREE.BoxGeometry(thick, wH, sideDepth, 2, segY, segXZ); 
            left.translate(-(p.baseW/2 - thick/2), wH/2, 0);
            
            const right = new THREE.BoxGeometry(thick, wH, sideDepth, 2, segY, segXZ); 
            right.translate((p.baseW/2 - thick/2), wH/2, 0);
            
            let resultGeo = safeMerge([topBox, front, back, left, right]);
            
            if(resultGeo && !useCSG) deformMesh(resultGeo, p); 
            return resultGeo;
        }

        function deformMesh(geo, p) {
            const pos = geo.attributes.position; const v = new THREE.Vector3(); const thick = state.wallThickness; geo.computeBoundingBox(); const uvs = geo.attributes.uv;
            const useImageTexture = state.imgContent && state.imgTextureVisible; const useProcedural = state.textureType !== 'none';
            const texScale = state.textureScale * 0.1; const texStr = state.textureStrength; const twistRad = THREE.MathUtils.degToRad(state.twist); const twistPerUnit = twistRad / p.h; const filletR = state.roundCorner; const hasFillet = filletR > 0.05;
            
            const wallTopY = p.h - thick;
            
            for(let i=0; i<pos.count; i++){
                v.fromBufferAttribute(pos, i);
                
                if (Math.abs(state.twist) > 0.1) { 
                    const angle = twistPerUnit * v.y; 
                    const sinA = Math.sin(angle); const cosA = Math.cos(angle); 
                    const tx = v.x * cosA - v.z * sinA; 
                    const tz = v.x * sinA + v.z * cosA; 
                    v.x = tx; v.z = tz; 
                }
                
                const ratioY = Math.max(0, Math.min(1, v.y / p.h));
                
                const currentScale = THREE.MathUtils.lerp(1.0, state.topScale, ratioY);
                
                if (Math.abs(currentScale - 1.0) > 0.0001) { 
                    v.x *= currentScale; 
                    v.z *= currentScale; 
                }
                
                if (hasFillet) { 
                    const currentW = p.baseW * currentScale; 
                    const currentD = p.baseD * currentScale; 
                    const scaledR = filletR * currentScale; 
                    const deformed = applySquircle(v.x, v.z, currentW, currentD, scaledR); 
                    v.x = deformed.x; 
                    v.z = deformed.z; 
                }
                
                if (v.y > 0.01) {
                    const surfY = getSurfaceHeight(v.x, v.z, p);
                    const origY = v.y;
                    
                    if (origY >= wallTopY) {
                        const topRatio = (origY - wallTopY) / thick;
                        v.y = THREE.MathUtils.lerp(surfY - thick, surfY, Math.min(1, topRatio));
                    } else {
                        const wallRatio = origY / wallTopY;
                        const targetTopY = surfY - thick;
                        v.y = wallRatio * targetTopY;
                    }
                }
                
                if (useProcedural && ratioY > 0.01) {
                    const isTop = ratioY > 0.95 && v.y > wallTopY;
                    if (state.textureGlobal || isTop) {
                        let noiseVal = 0; const type = state.textureType;
                        let mapX = v.x * texScale; let mapZ = v.z * texScale; let mapY = v.y * texScale;
                        if (!isTop && !state.textureGlobal) mapY = Math.atan2(v.z, v.x) * 10; 
                        if (type === 'noise') noiseVal = SimpleNoise.noise(mapX, isTop?mapZ:mapY);
                        else if (type === 'grid') noiseVal = Math.sin(mapX) * Math.sin(isTop?mapZ:mapY);
                        else if (type === 'knurling') noiseVal = Math.sin((mapX + (isTop?mapZ:mapY))) * Math.sin((mapX - (isTop?mapZ:mapY)));
                        else if (type === 'stripes') noiseVal = Math.sin(mapX);
                        else if (type === 'ripple') { const dist = Math.sqrt(mapX*mapX + (isTop?mapZ:mapY)*(isTop?mapZ:mapY)); noiseVal = Math.sin(dist); }
                        else if (type === 'wood') { noiseVal = Math.sin(mapX * 2 + SimpleNoise.noise(mapX, isTop?mapZ:mapY) * 3); }
                        else if (type === 'hammered') { noiseVal = 1.0 - Math.abs(SimpleNoise.noise(mapX*0.5, isTop?mapZ*0.5:mapY*0.5)); }
                        else if (type === 'hexagon') { const u = mapX * 1.5; const vC = (isTop?mapZ:mapY) * 1.5; noiseVal = Math.max(Math.abs(Math.sin(u)*Math.cos(vC)), Math.abs(Math.cos(u)*Math.sin(vC))); }
                        else if (type === 'bricks') { const bx = Math.floor(mapX); const by = Math.floor(isTop?mapZ:mapY); const off = (by % 2) * 0.5; noiseVal = (mapX + off) - Math.floor(mapX + off) > 0.1 && (isTop?mapZ:mapY) - by > 0.1 ? 1 : 0; }
                        if (isTop) v.y += noiseVal * texStr;
                        else if (ratioY > 0.1 && state.textureGlobal) { const norm = new THREE.Vector3(v.x, 0, v.z).normalize(); v.x += norm.x * noiseVal * texStr; v.z += norm.z * noiseVal * texStr; }
                    }
                }
                
                pos.setXYZ(i, v.x, v.y, v.z);
                if (useImageTexture && uvs) { const cosR = Math.cos(THREE.MathUtils.degToRad(-state.imgRot)); const sinR = Math.sin(THREE.MathUtils.degToRad(-state.imgRot)); let ux = v.x; let uz = v.z; const rx = ux * cosR - uz * sinR; const rz = ux * sinR + uz * cosR; const mapSize = 19.05 * state.uSize; let u = (rx / mapSize) + 0.5; let v_uv = (rz / mapSize) + 0.5; u = (u - 0.5) / state.imgScale + 0.5 - state.imgPosX; v_uv = (v_uv - 0.5) / state.imgScale + 0.5 - state.imgPosY; uvs.setXY(i, u, v_uv); }
            }
            geo.computeVertexNormals();
        }

        function createStemUnit(height, rOuter, clear) { const shape = new THREE.Shape(); shape.absarc(0,0, rOuter, 0, Math.PI*2); const w = (1.15 + clear)/2; const l = (4.1 + clear)/2; const hole = new THREE.Path(); hole.moveTo(-w,-l); hole.lineTo(w,-l); hole.lineTo(w,-w); hole.lineTo(l,-w); hole.lineTo(l,w); hole.lineTo(w,w); hole.lineTo(w,l); hole.lineTo(-w,l); hole.lineTo(-w,w); hole.lineTo(-l,w); hole.lineTo(-l,-w); hole.lineTo(-w,-w); hole.lineTo(-w,-l); shape.holes.push(hole); const geo = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled:false, curveSegments:24 }); geo.rotateX(Math.PI/2); geo.translate(0, height, 0); return geo; }

        function createStemAndRibs(p, useCSG = false) {
            const thick = state.wallThickness; const rawH = p.h; const clear = state.stemClearance; const ext = state.enableStemExtension ? state.stemExtension : 0.0; const totalStemH = rawH + ext; const rOuter = state.stemDiameter / 2;
            const stemGeos = []; const cStem = createStemUnit(totalStemH, rOuter, clear); if (ext > 0) cStem.translate(0, -ext, 0);
            if (state.boxStem) { const boxSize = 5.6 + clear; const boxH = totalStemH * 0.8; const wWall = 0.8; const bS = boxSize + wWall*2; const front = new THREE.BoxGeometry(bS, boxH, wWall); front.translate(0, boxH/2-ext, boxSize/2+wWall/2); const back = new THREE.BoxGeometry(bS, boxH, wWall); back.translate(0, boxH/2-ext, -(boxSize/2+wWall/2)); const left = new THREE.BoxGeometry(wWall, boxH, boxSize); left.translate(-(boxSize/2+wWall/2), boxH/2-ext, 0); const right = new THREE.BoxGeometry(wWall, boxH, boxSize); right.translate(boxSize/2+wWall/2, boxH/2-ext, 0); stemGeos.push(front, back, left, right); }
            stemGeos.push(cStem); const stabOffset = getStabilizerOffset(state.uSize);
            if(stabOffset > 0) { const sL = createStemUnit(totalStemH, rOuter, clear); if(ext > 0) sL.translate(0, -ext, 0); sL.translate(-stabOffset, 0, 0); const sR = createStemUnit(totalStemH, rOuter, clear); if(ext > 0) sR.translate(0, -ext, 0); sR.translate(stabOffset, 0, 0); stemGeos.push(sL, sR); }
            const ribGeos = [];
            if(state.enableRibs && !state.boxStem) {
                const shorten = state.ribShorten; const ribH = rawH - shorten; const ribY = shorten; const ribThick = 1.2;
                const overlap = useCSG ? 0.8 : 0.4;
                if(ribH > 0.1) {
                    const endX = (p.baseW/2)-thick+0.5; const lx = (endX + overlap) - (rOuter - overlap); if(lx>0) { const rX = new THREE.BoxGeometry(lx, ribH, ribThick); const cx = (rOuter - overlap) + lx/2; const r1 = rX.clone(); r1.translate(cx, ribY+ribH/2, 0); const r2 = rX.clone(); r2.translate(-cx, ribY+ribH/2, 0); ribGeos.push(r1, r2); }
                    const endZ = (p.baseD/2)-thick+0.5; const lz = (endZ + overlap) - (rOuter - overlap); if(lz>0) { const rZ = new THREE.BoxGeometry(ribThick, ribH, lz); const cz = (rOuter - overlap) + lz/2; const r3 = rZ.clone(); r3.translate(0, ribY+ribH/2, cz); const r4 = rZ.clone(); r4.translate(0, ribY+ribH/2, -cz); ribGeos.push(r3, r4); }
                }
            }
            
            let merged;
            if (useCSG) {
                merged = csgUnion([...stemGeos, ...ribGeos]);
                if (merged) {
                    merged = BufferGeometryUtils.mergeVertices(merged, 0.0001);
                    merged.computeVertexNormals();
                }
                return merged;
            } else {
                merged = safeMerge([...stemGeos, ...ribGeos]);
            }
            
            if(merged && !useCSG) { const pos = merged.attributes.position; const v = new THREE.Vector3(); merged.computeBoundingBox(); const maxY = merged.boundingBox.max.y; const twistRad = THREE.MathUtils.degToRad(state.twist); const twistPerUnit = twistRad / p.h; for(let i=0; i<pos.count; i++){ v.fromBufferAttribute(pos, i); if (Math.abs(state.twist) > 0.1) { const angle = twistPerUnit * v.y; const sinA = Math.sin(angle); const cosA = Math.cos(angle); const tx = v.x * cosA - v.z * sinA; const tz = v.x * sinA + v.z * cosA; v.x = tx; v.z = tz; } const ratioY = Math.max(0, v.y / p.h); const dist = Math.sqrt(v.x*v.x + v.z*v.z); if(dist > rOuter + 0.5) { const taper = THREE.MathUtils.lerp(1.0, state.topScale, ratioY); v.x *= taper; v.z *= taper; } if(v.y > maxY - 1.0) { const sy = getSurfaceHeight(v.x, v.z, p); v.y = sy - thick; } pos.setXYZ(i, v.x, v.y, v.z); } merged.computeVertexNormals(); }
            return merged;
        }

        function createHomingBump(p) { if (state.legoStud) { const r = 2.4 + (state.legoClear || 0); const stud = new THREE.CylinderGeometry(r, r, 1.8, 24); const bx = state.legoX; const bz = state.legoZ; const y = getSurfaceHeight(bx, bz, p); stud.translate(bx, y + 0.9 + state.legoY, bz); stud.rotateX(THREE.MathUtils.degToRad(p.angle)); return stud; } if(!state.homingBump) return null; const bx = state.bumpX; const bz = state.bumpZ; const y = getSurfaceHeight(bx, bz, p); let geo; if(state.homingType === 'round') { geo = new THREE.SphereGeometry(0.6, 12, 12); geo.scale(1, 0.6, 1); } else { geo = new THREE.BoxGeometry(4.0, 0.5, 0.8); } geo.translate(bx, y + state.bumpOffsetY, bz); geo.rotateX(THREE.MathUtils.degToRad(p.angle)); if (Math.abs(state.twist) > 0.1) { const twistRad = THREE.MathUtils.degToRad(state.twist); const angle = (twistRad / p.h) * y; geo.rotateY(-angle); } return geo; }

        function createConformedText(p, textVal, sizeVal, xVal, zVal, mode) {
            if (!loadedFonts[state.font] || !textVal) return null;
            
            let genHeight = state.textHeight;
            let yEmbedOffset = 0;

            if (mode === 'engrave') {
                genHeight = state.textHeight + 5.0;
                yEmbedOffset = -state.textHeight;
            } else if (mode === 'doubleshot') {
                yEmbedOffset = -state.textHeight + 0.02;
            }
            
            yEmbedOffset += state.textOffsetY;

            const lines = textVal.split('\n'); 
            const font = loadedFonts[state.font]; 
            const size = sizeVal; 
            const lineHeight = size * 1.2; 
            const lineGeos = [];
            
            lines.forEach((lineText, i) => { 
                if(!lineText) return; 
                const geo = new TextGeometry(lineText, { font: font, size: size, height: genHeight, curveSegments: 6, bevelEnabled: false }); 
                geo.computeBoundingBox(); 
                const cx = -0.5 * (geo.boundingBox.max.x + geo.boundingBox.min.x); 
                const cy = -0.5 * (geo.boundingBox.max.y + geo.boundingBox.min.y); 
                geo.translate(cx, cy, 0); 
                lineGeos.push({ geo: geo, index: i }); 
            });
            
            const mergedLines = []; 
            const blockYOffset = (lines.length - 1) * lineHeight / 2;
            lineGeos.forEach(item => { 
                const yPos = blockYOffset - (item.index * lineHeight); 
                item.geo.translate(0, yPos, 0); 
                mergedLines.push(item.geo); 
            });
            
            if(mergedLines.length === 0) return null; 
            const combinedGeo = BufferGeometryUtils.mergeGeometries(mergedLines);
            
            if (!state.textConform) {
                combinedGeo.rotateX(-Math.PI/2);
                const sy = getSurfaceHeight(xVal, zVal, p);
                combinedGeo.translate(xVal, sy + yEmbedOffset, zVal);
                combinedGeo.rotateX(THREE.MathUtils.degToRad(p.angle));
                return combinedGeo;
            } else {
                const pos = combinedGeo.attributes.position; 
                const v = new THREE.Vector3();
                const twistRad = THREE.MathUtils.degToRad(state.twist); 
                const twistPerUnit = twistRad / p.h;
                
                for(let i=0; i<pos.count; i++) {
                    v.fromBufferAttribute(pos, i);
                    const targetX = v.x + xVal;
                    const targetZ = -v.y + zVal;
                    const thicknessOffset = v.z;
                    const surfY = getSurfaceHeight(targetX, targetZ, p);
                    let finalX = targetX; 
                    let finalZ = targetZ;
                    if (Math.abs(state.twist) > 0.1) {
                        const angle = twistPerUnit * surfY;
                        const sinA = Math.sin(angle); 
                        const cosA = Math.cos(angle);
                        finalX = targetX * cosA - targetZ * sinA;
                        finalZ = targetX * sinA + targetZ * cosA;
                    }
                    pos.setXYZ(i, finalX, surfY + thicknessOffset + yEmbedOffset, finalZ);
                }
                combinedGeo.computeVertexNormals();
                return combinedGeo;
            }
        }

        function createSidePrint(p, mode) { 
            if (!state.enableSide || !state.sideText || !loadedFonts[state.font]) return null; 
            const geo = new TextGeometry(state.sideText, {font: loadedFonts[state.font], size: state.sideSize, height: 0.5, curveSegments: 4, bevelEnabled: false}); 
            geo.computeBoundingBox(); 
            geo.translate(-0.5*(geo.boundingBox.max.x+geo.boundingBox.min.x), -0.5*(geo.boundingBox.max.y+geo.boundingBox.min.y), 0); 
            geo.rotateX(THREE.MathUtils.degToRad(state.sideRot)); 
            geo.translate(0, p.h/2 + state.sideY, 0); 
            const pos = geo.attributes.position; 
            const v = new THREE.Vector3(); 
            let depthOffset = 0.05; 
            if (mode === 'doubleshot') depthOffset = -0.5; 
            else if (mode === 'engrave') depthOffset = -0.4; 
            for(let i=0; i<pos.count; i++) { 
                v.fromBufferAttribute(pos, i); 
                const s = THREE.MathUtils.lerp(1.0, state.topScale, Math.max(0,Math.min(1,v.y/p.h))); 
                v.z += (p.baseD/2)*s + depthOffset; 
                pos.setXYZ(i, v.x, v.y, v.z); 
            } 
            geo.computeVertexNormals(); 
            return geo; 
        }
        function createConformedSVG(p, mode) {
            if (!state.svgContent || !state.svgVisible) return null;
            const loader = new SVGLoader();
            const data = loader.parse(state.svgContent);
            const thick = state.wallThickness;
            
            let globalMinX = Infinity, globalMaxX = -Infinity, globalMinY = Infinity, globalMaxY = -Infinity;
            const allShapes = [];
            data.paths.forEach(path => {
                const pathShapes = SVGLoader.createShapes(path);
                pathShapes.forEach(shape => {
                    allShapes.push(shape);
                    const pts = shape.getPoints();
                    pts.forEach(pt => {
                        if(pt.x < globalMinX) globalMinX = pt.x;
                        if(pt.x > globalMaxX) globalMaxX = pt.x;
                        if(pt.y < globalMinY) globalMinY = pt.y;
                        if(pt.y > globalMaxY) globalMaxY = pt.y;
                    });
                });
            });
            if (allShapes.length === 0) return null;
            
            const globalW = globalMaxX - globalMinX;
            const globalH = globalMaxY - globalMinY;
            const globalArea = globalW * globalH;
            
            const shapeData = allShapes.map((shape, idx) => {
                const pts = shape.getPoints();
                let sMinX = Infinity, sMaxX = -Infinity, sMinY = Infinity, sMaxY = -Infinity;
                pts.forEach(pt => {
                    if(pt.x < sMinX) sMinX = pt.x; if(pt.x > sMaxX) sMaxX = pt.x;
                    if(pt.y < sMinY) sMinY = pt.y; if(pt.y > sMaxY) sMaxY = pt.y;
                });
                return { shape, idx, areaRatio: (globalArea > 0) ? ((sMaxX-sMinX)*(sMaxY-sMinY) / globalArea) : 0 };
            });
            
            const validShapes = [];
            shapeData.forEach((sd, i) => {
                const isBackground = (sd.areaRatio > 0.80 && allShapes.length > 1) || (i === 0 && sd.areaRatio > 0.70 && allShapes.length > 1);
                if (!isBackground) validShapes.push(sd.shape);
            });
            if(validShapes.length === 0) return null;
            
            const maxEngraveDepth = thick - 0.5;
            let effectiveSvgThickness = state.svgThickness;
            if ((mode === 'engrave' || mode === 'doubleshot') && effectiveSvgThickness > maxEngraveDepth) {
                effectiveSvgThickness = maxEngraveDepth;
            }
            let genThick = effectiveSvgThickness;
            let yEmbedOffset = (mode === 'engrave' || mode === 'doubleshot') ? 0.02 : 0;
            yEmbedOffset += state.svgOffsetY;
            
            let geo = new THREE.ExtrudeGeometry(validShapes, {depth: genThick, bevelEnabled: false});
            geo.computeBoundingBox();
            const c = new THREE.Vector3();
            geo.boundingBox.getCenter(c);
            geo.translate(-c.x, -c.y, 0);
            geo.scale(0.1*state.svgScale, -0.1*state.svgScale, 1.0);
            geo.rotateZ(THREE.MathUtils.degToRad(state.svgRotZ));
            geo = BufferGeometryUtils.mergeVertices(geo, 0.001);
            geo.computeVertexNormals();
            
            if(!state.svgConform) {
                geo.rotateX(Math.PI/2);
                geo.rotateX(THREE.MathUtils.degToRad(state.svgRotX));
                geo.rotateY(THREE.MathUtils.degToRad(state.svgRotY));
                if (mode === 'engrave' || mode === 'doubleshot') { geo.scale(1, -1, 1); geo.translate(0, genThick, 0); }
                geo.rotateX(THREE.MathUtils.degToRad(p.angle));
                const sy = getSurfaceHeight(state.svgPosX, state.svgPosZ, p);
                geo.translate(state.svgPosX, sy + yEmbedOffset, state.svgPosZ);
                return geo;
            } else {
                const pos = geo.attributes.position;
                const v = new THREE.Vector3();
                for(let i=0; i<pos.count; i++) {
                    v.fromBufferAttribute(pos, i);
                    const tx = v.x + state.svgPosX;
                    const tz = -v.y + state.svgPosZ;
                    const sy = getSurfaceHeight(tx, tz, p);
                    const depthOffset = (mode === 'engrave' || mode === 'doubleshot') ? -v.z : v.z;
                    pos.setXYZ(i, tx, sy + depthOffset + yEmbedOffset, tz);
                }
                geo.computeVertexNormals();
                return geo;
            }
        }

        function createConformedSVGForExport(p, mode) {
            if (!state.svgContent || !state.svgVisible) return null;
            const loader = new SVGLoader();
            const data = loader.parse(state.svgContent);
            const thick = state.wallThickness;
            
            let globalMinX = Infinity, globalMaxX = -Infinity, globalMinY = Infinity, globalMaxY = -Infinity;
            const allShapes = [];
            data.paths.forEach(path => {
                const pathShapes = SVGLoader.createShapes(path);
                pathShapes.forEach(shape => {
                    allShapes.push(shape);
                    const pts = shape.getPoints();
                    pts.forEach(pt => {
                        if(pt.x < globalMinX) globalMinX = pt.x;
                        if(pt.x > globalMaxX) globalMaxX = pt.x;
                        if(pt.y < globalMinY) globalMinY = pt.y;
                        if(pt.y > globalMaxY) globalMaxY = pt.y;
                    });
                });
            });
            if (allShapes.length === 0) return null;
            
            const globalW = globalMaxX - globalMinX;
            const globalH = globalMaxY - globalMinY;
            const globalArea = globalW * globalH;
            const globalCenterX = (globalMinX + globalMaxX) / 2;
            const globalCenterY = (globalMinY + globalMaxY) / 2;
            
            const shapeData = allShapes.map((shape, idx) => {
                const pts = shape.getPoints();
                let sMinX = Infinity, sMaxX = -Infinity, sMinY = Infinity, sMaxY = -Infinity;
                pts.forEach(pt => {
                    if(pt.x < sMinX) sMinX = pt.x; if(pt.x > sMaxX) sMaxX = pt.x;
                    if(pt.y < sMinY) sMinY = pt.y; if(pt.y > sMaxY) sMaxY = pt.y;
                });
                const sW = sMaxX - sMinX;
                const sH = sMaxY - sMinY;
                const sArea = sW * sH;
                const areaRatio = (globalArea > 0) ? (sArea / globalArea) : 0;
                return { shape, idx, areaRatio, numPts: pts.length };
            });
            
            const validShapes = [];
            shapeData.forEach((sd, i) => {
                const isBackground =
                    (sd.areaRatio > 0.80 && allShapes.length > 1) ||
                    (i === 0 && sd.areaRatio > 0.70 && allShapes.length > 1);
                
                if (isBackground) {
                    console.log("V63.43: Removed background shape #" + sd.idx + " (area:" + (sd.areaRatio*100).toFixed(1) + "%, pts:" + sd.numPts + ")");
                } else {
                    validShapes.push(sd.shape);
                }
            });
            
            if(validShapes.length === 0) return null;
            
            const maxEngraveDepth = thick - 0.5;
            let effectiveSvgThickness = state.svgThickness;
            if ((mode === 'engrave' || mode === 'doubleshot') && effectiveSvgThickness > maxEngraveDepth) {
                effectiveSvgThickness = maxEngraveDepth;
                console.log("V63.43: SVG depth limited to " + effectiveSvgThickness.toFixed(2) + "mm");
            }
            
            let genThick = effectiveSvgThickness;
            let yEmbedOffset = 0;
            
            const embedIntoBody = 0.3;
            
            if (mode === 'emboss') {
                genThick = effectiveSvgThickness + embedIntoBody;
                yEmbedOffset = -embedIntoBody;
            } else if (mode === 'engrave') {
                genThick = effectiveSvgThickness;
                yEmbedOffset = 0.02;
            } else if (mode === 'doubleshot') {
                genThick = effectiveSvgThickness;
                yEmbedOffset = 0.02;
            }
            yEmbedOffset += state.svgOffsetY;
            
            const extrudedGeos = [];
            for (const shape of validShapes) {
                try {
                    const simplifiedShape = simplifyShape(shape, 0.5);
                    
                    let shapeGeo = new THREE.ExtrudeGeometry([simplifiedShape], {
                        depth: genThick, 
                        bevelEnabled: false,
                        curveSegments: 4
                    });
                    
                    shapeGeo.translate(-globalCenterX, -globalCenterY, 0);
                    
                    shapeGeo.scale(0.1 * state.svgScale, -0.1 * state.svgScale, 1.0);
                    shapeGeo.rotateZ(THREE.MathUtils.degToRad(state.svgRotZ));
                    
                    shapeGeo = BufferGeometryUtils.mergeVertices(shapeGeo, 0.08);
                    shapeGeo.computeVertexNormals();
                    
                    extrudedGeos.push(shapeGeo);
                } catch (e) {
                    console.warn("SVG shape extrude failed:", e);
                }
            }
            
            if (extrudedGeos.length === 0) return null;
            
            let geo;
            if (extrudedGeos.length === 1) {
                geo = extrudedGeos[0];
            } else {
                try {
                    console.log("V63.65: Merging " + extrudedGeos.length + " SVG shapes with CSG Union...");
                    geo = extrudedGeos[0];
                    for (let i = 1; i < extrudedGeos.length; i++) {
                        const b1 = new Brush(geo); b1.updateMatrixWorld();
                        const b2 = new Brush(extrudedGeos[i]); b2.updateMatrixWorld();
                        const res = csgEvaluator.evaluate(b1, b2, ADDITION);
                        geo = res.geometry;
                    }
                    geo = BufferGeometryUtils.mergeVertices(geo, 0.08);
                    geo.computeVertexNormals();
                    console.log("V63.65: CSG Union complete");
                } catch (e) {
                    console.warn("SVG CSG Union failed, falling back to merge:", e);
                    geo = BufferGeometryUtils.mergeGeometries(extrudedGeos);
                    geo = BufferGeometryUtils.mergeVertices(geo, 0.08);
                    geo.computeVertexNormals();
                }
            }
            
            if(!state.svgConform) {
                geo.rotateX(Math.PI/2);
                geo.rotateX(THREE.MathUtils.degToRad(state.svgRotX));
                geo.rotateY(THREE.MathUtils.degToRad(state.svgRotY));
                if (mode === 'engrave' || mode === 'doubleshot') {
                    geo.scale(1, -1, 1);
                    geo.translate(0, genThick, 0);
                }
                geo.rotateX(THREE.MathUtils.degToRad(p.angle));
                const sy = getSurfaceHeight(state.svgPosX, state.svgPosZ, p);
                geo.translate(state.svgPosX, sy + yEmbedOffset, state.svgPosZ);
                geo = BufferGeometryUtils.mergeVertices(geo, 0.08);
                geo.computeVertexNormals();
                return geo;
            } else {
                const pos = geo.attributes.position;
                const v = new THREE.Vector3();
                for(let i=0; i<pos.count; i++) {
                    v.fromBufferAttribute(pos, i);
                    const tx = v.x + state.svgPosX;
                    const tz = -v.y + state.svgPosZ;
                    const sy = getSurfaceHeight(tx, tz, p);
                    const depthOffset = (mode === 'engrave' || mode === 'doubleshot') ? -v.z : v.z;
                    pos.setXYZ(i, tx, sy + depthOffset + yEmbedOffset, tz);
                }
                geo = BufferGeometryUtils.mergeVertices(geo, 0.08);
                geo.computeVertexNormals();
                return geo;
            }
        }
        
        function simplifyShape(shape, tolerance) {
            const simplifyPoints = (points, tol) => {
                if (points.length <= 2) return points;
                
                const result = [points[0]];
                let lastPoint = points[0];
                
                for (let i = 1; i < points.length - 1; i++) {
                    const dist = Math.sqrt(
                        Math.pow(points[i].x - lastPoint.x, 2) + 
                        Math.pow(points[i].y - lastPoint.y, 2)
                    );
                    if (dist >= tol) {
                        result.push(points[i]);
                        lastPoint = points[i];
                    }
                }
                
                result.push(points[points.length - 1]);
                return result;
            };
            
            const mainPoints = shape.getPoints(12);
            const simplifiedMain = simplifyPoints(mainPoints, tolerance);
            
            const newShape = new THREE.Shape(simplifiedMain);
            
            if (shape.holes && shape.holes.length > 0) {
                for (const hole of shape.holes) {
                    const holePoints = hole.getPoints(12);
                    const simplifiedHole = simplifyPoints(holePoints, tolerance);
                    if (simplifiedHole.length >= 3) {
                        newShape.holes.push(new THREE.Path(simplifiedHole));
                    }
                }
            }
            
            return newShape;
        }

        function updateModel() {
            mainGroup.rotation.x = THREE.MathUtils.degToRad(state.globalRotX);
            mainGroup.rotation.y = THREE.MathUtils.degToRad(state.globalRotY);
            const p = getParams();
            let bodyMat, textMat;
            
            if (state.renderMode === 'wireframe') {
                bodyMat = new THREE.MeshBasicMaterial({ color: state.colBody, wireframe: true });
                textMat = new THREE.MeshBasicMaterial({ color: state.colText, wireframe: true });
            } else {
                let map = null;
                if (state.imgContent && state.imgTextureVisible) {
                    map = textureLoader.load(state.imgContent);
                    map.wrapS = THREE.ClampToEdgeWrapping;
                    map.wrapT = THREE.ClampToEdgeWrapping;
                    map.minFilter = THREE.LinearFilter;
                }
                bodyMat = new THREE.MeshStandardMaterial({ color: state.colBody, roughness: 0.6, metalness: 0.1, side: THREE.DoubleSide, map: map });
                textMat = new THREE.MeshStandardMaterial({ color: state.colText, side: THREE.DoubleSide });
            }
            
            const body = createBodyParts(p, false);
            const stem = createStemAndRibs(p, false);
            const bump = createHomingBump(p);
            let finalKeycapGeo = safeMerge([body, stem, bump]);
            
            mainGroup.clear();
            const textGeos = [];
            const engraveGeos = [];
            
            const handleGeo = (geo, mode) => {
                if (!geo) return;
                if (mode === 'emboss') {
                    textGeos.push(geo);
                } else if (mode === 'engrave') {
                    engraveGeos.push(geo);
                } else if (mode === 'doubleshot') {
                    textGeos.push(geo);
                    engraveGeos.push(geo.clone());
                }
            };
            
            if (state.enableText && loadedFonts[state.font]) {
                handleGeo(createConformedText(p, state.text, state.fontSize, state.posX, state.posZ, state.textMode), state.textMode);
            }
            if (state.enableText2 && loadedFonts[state.font]) {
                handleGeo(createConformedText(p, state.text2, state.text2Size, state.text2X, state.text2Z, state.text2Mode), state.text2Mode);
            }
            if(state.enableSide) {
                handleGeo(createSidePrint(p, state.sideMode), state.sideMode);
            }
            if (state.svgContent && state.svgVisible) {
                handleGeo(createConformedSVG(p, state.svgMode), state.svgMode);
            }
            
            let finalTextGeo = safeMerge(textGeos);
            let finalEngraveGeo = safeMerge(engraveGeos);
            
            let importedGeo = null;
            if(importedModelBuffer && state.modelVisible) {
                importedGeo = new STLLoader().parse(importedModelBuffer);
                importedGeo.scale(state.modelScale, state.modelScale, state.modelScale);
                importedGeo.rotateX(THREE.MathUtils.degToRad(state.modelRX));
                importedGeo.rotateY(THREE.MathUtils.degToRad(state.modelRY));
                importedGeo.rotateZ(THREE.MathUtils.degToRad(state.modelRZ));
                importedGeo.translate(state.modelX, state.modelY, state.modelZ);
            }
            
            if (state.modelOperation === 'subtract' && importedGeo && finalKeycapGeo) {
                const b1 = new Brush(finalKeycapGeo); b1.updateMatrixWorld();
                const b2 = new Brush(importedGeo); b2.updateMatrixWorld();
                const res = csgEvaluator.evaluate(b1, b2, SUBTRACTION);
                finalKeycapGeo = res.geometry;
                importedGeo = null;
            }
            
            if (finalEngraveGeo && finalKeycapGeo) {
                const b1 = new Brush(finalKeycapGeo); b1.updateMatrixWorld();
                const b2 = new Brush(finalEngraveGeo); b2.updateMatrixWorld();
                const res = csgEvaluator.evaluate(b1, b2, SUBTRACTION);
                finalKeycapGeo = res.geometry;
            }
            
            if(finalKeycapGeo) {
                finalKeycapGeo.computeVertexNormals();
                const mesh = new THREE.Mesh(finalKeycapGeo, bodyMat);
                mesh.name = "KeycapBody";
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mainGroup.add(mesh);
            }
            if(finalTextGeo) {
                const mesh = new THREE.Mesh(finalTextGeo, textMat);
                mesh.name = "KeycapText";
                mainGroup.add(mesh);
            }
            if(importedGeo) {
                const mesh = new THREE.Mesh(importedGeo, textMat);
                mesh.name = "ImportedModel";
                mainGroup.add(mesh);
            }
            
            calculateStats();
        }

        let debounceTimeout = null;
        function requestUpdate() {
            if(debounceTimeout) clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(updateModel, 100);
        }

        function cleanupGeometry(geometry) {
            if (!geometry) return null;
            let geo = geometry.clone();
            if (geo.index) geo = geo.toNonIndexed();
            geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
            geo.computeVertexNormals();
            return geo;
        }

        function repairMesh(geometry) {
            if (!geometry) return null;
            
            let geo = geometry;
            if (geo.index) {
                geo = geo.toNonIndexed();
            }
            
            const position = geo.attributes.position;
            const epsilon = 0.0001;
            const triangles = [];
            
            for (let i = 0; i < position.count; i += 3) {
                const v0 = new THREE.Vector3(position.getX(i), position.getY(i), position.getZ(i));
                const v1 = new THREE.Vector3(position.getX(i+1), position.getY(i+1), position.getZ(i+1));
                const v2 = new THREE.Vector3(position.getX(i+2), position.getY(i+2), position.getZ(i+2));
                
                const edge1 = new THREE.Vector3().subVectors(v1, v0);
                const edge2 = new THREE.Vector3().subVectors(v2, v0);
                const cross = new THREE.Vector3().crossVectors(edge1, edge2);
                const area = cross.length() / 2;
                
                if (area < epsilon) continue;
                
                if (v0.distanceTo(v1) < epsilon || v1.distanceTo(v2) < epsilon || v2.distanceTo(v0) < epsilon) continue;
                
                triangles.push({ v0, v1, v2, area });
            }
            
            const uniqueTriangles = [];
            const seen = new Set();
            
            for (const tri of triangles) {
                const cx = ((tri.v0.x + tri.v1.x + tri.v2.x) / 3).toFixed(3);
                const cy = ((tri.v0.y + tri.v1.y + tri.v2.y) / 3).toFixed(3);
                const cz = ((tri.v0.z + tri.v1.z + tri.v2.z) / 3).toFixed(3);
                const areaKey = tri.area.toFixed(4);
                const key = `${cx},${cy},${cz},${areaKey}`;
                
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueTriangles.push(tri);
                }
            }
            
            const newPositions = [];
            for (const tri of uniqueTriangles) {
                newPositions.push(tri.v0.x, tri.v0.y, tri.v0.z);
                newPositions.push(tri.v1.x, tri.v1.y, tri.v1.z);
                newPositions.push(tri.v2.x, tri.v2.y, tri.v2.z);
            }
            
            const newGeo = new THREE.BufferGeometry();
            newGeo.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
            
            const mergedGeo = BufferGeometryUtils.mergeVertices(newGeo, 0.0001);
            mergedGeo.computeVertexNormals();
            
            console.log(`Repair: ${position.count/3} -> ${uniqueTriangles.length} triangles`);
            
            return mergedGeo;
        }

        function buildExportGeometry() {
            try {
                const p = getParams();
                
                console.log("Building export geometry V63.21...");
                
                const body = createBodyParts(p, false);
                const stem = createStemAndRibs(p, false);
                const bump = createHomingBump(p);
                
                let bodyGeos = [body, stem, bump].filter(g => g != null);
                
                bodyGeos = bodyGeos.map(g => {
                    if (g.index) {
                        return g.toNonIndexed();
                    }
                    return g;
                });
                
                let finalKeycapGeo = BufferGeometryUtils.mergeGeometries(bodyGeos);
                
                if (finalKeycapGeo) {
                    finalKeycapGeo = BufferGeometryUtils.mergeVertices(finalKeycapGeo, 0.0001);
                    finalKeycapGeo.computeVertexNormals();
                }
                
                console.log("Body geo created:", finalKeycapGeo);
                
                const textGeos = [];
                const engraveGeos = [];
                
                const handleGeo = (geo, mode) => {
                    if (!geo) return;
                    if (mode === 'emboss') {
                        textGeos.push(geo);
                    } else if (mode === 'engrave') {
                        engraveGeos.push(geo);
                    } else if (mode === 'doubleshot') {
                        textGeos.push(geo);
                        engraveGeos.push(geo.clone());
                    }
                };
                
                if (state.enableText && loadedFonts[state.font]) {
                    handleGeo(createConformedText(p, state.text, state.fontSize, state.posX, state.posZ, state.textMode), state.textMode);
                }
                if (state.enableText2 && loadedFonts[state.font]) {
                    handleGeo(createConformedText(p, state.text2, state.text2Size, state.text2X, state.text2Z, state.text2Mode), state.text2Mode);
                }
                if (state.enableSide) {
                    handleGeo(createSidePrint(p, state.sideMode), state.sideMode);
                }
                if (state.svgContent && state.svgVisible) {
                    let svgGeo = createConformedSVGForExport(p, state.svgMode);
                    if (svgGeo) {
                        console.log("V63.53: Applying enhanced repair to SVG geometry...");
                        svgGeo = repairSVGMesh(svgGeo);
                        
                        if (state.svgMode === 'emboss' && finalKeycapGeo) {
                            try {
                                console.log("V63.41: CSG Union SVG with body...");
                                const b1 = new Brush(finalKeycapGeo); b1.updateMatrixWorld();
                                const b2 = new Brush(svgGeo); b2.updateMatrixWorld();
                                const res = csgEvaluator.evaluate(b1, b2, ADDITION);
                                finalKeycapGeo = res.geometry;
                                finalKeycapGeo = BufferGeometryUtils.mergeVertices(finalKeycapGeo, 0.0001);
                                console.log("V63.41: CSG Union successful");
                                svgGeo = null;
                            } catch (e) {
                                console.error("SVG CSG Union failed:", e);
                            }
                        }
                    }
                    if (svgGeo) {
                        handleGeo(svgGeo, state.svgMode);
                    }
                }
                
                if (engraveGeos.length > 0 && finalKeycapGeo) {
                    let engraveGeo = BufferGeometryUtils.mergeGeometries(engraveGeos.map(g => g.index ? g.toNonIndexed() : g));
                    if (engraveGeo) {
                        try {
                            const b1 = new Brush(finalKeycapGeo); b1.updateMatrixWorld();
                            const b2 = new Brush(engraveGeo); b2.updateMatrixWorld();
                            const res = csgEvaluator.evaluate(b1, b2, SUBTRACTION);
                            finalKeycapGeo = res.geometry;
                            finalKeycapGeo = BufferGeometryUtils.mergeVertices(finalKeycapGeo, 0.0001);
                        } catch (e) {
                            console.error("Engrave CSG failed:", e);
                        }
                    }
                }
                
                let finalTextGeo = null;
                if (textGeos.length > 0) {
                    const textGeosNonIndexed = textGeos.map(g => g.index ? g.toNonIndexed() : g);
                    finalTextGeo = BufferGeometryUtils.mergeGeometries(textGeosNonIndexed);
                    if (finalTextGeo) {
                        finalTextGeo = BufferGeometryUtils.mergeVertices(finalTextGeo, 0.0001);
                        finalTextGeo.computeVertexNormals();
                    }
                }
                
                console.log("Text geo created:", finalTextGeo);
                
                console.log("Repairing meshes...");
                if (finalKeycapGeo) {
                    finalKeycapGeo = repairMesh(finalKeycapGeo);
                    console.log("Body repaired:", finalKeycapGeo);
                }
                if (finalTextGeo) {
                    finalTextGeo = repairMesh(finalTextGeo);
                    console.log("Text repaired:", finalTextGeo);
                }
                
                console.log("Export geometry built successfully");
                
                return { bodyGeo: finalKeycapGeo, textGeo: finalTextGeo, importedGeo: null };
                
            } catch (error) {
                console.error("buildExportGeometry error:", error);
                document.getElementById('error-log').textContent = "Build error: " + error.message;
                throw error;
            }
        }

        async function export3MF() {
            try {
                const t = translations[currentLang];
                showToast(t.toast_generating);
                
                await new Promise(r => setTimeout(r, 100));
                
                console.log("Building export geometry...");
                const { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
                console.log("bodyGeo:", bodyGeo);
                console.log("textGeo:", textGeo);
                
                if (!bodyGeo) {
                    showToast(t.toast_no_body);
                    return;
                }
                
                const zip = new JSZip();
                
                function geoTo3MFMesh(geometry) {
                    if (!geometry) return null;
                    
                    let geo = geometry.clone();
                    
                    if (!geo.index) {
                        geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
                    }
                    
                    const position = geo.attributes.position;
                    if (!position) return null;
                    
                    const vertices = [];
                    const triangles = [];
                    
                    const index = geo.index;
                    
                    if (index && index.array) {
                        for (let i = 0; i < position.count; i++) {
                            vertices.push(`      <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                        }
                        const indexArray = index.array;
                        for (let i = 0; i < indexArray.length; i += 3) {
                            triangles.push(`      <triangle v1="${indexArray[i]}" v2="${indexArray[i+1]}" v3="${indexArray[i+2]}" />`);
                        }
                    } else {
                        for (let i = 0; i < position.count; i++) {
                            vertices.push(`      <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                        }
                        for (let i = 0; i < position.count; i += 3) {
                            triangles.push(`      <triangle v1="${i}" v2="${i+1}" v3="${i+2}" />`);
                        }
                    }
                    
                    return { vertices, triangles };
                }
                
                let modelXml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02" xmlns:m="http://schemas.microsoft.com/3dmanufacturing/material/2015/02">
  <metadata name="Application">Keycap Generator V63.3.1</metadata>
  <resources>
    <m:basematerials id="1">
      <m:base name="Body" displaycolor="#${state.colBody.slice(1).toUpperCase()}" />
      <m:base name="Text" displaycolor="#${state.colText.slice(1).toUpperCase()}" />
    </m:basematerials>`;
                
                let objectId = 2;
                let buildItems = '';
            
            if (bodyGeo) {
                const mesh = geoTo3MFMesh(bodyGeo);
                if (mesh) {
                    modelXml += `
    <object id="${objectId}" name="KeycapBody" type="model">
      <mesh>
        <vertices>
${mesh.vertices.join('\n')}
        </vertices>
        <triangles>
${mesh.triangles.map(t => t.replace('/>', ' pid="1" p1="0" />')).join('\n')}
        </triangles>
      </mesh>
    </object>`;
                    buildItems += `    <item objectid="${objectId}" />`;
                    objectId++;
                }
            }
            
            let combinedTextGeo = textGeo;
            console.log("combinedTextGeo before import check:", combinedTextGeo);
            if (importedGeo) {
                if (combinedTextGeo) {
                    combinedTextGeo = BufferGeometryUtils.mergeGeometries([combinedTextGeo, importedGeo]);
                    combinedTextGeo = BufferGeometryUtils.mergeVertices(combinedTextGeo, 0.0001);
                } else {
                    combinedTextGeo = importedGeo;
                }
            }
            
            console.log("combinedTextGeo after import check:", combinedTextGeo);
            if (combinedTextGeo) {
                const mesh = geoTo3MFMesh(combinedTextGeo);
                console.log("Text mesh:", mesh);
                if (mesh) {
                    console.log("Adding text object to 3MF, vertices:", mesh.vertices.length, "triangles:", mesh.triangles.length);
                    modelXml += `
    <object id="${objectId}" name="KeycapText" type="model">
      <mesh>
        <vertices>
${mesh.vertices.join('\n')}
        </vertices>
        <triangles>
${mesh.triangles.map(t => t.replace('/>', ' pid="1" p1="1" />')).join('\n')}
        </triangles>
      </mesh>
    </object>`;
                    buildItems += `\n    <item objectid="${objectId}" />`;
                    console.log("Text object added to 3MF");
                } else {
                    console.log("geoTo3MFMesh returned null for text");
                }
            } else {
                console.log("No text geometry to export");
            }
            
            modelXml += `
  </resources>
  <build>
${buildItems}
  </build>
</model>`;

            const contentTypes = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />
</Types>`;

            const rels = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>`;

                zip.file("[Content_Types].xml", contentTypes);
                zip.folder("_rels").file(".rels", rels);
                zip.folder("3D").file("3dmodel.model", modelXml);
                
                const blob = await zip.generateAsync({ type: "blob", compression: "DEFLATE" });
                saveBlob(blob, getFileName() + '.3mf');
                showToast(t.toast_3mf_exported);
            } catch (error) {
                console.error("3MF Export Error:", error);
                const t = translations[currentLang];
                showToast(t.toast_export_failed + error.message);
                document.getElementById('error-log').textContent = "3MF Export Error: " + error.message;
            }
        }

        async function init() {
            document.getElementById('loading').style.display = 'flex';
            
            await initManifold();
            
            const fontConfigs = [
                ['helvetiker', 'helvetiker_regular', 'Helvetiker'],
                ['helvetiker_bold', 'helvetiker_bold', 'Helvetiker Bold'],
                ['optimer', 'optimer_regular', 'Optimer'],
                ['optimer_bold', 'optimer_bold', 'Optimer Bold'],
                ['gentilis', 'gentilis_regular', 'Gentilis'],
                ['gentilis_bold', 'gentilis_bold', 'Gentilis Bold'],
                ['droid_sans', 'droid/droid_sans_regular', 'Droid Sans'],
                ['droid_sans_bold', 'droid/droid_sans_bold', 'Droid Sans Bold'],
                ['droid_serif', 'droid/droid_serif_regular', 'Droid Serif'],
                ['droid_serif_bold', 'droid/droid_serif_bold', 'Droid Serif Bold']
            ];
            
            let fontsLoaded = 0;
            for(const [name, fileName, displayName] of fontConfigs) {
                try {
                    const path = `https://cdn.jsdelivr.net/npm/three@0.160.0/examples/fonts/${fileName}.typeface.json`;
                    loadedFonts[name] = await new Promise((resolve, reject) => fontLoader.load(path, resolve, undefined, reject));
                    fontsLoaded++;
                    console.log(`Font loaded: ${displayName}`);
                } catch(e) {
                    console.warn(`Font load failed: ${name} (${fileName})`);
                }
            }
            if(fontsLoaded === 0) document.getElementById('error-log').textContent = "Warning: No fonts loaded.";
            
            initFilamentManager();
            initNavigation();
            setupCustomDropdown();
            syncUI();
            
            HTML_COLORS.forEach(c => {
                const s1 = document.createElement('div');
                s1.className = 'palette-swatch';
                s1.style.background = c;
                s1.addEventListener('click', () => { state.colBody = c; document.getElementById('col-body').value = c; updateModel(); });
                document.getElementById('palette-body').appendChild(s1);
                const s2 = document.createElement('div');
                s2.className = 'palette-swatch';
                s2.style.background = c;
                s2.addEventListener('click', () => { state.colText = c; document.getElementById('col-text').value = c; updateModel(); });
                document.getElementById('palette-text').appendChild(s2);
            });
            
            document.getElementById('unit-size-select').addEventListener('change', (e) => { state.unitSize = parseFloat(e.target.value); requestUpdate(); });
            document.getElementById('profile-select').addEventListener('change', (e) => { state.profile = e.target.value; requestUpdate(); });
            document.getElementById('row-select').addEventListener('change', (e) => { state.row = e.target.value; requestUpdate(); });
            document.getElementById('texture-type').addEventListener('change', (e) => { state.textureType = e.target.value; requestUpdate(); });
            document.getElementById('text-mode').addEventListener('change', (e) => { state.textMode = e.target.value; requestUpdate(); });
            document.getElementById('text2-mode').addEventListener('change', (e) => { state.text2Mode = e.target.value; requestUpdate(); });
            document.getElementById('side-mode').addEventListener('change', (e) => { state.sideMode = e.target.value; requestUpdate(); });
            document.getElementById('svg-mode').addEventListener('change', (e) => { state.svgMode = e.target.value; requestUpdate(); });
            document.getElementById('render-mode').addEventListener('change', (e) => { state.renderMode = e.target.value; requestUpdate(); });
            document.getElementById('stabilizer-type').addEventListener('change', (e) => {
                state.stabilizerType = e.target.value;
                document.getElementById('stabilizer-custom-ui').style.display = e.target.value === 'custom' ? 'block' : 'none';
                requestUpdate();
            });
            document.getElementById('lego-stud').addEventListener('change', (e) => {
                state.legoStud = e.target.checked;
                document.getElementById('lego-adj-panel').style.display = e.target.checked ? 'block' : 'none';
                requestUpdate();
            });
            document.getElementById('enable-stem-extension').addEventListener('change', (e) => {
                state.enableStemExtension = e.target.checked;
                document.getElementById('stem-ext-control').style.display = e.target.checked ? 'block' : 'none';
                requestUpdate();
            });
            
            const mInput = document.getElementById('model-file-input');
            if(mInput) mInput.addEventListener('change', function(e) {
                const file = e.target.files[0]; if(!file) return;
                const reader = new FileReader();
                reader.onload = function(ev) { importedModelBuffer = ev.target.result; updateModel(); };
                reader.readAsArrayBuffer(file);
            });
            const bClearModel = document.getElementById('btn-clear-model');
            if(bClearModel) bClearModel.addEventListener('click', () => {
                importedModelBuffer = null;
                if(mInput) mInput.value = '';
                updateModel();
            });
            
            const imgInput = document.getElementById('img-texture-input');
            if(imgInput) imgInput.addEventListener('change', function(e) {
                const file = e.target.files[0]; if(!file) return;
                const reader = new FileReader();
                reader.onload = function(ev) {
                    state.imgContent = ev.target.result;
                    state.imgTextureVisible = true;
                    document.getElementById('img-texture-visible').checked = true;
                    updateModel();
                };
                reader.readAsDataURL(file);
            });
            const bClearImgTex = document.getElementById('btn-clear-img-texture');
            if(bClearImgTex) bClearImgTex.addEventListener('click', () => {
                state.imgContent = null;
                state.imgTextureVisible = false;
                document.getElementById('img-texture-visible').checked = false;
                if(imgInput) imgInput.value = '';
                updateModel();
            });
            
            document.getElementById('btn-random').addEventListener('click', randomizeParams);
            document.getElementById('btn-reset-params').addEventListener('click', resetParams);
            document.getElementById('btn-align-center').addEventListener('click', () => { state.posX = 0; state.posZ = 0; syncUI(); requestUpdate(); });
            document.getElementById('btn-align-tl').addEventListener('click', () => { state.posX = -3.5; state.posZ = -3.5; syncUI(); requestUpdate(); });
            document.getElementById('btn-align-tr').addEventListener('click', () => { state.posX = 3.5; state.posZ = -3.5; syncUI(); requestUpdate(); });
            document.getElementById('btn-align-bl').addEventListener('click', () => { state.posX = -3.5; state.posZ = 3.5; syncUI(); requestUpdate(); });
            document.getElementById('btn-align-br').addEventListener('click', () => { state.posX = 3.5; state.posZ = 3.5; syncUI(); requestUpdate(); });
            
            const statsPanel = document.getElementById('top-right-panel');
            const toggleStatsBtn = document.getElementById('btn-toggle-stats');
            if(toggleStatsBtn) {
                toggleStatsBtn.addEventListener('click', () => {
                    statsPanel.classList.toggle('stats-collapsed');
                    toggleStatsBtn.textContent = statsPanel.classList.contains('stats-collapsed') ? "+" : "ï¼";
                });
            }
            
            const toggleUiBtn = document.getElementById('btn-toggle-ui');
            if(toggleUiBtn) {
                toggleUiBtn.addEventListener('click', () => {
                    document.body.classList.toggle('ui-closed');
                    const isClosed = document.body.classList.contains('ui-closed');
                    toggleUiBtn.textContent = isClosed ? "â–¶" : "â—€";
                    setTimeout(() => {
                        const w = container.clientWidth;
                        const h = container.clientHeight;
                        renderer.setSize(w, h);
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                    }, 350);
                });
            }
            
            document.getElementById('loading').style.display = 'none';
            requestUpdate();
            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.clear();
            controls.update();
            renderer.render(scene, camera);
            const vhSize = 128;
            renderer.setViewport(container.clientWidth - vhSize, 0, vhSize, vhSize);
            renderer.setScissor(container.clientWidth - vhSize, 0, vhSize, vhSize);
            renderer.setScissorTest(true);
            viewHelper.render(renderer);
            renderer.setScissorTest(false);
            renderer.setViewport(0, 0, container.clientWidth, container.clientHeight);
        }

        const bind = (id, key) => {
            const el = document.getElementById(id);
            if(!el) return;
            const up = () => {
                const v = (el.type==='checkbox') ? el.checked : (el.type==='range'||el.type==='number' ? parseFloat(el.value) : el.value);
                state[key]=v;
                if(el.type==='range') {
                    const sp = document.getElementById('v-'+id);
                    if(sp) sp.textContent = (id === 'tex-scale') ? parseInt(v) : v.toFixed(2);
                }
                if(id === 'lock-thickness') {
                    const slider = document.getElementById('text-height');
                    if(slider) {
                        slider.disabled = v;
                        if(v) { slider.value=0.5; state.textHeight=0.5; document.getElementById('v-text-height').textContent="0.50"; }
                    }
                }
                requestUpdate();
            };
            el.addEventListener('input', up);
            el.addEventListener('change', ()=>{up(); commitHistory();});
            const vS = document.getElementById('v-'+id);
            if(vS && id !== 'text-height') vS.addEventListener('dblclick', ()=>{
                const i=document.createElement('input');
                i.type='number';
                i.value=state[key];
                i.className='direct-input';
                vS.style.display='none';
                vS.parentNode.insertBefore(i, vS.nextSibling);
                i.style.display='inline-block';
                i.focus();
                const end = ()=>{
                    const n=parseFloat(i.value);
                    if(!isNaN(n)){state[key]=n; el.value=n; vS.textContent=n.toFixed(2); requestUpdate(); commitHistory();}
                    i.remove();
                    vS.style.display='inline-block';
                };
                i.addEventListener('blur', end);
                i.addEventListener('keydown', e=>{if(e.key==='Enter')end();});
            });
        };
        
        Object.keys(paramMap).forEach(id => bind(id, paramMap[id]));
        Object.keys(boolMap).forEach(id => bind(id, boolMap[id]));
        
        const txtC = document.getElementById('text-content');
        if(txtC) txtC.addEventListener('input', e=>{state.text=e.target.value; requestUpdate();});
        const txt2C = document.getElementById('text2-content');
        if(txt2C) txt2C.addEventListener('input', e=>{state.text2=e.target.value; requestUpdate();});
        const sideT = document.getElementById('side-text');
        if(sideT) sideT.addEventListener('input', e=>{state.sideText=e.target.value; requestUpdate();});
        const colB = document.getElementById('col-body');
        if(colB) colB.addEventListener('input', e=>{state.colBody=e.target.value; updateModel();});
        const colT = document.getElementById('col-text');
        if(colT) colT.addEventListener('input', e=>{state.colText=e.target.value; updateModel();});
        
        const bUndo = document.getElementById('btn-undo'); if(bUndo) bUndo.addEventListener('click', undo);
        const bRedo = document.getElementById('btn-redo'); if(bRedo) bRedo.addEventListener('click', redo);
        
        window.addEventListener('resize', () => {
            camera.aspect=container.clientWidth/container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth,container.clientHeight);
        });
        
        const fInput = document.getElementById('font-file-input');
        if(fInput) fInput.addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const json = JSON.parse(e.target.result);
                    const font = fontLoader.parse(json);
                    const fontName = "custom_" + Date.now();
                    loadedFonts[fontName] = font;
                    const select = document.getElementById('font-family');
                    if(select) {
                        const option = document.createElement('option');
                        option.value = fontName;
                        option.text = file.name.replace('.json','');
                        select.add(option);
                        select.value = fontName;
                        state.font = fontName;
                        committedFont = fontName;
                        updateCustomDropdown();
                        setupCustomDropdown();
                        requestUpdate();
                    }
                } catch(err) {
                    showToast(translations[currentLang].msg_import_err, true);
                }
            };
            reader.readAsText(file);
        });
        
        const sInput = document.getElementById('svg-file-input');
        if(sInput) sInput.addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                state.svgContent = e.target.result;
                updateModel();
            };
            reader.readAsText(file);
        });
        const bClearSvg = document.getElementById('btn-clear-svg');
        if(bClearSvg) bClearSvg.addEventListener('click', () => {
            state.svgContent = null;
            if(sInput) sInput.value = '';
            updateModel();
        });
        
        const getFileName = () => {
            const el = document.getElementById('export-name');
            const base = el ? (el.value || 'keycap') : 'keycap';
            const suffix = state.text ? `_[${state.text.replace(/\n/g,'_')}]` : '';
            return base + suffix;
        };
        const saveBlob = (blob, name) => {
            if (typeof saveAs !== 'undefined') {
                saveAs(blob, name);
            } else {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = name;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
            }
        };
        
        const exportSTL = (suff) => {
            const t = translations[currentLang];
            showToast(t.toast_generating);
            setTimeout(() => {
                const { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
                
                const clone = new THREE.Group();
                if (bodyGeo) clone.add(new THREE.Mesh(bodyGeo, new THREE.MeshBasicMaterial()));
                if (textGeo) clone.add(new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial()));
                if (importedGeo) clone.add(new THREE.Mesh(importedGeo, new THREE.MeshBasicMaterial()));
                
                const res = new STLExporter().parse(clone, {binary:true});
                saveBlob(new Blob([res], {type:'application/octet-stream'}), getFileName()+suff);
                showToast(t.toast_stl_exported);
            }, 100);
        };
        
        const exportOBJ = () => {
            const t = translations[currentLang];
            showToast(t.toast_generating);
            setTimeout(() => {
                const { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
                
                const clone = new THREE.Group();
                if (bodyGeo) {
                    const mesh = new THREE.Mesh(bodyGeo, new THREE.MeshBasicMaterial({ color: state.colBody }));
                    mesh.name = "KeycapBody";
                    clone.add(mesh);
                }
                if (textGeo) {
                    const mesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial({ color: state.colText }));
                    mesh.name = "KeycapText";
                    clone.add(mesh);
                }
                if (importedGeo) {
                    const mesh = new THREE.Mesh(importedGeo, new THREE.MeshBasicMaterial({ color: state.colText }));
                    mesh.name = "ImportedModel";
                    clone.add(mesh);
                }
                
                const res = new OBJExporter().parse(clone);
                saveBlob(new Blob([res], {type:'text/plain'}), getFileName() + '.obj');
                showToast(t.toast_obj_exported);
            }, 100);
        };
        
        const bExpAll = document.getElementById('btn-export-all');
        if(bExpAll) bExpAll.addEventListener('click', ()=>exportSTL('.stl'));
        const bExpBody = document.getElementById('btn-export-body');
        if(bExpBody) bExpBody.addEventListener('click', ()=>exportSTL('_body.stl'));
        const bExpText = document.getElementById('btn-export-text');
        if(bExpText) bExpText.addEventListener('click', ()=>exportSTL('_text_svg.stl'));
        const bExpObj = document.getElementById('btn-export-obj');
        if(bExpObj) bExpObj.addEventListener('click', exportOBJ);
        const bExp3MF = document.getElementById('btn-export-3mf');
        if(bExp3MF) bExp3MF.addEventListener('click', export3MF);
        
        const STORAGE_KEY = 'keycap_gen_v63_preset';
        document.getElementById('btn-quick-save').addEventListener('click', () => {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            showToast(translations[currentLang].msg_save_ok);
        });
        document.getElementById('btn-quick-load').addEventListener('click', () => {
            const data = localStorage.getItem(STORAGE_KEY);
            if(data) {
                state = JSON.parse(data);
                syncUI();
                updateCustomDropdown();
                requestUpdate();
                commitHistory();
                showToast(translations[currentLang].msg_load_ok);
            } else {
                showToast(translations[currentLang].msg_load_err, true);
            }
        });
        document.getElementById('btn-export-preset').addEventListener('click', () => {
            const blob = new Blob([JSON.stringify(state, null, 2)], {type: "application/json"});
            saveBlob(blob, "keycap_preset.json");
        });
        document.getElementById('preset-file-input').addEventListener('change', (e) => {
            const file = e.target.files[0]; if(!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    state = JSON.parse(ev.target.result);
                    syncUI();
                    updateCustomDropdown();
                    requestUpdate();
                    commitHistory();
                } catch(err) {
                    showToast(translations[currentLang].msg_import_err, true);
                }
                e.target.value = '';
            };
            reader.readAsText(file);
        });
        
        async function runBatchExport() {
            const t = translations[currentLang];
            const raw = document.getElementById('batch-list').value;
            const list = raw.split(/[\n,]+/).map(s => s.trim()).filter(s => s);
            if(list.length === 0) { showToast(t.msg_batch_empty, true); return; }
            
            const format = document.getElementById('batch-format').value;
            
            const originalText = state.text;
            const loading = document.getElementById('loading');
            const progress = document.getElementById('batch-progress');
            loading.style.display = 'flex';
            progress.style.display = 'block';
            
            const baseName = document.getElementById('export-name').value || 'keycap';
            
            try {
                for(let i=0; i<list.length; i++) {
                    const char = list[i];
                    progress.textContent = `${t.batch_processing} ${char} (${i+1}/${list.length})`;
                    state.text = char;
                    
                    await new Promise(r => setTimeout(r, 100));
                    
                    const { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
                    const safeChar = char.replace(/[\\/:*?"<>|]/g, '_');
                    
                    if (format === 'stl') {
                        const clone = new THREE.Group();
                        if (bodyGeo) clone.add(new THREE.Mesh(bodyGeo, new THREE.MeshBasicMaterial()));
                        if (textGeo) clone.add(new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial()));
                        if (importedGeo) clone.add(new THREE.Mesh(importedGeo, new THREE.MeshBasicMaterial()));
                        
                        const stlData = new STLExporter().parse(clone, {binary:true});
                        const fileName = `${baseName}_[${safeChar}].stl`;
                        saveBlob(new Blob([stlData], {type:'application/octet-stream'}), fileName);
                    } else {
                        const fileData = await generate3MFData(bodyGeo, textGeo, importedGeo);
                        const fileName = `${baseName}_[${safeChar}].3mf`;
                        saveBlob(fileData, fileName);
                    }
                    
                    await new Promise(r => setTimeout(r, 300));
                }
                
                progress.textContent = t.batch_complete;
                await new Promise(r => setTimeout(r, 1000));
            } finally {
                state.text = originalText;
                syncUI();
                requestUpdate();
                loading.style.display = 'none';
                progress.style.display = 'none';
            }
        }
        
        async function generate3MFData(bodyGeo, textGeo, importedGeo) {
            const zip = new JSZip();
            
            function geoTo3MFMesh(geometry) {
                if (!geometry) return null;
                let geo = geometry.clone();
                if (!geo.index) {
                    geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
                }
                const position = geo.attributes.position;
                if (!position) return null;
                
                const vertices = [];
                const triangles = [];
                const index = geo.index;
                
                if (index && index.array) {
                    for (let i = 0; i < position.count; i++) {
                        vertices.push(`      <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                    }
                    const indexArray = index.array;
                    for (let i = 0; i < indexArray.length; i += 3) {
                        triangles.push(`      <triangle v1="${indexArray[i]}" v2="${indexArray[i+1]}" v3="${indexArray[i+2]}" />`);
                    }
                } else {
                    for (let i = 0; i < position.count; i++) {
                        vertices.push(`      <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                    }
                    for (let i = 0; i < position.count; i += 3) {
                        triangles.push(`      <triangle v1="${i}" v2="${i+1}" v3="${i+2}" />`);
                    }
                }
                return { vertices, triangles };
            }
            
            let modelXml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02" xmlns:m="http://schemas.microsoft.com/3dmanufacturing/material/2015/02">
  <metadata name="Application">Keycap Generator V63.3.1</metadata>
  <resources>
    <m:basematerials id="1">
      <m:base name="Body" displaycolor="#${state.colBody.slice(1).toUpperCase()}" />
      <m:base name="Text" displaycolor="#${state.colText.slice(1).toUpperCase()}" />
    </m:basematerials>`;
            
            let objectId = 2;
            let buildItems = '';
            
            if (bodyGeo) {
                const mesh = geoTo3MFMesh(bodyGeo);
                if (mesh) {
                    modelXml += `
    <object id="${objectId}" name="KeycapBody" type="model">
      <mesh>
        <vertices>
${mesh.vertices.join('\n')}
        </vertices>
        <triangles>
${mesh.triangles.map(t => t.replace('/>', ' pid="1" p1="0" />')).join('\n')}
        </triangles>
      </mesh>
    </object>`;
                    buildItems += `    <item objectid="${objectId}" />`;
                    objectId++;
                }
            }
            
            let combinedTextGeo = textGeo;
            if (importedGeo) {
                if (combinedTextGeo) {
                    combinedTextGeo = BufferGeometryUtils.mergeGeometries([combinedTextGeo, importedGeo]);
                    combinedTextGeo = BufferGeometryUtils.mergeVertices(combinedTextGeo, 0.0001);
                } else {
                    combinedTextGeo = importedGeo;
                }
            }
            
            if (combinedTextGeo) {
                const mesh = geoTo3MFMesh(combinedTextGeo);
                if (mesh) {
                    modelXml += `
    <object id="${objectId}" name="KeycapText" type="model">
      <mesh>
        <vertices>
${mesh.vertices.join('\n')}
        </vertices>
        <triangles>
${mesh.triangles.map(t => t.replace('/>', ' pid="1" p1="1" />')).join('\n')}
        </triangles>
      </mesh>
    </object>`;
                    buildItems += `\n    <item objectid="${objectId}" />`;
                }
            }
            
            modelXml += `
  </resources>
  <build>
${buildItems}
  </build>
</model>`;

            const contentTypes = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />
</Types>`;

            const rels = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>`;

            zip.file("[Content_Types].xml", contentTypes);
            zip.folder("_rels").file(".rels", rels);
            zip.folder("3D").file("3dmodel.model", modelXml);
            
            return await zip.generateAsync({ type: "blob", compression: "DEFLATE" });
        }
        
        document.getElementById('btn-batch-export').addEventListener('click', runBatchExport);
        
        const pSel = document.getElementById('profile-select');
        if(pSel) pSel.addEventListener('change', e => {
            const defs = {cherry:4.3, oem:5.0, sa:6.0, xda:2.5, dsa:2.5};
            if(defs[e.target.value]) {
                state.ribShorten = defs[e.target.value];
                document.getElementById('rib-shorten').value = state.ribShorten;
                document.getElementById('v-rib-shorten').textContent = state.ribShorten.toFixed(2);
                requestUpdate();
            }
        });
        
        const fStart = document.getElementById('force-start-btn');
        if(fStart) fStart.addEventListener('click', ()=>{
            document.getElementById('loading').style.display='none';
            requestUpdate();
        });
        
        init();
    </script>
</body>
</html>