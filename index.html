<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="google-site-verification" content="E2yuICa6eKYqirbpWGXo9DtwvVG9mlCf_g56Qzpse2M" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keycap Generator V67</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 306.06 217.55'%3E%3Cstyle%3E.a%7Bstroke:%23ccc;stroke-miterlimit:10;fill:none%7D.b%7Bfill:aqua;stroke:aqua;stroke-miterlimit:10%7D.c%7Bstroke:aqua;stroke-miterlimit:10;fill:none;stroke-width:4px%7D.d%7Bfill:%23b3b3b3%7D%3C/style%3E%3Cpolygon class='d' points='273.2 41.92 305.59 144.63 149.26 216.93 148.91 216.18 151.25 80.26 273.2 41.92'/%3E%3Cpolygon class='d' points='273.2 41.92 151.25 80.26 35.16 29.06 152.73 .49 273.2 41.92'/%3E%3Cpolygon class='d' points='151.25 80.26 148.91 216.18 .25 136.62 .61 135.77 35.16 29.06 151.25 80.26'/%3E%3Cline class='a' x1='35.16' y1='29.06' x2='.61' y2='135.77'/%3E%3Cline class='a' x1='.25' y1='136.62' x2='148.91' y2='216.18'/%3E%3Cline class='a' x1='151.25' y1='80.26' x2='35.16' y2='29.06'/%3E%3Cline class='a' x1='148.91' y1='216.18' x2='151.25' y2='80.26'/%3E%3Cline class='a' x1='273.2' y1='41.92' x2='151.25' y2='80.26'/%3E%3Cline class='a' x1='305.59' y1='144.63' x2='273.2' y2='41.92'/%3E%3Cpolyline class='a' points='148.91 217.1 149.26 216.93 305.59 144.63'/%3E%3Cline class='a' x1='152.73' y1='.49' x2='273.2' y2='41.92'/%3E%3Cline class='a' x1='152.73' y1='.49' x2='35.16' y2='29.06'/%3E%3Cline class='c' x1='86.1' y1='30.23' x2='119.97' y2='22'/%3E%3Cline class='c' x1='155.68' y1='60.92' x2='86.1' y2='30.23'/%3E%3Cline class='c' x1='224.32' y1='40.72' x2='154.45' y2='60.92'/%3E%3Cline class='c' x1='224.32' y1='41.22' x2='198.07' y2='32.19'/%3E%3Cpath class='b' d='M167.62,24.24s-20.08-4.1-28.79,0c-8.7,4.1,7.85-6.02,3.19-9.13s11.8,5.35,23.8.19c12-5.15-13.25,5.77,1.79,8.94Z'/%3E%3Cpath class='b' d='M169.51,46.26s-18.64-3.8-26.72,0c-8.08,3.8,7.29-5.59,2.96-8.48-4.32-2.88,10.96,4.96,22.1.18,11.14-4.78-12.3,5.36,1.66,8.3Z'/%3E%3Cpath class='b' d='M134.59,37.59s-10.53-2.15-15.09,0,4.12-3.16,1.67-4.79c-2.44-1.63,6.19,2.8,12.48.1,6.29-2.7-6.94,3.03.94,4.69Z'/%3E%3C/svg%3E">
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <!-- MeshFix WASM - ÁèæÂú®ÁÑ°ÂäπÔºà„Çπ„ÉÜ„É†Á©¥„ÇíÊåÅ„Å§„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Å´„ÅØ‰∏çÂêë„ÅçÔºâ -->
    <!-- <script src="meshfix.js"></script> -->
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: rgba(30, 30, 30, 0.98);
            --text-main: #e0f7fa;
            --text-muted: #80deea;
            --accent: #00e5ff;
            --accent-hover: #84ffff;
            --border: #444;
            --input-bg: #263238;
            --danger: #ff5252;
            --sub-bg: rgba(0, 229, 255, 0.05); 
            --import-bg: rgba(255, 152, 0, 0.05);
            --texture-bg: rgba(233, 30, 99, 0.05);
            --highlight: rgba(255, 235, 59, 0.3);
        }

        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: var(--bg-color); color: var(--text-main); }
        
        #canvas-container { 
            position: absolute; left: 400px; width: calc(100% - 400px); height: 100%; top: 0; z-index: 1; 
            transition: all 0.3s ease; 
        }
        
        #ui-panel {
            position: absolute; left: 0; top: 0; width: 400px; height: 100%;
            background: var(--panel-bg); border-right: 1px solid var(--border);
            box-sizing: border-box; 
            display: flex; flex-direction: column; 
            box-shadow: 4px 0 15px rgba(0,0,0,0.6); z-index: 2;
            padding: 0; transition: transform 0.3s ease;
        }

        body.ui-closed #ui-panel { transform: translateX(-400px); }
        body.ui-closed #canvas-container { left: 0 !important; width: 100% !important; }
        body.ui-closed #gallery-strip { left: 15px !important; }

        #ui-header-area { flex: 0 0 auto; padding: 15px 15px 5px 15px; background: var(--panel-bg); border-bottom: 1px solid #333; z-index: 10; }
        #ui-scroll-area { flex: 1; overflow-y: auto; padding: 10px 15px 30px 15px; scroll-behavior: smooth; }
        #ui-scroll-area::-webkit-scrollbar { width: 6px; }
        #ui-scroll-area::-webkit-scrollbar-thumb { background: #006064; border-radius: 3px; }

        #top-right-panel {
            position: absolute; top: 10px; right: 10px; width: 260px;
            background: rgba(20, 20, 20, 0.95); border: 1px solid var(--accent);
            padding: 12px 12px 12px 50px; border-radius: 6px; z-index: 10;
            box-shadow: -4px 4px 15px rgba(0,0,0,0.5); font-family: monospace; transition: all 0.3s ease;
        }
        #top-right-panel:hover { background: rgba(30, 30, 30, 0.98); box-shadow: -4px 4px 20px rgba(0,229,255,0.2); }
        #top-right-panel.stats-collapsed { height: 36px; width: 36px; min-width: 0; padding: 0; overflow: hidden; border: none; background: transparent; box-shadow: none; }
        #top-right-panel.stats-collapsed .cost-row, #top-right-panel.stats-collapsed .fil-control, #top-right-panel.stats-collapsed #btn-toggle-fil, #top-right-panel.stats-collapsed #info-fil-name, #top-right-panel.stats-collapsed #fil-details-panel { display: none; }

        .cost-row { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 1.0rem; border-bottom: 1px solid #333; padding-bottom: 4px; }
        .cost-val { color: var(--accent); font-weight: bold; }
        .cost-sub { font-size: 0.75rem; color: #aaa; text-align: right; margin-bottom: 10px; }
        .fil-control { margin-top: 8px; }
        .fil-control label { color: #b2ff59; font-size: 0.75rem; margin-bottom: 2px; display: block; }
        .fil-control select { width: 100%; padding: 5px; font-size: 0.85rem; background: #111; border: 1px solid #555; color: #fff; margin-bottom: 5px; border-radius: 4px; cursor: pointer; }
        .fil-details { display: none; margin-top: 8px; padding-top: 8px; border-top: 1px dashed #444; background: rgba(255,255,255,0.02); padding: 5px; border-radius: 4px; }
        .fil-details.open { display: block; animation: fadeIn 0.2s; }
        .fil-input-row { display: flex; gap: 5px; margin-bottom: 5px; align-items: center; }
        .fil-input-row label { width: 45px; color: #aaa; font-size: 0.7rem; margin: 0; }
        .fil-input-row input { flex: 1; min-width: 0; background: #222; border: 1px solid #444; color: #fff; padding: 4px; font-size: 0.8rem; text-align: right; border-radius: 2px; }
        #btn-toggle-fil { width: 100%; padding: 4px; font-size: 0.75rem; background: transparent; border: 1px solid #333; color: #aaa; cursor: pointer; border-radius: 4px; transition: 0.2s; margin-top: 5px; }
        #btn-toggle-fil:hover { color: #fff; border-color: #777; background: rgba(255,255,255,0.05); }

        .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .title-block { display: flex; align-items: center; gap: 10px; }
        #app-logo { height: 45px; width: auto; cursor: pointer; transition: transform 0.2s, filter 0.2s; filter: drop-shadow(0 0 2px rgba(0, 229, 255, 0.3)); }
        #app-logo:hover { transform: scale(1.1); filter: drop-shadow(0 0 5px rgba(0, 229, 255, 0.8)); }
        h2 { margin: 0; color: var(--accent); font-size: 1.3rem; line-height: 1.1; }
        .ver { font-size: 0.65rem; color: var(--text-muted); opacity: 0.8; display: block; }
        #language-select { background: var(--input-bg); border: 1px solid var(--border); color: var(--text-main); padding: 4px 8px; border-radius: 4px; font-size: 0.85rem; cursor: pointer; }

        #nav-bar { display: flex; flex-direction: column; gap: 5px; margin-bottom: 5px; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px; border: 1px solid #333; }
        .nav-row { display: flex; gap: 5px; }
        #section-select { flex: 1; background: #222; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 4px; font-size: 0.85rem; cursor: pointer; }
        #section-select:hover { border-color: var(--accent); }
        #search-box { flex: 1; background: #222; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 4px 8px; font-size: 0.85rem; }
        #search-box:focus { border-color: var(--accent); outline: none; }
        .search-highlight { background-color: var(--highlight); color: #000 !important; border-radius: 2px; padding: 0 2px; transition: 0.3s; }

        h3 { font-size: 0.85rem; border-bottom: 1px solid var(--accent); margin-top: 15px; padding-bottom: 3px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; scroll-margin-top: 10px; }
        .control-group { margin-bottom: 6px; }
        .control-row { display: flex; gap: 8px; align-items: center; margin-bottom: 4px; }
        label { font-size: 0.75rem; display: flex; justify-content: space-between; color: #b2ebf2; margin-bottom: 2px; align-items: center; white-space: nowrap; }
        span.val { color: var(--accent); font-family: monospace; font-size: 0.9rem; font-weight: bold; min-width: 35px; text-align: right; display: inline-block; }
        
        input.direct-input { width: 50px; background: #000; border: 1px solid var(--accent); color: var(--accent); font-family: monospace; font-size: 0.9rem; text-align: right; padding: 2px 4px; display: none; z-index:100; }
        input[type="range"] { width: 100%; margin: 4px 0; cursor: pointer; appearance: none; background: transparent; }
        input[type="range"]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #006064; border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; height: 14px; width: 14px; border-radius: 50%; background: var(--accent); margin-top: -5px; box-shadow: 0 0 5px var(--accent); transition: 0.2s; }
        input[type="range"]:disabled { opacity: 0.3; cursor: not-allowed; }
        select, input[type="text"], textarea { width: 100%; background: var(--input-bg); border: 1px solid #00838f; color: white; padding: 6px; border-radius: 4px; font-size: 0.85rem; font-family: sans-serif; box-sizing: border-box; }
        textarea { resize: vertical; min-height: 40px; }
        
        .toggle-switch { display: flex; align-items: center; gap: 8px; cursor: pointer; justify-content: start; width: 100%; margin-bottom: 4px; }
        .toggle-input { display: none; }
        .toggle-knob { width: 36px; height: 18px; background: #444; border-radius: 9px; position: relative; transition: 0.3s; border:1px solid #666; flex-shrink: 0; }
        .toggle-knob::after { content:''; position:absolute; left:2px; top:2px; width:12px; height:12px; background:white; border-radius:50%; transition:0.3s; }
        .toggle-input:checked + .toggle-knob { background: var(--accent); border-color:var(--accent); }
        .toggle-input:checked + .toggle-knob::after { left: 20px; background: black; }
        .toggle-label { color: #e0f7fa; font-size: 0.8rem; user-select: none; }

        .hint-tooltip { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%) translateY(5px); background: rgba(0, 40, 45, 0.95); border: 1px solid var(--accent); color: #e0f7fa; padding: 10px 14px; border-radius: 6px; font-size: 0.75rem; max-width: 320px; z-index: 9999; pointer-events: none; box-shadow: 0 4px 20px rgba(0, 229, 255, 0.3); opacity: 0; transition: opacity 0.3s ease, transform 0.3s ease, bottom 0.3s ease; line-height: 1.5; }
        .hint-tooltip.visible { opacity: 1; transform: translateX(-50%) translateY(0); pointer-events: auto; }
        .hint-tooltip .hint-text::before { content: 'üí°'; margin-right: 6px; }
        .hint-tooltip .hint-text { display: block; }
        .hint-tooltip .hint-video-area { display: none; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px dashed rgba(0, 229, 255, 0.3); }
        .hint-tooltip.show-video .hint-video-area { display: block; animation: fadeIn 0.3s ease; }
        .hint-tooltip .hint-video-placeholder { width: 100%; height: 120px; background: rgba(0, 0, 0, 0.5); border: 1px dashed rgba(0, 229, 255, 0.5); border-radius: 4px; display: flex; justify-content: center; align-items: center; color: #80deea; font-size: 0.7rem; text-align: center; }
        .hint-tooltip .hint-video-placeholder video, .hint-tooltip .hint-video-placeholder img { width: 100%; height: 100%; object-fit: contain; border-radius: 4px; }
        .hint-tooltip .hint-f1-notice { margin-top: 8px; font-size: 0.65rem; color: #80deea; opacity: 0.8; display: flex; align-items: center; justify-content: flex-end; gap: 4px; }
        .hint-tooltip .hint-f1-notice .kbd { background: #1a3a3a; padding: 2px 6px; border-radius: 3px; border-bottom: 2px solid #0d2626; font-family: monospace; font-size: 0.6rem; color: #4dd0e1; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        [data-hint] { position: relative; }
        [data-hint].hint-highlight { background: rgba(0, 229, 255, 0.1); border-radius: 4px; transition: background 0.3s; }

        .file-upload { position: relative; display: inline-block; width: 100%; }
        .file-upload input[type="file"] { display: none; }
        .file-upload-label { display: block; width: 100%; padding: 8px; background: #004d40; border: 1px dashed #00e5ff; color: #e0f7fa; text-align: center; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: 0.3s; box-sizing: border-box; }
        .file-upload-label:hover { background: #006064; }
        .file-upload-label.preset { background: #37474f; border-color: #90a4ae; color: #eceff1; }
        .file-upload-label.preset:hover { background: #455a64; }

        button { width: 100%; background: transparent; border: 1px solid var(--accent); padding: 10px; color: var(--accent); font-weight: bold; cursor: pointer; border-radius: 4px; margin-top: 5px; transition: 0.2s; text-transform: uppercase; font-size: 0.8rem; }
        button:hover { background: var(--accent); color: #000; box-shadow: 0 0 10px var(--accent); }
        button:disabled { border-color: #555; color: #555; background: rgba(0,0,0,0.5); cursor: not-allowed; box-shadow: none; }
        button.secondary { border-color: #555; color: #aaa; }
        button.secondary:hover { background: #555; color: white; }
        button.danger { border-color: var(--danger); color: var(--danger); margin-top:0; padding: 0; }
        button.danger:hover { background: var(--danger); color: white; }
        button.accent { background: rgba(0, 229, 255, 0.1); }
        button.accent:hover { background: var(--accent); color: black; }
        button.primary-3mf { border-color: #4caf50; color: #4caf50; background: rgba(76, 175, 80, 0.1); }
        button.primary-3mf:hover { background: #4caf50; color: white; }
        .btn-square { width: 34px; height: 34px; display: flex; justify-content: center; align-items: center; font-size: 1.2rem; margin: 0; flex-shrink: 0; }
        .btn-small { padding: 6px; font-size: 0.75rem; margin-top: 0; }

        .color-input { -webkit-appearance: none; appearance: none; border: none; width: 100%; height: 30px; cursor: pointer; padding: 0; background: none; }
        .palette-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-top: 6px; }
        .palette-swatch { width: 100%; padding-bottom: 60%; border-radius: 3px; cursor: pointer; border: 1px solid #555; transition: transform 0.1s; }
        .palette-swatch:hover { transform: scale(1.1); border-color: white; z-index: 10; box-shadow: 0 0 8px rgba(255,255,255,0.5); }

        #history-controls { position: absolute; top: 10px; left: 450px; z-index: 10; display: flex; gap: 5px; transition: all 0.3s ease; }
        .hist-btn { background: rgba(0,0,0,0.8); border: 1px solid var(--accent); color: var(--accent); width: 40px; height: 40px; border-radius: 4px; font-size: 1.2rem; cursor: pointer; display: flex; justify-content: center; align-items: center; padding: 0; margin: 0; }
        .hist-btn:hover { background: var(--accent); color: #000; }
        .hist-btn:disabled { border-color: #555; color: #555; background: rgba(0,0,0,0.5); }
        #render-mode-controls { position: absolute; top: 60px; left: 450px; z-index: 10; width: 120px; transition: all 0.3s ease; }
        #render-mode-controls select { background: rgba(0,0,0,0.8); border: 1px solid var(--accent); color: var(--accent); padding: 5px; cursor: pointer; width: 100%; }
        #gumball-target-controls { position: absolute; top: 95px; left: 450px; z-index: 10; width: 120px; transition: all 0.3s ease; }
        #gumball-target-controls select { background: rgba(0,0,0,0.8); border: 1px solid #4caf50; color: #4caf50; padding: 5px; cursor: pointer; width: 100%; font-size: 0.8rem; }
        body.ui-closed #history-controls { left: 50px; top: 85px; }
        body.ui-closed #render-mode-controls { left: 50px; top: 130px; }
        body.ui-closed #gumball-target-controls { left: 50px; top: 162px; }
        body.ui-closed #preset-float-panel { left: 50px; top: 195px; }

        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; color: var(--accent); font-size: 1.5rem; transition: opacity 0.5s; }
        #force-start-btn { margin-top: 20px; padding: 10px 20px; border: 1px solid white; color: white; background: transparent; cursor: pointer; display: none; }
        #error-log { color:#ff5252; font-size:0.9rem; margin-top:10px; max-width:80%; font-family:monospace; white-space: pre-wrap; }
        #batch-progress { margin-top: 20px; font-size: 1rem; color: var(--text-main); display: none; }

        .info-link { font-size: 0.75rem; color: #aaa; margin-bottom: 6px; line-height: 1.3; }
        .info-link a { color: var(--accent); text-decoration: none; }
        .custom-select-container { position: relative; width: 100%; }
        .custom-select-head { background: var(--input-bg); border: 1px solid #00838f; color: white; padding: 8px; border-radius: 4px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; }
        .custom-select-list { position: absolute; top: 100%; left: 0; right: 0; background: #1e272c; border: 1px solid var(--accent); border-top: none; z-index: 999; max-height: 200px; overflow-y: auto; display: none; border-radius: 0 0 4px 4px; }
        .custom-select-list.open { display: block; }
        .custom-option { padding: 8px; cursor: pointer; font-size: 0.85rem; border-bottom: 1px solid #333; }
        .custom-option:hover { background: rgba(0, 229, 255, 0.2); color: white; }
        .custom-option.selected { background: var(--accent); color: black; font-weight: bold; }

        .section-sep { border-top: 1px solid #333; margin: 15px 0 5px 0; }
        .v60-sub-panel { background: var(--sub-bg); padding: 8px; border-radius: 4px; border: 1px dashed #444; margin-top: 5px; }
        .v60-import-panel { background: var(--import-bg); padding: 8px; border-radius: 4px; border: 1px dashed #ff9800; margin-top: 5px; }
        .v60-label { color: #ffeb3b; font-weight: bold; }
        .v60-label-side { color: #b2ff59; font-weight: bold; }
        .v61-texture-panel { background: var(--texture-bg); padding: 8px; border-radius: 4px; border: 1px dashed #e91e63; margin-top: 5px; }
        .v63-texture-map-panel { background: rgba(156, 39, 176, 0.05); padding: 8px; border-radius: 4px; border: 1px dashed #ba68c8; margin-top: 5px; }

        #btn-toggle-ui { position: absolute; left: 400px; top: 10px; z-index: 20; width: 30px; height: 40px; border-radius: 0 4px 4px 0; background: var(--panel-bg); color: var(--accent); border: 1px solid var(--border); border-left: none; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: all 0.3s ease; font-weight: bold; font-size: 1.2rem; font-family: "Segoe UI Symbol", sans-serif; }
        #btn-toggle-ui:hover { background: #333; color: #fff; }
        body.ui-closed #btn-toggle-ui { left: 0; background: rgba(0,0,0,0.5); }
        #btn-toggle-stats { position: absolute; top: 5px; left: 5px; width: 36px; height: 36px; border: 1px solid var(--accent); background: rgba(0, 0, 0, 0.5); color: var(--accent); cursor: pointer; font-weight: bold; z-index: 11; font-size: 1.2rem; line-height: 1; padding: 0; border-radius: 4px; display: flex; justify-content: center; align-items: center; transition: all 0.2s ease; font-family: "Segoe UI Symbol", sans-serif; }
        #btn-toggle-stats:hover { background: var(--accent); color: #000; }
        #top-right-panel.stats-collapsed #btn-toggle-stats { top: 0; left: 0; border-color: #555; color: #aaa; background: rgba(0,0,0,0.8); }
        #top-right-panel.stats-collapsed #btn-toggle-stats:hover { border-color: var(--accent); color: var(--accent); }
        .social-links { display: flex; gap: 10px; align-items: center; margin-right: 10px; }
        .social-icon { width: 32px; height: 32px; cursor: pointer; transition: transform 0.2s, filter 0.2s; fill: var(--text-muted); }
        .social-icon:hover { transform: scale(1.2); filter: drop-shadow(0 0 5px var(--accent)); fill: var(--accent); }
        .social-icon.github-icon path { fill: var(--text-muted); transition: fill 0.2s; }
        .social-icon.github-icon:hover path { fill: var(--accent); }

        #toast-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 2000; display: flex; flex-direction: column; gap: 10px; pointer-events: none; }
        .toast { background: rgba(0, 0, 0, 0.85); color: #e0f7fa; padding: 10px 20px; border-radius: 4px; border: 1px solid var(--accent); box-shadow: 0 4px 15px rgba(0,0,0,0.5); font-size: 0.9rem; opacity: 0; transform: translateY(20px); transition: all 0.3s ease; pointer-events: auto; text-align: center; }
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.error { border-color: var(--danger); color: #ffeb3b; }

        /* V66 Simple Mode Styles */
        .simple-mode-panel { background: rgba(76, 175, 80, 0.1); border: 2px solid #4caf50; border-radius: 8px; padding: 15px; margin-bottom: 15px; }
        .simple-mode-panel h3 { color: #4caf50; border-color: #4caf50; margin-top: 0; }
        .simple-mode-hidden { display: none !important; }
        
        .key-size-buttons { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin-top: 8px; }
        .key-size-btn { padding: 8px 4px; font-size: 0.7rem; border: 1px solid #555; background: #333; color: #aaa; cursor: pointer; border-radius: 4px; transition: all 0.2s; text-align: center; }
        .key-size-btn:hover { border-color: var(--accent); color: var(--accent); }
        .key-size-btn.active { background: var(--accent); color: #000; border-color: var(--accent); font-weight: bold; }
        .key-size-btn .size-label { display: block; font-weight: bold; font-size: 0.85rem; }
        .key-size-btn .size-desc { display: block; font-size: 0.6rem; opacity: 0.8; margin-top: 2px; }

        /* V66 Visual Preset Library */
        .visual-preset-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 10px; }
        .visual-preset-btn { padding: 12px 8px; border: 1px solid #555; background: #222; color: #aaa; cursor: pointer; border-radius: 6px; transition: all 0.2s; text-align: center; font-size: 0.75rem; }
        .visual-preset-btn:hover { border-color: var(--accent); color: var(--accent); background: rgba(0, 229, 255, 0.1); }
        .visual-preset-btn .preset-icon { font-size: 1.5rem; display: block; margin-bottom: 4px; }
        .visual-preset-btn .preset-name { display: block; font-size: 0.65rem; }

        /* V66 Stock Icons */
        .stock-icon-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; margin-top: 8px; max-height: 200px; overflow-y: auto; }
        .stock-icon-btn { width: 100%; aspect-ratio: 1; border: 1px solid #555; background: #222; color: #aaa; cursor: pointer; border-radius: 4px; transition: all 0.2s; display: flex; justify-content: center; align-items: center; font-size: 1.2rem; padding: 4px; }
        .stock-icon-btn svg { width: 100%; height: 100%; fill: currentColor; stroke: currentColor; }
        .stock-icon-btn:hover { border-color: #ffeb3b; color: #ffeb3b; background: rgba(255, 235, 59, 0.1); }
        .stock-icon-btn.selected { border-color: #ffeb3b; background: #ffeb3b; color: #000; }
        .stock-icon-btn.selected svg { fill: #000; stroke: #000; }

        /* V66 Dimension Lines */
        .dimension-overlay { 
            position: absolute; 
            bottom: 10px; 
            left: 10px; 
            background: rgba(0,0,0,0.85); 
            border: 1px solid #2196f3; 
            padding: 10px; 
            border-radius: 4px; 
            font-family: monospace; 
            font-size: 0.8rem; 
            color: #aaa; 
            z-index: 4;
            min-width: 140px;
        }
        .dimension-row { display: flex; justify-content: space-between; gap: 15px; margin-bottom: 4px; }
        .dimension-row:last-child { margin-bottom: 0; }
        .dimension-label { color: #2196f3; }
        .dimension-value { color: var(--accent); font-weight: bold; }

        /* V66 Tolerance Test Kit */
        .tolerance-test-panel { background: rgba(156, 39, 176, 0.1); border: 1px dashed #9c27b0; padding: 10px; border-radius: 4px; margin-top: 10px; }
        .tolerance-test-panel label { color: #9c27b0; }

        /* V66 Sprue Kit */
        .sprue-kit-panel { background: rgba(0, 188, 212, 0.1); border: 1px dashed #00bcd4; padding: 10px; border-radius: 4px; margin-top: 10px; }
        .sprue-kit-panel label { color: #00bcd4; }
        
        /* Custom Sprue Kit Dialog */
        .csk-dialog {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #00bcd4; border-radius: 16px;
            padding: 16px; width: 94vw; max-width: 1200px; height: 90vh;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            transform: scale(0.8); opacity: 0; transition: transform 0.3s ease, opacity 0.3s ease;
            display: flex; flex-direction: column;
        }
        .csk-dialog.show { transform: scale(1); opacity: 1; }
        .csk-body { display: flex; gap: 12px; flex: 1; min-height: 0; overflow: hidden; }
        .csk-left { width: 170px; min-width: 170px; display: flex; flex-direction: column; }
        .csk-left-title { 
            color: #4fc3f7; font-size: 0.75rem; font-weight: bold; 
            padding: 5px 8px;
            background: rgba(0,0,0,0.3); border-radius: 6px; border: 1px solid #333;
            height: 34px; display: flex; align-items: center; box-sizing: border-box;
        }
        .csk-gallery {
            flex: 1; overflow-y: auto; display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px;
            align-content: flex-start; padding: 6px;
            background: rgba(0,0,0,0.3); border-radius: 8px; border: 1px solid #333;
            margin-top: 4px;
        }
        .csk-gallery-tile {
            aspect-ratio: 1; border-radius: 5px; cursor: grab;
            background: #0a0a15; border: 2px solid #333; overflow: hidden;
            display: flex; align-items: center; justify-content: center; position: relative;
            transition: border-color 0.15s;
        }
        .csk-gallery-tile:hover { border-color: #4fc3f7; }
        .csk-gallery-tile img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        .csk-gallery-tile .csk-tile-label {
            position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7);
            color: #fff; font-size: 0.5rem; text-align: center; padding: 2px 3px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .csk-right { flex: 1; display: flex; flex-direction: column; min-width: 0; }
        .csk-toolbar {
            display: flex; gap: 6px; align-items: center; flex-wrap: nowrap;
            padding: 5px 8px;
            background: rgba(0,0,0,0.3); border-radius: 6px; border: 1px solid #333;
            height: 34px; box-sizing: border-box;
        }
        .csk-toolbar label { color: #aaa; font-size: 0.65rem; white-space: nowrap; }
        .csk-toolbar select { font-size: 0.7rem; padding: 2px 4px; max-width: 110px; }
        .csk-toolbar-sep { width: 1px; height: 20px; background: #444; flex-shrink: 0; }
        .csk-toolbar-btn {
            padding: 3px 8px; border-radius: 5px; border: 1px solid #555;
            background: rgba(255,255,255,0.05); color: #ccc; font-size: 0.65rem; cursor: pointer;
            transition: all 0.15s; white-space: nowrap;
        }
        .csk-toolbar-btn:hover { background: rgba(79,195,247,0.2); border-color: #4fc3f7; color: #4fc3f7; }
        .csk-grid-wrap {
            flex: 1; display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.25); border-radius: 8px; border: 1px solid #333;
            padding: 8px; overflow: hidden; position: relative;
            margin-top: 4px;
        }
        .csk-grid {
            display: inline-grid; gap: 3px;
        }
        .csk-slot {
            border-radius: 4px;
            background: rgba(0,188,212,0.08); border: 2px dashed #335;
            display: flex; align-items: center; justify-content: center;
            position: relative; cursor: pointer; transition: all 0.15s;
            font-size: 0.45rem; color: #446;
        }
        .csk-slot.drag-over { border-color: #4fc3f7; background: rgba(79,195,247,0.15); }
        .csk-slot.filled { border-style: solid; background: #0a0a15; cursor: pointer; }
        .csk-slot.filled:hover { filter: brightness(1.2); }
        .csk-slot.selected { border-color: #00e5ff; box-shadow: 0 0 8px rgba(0,229,255,0.4); }
        .csk-slot img { width: 100%; height: 100%; object-fit: cover; border-radius: 3px; pointer-events: none; }
        .csk-slot .csk-slot-label {
            position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7);
            color: #fff; font-size: 0.4rem; text-align: center; padding: 1px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .csk-slot .csk-rot-badge {
            position: absolute; top: 1px; left: 1px; background: rgba(0,0,0,0.7);
            color: #4fc3f7; font-size: 0.45rem; padding: 1px 2px; border-radius: 3px;
        }
        .csk-slot .csk-remove-btn {
            position: absolute; top: 1px; right: 1px; background: rgba(255,82,82,0.9);
            color: #fff; font-size: 0.55rem; width: 14px; height: 14px; border-radius: 2px;
            display: none; align-items: center; justify-content: center; cursor: pointer; line-height: 1;
        }
        .csk-slot.filled:hover .csk-remove-btn { display: flex; }
        /* ‰∏ÄÊã¨ÈÖçÁΩÆÈÅ∏Êäû„É¢„Éº„Éâ */
        .csk-slot.batch-selected { border-color: #ff9800; box-shadow: 0 0 8px rgba(255,152,0,0.5); }
        .csk-slot .csk-batch-check {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255,152,0,0.9); color: #fff; font-size: 1.2rem;
            width: 24px; height: 24px; border-radius: 50%;
            display: none; align-items: center; justify-content: center; z-index: 5;
        }
        .csk-slot.batch-selected .csk-batch-check { display: flex; }
        /* ÈÖçÁΩÆÊñπÂêë„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº */
        .csk-slot .csk-orient-badge {
            position: absolute; top: 26px; right: 2px;
            width: 14px; height: 14px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 0.4rem; font-weight: bold; color: #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5); z-index: 4;
        }
        .csk-orient-badge.orient-top { background: rgb(0, 111, 116); }
        .csk-orient-badge.orient-bottom { background: rgb(62, 99, 97); }
        .csk-orient-badge.orient-front { background: rgb(88, 107, 104); }
        .csk-orient-badge.orient-left { background: rgb(113, 91, 80); }
        .csk-orient-badge.orient-right { background: rgb(108, 71, 71); }
        .csk-orient-badge.orient-back { background: rgb(76, 70, 110); }
        /* ‰∏ÄÊã¨ÈÖçÁΩÆ„Éë„Éç„É´ */
        .csk-batch-panel {
            display: none; margin-top: 8px; padding: 10px;
            background: rgba(255,152,0,0.1); border: 1px solid #ff9800;
            border-radius: 6px;
        }
        .csk-batch-panel.active { display: block; }
        .csk-batch-panel-header {
            display: flex; align-items: center; gap: 10px; margin-bottom: 8px;
        }
        .csk-batch-panel-title {
            color: #ff9800; font-size: 0.75rem; font-weight: bold;
        }
        .csk-batch-count {
            color: #aaa; font-size: 0.65rem;
        }
        .csk-props {
            margin-top: 6px; padding: 6px 8px;
            background: rgba(0,0,0,0.3); border-radius: 6px; border: 1px solid #333;
            display: none;
        }
        .csk-props.active { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .csk-props label { color: #aaa; font-size: 0.65rem; }
        .csk-col-header {
            font-size: 0.5rem; color: #4fc3f7; text-align: center; cursor: pointer;
            padding: 2px; border-radius: 4px; transition: background 0.15s;
        }
        .csk-col-header:hover { background: rgba(79,195,247,0.15); }

        /* F1 Wiki Help Hint */
        .wiki-hint {
            color: #666; font-size: 0.65rem; display: flex; align-items: center; gap: 4px;
            white-space: nowrap; flex-shrink: 0;
        }
        .wiki-hint .kbd { 
            background: #333; padding: 2px 6px; border-radius: 3px; 
            border-bottom: 2px solid #222; font-family: monospace; font-size: 0.6rem; color: #888;
        }
        
        /* Export Confirmation Popup */
        .export-popup-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0); display: flex; justify-content: center; align-items: center;
            z-index: 10000; transition: background 0.3s ease;
        }
        .export-popup {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #4fc3f7; border-radius: 16px;
            padding: 20px; min-width: min(480px, 95vw); max-width: min(600px, 95vw);
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            transform: scale(0.8); opacity: 0; transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .export-popup.show { transform: scale(1); opacity: 1; }
        .export-popup-header {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #4fc3f7; padding-bottom: 10px; margin-bottom: 15px;
        }
        .export-popup-title { color: #4fc3f7; font-size: 1.1rem; font-weight: bold; margin: 0; }
        .export-popup-format { background: #4fc3f7; color: #000; padding: 4px 12px; border-radius: 12px; font-size: 0.8rem; font-weight: bold; }
        .export-popup-preview {
            background: #0a0a15; border-radius: 8px; height: 210px;
            display: flex; justify-content: center; align-items: center;
            margin-bottom: 15px; overflow: hidden;
        }
        .export-popup-preview canvas { max-width: 100%; max-height: 100%; }
        .export-popup-info { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        .export-info-item {
            background: rgba(79, 195, 247, 0.1); padding: 8px 12px; border-radius: 6px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .export-info-label { color: #888; font-size: 0.75rem; }
        .export-info-value { color: #fff; font-size: 0.85rem; font-weight: bold; }
        .export-info-value.highlight { color: #4fc3f7; }
        .export-info-full { grid-column: 1 / -1; }
        .export-popup-buttons {
            display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px;
            padding-top: 15px; border-top: 1px solid #333; align-items: center;
            flex-wrap: nowrap;
        }
        .export-popup-btn {
            padding: 10px 24px; border-radius: 8px; font-size: 0.9rem; cursor: pointer;
            transition: all 0.2s; border: none;
        }
        .export-popup-btn.cancel { background: #444; color: #fff; }
        .export-popup-btn.cancel:hover { background: #555; }
        .export-popup-btn.confirm { background: #4fc3f7; color: #000; font-weight: bold; }
        .export-popup-btn.confirm:hover { background: #80deea; transform: scale(1.02); }
        .export-format-option:has(input:checked) { border-color: #4fc3f7 !important; }
        .export-format-option:hover { background: rgba(79,195,247,0.15) !important; }
        
        /* === V67 HUD „Çπ„Çø„Ç§„É´ === */
        .hud-btn:hover { transform: scale(1.15); }
        .hud-btn:hover svg path, .hud-btn:hover svg rect, .hud-btn:hover svg text { fill: #00e5ff; }
        .hud-btn.active svg path, .hud-btn.active svg rect, .hud-btn.active svg text { fill: #00e5ff !important; }
        
        /* === V67 „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„Éº === */
        .ctx-item:hover { background: rgba(0, 229, 255, 0.15); }
        
        /* === V67 „ÇÆ„É£„É©„É™„Éº„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ === */
        @keyframes gallerySlideIn {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        @keyframes gallerySlideOut {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(20px); }
        }
        #gallery-strip.show { display: block !important; animation: gallerySlideIn 0.25s ease-out forwards; }
        #gallery-strip.hide { animation: gallerySlideOut 0.2s ease-in forwards; }
        #gallery-strip { display: none; }
        #gallery-content::-webkit-scrollbar { height: 6px; }
        #gallery-content::-webkit-scrollbar-track { background: rgba(255,255,255,0.1); border-radius: 3px; }
        #gallery-content::-webkit-scrollbar-thumb { background: rgba(0, 229, 255, 0.5); border-radius: 3px; }
        #gallery-content::-webkit-scrollbar-thumb:hover { background: rgba(0, 229, 255, 0.8); }
        
        /* === V67 „ÇÆ„É£„É©„É™„Éº„Çπ„Éà„É™„ÉÉ„Éó === */
        #gallery-strip { left: 420px; }
        #batch-color-btn, #batch-export-btn { width: 60px; }
        
        /* === V67 „ÇÆ„É£„É©„É™„Éº„Ç¢„Ç§„ÉÜ„É† === */
        .gallery-item { display: inline-block; width: 85px; height: 85px; position: relative; cursor: pointer; border: 2px solid #444; border-radius: 6px; overflow: hidden; transition: all 0.2s ease; flex-shrink: 0; pointer-events: auto; }
        .gallery-item:hover { border-color: #00e5ff; transform: scale(1.05); box-shadow: 0 0 15px rgba(0, 229, 255, 0.4); }
        .gallery-item img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        .gallery-item .gallery-delete { position: absolute; top: 3px; right: 3px; background: rgba(255, 82, 82, 0.9); color: white; border: none; width: 16px; height: 16px; border-radius: 3px; cursor: pointer; font-size: 10px; line-height: 1; opacity: 0; transition: opacity 0.2s; display: flex; align-items: center; justify-content: center; padding: 0; pointer-events: auto; }
        .gallery-item:hover .gallery-delete { opacity: 1; }
        .gallery-item .gallery-name { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7); color: #fff; font-size: 0.6rem; padding: 2px 4px; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; pointer-events: none; }
        
        /* === V67 ‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Éú„Çø„É≥ === */
        #batch-export-btn:hover { background:rgba(0, 229, 255, 0.15) !important; }
        #batch-export-btn:hover svg path, #batch-export-btn:hover svg rect { fill:#00e5ff; }
        #batch-export-btn:hover span { color:#00e5ff !important; }
        #batch-color-btn:hover { background:rgba(76, 175, 80, 0.15) !important; }
        #batch-color-btn:hover svg path { fill:#4caf50; }
        #batch-color-btn:hover span { color:#4caf50 !important; }
        
        /* === V67 ‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÁ¢∫Ë™çÁîªÈù¢ === */
        .batch-format-option:has(input:checked) { border-color:#4fc3f7 !important; }
        .batch-format-option:hover { background:rgba(79,195,247,0.15) !important; }
        #batch-export-preview::-webkit-scrollbar, #batch-color-preview::-webkit-scrollbar { height: 6px; }
        #batch-export-preview::-webkit-scrollbar-track, #batch-color-preview::-webkit-scrollbar-track { background: rgba(255,255,255,0.1); border-radius: 3px; }
        #batch-export-preview::-webkit-scrollbar-thumb, #batch-color-preview::-webkit-scrollbar-thumb { background: rgba(79, 195, 247, 0.5); border-radius: 3px; }
        .batch-preview-item { 
            min-width: 70px; width: 70px; height: 70px; border-radius: 6px; overflow: hidden; 
            border: 2px solid #333; transition: all 0.2s; position: relative; flex-shrink: 0;
            cursor: pointer;
        }
        .batch-preview-item:hover { border-color: #4fc3f7; }
        .batch-preview-item.selected { border-color: #00e5ff; box-shadow: 0 0 10px rgba(0,229,255,0.5); }
        .batch-preview-item img { width: 100%; height: 100%; object-fit: cover; }
        .batch-preview-item .batch-preview-name {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.8); color: #fff; font-size: 0.5rem;
            padding: 2px 4px; text-align: center; white-space: nowrap;
            overflow: hidden; text-overflow: ellipsis;
        }
        .batch-preview-item.selected .batch-preview-name { background: rgba(0,229,255,0.8); color: #000; }
        
        .format-option:has(input:checked) { border-color:#00e5ff !important; }
        
        /* === V67 „ÇÆ„É£„É©„É™„Éº„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„Éº === */
        .gallery-ctx-item:hover { background:rgba(0, 229, 255, 0.15); }
        
        /* === V67 ÈÖçÁΩÆ„É¢„Éº„Éâ„Éë„Éç„É´ === */
        .v67-placement-panel { margin-bottom: 15px; border: 1px solid #00e5ff; padding: 10px; border-radius: 6px; background: rgba(0, 229, 255, 0.05); }
        .v67-placement-panel.active { border-color: #84ffff; background: rgba(0, 229, 255, 0.15); box-shadow: 0 0 15px rgba(0, 229, 255, 0.3); }
        
        /* === V67 „ÇØ„É™„ÉÉ„ÇØ„Ç®„Éï„Çß„ÇØ„Éà === */
        @keyframes clickRipple { 0% { transform: translate(-50%, -50%) scale(0); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(2); opacity: 0; } }
        .click-effect { position: absolute; width: 30px; height: 30px; border-radius: 50%; background: rgba(0, 229, 255, 0.5); pointer-events: none; animation: clickRipple 0.5s ease-out forwards; }

        /* === V67 AMSË®≠ÂÆö„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó === */
        .ams-popup-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 10000; display: flex;
            justify-content: center; align-items: center;
        }
        .ams-popup {
            background: #1a1a1a; border: 2px solid #4fc3f7; border-radius: 12px;
            padding: 20px; min-width: min(700px, 95vw); max-width: min(900px, 95vw);
            transform: scale(0.9); opacity: 0;
            transition: all 0.2s ease;
        }
        .ams-popup.show { transform: scale(1); opacity: 1; }
        .ams-popup-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #333;
        }
        .ams-popup-title { color: #4fc3f7; font-size: 1.2rem; font-weight: bold; margin: 0; }
        
        .ams-content { display: flex; gap: 15px; }
        
        /* Â∑¶ÂÅ¥: „Ç´„É©„Éº„Éë„É¨„ÉÉ„Éà */
        .ams-palette-section {
            width: 200px; background: #222; border-radius: 8px; padding: 12px; flex-shrink: 0;
        }
        .ams-palette-title { color: #aaa; font-size: 0.8rem; margin-bottom: 10px; }
        .ams-palette-grid {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px;
        }
        .ams-palette-color {
            width: 34px; height: 34px; border-radius: 4px; cursor: grab;
            border: 2px solid #444; transition: all 0.2s; position: relative;
        }
        .ams-palette-color:hover { transform: scale(1.1); border-color: #fff; }
        .ams-palette-color.dragging { opacity: 0.5; cursor: grabbing; }
        .ams-palette-color-num {
            position: absolute; bottom: 1px; right: 2px; font-size: 0.5rem;
            color: rgba(255,255,255,0.9); text-shadow: 0 0 2px #000, 0 0 4px #000;
        }
        
        /* Âè≥ÂÅ¥: AMS„Çπ„É≠„ÉÉ„Éà */
        .ams-slots-section { flex: 1; display: flex; gap: 15px; }
        .ams-type-column { flex: 0 0 auto; }
        .ams-type-column.ht-column { flex: 0 0 auto; width: 170px; }
        .ams-type-header {
            display: flex; align-items: center; gap: 8px;
            margin-bottom: 8px;
        }
        .ams-type-title { color: #ff9800; font-size: 0.85rem; font-weight: bold; white-space: nowrap; }
        .ams-add-btn {
            background: #333; border: 1px dashed #666; color: #888;
            padding: 3px 8px; border-radius: 4px; cursor: pointer; font-size: 0.65rem;
            white-space: nowrap;
        }
        .ams-add-btn:hover { border-color: #4fc3f7; color: #4fc3f7; }
        .ams-add-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        
        .ams-units-container { display: flex; flex-direction: column; gap: 6px; }
        .ams-units-container.ht-grid { 
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; 
        }
        
        .ams-unit {
            background: #252525; border: 1px solid #444; border-radius: 6px;
            padding: 6px 8px; position: relative; display: inline-block; width: fit-content;
        }
        /* HTÂ∞ÇÁî®„Çπ„Çø„Ç§„É´ */
        .ams-unit.ht-unit {
            padding: 6px 8px; width: auto;
        }
        .ams-unit.ht-unit .ams-unit-header {
            margin-bottom: 4px;
        }
        .ams-unit.ht-unit .ams-unit-label {
            font-size: 0.65rem; white-space: nowrap;
        }
        .ams-unit.ht-unit .ams-unit-remove {
            width: 16px; height: 16px; font-size: 10px; line-height: 16px;
        }
        .ams-unit-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 6px;
        }
        .ams-unit-label { color: #888; font-size: 0.7rem; white-space: nowrap; }
        .ams-unit-remove {
            background: #ff5252; border: none; color: #fff; width: 18px; height: 18px;
            border-radius: 3px; cursor: pointer; font-size: 12px; line-height: 18px;
            text-align: center; padding: 0; font-family: Arial, sans-serif;
        }
        .ams-unit-remove:hover { background: #ff7777; }
        
        .ams-slots { display: flex; gap: 5px; }
        .ams-slot {
            width: 58px; height: 72px; background: #1a1a1a; border: 2px dashed #555;
            border-radius: 4px; display: flex; flex-direction: column;
            align-items: center; justify-content: center; position: relative;
            transition: all 0.2s; padding: 3px;
        }
        .ams-slot.drag-over { border-color: #4fc3f7; background: rgba(79,195,247,0.1); }
        .ams-slot-num {
            position: absolute; top: 2px; left: 4px; font-size: 0.6rem;
            color: #666; font-weight: bold;
        }
        .ams-slot-color {
            width: 38px; height: 38px; border-radius: 4px; border: 1px solid #666;
        }
        .ams-slot-material {
            font-size: 0.5rem; color: #aaa; margin-top: 3px; text-align: center;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            max-width: 54px; line-height: 1.2;
        }
        .ams-slot-empty { color: #555; font-size: 1rem; }
        .ams-slot-clear {
            position: absolute; top: -4px; right: -4px; background: #ff5252;
            border: none; color: #fff; width: 14px; height: 14px; border-radius: 3px;
            cursor: pointer; font-size: 10px; line-height: 14px; text-align: center;
            padding: 0; z-index: 10; font-family: Arial, sans-serif;
        }
        .ams-slot-clear:hover { background: #ff7777; }

        /* Ë®≠ÂÆö„Çø„ÉñÁî®AMSÈÄ£Êê∫„Éë„É¨„ÉÉ„Éà */
        .ams-select-palette {
            display: flex; flex-wrap: wrap; gap: 6px;
        }
        .ams-select-item {
            width: 50px; height: 60px; border-radius: 6px; cursor: pointer;
            border: 2px solid #444; transition: all 0.2s; position: relative;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: #1a1a1a;
        }
        .ams-select-item:hover { border-color: #888; transform: scale(1.05); }
        .ams-select-item.selected { border-color: #4fc3f7; box-shadow: 0 0 10px rgba(79,195,247,0.5); }
        .ams-select-item.body-selected { border-color: #00e5ff; box-shadow: 0 0 10px rgba(0,229,255,0.5); }
        .ams-select-item.text-selected { border-color: #ff9800; box-shadow: 0 0 10px rgba(255,152,0,0.5); }
        .ams-select-item-num {
            position: absolute; top: 2px; left: 4px; font-size: 0.6rem;
            color: #888; font-weight: bold;
        }
        .ams-select-item-color {
            width: 32px; height: 32px; border-radius: 4px; border: 1px solid #666;
        }
        .ams-select-item-material {
            font-size: 0.5rem; color: #aaa; margin-top: 2px; text-align: center;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 46px;
        }
        .ams-select-empty {
            color: #555; font-size: 0.7rem; text-align: center;
        }
        
        .ams-popup-footer {
            display: flex; justify-content: flex-end; gap: 10px;
            margin-top: 15px; padding-top: 15px; border-top: 1px solid #333; 
            align-items: center; flex-wrap: nowrap;
        }
        .ams-popup-btn {
            padding: 10px 24px; border-radius: 6px; font-size: 0.9rem;
            cursor: pointer; border: none; transition: all 0.2s;
        }
        .ams-popup-btn.cancel { background: #444; color: #fff; }
        .ams-popup-btn.cancel:hover { background: #555; }
        .ams-popup-btn.confirm { background: #4fc3f7; color: #000; font-weight: bold; }
        .ams-popup-btn.confirm:hover { background: #80deea; }

        /* ‚ñº‚ñº‚ñº V67ËøΩÂä†: „Éì„É•„Éº„Ç≠„É•„Éº„Éñ (View Cube) ‚ñº‚ñº‚ñº */
        #view-cube-wrapper {
            position: absolute; bottom: 20px; right: 20px; width: 130px; height: 130px;
            perspective: 800px; z-index: 100; pointer-events: none;
            transition: bottom 0.3s ease;
        }
        #view-cube {
            width: 100%; height: 100%; position: relative; transform-style: preserve-3d;
            transition: transform 0.1s; pointer-events: auto; cursor: pointer;
            transform-origin: center center;
        }
        
        /* Èù¢„ÅÆ„Éá„Ç∂„Ç§„É≥ */
        .cube-face {
            position: absolute; width: 50px; height: 50px; background: rgba(30,30,35,0.95);
            border: 1px solid #666; line-height: 50px; text-align: center; font-size: 11px;
            color: #bbb; font-weight: bold; user-select: none; box-shadow: inset 0 0 12px rgba(0,0,0,0.6);
            transition: 0.15s; backface-visibility: hidden;
            left: 40px; top: 40px;
        }
        .cube-face:hover { background: rgba(0, 229, 255, 0.9); color: #000; border-color: #fff; }

        /* Èù¢„ÅÆÈÖçÁΩÆ */
        .face-front  { transform: rotateY(  0deg) translateZ(25px); }
        .face-back   { transform: rotateY(180deg) translateZ(25px); }
        .face-right  { transform: rotateY( 90deg) translateZ(25px); }
        .face-left   { transform: rotateY(-90deg) translateZ(25px); }
        .face-top    { transform: rotateX( 90deg) translateZ(25px); }
        .face-bottom { transform: rotateX(-90deg) translateZ(25px); }

        /* 3Ëª∏Ôºà„Ç≠„É•„Éº„Éñ„ÅÆËßí„Åã„ÇâÂ§ñÂÅ¥„Å∏‰º∏„Å∞„ÅôÔºâ */
        .cube-axis {
            position: absolute; top: 65px; left: 65px;
            transform-style: preserve-3d; pointer-events: none;
        }
        .axis-line {
            position: absolute; transform-origin: 0 0;
        }
        /* XËª∏: Ëµ§ - „Ç≠„É•„Éº„Éñ„ÅÆ‰∏ãÂâç„ÅÆÁ∏Å„Åã„ÇâÂè≥„Å∏ */
        .axis-x { 
            width: 35px; height: 4px; 
            background: #ff2222;
            box-shadow: 0 0 6px #ff4444;
            transform: translate3d(-25px, 25px, 25px); 
            border-radius: 0 2px 2px 0; 
        }
        /* YËª∏: Á∑ë - „Ç≠„É•„Éº„Éñ„ÅÆÂ∑¶‰∏ãÂâç„ÅÆËßí„Åã„Çâ‰∏ä„Å∏ */
        .axis-y { 
            width: 4px; height: 50px; 
            background: #22ff22;
            box-shadow: 0 0 6px #44ff44;
            transform: translate3d(-25px, -25px, 25px); 
            border-radius: 2px 2px 0 0; 
        }
        /* ZËª∏: „Ç∑„Ç¢„É≥ - Â∑¶‰∏ãÂâç„ÅÆËßí„Åã„ÇâÊâãÂâç„Å∏ */
        .axis-z { 
            width: 35px; height: 4px; 
            background: #00e5ff;
            box-shadow: 0 0 6px #00ffff;
            transform: translate3d(-25px, 25px, 25px) rotateY(90deg); 
            border-radius: 0 2px 2px 0; 
        }
        
        /* Ëª∏„É©„Éô„É´Ôºà„Ç≠„É•„Éº„Éñ„ÅÆ‰∏ä„Å´Èáç„Å≠„Å¶ÈÖçÁΩÆ„ÄÅJS„Åß2D‰ΩçÁΩÆ„ÇíË®àÁÆóÔºâ */
        #axis-labels-container {
            position: absolute; bottom: 20px; right: 20px; width: 130px; height: 130px;
            pointer-events: none; z-index: 101;
            transition: bottom 0.3s ease;
            overflow: visible;
        }
        .axis-label-2d {
            position: absolute; font-size: 12px; font-weight: bold; pointer-events: none;
            text-shadow: 0 0 3px #000, 0 0 6px #000;
            white-space: nowrap;
        }
        .axis-label-2d.label-x { color: #ff4444; }
        .axis-label-2d.label-y { color: #44ff44; }
        .axis-label-2d.label-z { color: #00e5ff; }

        /* „Ç≥„Éº„Éä„ÉºÈÅ∏Êäû */
        .cube-corner {
            position: absolute; width: 22px; height: 22px; background: rgba(200,200,200,0.3);
            z-index: 200; cursor: pointer; border-radius: 4px; border: 1px solid rgba(255,255,255,0.4);
            transform-style: preserve-3d; transition: 0.15s; pointer-events: auto;
            left: 54px; top: 54px;
            backface-visibility: visible;
        }
        .cube-corner:hover { background: rgba(255, 140, 0, 0.9); box-shadow: 0 0 18px #ff8c00; border-color: #ffd700; }
        
        /* 8„Å§„ÅÆËßí„ÅÆÈÖçÁΩÆ */
        .c-frt { transform: translate3d( 22px, -22px,  22px); }
        .c-flt { transform: translate3d(-22px, -22px,  22px); }
        .c-brt { transform: translate3d( 22px, -22px, -22px); }
        .c-blt { transform: translate3d(-22px, -22px, -22px); }
        .c-frb { transform: translate3d( 22px,  22px,  22px); }
        .c-flb { transform: translate3d(-22px,  22px,  22px); }
        .c-brb { transform: translate3d( 22px,  22px, -22px); }
        .c-blb { transform: translate3d(-22px,  22px, -22px); }

        /* ‚ñº‚ñº‚ñº V67ËøΩÂä†: „Éï„Ç£„É©„É°„É≥„Éà„Éî„ÉÉ„Ç´„Éº ‚ñº‚ñº‚ñº */
        .filament-tabs { display: flex; gap: 4px; margin-bottom: 8px; border-bottom: 1px solid #444; padding-bottom: 5px; flex-wrap: wrap; }
        .f-tab { 
            background: none; border: none; color: #888; cursor: pointer; padding: 4px 8px; font-size: 10px; 
            border-radius: 4px 4px 0 0; transition: 0.2s;
        }
        .f-tab.active { background: #444; color: #fff; font-weight: bold; }
        .f-tab:hover { color: #fff; }
        .palette-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; }
        .color-swatch {
            width: 100%; aspect-ratio: 1; border-radius: 4px; border: 2px solid #333; cursor: pointer;
            position: relative; transition: transform 0.1s, border-color 0.1s;
        }
        .color-swatch:hover { transform: scale(1.15); z-index: 10; border-color: #fff; }
        .color-swatch.active { border: 2px solid #00e5ff; box-shadow: 0 0 8px rgba(0,229,255,0.6); }

        /* ‚ñº‚ñº‚ñº V67ËøΩÂä†: „Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„Éó „Ç™„Éº„Éê„Éº„É¨„Ç§ ‚ñº‚ñº‚ñº */
        #dnd-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 229, 255, 0.15); border: 4px dashed #00e5ff;
            display: flex; justify-content: center; align-items: center;
            z-index: 9999; pointer-events: none; opacity: 0; transition: opacity 0.2s;
        }
        #dnd-overlay.active { opacity: 1; backdrop-filter: blur(3px); }
        #dnd-overlay h1 { color: #fff; text-shadow: 0 0 20px #000, 0 0 40px #00e5ff; font-size: 2rem; }

        /* ‚ñº‚ñº‚ñº V67ËøΩÂä†: „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà‰∏ÄË¶ß ‚ñº‚ñº‚ñº */
        #shortcut-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 10000; display: none;
            justify-content: center; align-items: center;
        }
        .shortcut-card {
            background: #1a1a2e; padding: 25px 30px; border-radius: 12px; border: 1px solid #00e5ff;
            max-width: 450px; width: 90%; color: #eee; box-shadow: 0 10px 40px rgba(0,229,255,0.2);
        }
        .shortcut-card h2 { margin-top: 0; color: #00e5ff; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .key-row { display: flex; justify-content: space-between; margin-bottom: 10px; padding: 6px 0; border-bottom: 1px solid #222; }
        .kbd { background: #333; padding: 3px 8px; border-radius: 4px; border-bottom: 2px solid #111; font-family: monospace; font-weight: bold; font-size: 12px; color: #00e5ff; }
        #btn-help { 
            position: fixed; bottom: 25px; right: 170px; width: 32px; height: 32px; border-radius: 50%; 
            background: rgba(30,30,30,0.9); border: 1px solid #555; color: #888; cursor: pointer; 
            z-index: 90; font-size: 14px; transition: bottom 0.3s ease, background 0.2s;
        }
        #btn-help:hover { background: #00e5ff; color: #000; border-color: #fff; }

        /* F5 Debug Panel */
        #debug-panel-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8);
            display: none; justify-content: center; align-items: center; z-index: 10001;
        }
        .debug-panel {
            background: #1a1a2e; border: 2px solid #ff5252; border-radius: 12px;
            padding: 24px; max-width: 520px; width: 90%; max-height: 80vh; overflow-y: auto;
            color: #e0e0e0; font-size: 0.85rem;
        }
        .debug-panel h2 { color: #ff5252; margin: 0 0 15px 0; font-size: 1.1rem; border-bottom: 1px solid #ff5252; padding-bottom: 8px; }
        .debug-section { margin-bottom: 16px; }
        .debug-section h3 { color: #ff9800; font-size: 0.85rem; margin: 0 0 8px 0; text-transform: none; border-bottom: 1px dashed #444; padding-bottom: 4px; }
        .debug-btn {
            display: block; width: 100%; padding: 10px 14px; margin-bottom: 6px;
            background: rgba(255,255,255,0.05); border: 1px solid #555; color: #e0e0e0;
            border-radius: 6px; cursor: pointer; font-size: 0.8rem; text-align: left;
            transition: all 0.15s;
        }
        .debug-btn:hover { background: rgba(255,82,82,0.15); border-color: #ff5252; color: #fff; }
        .debug-btn.danger { border-color: #ff5252; color: #ff5252; }
        .debug-btn.danger:hover { background: rgba(255,82,82,0.25); }
        .debug-info { background: #0a0a15; border: 1px solid #333; border-radius: 6px; padding: 10px; font-family: monospace; font-size: 0.75rem; color: #80deea; max-height: 150px; overflow-y: auto; white-space: pre-wrap; word-break: break-all; }

        /* ========================================
           „É¨„Çπ„Éù„É≥„Ç∑„ÉñÂØæÂøú - „É°„Éá„Ç£„Ç¢„ÇØ„Ç®„É™
           ======================================== */
        
        /* CSSÂ§âÊï∞„Åß„Çµ„Ç§„Éâ„Éê„ÉºÂπÖ„ÇíÁÆ°ÁêÜ */
        :root {
            --sidebar-width: 400px;
        }
        
        /* 1400px‰ª•‰∏ã: „ÇÑ„ÇÑÁã≠„ÅÑ„É¢„Éã„Çø„Éº */
        @media screen and (max-width: 1400px) {
            :root { --sidebar-width: 360px; }
            #ui-panel { width: var(--sidebar-width); }
            #canvas-container { left: var(--sidebar-width); width: calc(100% - var(--sidebar-width)); }
            #btn-toggle-ui { left: var(--sidebar-width); }
            /* Ê®™‰ΩçÁΩÆ„ÅØ„Åù„ÅÆ„Åæ„Åæ„ÄÅÁ∏¶„Å†„ÅëHUD„ÅÆ‰∏ã„Å´„Åö„Çâ„Åô */
            #history-controls { left: calc(var(--sidebar-width) + 50px); top: 105px; }
            #render-mode-controls { left: calc(var(--sidebar-width) + 50px); top: 150px; }
            #gumball-target-controls { left: calc(var(--sidebar-width) + 50px); top: 182px; }
            #preset-float-panel { left: calc(var(--sidebar-width) + 50px); top: 215px; }
            #gallery-strip { left: calc(var(--sidebar-width) + 15px); }
            #top-right-panel { width: 240px; }
        }
        
        /* 1200px‰ª•‰∏ã: Â∞è„Åï„ÇÅ„ÅÆ„É¢„Éã„Çø„Éº */
        @media screen and (max-width: 1200px) {
            :root { --sidebar-width: 320px; }
            #ui-panel { width: var(--sidebar-width); }
            #canvas-container { left: var(--sidebar-width); width: calc(100% - var(--sidebar-width)); }
            #btn-toggle-ui { left: var(--sidebar-width); }
            /* Ê®™‰ΩçÁΩÆ„ÅØ„Åù„ÅÆ„Åæ„Åæ„ÄÅÁ∏¶„Å†„ÅëHUD„ÅÆ‰∏ã„Å´„Åö„Çâ„Åô */
            #history-controls { left: calc(var(--sidebar-width) + 50px); top: 100px; }
            #render-mode-controls { left: calc(var(--sidebar-width) + 50px); top: 145px; }
            #gumball-target-controls { left: calc(var(--sidebar-width) + 50px); top: 177px; }
            #preset-float-panel { left: calc(var(--sidebar-width) + 50px); top: 210px; }
            #gallery-strip { left: calc(var(--sidebar-width) + 15px); height: 90px; }
            #top-right-panel { width: 220px; font-size: 0.85rem; }
            #hud { padding: 6px 12px; gap: 6px; }
            .hud-btn { width: 24px !important; height: 24px !important; }
            .hud-btn svg { width: 18px !important; height: 18px !important; }
            .gallery-item { width: 70px; height: 70px; }
            .export-popup { min-width: min(400px, 90vw) !important; max-width: min(550px, 95vw) !important; }
            .ams-popup { min-width: min(600px, 95vw) !important; max-width: min(750px, 95vw) !important; }
            .csk-dialog { width: 90vw; max-width: 1000px; }
            .csk-left { width: 150px; min-width: 150px; }
            .control-group label { font-size: 0.78rem; }
            h3 { font-size: 0.95rem; }
            #batch-color-btn, #batch-export-btn { width: 55px !important; }
        }
        
        /* 1024px‰ª•‰∏ã: Â∞è„Åï„ÅÑ„É¢„Éã„Çø„ÉºÔºà„Éé„Éº„ÉàPCÁ≠âÔºâ */
        @media screen and (max-width: 1024px) {
            :root { --sidebar-width: 280px; }
            #ui-panel { width: var(--sidebar-width); }
            #canvas-container { left: var(--sidebar-width); width: calc(100% - var(--sidebar-width)); }
            #btn-toggle-ui { left: var(--sidebar-width); }
            /* Ê®™‰ΩçÁΩÆ„ÅØ„Åù„ÅÆ„Åæ„Åæ„ÄÅÁ∏¶„Å†„ÅëHUD„ÅÆ‰∏ã„Å´„Åö„Çâ„Åô */
            #history-controls { left: calc(var(--sidebar-width) + 50px); top: 80px; }
            #render-mode-controls { left: calc(var(--sidebar-width) + 50px); top: 122px; width: 100px; }
            #gumball-target-controls { left: calc(var(--sidebar-width) + 50px); top: 154px; width: 100px; }
            #preset-float-panel { left: calc(var(--sidebar-width) + 50px); top: 187px; }
            #gallery-strip { left: calc(var(--sidebar-width) + 10px); height: 80px; right: 10px; }
            #top-right-panel { width: 200px; padding: 10px; font-size: 0.8rem; }
            .cost-row { font-size: 0.75rem; }
            .fil-control label { font-size: 0.7rem; }
            .fil-control select { font-size: 0.75rem; padding: 4px; }
            #hud { padding: 5px 10px; gap: 5px; top: 10px; }
            .hud-btn { width: 22px !important; height: 22px !important; }
            .hud-btn svg { width: 16px !important; height: 16px !important; }
            .gallery-item { width: 60px; height: 60px; }
            #batch-color-btn, #batch-export-btn { width: 50px !important; }
            #batch-color-btn span, #batch-export-btn span { font-size: 0.5rem !important; }
            #batch-color-btn svg, #batch-export-btn svg { width: 22px !important; height: 22px !important; }
            .export-popup { min-width: min(350px, 90vw) !important; max-width: min(500px, 95vw) !important; padding: 15px; }
            .export-popup-title { font-size: 1rem; }
            .export-popup-preview { height: 150px; }
            .ams-popup { min-width: min(500px, 95vw) !important; max-width: min(650px, 95vw) !important; }
            .ams-palette-section { width: 160px; }
            .ams-slot { width: 50px; height: 60px; }
            .ams-slot-color { width: 32px; height: 32px; }
            .csk-dialog { width: 95vw; height: 85vh; padding: 12px; }
            .csk-left { width: 130px; min-width: 130px; }
            .csk-gallery-tile { width: 55px; height: 55px; }
            .csk-slot { width: 50px; height: 50px; }
            .control-group { margin-bottom: 10px; }
            .control-group label { font-size: 0.75rem; }
            input[type="range"] { margin: 2px 0; }
            h3 { font-size: 0.9rem; padding: 8px 0; margin-bottom: 8px; }
            .toggle-knob { width: 30px; height: 15px; }
            .toggle-knob::after { width: 10px; height: 10px; }
            .toggle-input:checked + .toggle-knob::after { left: 17px; }
            #view-cube-container { width: 100px !important; height: 100px !important; }
            .cube-face span { font-size: 0.55rem; }
            .hist-btn { width: 34px; height: 34px; font-size: 1rem; }
            button { padding: 8px; font-size: 0.75rem; }
            .btn-square { width: 28px; height: 28px; font-size: 1rem; }
            select, input[type="text"], textarea { padding: 5px; font-size: 0.8rem; }
            #app-logo { height: 35px; }
            .social-icon { width: 26px; height: 26px; }
            /* „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆ„Ç∞„É™„ÉÉ„ÉâË™øÊï¥ */
            .export-popup-info { grid-template-columns: 1fr !important; gap: 5px !important; }
            .ams-content { gap: 10px; }
        }
        
        /* 900px‰ª•‰∏ã: ÈùûÂ∏∏„Å´Â∞è„Åï„ÅÑ„É¢„Éã„Çø„Éº */
        @media screen and (max-width: 900px) {
            :root { --sidebar-width: 260px; }
            #ui-panel { width: var(--sidebar-width); }
            #canvas-container { left: var(--sidebar-width); width: calc(100% - var(--sidebar-width)); }
            #btn-toggle-ui { left: var(--sidebar-width); }
            /* Ê®™‰ΩçÁΩÆ„ÅØ„Åù„ÅÆ„Åæ„Åæ„ÄÅÁ∏¶„Å†„ÅëHUD„ÅÆ‰∏ã„Å´„Åö„Çâ„Åô */
            #history-controls { left: calc(var(--sidebar-width) + 50px); top: 75px; }
            #render-mode-controls { left: calc(var(--sidebar-width) + 50px); top: 115px; }
            #gumball-target-controls { left: calc(var(--sidebar-width) + 50px); top: 145px; }
            #preset-float-panel { left: calc(var(--sidebar-width) + 50px); top: 177px; }
            #gallery-strip { left: calc(var(--sidebar-width) + 10px); height: 70px; }
            #top-right-panel { width: 180px; padding: 8px; }
            #hud { padding: 4px 8px; gap: 4px; top: 10px; flex-wrap: wrap; max-width: calc(100% - var(--sidebar-width) - 220px); }
            .hud-btn { width: 20px !important; height: 20px !important; }
            .hud-btn svg { width: 14px !important; height: 14px !important; }
            .gallery-item { width: 50px; height: 50px; }
            #batch-color-btn, #batch-export-btn { width: 45px !important; }
            .export-popup { min-width: min(300px, 90vw) !important; max-width: min(450px, 95vw) !important; }
            .export-popup-preview { height: 120px; }
            .ams-popup { min-width: min(400px, 95vw) !important; max-width: 95vw !important; padding: 15px; }
            .ams-content { flex-direction: column; }
            .ams-palette-section { width: 100%; }
            .csk-dialog { padding: 10px; }
            .csk-body { flex-direction: column; }
            .csk-left { width: 100%; min-width: auto; height: 120px; }
            .csk-gallery { flex-direction: row; flex-wrap: wrap; overflow-x: auto; overflow-y: hidden; height: 100%; }
            .csk-gallery-tile { width: 50px; height: 50px; }
            h3 { font-size: 0.85rem; }
            .control-group label { font-size: 0.7rem; }
            #view-cube-container { width: 80px !important; height: 80px !important; bottom: 15px !important; right: 15px !important; }
            .cube-face span { font-size: 0.5rem; }
            /* HUD„Çª„Éë„É¨„Éº„Çø„ÉºÈùûË°®Á§∫ */
            #hud > div[style*="width:1px"] { display: none; }
            .hist-btn { width: 30px; height: 30px; font-size: 0.9rem; }
        }
        
        /* 800px‰ª•‰∏ã: „Çø„Éñ„É¨„ÉÉ„Éà„Çµ„Ç§„Ç∫ */
        @media screen and (max-width: 800px) {
            :root { --sidebar-width: 240px; }
            #ui-panel { width: var(--sidebar-width); }
            #canvas-container { left: var(--sidebar-width); width: calc(100% - var(--sidebar-width)); }
            #btn-toggle-ui { left: var(--sidebar-width); }
            /* Ê®™‰ΩçÁΩÆ„ÅØ„Åù„ÅÆ„Åæ„Åæ„ÄÅÁ∏¶„Å†„ÅëHUD„ÅÆ‰∏ã„Å´„Åö„Çâ„Åô */
            #history-controls { left: calc(var(--sidebar-width) + 50px); top: 70px; }
            #render-mode-controls { left: calc(var(--sidebar-width) + 50px); top: 107px; width: 90px; }
            #gumball-target-controls { left: calc(var(--sidebar-width) + 50px); top: 135px; width: 90px; }
            #preset-float-panel { display: none; }
            #gallery-strip { left: calc(var(--sidebar-width) + 5px); height: 60px; right: 5px; }
            #top-right-panel { width: 160px; padding: 6px; font-size: 0.75rem; }
            #hud { padding: 3px 6px; gap: 3px; top: 8px; }
            .hud-btn { width: 18px !important; height: 18px !important; }
            .hud-btn svg { width: 12px !important; height: 12px !important; }
            .gallery-item { width: 45px; height: 45px; }
            #batch-color-btn, #batch-export-btn { width: 40px !important; }
            #batch-color-btn span, #batch-export-btn span { display: none !important; }
            .export-popup { padding: 12px !important; }
            .export-popup-preview { height: 100px; }
            .ams-popup { padding: 12px !important; }
            .ams-slot { width: 45px; height: 55px; }
            .ams-slot-color { width: 28px; height: 28px; }
            #view-cube-container { width: 70px !important; height: 70px !important; }
            .cube-face span { font-size: 0.45rem; }
            .hist-btn { width: 28px; height: 28px; font-size: 0.85rem; }
            .nav-row { padding: 6px 8px !important; }
        }
        
        /* È´ò„Åï„ÅåÂ∞è„Åï„ÅÑÂ†¥Âêà„ÅÆÂØæÂøú */
        @media screen and (max-height: 800px) {
            #top-right-panel { max-height: 200px; overflow-y: auto; }
            #gallery-strip { height: 70px !important; }
            .gallery-item { width: 55px !important; height: 55px !important; }
            .export-popup { max-height: 85vh; overflow-y: auto; }
            .export-popup-preview { height: 130px; }
            .ams-popup { max-height: 85vh; overflow-y: auto; }
            .csk-dialog { height: 85vh; }
            #view-cube-container { width: 90px !important; height: 90px !important; }
        }
        
        @media screen and (max-height: 700px) {
            #top-right-panel { max-height: 160px; }
            #gallery-strip { height: 60px !important; }
            .gallery-item { width: 45px !important; height: 45px !important; }
            .export-popup-preview { height: 100px; }
            .csk-dialog { height: 90vh; }
            #view-cube-container { width: 70px !important; height: 70px !important; }
            .cube-face span { font-size: 0.45rem; }
            #hud { top: 5px !important; }
            /* Â±•Ê≠¥„Éú„Çø„É≥„Å®Ë°®Á§∫ÂàáÊõø„ÇíHUD„ÅÆ‰∏ã„Å´ */
            #history-controls { top: 70px !important; }
            #render-mode-controls { top: 110px !important; }
            #gumball-target-controls { top: 140px !important; }
            #preset-float-panel { top: 172px !important; }
        }
        
        @media screen and (max-height: 600px) {
            #top-right-panel { max-height: 120px; }
            #gallery-strip { height: 50px !important; }
            .gallery-item { width: 40px !important; height: 40px !important; }
            #batch-color-btn, #batch-export-btn { width: 35px !important; }
            .export-popup-preview { height: 80px; }
            #view-cube-container { width: 60px !important; height: 60px !important; }
        }
        
        /* UIÈñâ„Åò„ÅüÊôÇ„ÅÆË™øÊï¥ */
        body.ui-closed #canvas-container { left: 0 !important; width: 100% !important; }
        body.ui-closed #history-controls { left: 50px !important; top: 85px !important; }
        body.ui-closed #render-mode-controls { left: 50px !important; top: 130px !important; }
        body.ui-closed #gumball-target-controls { left: 50px !important; top: 162px !important; }
        body.ui-closed #preset-float-panel { left: 50px !important; top: 195px !important; }
        body.ui-closed #gallery-strip { left: 15px !important; }
        body.ui-closed #hud { max-width: calc(100% - 120px); }
    </style>
    
    <script src="https://unpkg.com/lz-string@1.5.0/libs/lz-string.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "three-bvh-csg": "https://unpkg.com/three-bvh-csg@0.0.16/build/index.module.js",
                "three-mesh-bvh": "https://unpkg.com/three-mesh-bvh@0.7.3/build/index.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="toast-container"></div>
    
    <!-- Export Confirmation Popup -->
    <div id="export-popup-overlay" class="export-popup-overlay" style="display:none;">
        <div class="export-popup" id="export-popup">
            <div class="export-popup-header">
                <h3 class="export-popup-title" data-i18n="popup_export_confirm">„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÁ¢∫Ë™ç</h3>
                <span class="export-popup-format" id="export-popup-format">STL</span>
            </div>
            <div class="export-popup-preview" id="export-popup-preview" style="position:relative;">
                <!-- „ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØ„Åå„Åì„Åì„Å´ËøΩÂä†„Åï„Çå„Çã -->
            </div>
            
            <!-- Ë≠¶Âëä„É°„ÉÉ„Çª„Éº„Ç∏„Ç®„É™„Ç¢ -->
            <div id="export-single-warning" style="display:none; margin-bottom:10px; background:rgba(255,82,82,0.1); border:1px solid #ff5252; border-radius:4px; padding:8px; font-size:0.75rem;"></div>
            
            <!-- AMSËâ≤ÈÅ∏Êäû„Éë„É¨„ÉÉ„Éà -->
            <div id="export-ams-colors" style="margin-bottom:15px; padding:10px; background:rgba(30,30,50,0.5); border-radius:8px; border:1px solid #444;">
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px;">
                    <div>
                        <label style="color:#00e5ff; font-size:0.75rem; font-weight:bold; display:block; margin-bottom:5px;" data-i18n="batch_color_body_filament">üé® Êú¨‰Ωì„Éï„Ç£„É©„É°„É≥„Éà</label>
                        <div id="export-body-palette" class="ams-select-palette" style="max-height:60px; overflow-y:auto; gap:4px;"></div>
                    </div>
                    <div>
                        <label style="color:#ff9800; font-size:0.75rem; font-weight:bold; display:block; margin-bottom:5px;" data-i18n="batch_color_text_filament">üìù ÊñáÂ≠ó„Éï„Ç£„É©„É°„É≥„Éà</label>
                        <div id="export-text-palette" class="ams-select-palette" style="max-height:60px; overflow-y:auto; gap:4px;"></div>
                    </div>
                </div>
            </div>
            
            <!-- „Éï„Ç©„Éº„Éû„ÉÉ„ÉàÈÅ∏ÊäûUIÔºàÂçò‰Ωì/„Éê„ÉÉ„ÉÅ/„Çπ„Éó„É´„Éº/„Éà„É¨„É©„É≥„ÇπÁî®Ôºâ -->
            <div id="export-format-selector" style="margin-bottom:15px; display:none;">
                <label style="color:#888; font-size:0.75rem; display:block; margin-bottom:8px;" data-i18n="batch_export_format_select">Âá∫ÂäõÂΩ¢Âºè„ÇíÈÅ∏Êäû</label>
                <div style="display:flex; gap:10px;">
                    <label class="export-format-option" style="flex:1; display:flex; align-items:center; justify-content:center; gap:8px; background:rgba(76,175,80,0.1); padding:12px; border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s;">
                        <input type="radio" name="export-format-select" value="3mf" checked style="accent-color:#4caf50;">
                        <span style="color:#4caf50; font-weight:bold;">3MF</span>
                    </label>
                    <label class="export-format-option" style="flex:1; display:flex; align-items:center; justify-content:center; gap:8px; background:rgba(79,195,247,0.1); padding:12px; border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s;">
                        <input type="radio" name="export-format-select" value="stl" style="accent-color:#4fc3f7;">
                        <span style="color:#4fc3f7; font-weight:bold;">STL</span>
                    </label>
                    <label class="export-format-option" style="flex:1; display:flex; align-items:center; justify-content:center; gap:8px; background:rgba(255,152,0,0.1); padding:12px; border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s;">
                        <input type="radio" name="export-format-select" value="obj" style="accent-color:#ff9800;">
                        <span style="color:#ff9800; font-weight:bold;">OBJ</span>
                    </label>
                </div>
            </div>
            
            <div class="export-popup-info" id="export-popup-info"></div>
            <div class="export-popup-buttons">
                <span class="wiki-hint" data-help-url-ja="https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=1.%20%E9%80%9A%E5%B8%B8%E3%82%A8%E3%82%AF%E3%82%B9%E3%83%9D%E3%83%BC%E3%83%88%20(Standard%20Export)" data-help-url-en="https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%C2%B6-,1.%20Standard%20Export,-Preview%3A%203D"><span class="kbd">F1</span> <span data-i18n="wiki_hint">Wiki„ÅßË©≥„Åó„ÅèË¶ã„Çã</span></span>
                <span style="flex:1;"></span>
                <button class="export-popup-btn cancel" id="export-popup-cancel" data-i18n="popup_cancel">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="export-popup-btn confirm" id="export-popup-confirm" data-i18n="popup_export">„Ç®„ÇØ„Çπ„Éù„Éº„Éà</button>
            </div>
        </div>
    </div>
    
    <!-- Custom Sprue Kit Dialog -->
    <div id="csk-overlay" class="export-popup-overlay" style="display:none;">
        <div class="csk-dialog" id="csk-dialog">
            <div class="export-popup-header" style="border-color:#00bcd4;">
                <h3 class="export-popup-title" style="color:#ff9800;" data-i18n="csk_title">üé® „Ç´„Çπ„Çø„É†„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„Éà</h3>
                <span class="export-popup-format" style="background:#00bcd4;" id="csk-slot-count">0 / 0</span>
            </div>
            <div class="csk-body">
                <!-- Left: Gallery -->
                <div class="csk-left">
                    <div class="csk-left-title" data-i18n="csk_gallery">üì¶ „ÇÆ„É£„É©„É™„Éº</div>
                    <div class="csk-gallery" id="csk-gallery"></div>
                </div>
                <!-- Right: Grid + Tools -->
                <div class="csk-right">
                    <div class="csk-toolbar" id="csk-toolbar">
                        <label data-i18n="csk_printer">Ê©üÁ®Æ</label>
                        <select id="csk-printer-model" style="font-size:0.7rem;">
                            <option value="x1p1a1">X1/P1/A1</option>
                            <option value="a1mini">A1 mini</option>
                            <option value="h2d">H2D</option>
                            <option value="h2s">H2S</option>
                            <option value="h2c">H2C</option>
                        </select>
                        <select id="csk-printer-size" style="font-size:0.7rem;"></select>
                        <span id="csk-grid-info" style="color:#4fc3f7; font-size:0.65rem; white-space:nowrap;"></span>
                        <div class="csk-toolbar-sep"></div>
                        <button class="csk-toolbar-btn" id="csk-batch-orient" title="Set orientation for multiple tiles" style="border-color:#ff9800; color:#ff9800;" data-i18n="csk_batch_orient">üé≤ ‰∏ÄÊã¨ÈÖçÁΩÆ</button>
                        <div class="csk-toolbar-sep"></div>
                        <button class="csk-toolbar-btn" id="csk-clear-all" title="Delete all" style="border-color:#ff5252; color:#ff5252;">üóë</button>
                    </div>
                    <div class="csk-grid-wrap">
                        <div class="csk-grid" id="csk-grid"></div>
                    </div>
                    <!-- Properties panel for selected slot -->
                    <div class="csk-props" id="csk-props">
                        <label data-i18n="csk_orientation">üéØ ÈÖçÁΩÆÊñπÂêë</label>
                        <div id="csk-prop-orientation" style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                            <canvas id="csk-orientation-cube" width="70" height="70" style="border:1px solid #444; border-radius:4px; cursor:grab; background:#1a1a2e;"></canvas>
                            <div style="font-size:0.6rem; color:#888; line-height:1.3;">
                                <span data-i18n="csk_drag_rotate">„Éâ„É©„ÉÉ„Ç∞„ÅßÂõûËª¢</span><br>
                                <span id="csk-orientation-label" style="color:#00e5ff;" data-i18n="csk_bottom_down">‰∏ãÈù¢„Åå‰∏ã</span>
                            </div>
                        </div>
                        <div class="csk-toolbar-sep"></div>
                        <label data-i18n="csk_body_color">üé® Êú¨‰ΩìËâ≤</label>
                        <div id="csk-prop-body-palette" style="display:flex; gap:4px; flex-wrap:wrap;"></div>
                        <div class="csk-toolbar-sep"></div>
                        <label data-i18n="csk_text_color">üìù ÊñáÂ≠óËâ≤</label>
                        <div id="csk-prop-text-palette" style="display:flex; gap:4px; flex-wrap:wrap;"></div>
                    </div>
                    <!-- ‰∏ÄÊã¨ÈÖçÁΩÆ„Éë„Éç„É´ -->
                    <div class="csk-batch-panel" id="csk-batch-panel">
                        <div class="csk-batch-panel-header">
                            <span class="csk-batch-panel-title" data-i18n="csk_batch_orient_title">üé≤ ‰∏ÄÊã¨ÈÖçÁΩÆÊñπÂêëË®≠ÂÆö</span>
                            <span class="csk-batch-count" id="csk-batch-count" data-i18n="csk_selected_count">0ÂÄãÈÅ∏Êäû‰∏≠</span>
                            <span style="flex:1;"></span>
                            <button class="csk-toolbar-btn" id="csk-batch-select-all" style="font-size:0.6rem; padding:2px 6px;" data-i18n="csk_select_all">ÂÖ®ÈÅ∏Êäû</button>
                            <button class="csk-toolbar-btn" id="csk-batch-deselect-all" style="font-size:0.6rem; padding:2px 6px;" data-i18n="csk_deselect">Ëß£Èô§</button>
                        </div>
                        <div style="display:flex; align-items:center; gap:12px;">
                            <canvas id="csk-batch-cube" width="80" height="80" style="border:1px solid #ff9800; border-radius:4px; cursor:grab; background:#1a1a2e;"></canvas>
                            <div style="flex:1;">
                                <div style="font-size:0.6rem; color:#888; margin-bottom:6px;" data-i18n="csk_batch_hint">
                                    „Çø„Ç§„É´„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÅ∏Êäû<br>
                                    „Çµ„Ç§„Ç≥„É≠„ÇíÂãï„Åã„Åô„Å®Âç≥ÊôÇÂèçÊò†
                                </div>
                                <div style="font-size:0.65rem; color:#ff9800; margin-bottom:8px;" id="csk-batch-orient-label" data-i18n="csk_bottom_down">‰∏ãÈù¢„Åå‰∏ã</div>
                                <button class="csk-toolbar-btn" id="csk-batch-cancel" style="font-size:0.7rem; padding:4px 12px;" data-i18n="csk_done">ÁµÇ‰∫Ü</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="export-popup-buttons" style="border-color:#333;">
                <span class="wiki-hint" data-help-url-ja="https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%F0%9F%85%B1%EF%B8%8F%20CSK%20%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E3%82%B9%E3%83%97%E3%83%AB%E3%82%AD%E3%83%83%E3%83%88%E7%94%9F%E6%88%90%20(Custom%20Sprue%20Kit)" data-help-url-en="https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%F0%9F%85%B1%EF%B8%8F%20CSK%20(Custom%20Sprue%20Kit)"><span class="kbd">F1</span> <span data-i18n="wiki_hint">Wiki„ÅßË©≥„Åó„ÅèË¶ã„Çã</span></span>
                <div style="display:flex; align-items:center; gap:8px; margin-left:10px;">
                    <label style="color:#aaa; font-size:0.7rem; white-space:nowrap;" data-i18n="csk_runner_color">üîó „É©„É≥„Éä„ÉºËâ≤:</label>
                    <div id="csk-runner-palette" style="display:flex; gap:4px;"></div>
                </div>
                <span style="flex:1;"></span>
                <button class="export-popup-btn cancel" id="csk-cancel" data-i18n="popup_cancel">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="export-popup-btn confirm" id="csk-generate" style="background:#ff9800; border-color:#ff9800;" data-i18n="csk_generate">„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„ÉàÁîüÊàê</button>
            </div>
        </div>
    </div>
    
    <div id="loading">
        <div>Initializing V67...</div>
        <div id="error-log"></div>
        <div id="batch-progress"></div>
        <button id="force-start-btn">FORCE START</button>
    </div>

    <!-- V67: HUD („Éï„É≠„Éº„ÉÜ„Ç£„É≥„Ç∞„ÉÑ„Éº„É´„Éê„Éº) - ‰∏äÈÉ®ÈÖçÁΩÆ -->
    <div id="hud" style="position:absolute; top:15px; left:50%; transform:translateX(-50%); display:flex; gap:8px; background:rgba(30,30,30,0.92); padding:8px 16px; border-radius:8px; border:1px solid #444; backdrop-filter:blur(8px); z-index:100; box-shadow:0 4px 20px rgba(0,0,0,0.6); align-items:center;">
        <button class="hud-btn" id="hud-view-mode" title="View Mode (Normal/Wire)" style="background:none; border:none; width:28px; height:28px; cursor:pointer; transition: transform 0.2s, filter 0.2s; padding:2px;">
            <svg viewBox="0 0 512 512" style="width:100%; height:100%;"><path fill="#aaa" d="M511.58,252.219c-0.403-1.756-0.807-2.737-1.17-3.647c-0.727-1.7-1.424-2.982-2.239-4.437c-3.006-5.228-7.831-12.309-14.444-21.216c-9.872-13.273-23.47-30.09-38.871-46.686c-15.417-16.596-32.518-32.939-49.93-45.279c-24.624-17.426-48.569-30.976-73.091-40.184C307.33,81.555,282.246,76.77,256,76.785c-26.246-0.015-51.33,4.77-75.836,13.986c-24.53,9.207-48.466,22.757-73.09,40.176c-25.899,18.408-51.401,45.729-71.098,69.46c-9.825,11.866-18.106,22.798-24.078,31.325c-2.999,4.272-5.403,7.926-7.254,11.011c-0.933,1.567-1.716,2.966-2.468,4.533c-0.38,0.799-0.744,1.622-1.147,2.776c-0.198,0.586-0.412,1.266-0.609,2.168c-0.19,0.91-0.412,2.033-0.42,3.781c0.008,1.741,0.229,2.872,0.42,3.781c0.395,1.756,0.807,2.729,1.17,3.646c0.728,1.701,1.424,2.983,2.239,4.43c3.006,5.229,7.831,12.316,14.444,21.223c9.864,13.274,23.469,30.098,38.871,46.694c15.417,16.596,32.519,32.931,49.93,45.271c24.624,17.426,48.561,30.969,73.09,40.184c24.506,9.208,49.59,14.002,75.836,13.986c26.246,0.016,51.33-4.777,75.836-13.986c24.522-9.215,48.466-22.757,73.091-40.176c25.898-18.408,51.401-45.729,71.098-69.46c9.824-11.866,18.106-22.798,24.078-31.325c2.998-4.279,5.402-7.926,7.254-11.019c0.934-1.566,1.717-2.967,2.468-4.525c0.372-0.799,0.744-1.622,1.147-2.785c0.198-0.586,0.412-1.258,0.609-2.159c0.19-0.91,0.412-2.04,0.42-3.781C511.992,254.252,511.771,253.129,511.58,252.219z M440.61,303.209c-16.706,19.064-36.577,38.824-54.399,51.394c-23.011,16.287-44.558,28.334-65.758,36.292c-21.223,7.95-42.106,11.906-64.453,11.921c-22.346-0.015-43.23-3.97-64.452-11.921c-21.2-7.958-42.748-20.005-65.758-36.292c-21.738-15.315-46.354-41.244-64.856-63.67c-9.287-11.209-17.134-21.58-22.505-29.252c-1.511-2.159-2.768-4.026-3.852-5.68c6.36-9.769,20.171-28.263,36.814-47.2c16.706-19.072,36.577-38.824,54.399-51.409c23.011-16.28,44.559-28.327,65.758-36.284c21.223-7.95,42.106-11.905,64.452-11.921c22.347,0.016,43.23,3.97,64.453,11.921c21.2,7.958,42.747,20.005,65.758,36.292c21.738,15.322,46.355,41.252,64.856,63.67c9.287,11.217,17.134,21.588,22.506,29.252c1.51,2.16,2.768,4.027,3.852,5.68C471.064,265.77,457.253,284.264,440.61,303.209z"/><path fill="#aaa" d="M256,141.697c-63.14,0-114.303,51.187-114.303,114.303c0,63.132,51.164,114.303,114.303,114.303S370.303,319.133,370.303,256C370.303,192.884,319.14,141.697,256,141.697z M256,309.071c-29.308,0-53.062-23.763-53.062-53.07c0-29.308,23.754-53.054,53.062-53.054c5.766,0,11.296,0.941,16.493,2.634l-7.435,22.758c-1.907,5.806-0.609,12.166,3.409,16.77c4.019,4.58,10.157,6.708,16.152,5.609l23.525-4.344c0.578,3.117,0.918,6.337,0.918,9.627C309.062,285.308,285.308,309.071,256,309.071z"/></svg>
        </button>
        <button class="hud-btn" id="hud-gumball-toggle" title="Gumball (Move/Rotate)" data-hint="hint_gumball" style="background:none; border:none; width:28px; height:28px; cursor:pointer; transition: transform 0.2s, filter 0.2s; padding:2px;">
            <svg viewBox="0 0 512 512" style="width:100%; height:100%;"><path fill="#666" d="M498.849,191.102c-5.468-11.229-13.762-22.675-26.922-28.034c-6.497-2.524-14.035-2.944-20.679-0.61c-4.347,1.431-8.129,4.165-11.073,7.51c-0.155-0.246-0.246-0.528-0.41-0.784c-4.083-6.89-9.469-12.914-15.566-17.799c-12.166-9.824-26.092-16.806-40.684-20.988c-7.272-2.206-14.664-3.801-22.101-5.186c-7.427-1.504-15.146-2.115-22.337-2.962c-14.764-1.558-29.492-2.679-44.256-3.5c-59.084-3.125-117.921-1.23-176.003-7.254c-14.527-1.44-29-3.245-43.4-5.505l-10.882-1.75c-4.064-0.583-8.011-0.874-12.094-0.848c-8.102,0.055-16.395,1.431-24.178,4.703c-7.755,3.254-15.028,8.466-20.25,15.584c-5.268,7.064-8.248,16.068-8.002,25.027c0.173,8.967,3.418,17.525,8.193,24.507c4.775,7.044,10.973,12.668,17.598,17.233c13.352,9.096,28.38,14.072,43.29,17.372c14.983,3.253,30.139,4.529,45.176,4.72c11.274,0.137,22.484-0.319,33.638-1.22c-0.355,0.282-0.729,0.528-1.075,0.82c-6.234,5.303-11.392,12.358-14.1,20.423c-2.706,8.075-2.98,16.87-1.321,25.236c1.623,8.385,5.386,16.396,10.809,22.994c5.104,6.27,11.629,11.155,18.647,14.7c-0.583,0.966-1.084,1.968-1.495,2.989c-1.276,3.427-1.613,6.963-1.358,10.326c0.556,6.743,3.19,12.722,6.261,18.162c6.362,10.854,15.767,19.294,26.256,25.264c4.138,2.36,8.466,4.247,12.878,5.878c-1.231,1.968-2.214,4.137-2.616,6.361c-1.084,5.222-0.246,10.544,1.65,15.119c3.928,9.26,11.428,15.767,19.33,20.223c16.158,8.831,34.194,10.134,51.236,7.738c15.84-2.616,31.515-8.849,43.454-20.669c13.106,0.3,26.339-0.292,39.517-1.75c13.27-1.595,26.54-3.983,39.517-8.02c12.878-4.129,25.746-9.56,36.764-18.3c2.589-2.069,5.077-4.32,7.391-6.744c3.163,4.274,7.264,8.12,12.568,10.518c6.28,2.998,14.263,3.262,20.98,0.683c6.753-2.579,12.094-7.263,16.322-12.294c4.247-5.085,7.373-10.754,10.008-16.477c10.143-23.176,12.157-47.847,12.467-71.633C511.7,238.866,509.667,214.196,498.849,191.102z"/></svg>
        </button>
        <button class="hud-btn" id="hud-dimension" title="Dimension Lines ON/OFF" data-hint="hint_dimension_lines" style="background:none; border:none; width:28px; height:28px; cursor:pointer; transition: transform 0.2s, filter 0.2s; padding:2px;">
            <svg viewBox="0 0 512 512" style="width:100%; height:100%;"><path fill="#aaa" d="M465.252,494.656c-0.084-2.217-1.292-5.443-2.684-7.17L72.629,3.846C71.236,2.119,68.311,0.388,66.127,0L49.396,5.903c-1.456,1.673-2.648,4.856-2.648,7.075v481.87c0,2.218,0.742,5.689,1.648,7.714l7.789,7.79c2.024,0.907,5.495,1.648,7.714,1.648h386.953c2.218,0,5.488-1.085,7.266-2.411L465.252,494.656z M105.926,441.758c0,2.218-0.242,4.538-0.538,5.155c-0.296,0.617-3.667,1.122-5.885,1.122H66.102c-2.218,0-4.571-0.228-5.228-0.505c-0.657-0.278-1.195-3.554-1.195-5.772v-1.645c0-2.218,0.242-4.538,0.538-5.155c0.296-0.617,3.666-1.122,5.885-1.122h33.401c2.218,0,4.57,0.227,5.228,0.505c0.657,0.278,1.195,3.554,1.195,5.772V441.758z M105.926,371.942c0,2.218-0.242,4.538-0.538,5.155c-0.296,0.617-3.667,1.122-5.885,1.122H66.102c-2.218,0-4.571-0.228-5.228-0.505c-0.657-0.278-1.195-3.554-1.195-5.772v-1.645c0-2.218,0.242-4.538,0.538-5.155c0.296-0.617,3.666-1.122,5.885-1.122h33.401c2.218,0,4.57,0.228,5.228,0.505c0.657,0.278,1.195,3.554,1.195,5.772V371.942z M105.926,302.125c0,2.218-0.242,4.538-0.538,5.155c-0.296,0.617-3.667,1.122-5.885,1.122H66.102c-2.218,0-4.571-0.227-5.228-0.505c-0.657-0.277-1.195-3.555-1.195-5.773v-1.644c0-2.218,0.242-4.538,0.538-5.155c0.296-0.617,3.666-1.122,5.885-1.122h33.401c2.218,0,4.57,0.228,5.228,0.505c0.657,0.278,1.195,3.554,1.195,5.772V302.125z M105.926,232.31c0,2.218-0.242,4.538-0.538,5.155c-0.296,0.617-3.667,1.122-5.885,1.122H66.102c-2.218,0-4.571-0.227-5.228-0.505c-0.657-0.278-1.195-3.554-1.195-5.772v-1.645c0-2.218,0.242-4.538,0.538-5.155c0.296-0.617,3.666-1.122,5.885-1.122h33.401c2.218,0,4.57,0.228,5.228,0.505c0.657,0.278,1.195,3.554,1.195,5.772V232.31z M105.926,162.493c0,2.218-0.242,4.538-0.538,5.155c-0.296,0.617-3.667,1.122-5.885,1.122H66.102c-2.218,0-4.571-0.227-5.228-0.505c-0.657-0.278-1.195-3.554-1.195-5.772v-1.644c0-2.218,0.242-4.538,0.538-5.155c0.296-0.617,3.666-1.122,5.885-1.122h33.401c2.218,0,4.57,0.227,5.228,0.504c0.657,0.278,1.195,3.555,1.195,5.773V162.493z M268.797,408.295c-1.778,1.326-5.048,2.41-7.266,2.41h-85.296c-2.218,0-5.689-0.742-7.714-1.648l-4.096-4.096c-0.906-2.025-1.648-5.496-1.648-7.714V289.516c0-2.218,1.192-5.401,2.649-7.074l10.143-3.58c2.184,0.388,5.11,2.118,6.502,3.844l88.299,109.518c1.392,1.727,2.6,4.953,2.684,7.17L268.797,408.295z"/></svg>
        </button>
        <button class="hud-btn" id="hud-snapshot" title="Take Snapshot" data-hint="hint_snapshot" style="background:none; border:none; width:28px; height:28px; cursor:pointer; transition: transform 0.2s, filter 0.2s; padding:2px;">
            <svg viewBox="0 0 512 512" style="width:100%; height:100%;"><path fill="#aaa" d="M256,233.109c-28.5,0-51.594,23.297-51.594,52.047c0,28.766,23.094,52.047,51.594,52.047s51.594-23.281,51.594-52.047C307.594,256.406,284.5,233.109,256,233.109z"/><path fill="#aaa" d="M497.375,140.297c-8.984-9.094-21.641-14.813-35.453-14.813h-54.203c-4.359,0.016-8.438-2.594-10.313-6.813l-16.234-36.344c-8.031-18.016-25.891-29.734-45.703-29.734H176.531c-19.813,0-37.672,11.719-45.719,29.719v0.016l-16.219,36.344c-1.875,4.219-5.953,6.828-10.313,6.813H50.078c-13.813,0-26.484,5.719-35.484,14.813C5.594,149.359,0,162.031,0,175.828v233.25c0,13.797,5.594,26.469,14.594,35.531c9,9.094,21.672,14.813,35.484,14.797h225.781h186.063c13.813,0.016,26.469-5.703,35.453-14.797c9.031-9.063,14.625-21.734,14.625-35.531v-233.25C512,162.031,506.406,149.344,497.375,140.297z M473.281,409.078c0,3.313-1.281,6.125-3.375,8.281c-2.156,2.109-4.844,3.328-7.984,3.344H275.859H50.078c-3.156-0.016-5.859-1.234-7.984-3.344c-2.094-2.156-3.375-4.969-3.375-8.281v-233.25c0-3.313,1.281-6.125,3.375-8.281c2.125-2.125,4.828-3.328,7.984-3.344h54.203c19.781,0,37.656-11.734,45.688-29.766l16.188-36.328c1.906-4.203,5.969-6.813,10.375-6.813h158.938c4.406,0,8.469,2.609,10.359,6.797l16.219,36.359c8.016,18.016,25.891,29.75,45.672,29.75h54.203c3.141,0.016,5.828,1.219,7.984,3.344c2.094,2.156,3.375,4.984,3.375,8.281V409.078z"/><path fill="#aaa" d="M256,170.938c-31.313-0.016-59.75,12.844-80.203,33.5c-20.484,20.656-33.172,49.266-33.156,80.719c-0.016,31.453,12.672,60.094,33.156,80.719c20.453,20.672,48.891,33.516,80.203,33.516c31.297,0,59.75-12.844,80.203-33.516c20.484-20.625,33.172-49.266,33.156-80.719c0.016-31.453-12.672-60.063-33.156-80.719C315.75,183.781,287.297,170.922,256,170.938z M315.031,344.891c-15.172,15.297-35.953,24.688-59.031,24.688c-23.094,0-43.859-9.391-59.047-24.688c-15.141-15.297-24.5-36.328-24.516-59.734c0.016-23.391,9.375-44.422,24.516-59.734c15.188-15.297,35.953-24.672,59.047-24.688c23.078,0.016,43.859,9.391,59.031,24.688c15.156,15.313,24.516,36.344,24.531,59.734C339.547,308.563,330.188,329.594,315.031,344.891z"/><rect x="392.188" y="197.656" fill="#aaa" width="34.406" height="34.406"/></svg>
        </button>
        <div style="width:1px; height:20px; background:#555; margin:0 4px;"></div>
        <button class="hud-btn" id="hud-toggle-text" title="Toggle Text" data-hint="hint_toggle_text" style="background:none; border:none; width:28px; height:28px; cursor:pointer; transition: transform 0.2s, filter 0.2s; padding:2px;">
            <svg viewBox="0 0 512 512" style="width:100%; height:100%;"><text x="256" y="380" text-anchor="middle" fill="#aaa" font-size="400" font-weight="bold" font-family="Arial, sans-serif">T</text></svg>
        </button>
        <button class="hud-btn" id="hud-toggle-svg" title="Toggle SVG" data-hint="hint_toggle_svg" style="background:none; border:none; width:28px; height:28px; cursor:pointer; transition: transform 0.2s, filter 0.2s; padding:2px;">
            <svg viewBox="0 0 512 512" style="width:100%; height:100%;"><path fill="#aaa" d="M64,96 L256,416 L448,96 Z M160,160 L256,320 L352,160 Z" fill-rule="evenodd"/></svg>
        </button>
        <div style="width:1px; height:20px; background:#555; margin:0 4px;"></div>
        <button class="hud-btn" id="hud-gallery" title="Open Gallery" data-hint="hint_gallery_open" style="background:none; border:none; width:28px; height:28px; cursor:pointer; transition: transform 0.2s, filter 0.2s; padding:2px;">
            <svg viewBox="0 0 512 512" style="width:100%; height:100%;"><path fill="#aaa" d="M99.281,399.469h320.094c6.172,0,11.844-3.422,14.719-8.875c2.844-5.469,2.438-12.078-1.063-17.141l-69.156-100.094c-6.313-9.125-16.781-14.516-27.906-14.297s-21.406,5.969-27.375,15.359l-19.719,30.984l-54.828-79.359c-6.313-9.172-16.797-14.531-27.922-14.328s-21.406,5.969-27.375,15.359L85.281,373.984c-3.25,5.109-3.469,11.578-0.531,16.875C87.656,396.172,93.219,399.469,99.281,399.469z"/><path fill="#aaa" d="M322.672,223.906c23.688,0,42.922-19.219,42.922-42.922c0-23.688-19.234-42.906-42.922-42.906c-23.703,0-42.922,19.219-42.922,42.906C279.75,204.688,298.969,223.906,322.672,223.906z"/><path fill="#aaa" d="M0,19.703v472.594h512v-25.313V19.703H0z M461.375,441.672H50.625V70.328h410.75V441.672z"/></svg>
        </button>
        <button class="hud-btn" id="hud-gallery-save" title="Save to Gallery" data-hint="hint_gallery_save" style="background:none; border:none; width:28px; height:28px; cursor:pointer; transition: transform 0.2s, filter 0.2s; padding:2px;">
            <svg viewBox="0 0 512 512" style="width:100%; height:100%;"><path fill="#aaa" d="M16,0v512h480V0H16z M88,476H56v-56h32V476z M88,380H56v-56h32V380z M88,284H56v-56h32V284z M88,188H56v-56h32V188z M88,92H56V36h32V92z M392,475.313H120V276h272V475.313z M392,236H120V35.313h272V236z M456,476h-32v-56h32V476z M456,380h-32v-56h32V380z M456,284h-32v-56h32V284z M456,188h-32v-56h32V188z M456,92h-32V36h32V92z"/></svg>
        </button>
        <div style="width:1px; height:20px; background:#555; margin:0 4px;"></div>
        <button class="hud-btn" id="hud-ams" title="AMS Color Settings" style="background:none; border:none; width:28px; height:28px; cursor:pointer; transition: transform 0.2s, filter 0.2s; padding:2px;">
            <svg viewBox="0 0 117 133" style="width:100%; height:100%;"><path fill="#00e5ff" d="M49.6,15.6l36.07-.03c-3.48,12.09-5.69,30.38-5.69,50.85s2.25,39.07,5.78,51.16l-36.19-.23c.07-.21.13-.43.19-.65V16.14c-.05-.18-.1-.36-.16-.54Z"/><path fill="#808080" d="M100.54.5c8.65,0,15.65,29.51,15.65,65.92s-7,65.91-15.65,65.91c-.83,0-1.65-.28-2.45-.81,7.47-4.98,13.19-32.23,13.19-65.1S105.56,6.29,98.09,1.31c.8-.53,1.62-.81,2.45-.81Z"/><path fill="#808080" d="M98.09,1.31c7.47,4.98,13.19,32.23,13.19,65.11s-5.72,60.12-13.19,65.1c-7.48-4.95-13.2-32.21-13.2-65.1S90.61,6.26,98.09,1.31ZM105.48,66.42c0-7.95-2.21-14.4-4.94-14.4s-4.93,6.45-4.93,14.4,2.21,14.39,4.93,14.39,4.94-6.44,4.94-14.39Z"/><path fill="#fff" d="M100.54,52.02c2.73,0,4.94,6.45,4.94,14.4s-2.21,14.39-4.94,14.39-4.93-6.44-4.93-14.39,2.21-14.4,4.93-14.4Z"/><path fill="#808080" d="M85.67,15.57c2.7-9.41,6.18-15.07,9.96-15.07.84,0,1.66.28,2.46.81-7.48,4.95-13.2,32.22-13.2,65.11s5.72,60.15,13.2,65.1c-.8.53-1.62.81-2.46.81-3.74,0-7.18-5.53-9.87-14.75-3.53-12.09-5.78-30.52-5.78-51.16s2.21-38.76,5.69-50.85Z"/><path fill="#808080" d="M49.6,15.6h-4.03c-2.21-7.73-4.95-12.93-7.95-14.56.66-.36,1.34-.54,2.02-.54,3.79,0,7.26,5.67,9.96,15.1Z"/><path fill="#808080" d="M45.55,117.33l4.02.02c-2.7,9.36-6.16,14.98-9.93,14.98-.68,0-1.36-.18-2.02-.54,2.99-1.62,5.71-6.78,7.93-14.46Z"/><path fill="#00e5ff" d="M45.73,16.14v100.56l-.18.63-15.88-.1c-3.47-12.09-5.68-30.36-5.68-50.81s2.21-38.72,5.68-50.81h15.9c.06.17.11.35.16.53Z"/><path fill="#00e5ff" d="M45.57,15.6h4.03c.06.18.11.36.16.54v100.56c-.06.22-.12.44-.19.65l-4.02-.02.18-.63V16.14c-.05-.18-.1-.36-.16-.54Z"/><path fill="#808080" d="M45.57,15.6h-15.9c2.21-7.73,4.95-12.94,7.95-14.56,3,1.63,5.74,6.83,7.95,14.56Z"/><path fill="#808080" d="M29.67,117.23l15.88.1c-2.22,7.68-4.94,12.84-7.93,14.46-3-1.62-5.74-6.83-7.95-14.56Z"/><path fill="#808080" d="M29.67,117.23c2.21,7.73,4.95,12.94,7.95,14.56-.66.36-1.33.54-2.01.54-8.64,0-15.65-29.51-15.65-65.91S26.97.5,35.61.5c.68,0,1.35.18,2.01.54-3,1.62-5.74,6.83-7.95,14.57-3.47,12.09-5.68,30.36-5.68,50.81s2.21,38.72,5.68,50.81Z"/></svg>
        </button>
        <div style="width:1px; height:20px; background:#555; margin:0 4px;"></div>
        <!-- „Ç®„ÇØ„Çπ„Éù„Éº„Éà„Éú„Çø„É≥Ôºà„Éâ„É≠„ÉÉ„Éó„ÉÄ„Ç¶„É≥‰ªò„ÅçÔºâ -->
        <div id="hud-export-wrapper" style="position:relative;">
            <button class="hud-btn" id="hud-export" title="Export" data-hint="hint_export" style="background:none; border:none; width:28px; height:28px; cursor:pointer; transition: transform 0.2s, filter 0.2s; padding:2px;">
                <svg viewBox="0 0 512 512" style="width:100%; height:100%;"><rect x="141.818" y="394.181" fill="#aaa" width="228.365" height="21.82"/><rect x="141.818" y="305.688" fill="#aaa" width="228.365" height="21.82"/><rect x="141.818" y="217.203" fill="#aaa" width="228.365" height="21.827"/><rect x="262.546" y="128.725" fill="#aaa" width="107.636" height="21.82"/><path fill="#aaa" d="M411.626,0H222.758c-13.559,0-26.564,5.39-36.152,14.969L68.794,132.788c-9.59,9.587-14.976,22.596-14.976,36.156v296.5c0,25.67,20.889,46.556,46.56,46.556h311.247c25.667,0,46.556-20.886,46.556-46.556V46.542C458.182,20.878,437.292,0,411.626,0z M206.252,32.349v104.652c0,11.313-4.405,15.722-15.718,15.722H85.877L206.252,32.349z M432.002,465.444c0,11.237-9.146,20.372-20.376,20.372H100.378c-11.237,0-20.38-9.135-20.38-20.372V175.998h124.554c13.77,0,24.978-11.207,24.978-24.985V26.184h182.096c11.23,0,20.376,9.127,20.376,20.358V465.444z"/></svg>
            </button>
        </div>
    </div>

    <!-- V67: „ÇÆ„É£„É©„É™„Éº„Çπ„Éà„É™„ÉÉ„Éó - ÁîªÈù¢‰∏ãÈÉ®„ÄÅÂ∑¶ÂÅ¥„Éë„Éç„É´„ÇíÈÅø„Åë„Å¶ÈÖçÁΩÆ -->
    <div id="gallery-strip" style="position:absolute; bottom:15px; right:15px; height:110px; background:rgba(25,25,25,0.98); border:1px solid #00e5ff; border-radius:8px; display:none; overflow:hidden; padding:0; z-index:150; backdrop-filter:blur(8px); box-shadow:0 4px 20px rgba(0,0,0,0.5);">
        <div id="gallery-content" style="display:flex; gap:12px; height:100%; padding:10px 130px 10px 15px; overflow-x:auto; align-items:center; pointer-events:auto;"></div>
        <!-- ‰∏ÄÊã¨Ëâ≤Ë®≠ÂÆö„Éú„Çø„É≥ -->
        <button id="batch-color-btn" style="position:absolute; right:60px; top:0; bottom:0; background:rgba(45,45,45,0.98); border:none; border-left:1px solid #555; cursor:pointer; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:4px; transition:all 0.15s;">
            <svg viewBox="0 0 512 512" style="width:28px; height:28px;"><path fill="#4caf50" d="M480,288c0,17.696-14.336,32-32,32h-64v-64h64C465.664,256,480,270.304,480,288z"/><path fill="#ff9800" d="M480,160c0,17.696-14.336,32-32,32h-64V128h64C465.664,128,480,142.304,480,160z"/><path fill="#00e5ff" d="M480,416c0,17.696-14.336,32-32,32h-64v-64h64C465.664,384,480,398.304,480,416z"/><path fill="#e91e63" d="M480,32c0,17.696-14.336,32-32,32h-64V0h64C465.664,0,480,14.304,480,32z"/><path fill="#aaa" d="M352,480c0,17.696-14.304,32-32,32H64c-35.296,0-64-28.704-64-64V64C0,28.704,28.704,0,64,0h256c17.696,0,32,14.304,32,32V480z M320,448V64c0-17.696-14.304-32-32-32H64C46.304,32,32,46.304,32,64v384c0,17.696,14.304,32,32,32h224C305.696,480,320,465.696,320,448z"/></svg>
            <span style="font-size:0.6rem; color:#888;" data-i18n="gallery_batch_color">Ëâ≤Ë®≠ÂÆö</span>
        </button>
        <!-- ‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Éú„Çø„É≥ÔºàÂõ∫ÂÆö‰ΩçÁΩÆ„ÉªÂ§ß„Åç„ÅèÔºâ -->
        <button id="batch-export-btn" style="position:absolute; right:0; top:0; bottom:0; background:rgba(45,45,45,0.98); border:none; border-left:1px solid #555; border-radius:0 8px 8px 0; cursor:pointer; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:4px; transition:all 0.15s;">
            <svg viewBox="0 0 512 512" style="width:28px; height:28px;"><rect x="141.818" y="394.181" fill="#aaa" width="228.365" height="21.82"/><rect x="141.818" y="305.688" fill="#aaa" width="228.365" height="21.82"/><rect x="141.818" y="217.203" fill="#aaa" width="228.365" height="21.827"/><rect x="262.546" y="128.725" fill="#aaa" width="107.636" height="21.82"/><path fill="#aaa" d="M411.626,0H222.758c-13.559,0-26.564,5.39-36.152,14.969L68.794,132.788c-9.59,9.587-14.976,22.596-14.976,36.156v296.5c0,25.67,20.889,46.556,46.56,46.556h311.247c25.667,0,46.556-20.886,46.556-46.556V46.542C458.182,20.878,437.292,0,411.626,0z M206.252,32.349v104.652c0,11.313-4.405,15.722-15.718,15.722H85.877L206.252,32.349z M432.002,465.444c0,11.237-9.146,20.372-20.376,20.372H100.378c-11.237,0-20.38-9.135-20.38-20.372V175.998h124.554c13.77,0,24.978-11.207,24.978-24.985V26.184h182.096c11.23,0,20.376,9.127,20.376,20.358V465.444z"/></svg>
            <span style="font-size:0.6rem; color:#888;" data-i18n="gallery_batch_export">‰∏ÄÊã¨Âá∫Âäõ</span>
        </button>
    </div>
    
    <!-- V67: ‰∏ÄÊã¨Ëâ≤Ë®≠ÂÆöÁîªÈù¢Ôºà‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Å®Âêå„ÅòÂΩ¢ÂºèÔºâ -->
    <div id="batch-color-overlay" class="export-popup-overlay" style="display:none;">
        <div class="export-popup" id="batch-color-popup" style="min-width:min(650px, 95vw); max-width:min(800px, 95vw);">
            <div class="export-popup-header">
                <h3 class="export-popup-title" data-i18n="batch_color_title">üé® ‰∏ÄÊã¨Ëâ≤Ë®≠ÂÆö</h3>
                <span id="batch-color-count" style="color:#888; font-size:0.85rem;"></span>
            </div>
            
            <!-- „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ: 3D„Éó„É¨„Éì„É•„Éº + „Çµ„É†„Éç„Ç§„É´‰∏ÄË¶ß -->
            <div style="display:grid; grid-template-columns:200px 1fr; gap:15px; margin-bottom:15px;">
                <!-- Â∑¶ÂÅ¥: ÈÅ∏Êäû‰∏≠„Ç¢„Ç§„ÉÜ„É†„ÅÆ3D„Éó„É¨„Éì„É•„Éº -->
                <div style="background:#0a0a15; border-radius:8px; padding:10px;">
                    <div id="batch-color-3d-preview" style="width:180px; height:180px; border-radius:6px; overflow:hidden; background:#111;"></div>
                    <div id="batch-color-selected-name" style="text-align:center; margin-top:8px; font-size:0.8rem; color:#fff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"></div>
                </div>
                
                <!-- Âè≥ÂÅ¥: „Çµ„É†„Éç„Ç§„É´‰∏ÄË¶ß + Ë≠¶Âëä -->
                <div>
                    <div style="margin-bottom:8px; display:flex; align-items:flex-start; gap:10px;">
                        <label style="color:#888; font-size:0.7rem; white-space:nowrap;" data-i18n="batch_color_click_select">‚ñº „ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÅ∏Êäû</label>
                        <div id="batch-color-warning" style="display:none; flex:1; background:rgba(255,82,82,0.1); border:1px solid #ff5252; border-radius:4px; padding:5px 8px; font-size:0.7rem; max-height:60px; overflow-y:auto;"></div>
                    </div>
                    <div id="batch-color-preview" style="background:#0a0a15; border-radius:8px; height:160px; display:flex; gap:8px; padding:8px; overflow-x:auto; align-items:center; flex-wrap:wrap;">
                        <!-- „Çµ„É†„Éç„Ç§„É´„Åå„Åì„Åì„Å´ÂãïÁöÑ„Å´ËøΩÂä†„Åï„Çå„Çã -->
                    </div>
                </div>
            </div>
            
            <!-- AMS„Éï„Ç£„É©„É°„É≥„ÉàÈÅ∏ÊäûÔºàÈÅ∏Êäû„Åó„Åü„Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÁî®Ôºâ -->
            <div id="batch-color-ams" style="margin-bottom:15px; padding:10px; background:rgba(30,30,50,0.5); border-radius:8px; border:1px solid #444;">
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px;">
                    <div>
                        <label style="color:#00e5ff; font-size:0.75rem; font-weight:bold; display:block; margin-bottom:5px;" data-i18n="batch_color_body_filament">üé® Êú¨‰Ωì„Éï„Ç£„É©„É°„É≥„Éà</label>
                        <div id="batch-color-body-palette" class="ams-select-palette" style="max-height:60px; overflow-y:auto; gap:4px;"></div>
                    </div>
                    <div>
                        <label style="color:#ff9800; font-size:0.75rem; font-weight:bold; display:block; margin-bottom:5px;" data-i18n="batch_color_text_filament">üìù ÊñáÂ≠ó„Éï„Ç£„É©„É°„É≥„Éà</label>
                        <div id="batch-color-text-palette" class="ams-select-palette" style="max-height:60px; overflow-y:auto; gap:4px;"></div>
                    </div>
                </div>
                <div id="batch-color-item-info" style="margin-top:8px; padding:6px; background:rgba(0,229,255,0.1); border-radius:4px; font-size:0.75rem; color:#00e5ff; text-align:center;"></div>
            </div>
            
            <!-- „Éú„Çø„É≥ -->
            <div class="export-popup-buttons">
                <span class="wiki-hint" data-help-url-ja="https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%F0%9F%93%82%20%E3%82%AE%E3%83%A3%E3%83%A9%E3%83%AA%E3%83%BC%E6%A9%9F%E8%83%BD%20(Gallery)%20(v67.0%20New)" data-help-url-en="https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%F0%9F%93%82%20Gallery%20Features%20(v67.0%20New)"><span class="kbd">F1</span> <span data-i18n="wiki_hint">Wiki„ÅßË©≥„Åó„ÅèË¶ã„Çã</span></span>
                <span style="flex:1;"></span>
                <button class="export-popup-btn cancel" id="batch-color-cancel-btn" data-i18n="popup_cancel">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="export-popup-btn confirm" id="batch-color-apply-btn" data-i18n="btn_apply">ÈÅ©Áî®</button>
            </div>
        </div>
    </div>

    <!-- V67: ‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÁ¢∫Ë™çÁîªÈù¢ÔºàÊó¢Â≠òUI„Å®ÂêåÁ≠â„ÅÆ„Éá„Ç∂„Ç§„É≥Ôºâ -->
    <div id="batch-export-overlay" class="export-popup-overlay" style="display:none;">
        <div class="export-popup" id="batch-export-popup" style="min-width:min(650px, 95vw); max-width:min(800px, 95vw);">
            <div class="export-popup-header">
                <h3 class="export-popup-title" data-i18n="batch_export_title">‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÁ¢∫Ë™ç</h3>
                <div style="display:flex; gap:8px; align-items:center;">
                    <span id="batch-export-file-count" style="color:#888; font-size:0.85rem;"></span>
                    <span class="export-popup-format" id="batch-export-format-badge">STL</span>
                </div>
            </div>
            
            <!-- „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ: 3D„Éó„É¨„Éì„É•„Éº + „Çµ„É†„Éç„Ç§„É´‰∏ÄË¶ß -->
            <div style="display:grid; grid-template-columns:200px 1fr; gap:15px; margin-bottom:15px;">
                <!-- Â∑¶ÂÅ¥: ÈÅ∏Êäû‰∏≠„Ç¢„Ç§„ÉÜ„É†„ÅÆ3D„Éó„É¨„Éì„É•„Éº -->
                <div style="background:#0a0a15; border-radius:8px; padding:10px;">
                    <div id="batch-export-3d-preview" style="width:180px; height:180px; border-radius:6px; overflow:hidden; background:#111;"></div>
                    <div id="batch-export-selected-name" style="text-align:center; margin-top:8px; font-size:0.8rem; color:#fff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"></div>
                </div>
                
                <!-- Âè≥ÂÅ¥: „Çµ„É†„Éç„Ç§„É´‰∏ÄË¶ß + Ë≠¶Âëä -->
                <div>
                    <div style="margin-bottom:8px; display:flex; align-items:flex-start; gap:10px;">
                        <label style="color:#888; font-size:0.7rem; white-space:nowrap;" data-i18n="batch_color_click_select">‚ñº „ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÅ∏Êäû</label>
                        <div id="batch-export-warning" style="display:none; flex:1; background:rgba(255,82,82,0.1); border:1px solid #ff5252; border-radius:4px; padding:5px 8px; font-size:0.7rem; max-height:60px; overflow-y:auto;"></div>
                    </div>
                    <div id="batch-export-preview" style="background:#0a0a15; border-radius:8px; height:160px; display:flex; gap:8px; padding:8px; overflow-x:auto; align-items:center; flex-wrap:wrap;">
                        <!-- „Çµ„É†„Éç„Ç§„É´„Åå„Åì„Åì„Å´ÂãïÁöÑ„Å´ËøΩÂä†„Åï„Çå„Çã -->
                    </div>
                </div>
            </div>
            
            <!-- AMS„Éï„Ç£„É©„É°„É≥„ÉàÈÅ∏ÊäûÔºàÈÅ∏Êäû„Åó„Åü„Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÁî®Ôºâ -->
            <div id="batch-export-ams-colors" style="margin-bottom:15px; padding:10px; background:rgba(30,30,50,0.5); border-radius:8px; border:1px solid #444;">
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px;">
                    <div>
                        <label style="color:#00e5ff; font-size:0.75rem; font-weight:bold; display:block; margin-bottom:5px;" data-i18n="batch_color_body_filament">üé® Êú¨‰Ωì„Éï„Ç£„É©„É°„É≥„Éà</label>
                        <div id="batch-export-body-palette" class="ams-select-palette" style="max-height:60px; overflow-y:auto; gap:4px;"></div>
                    </div>
                    <div>
                        <label style="color:#ff9800; font-size:0.75rem; font-weight:bold; display:block; margin-bottom:5px;" data-i18n="batch_color_text_filament">üìù ÊñáÂ≠ó„Éï„Ç£„É©„É°„É≥„Éà</label>
                        <div id="batch-export-text-palette" class="ams-select-palette" style="max-height:60px; overflow-y:auto; gap:4px;"></div>
                    </div>
                </div>
                <div id="batch-selected-item-info" style="margin-top:8px; padding:6px; background:rgba(0,229,255,0.1); border-radius:4px; font-size:0.75rem; color:#00e5ff; text-align:center;"></div>
            </div>
            
            <!-- „Éï„Ç©„Éº„Éû„ÉÉ„ÉàÈÅ∏Êäû -->
            <div style="margin-bottom:15px;">
                <label style="color:#888; font-size:0.75rem; display:block; margin-bottom:8px;" data-i18n="batch_export_format_select">Âá∫ÂäõÂΩ¢Âºè„ÇíÈÅ∏Êäû</label>
                <div style="display:flex; gap:10px;">
                    <label class="batch-format-option" style="flex:1; display:flex; align-items:center; justify-content:center; gap:8px; background:rgba(79,195,247,0.1); padding:12px; border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s;">
                        <input type="radio" name="batch-export-format" value="stl" checked style="accent-color:#4fc3f7;">
                        <span style="color:#4fc3f7; font-weight:bold;">STL</span>
                    </label>
                    <label class="batch-format-option" style="flex:1; display:flex; align-items:center; justify-content:center; gap:8px; background:rgba(76,175,80,0.1); padding:12px; border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s;">
                        <input type="radio" name="batch-export-format" value="3mf" style="accent-color:#4caf50;">
                        <span style="color:#4caf50; font-weight:bold;">3MF</span>
                    </label>
                    <label class="batch-format-option" style="flex:1; display:flex; align-items:center; justify-content:center; gap:8px; background:rgba(255,152,0,0.1); padding:12px; border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s;">
                        <input type="radio" name="batch-export-format" value="obj" style="accent-color:#ff9800;">
                        <span style="color:#ff9800; font-weight:bold;">OBJ</span>
                    </label>
                </div>
            </div>
            
            <!-- ÊÉÖÂ†±Ë°®Á§∫ -->
            <div class="export-popup-info" id="batch-export-info">
                <!-- ÂãïÁöÑ„Å´ËøΩÂä†„Åï„Çå„Çã -->
            </div>
            
            <!-- „Éú„Çø„É≥ -->
            <div class="export-popup-buttons">
                <span class="wiki-hint" data-help-url-ja="https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=6.%20%E3%82%AE%E3%83%A3%E3%83%A9%E3%83%AA%E3%83%BC%E4%B8%80%E6%8B%AC%E3%82%A8%E3%82%AF%E3%82%B9%E3%83%9D%E3%83%BC%E3%83%88%20(Gallery%20Bulk%20Export)" data-help-url-en="https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=6.%20Gallery%20Bulk%20Export"><span class="kbd">F1</span> <span data-i18n="wiki_hint">Wiki„ÅßË©≥„Åó„ÅèË¶ã„Çã</span></span>
                <span style="flex:1;"></span>
                <button class="export-popup-btn cancel" id="batch-export-cancel-btn" data-i18n="popup_cancel">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="export-popup-btn confirm" id="batch-export-confirm-btn" data-i18n="batch_export_start">„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÈñãÂßã</button>
            </div>
        </div>
    </div>

    <!-- V67: „ÇÆ„É£„É©„É™„Éº„Ç¢„Ç§„ÉÜ„É†Áî®„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„Éº -->
    <div id="gallery-context-menu" style="display:none; position:fixed; background:rgba(35,35,35,0.98); border:1px solid #555; border-radius:6px; padding:4px 0; min-width:140px; box-shadow:0 4px 15px rgba(0,0,0,0.5); z-index:300;">
        <div class="gallery-ctx-item" data-action="load" style="padding:8px 16px; cursor:pointer; color:#eee; font-size:0.8rem; transition:background 0.15s;" data-i18n="gallery_ctx_load">üìÇ Ë™≠„ÅøËæº„ÇÄ</div>
        <div style="height:1px; background:#444; margin:4px 0;"></div>
        <div class="gallery-ctx-item" data-action="export" style="padding:8px 16px; cursor:pointer; color:#4fc3f7; font-size:0.8rem; transition:background 0.15s;" data-i18n="gallery_ctx_export">üì• „Ç®„ÇØ„Çπ„Éù„Éº„Éà</div>
        <div style="height:1px; background:#444; margin:4px 0;"></div>
        <div class="gallery-ctx-item" data-action="delete" style="padding:8px 16px; cursor:pointer; color:#f44; font-size:0.8rem; transition:background 0.15s;" data-i18n="gallery_ctx_delete">üóëÔ∏è ÂâäÈô§</div>
    </div>

    <!-- V67: AMSËâ≤Ë®≠ÂÆö„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó -->
    <div id="ams-popup-overlay" class="ams-popup-overlay" style="display:none;">
        <div class="ams-popup" id="ams-popup">
            <div class="ams-popup-header">
                <h3 class="ams-popup-title" style="display:flex; align-items:center; gap:8px;">
                    <svg viewBox="0 0 117 133" style="width:24px; height:24px;"><path fill="#00e5ff" d="M49.6,15.6l36.07-.03c-3.48,12.09-5.69,30.38-5.69,50.85s2.25,39.07,5.78,51.16l-36.19-.23c.07-.21.13-.43.19-.65V16.14c-.05-.18-.1-.36-.16-.54Z"/><path fill="#ccc" d="M100.54.5c8.65,0,15.65,29.51,15.65,65.92s-7,65.91-15.65,65.91c-.83,0-1.65-.28-2.45-.81,7.47-4.98,13.19-32.23,13.19-65.1S105.56,6.29,98.09,1.31c.8-.53,1.62-.81,2.45-.81Z"/><path fill="#ccc" d="M98.09,1.31c7.47,4.98,13.19,32.23,13.19,65.11s-5.72,60.12-13.19,65.1c-7.48-4.95-13.2-32.21-13.2-65.1S90.61,6.26,98.09,1.31ZM105.48,66.42c0-7.95-2.21-14.4-4.94-14.4s-4.93,6.45-4.93,14.4,2.21,14.39,4.93,14.39,4.94-6.44,4.94-14.39Z"/><path fill="#fff" d="M100.54,52.02c2.73,0,4.94,6.45,4.94,14.4s-2.21,14.39-4.94,14.39-4.93-6.44-4.93-14.39,2.21-14.4,4.93-14.4Z"/><path fill="#ccc" d="M85.67,15.57c2.7-9.41,6.18-15.07,9.96-15.07.84,0,1.66.28,2.46.81-7.48,4.95-13.2,32.22-13.2,65.11s5.72,60.15,13.2,65.1c-.8.53-1.62.81-2.46.81-3.74,0-7.18-5.53-9.87-14.75-3.53-12.09-5.78-30.52-5.78-51.16s2.21-38.76,5.69-50.85Z"/><path fill="#ccc" d="M49.6,15.6h-4.03c-2.21-7.73-4.95-12.93-7.95-14.56.66-.36,1.34-.54,2.02-.54,3.79,0,7.26,5.67,9.96,15.1Z"/><path fill="#ccc" d="M45.55,117.33l4.02.02c-2.7,9.36-6.16,14.98-9.93,14.98-.68,0-1.36-.18-2.02-.54,2.99-1.62,5.71-6.78,7.93-14.46Z"/><path fill="#00e5ff" d="M45.73,16.14v100.56l-.18.63-15.88-.1c-3.47-12.09-5.68-30.36-5.68-50.81s2.21-38.72,5.68-50.81h15.9c.06.17.11.35.16.53Z"/><path fill="#00e5ff" d="M45.57,15.6h4.03c.06.18.11.36.16.54v100.56c-.06.22-.12.44-.19.65l-4.02-.02.18-.63V16.14c-.05-.18-.1-.36-.16-.54Z"/><path fill="#ccc" d="M45.57,15.6h-15.9c2.21-7.73,4.95-12.94,7.95-14.56,3,1.63,5.74,6.83,7.95,14.56Z"/><path fill="#ccc" d="M29.67,117.23l15.88.1c-2.22,7.68-4.94,12.84-7.93,14.46-3-1.62-5.74-6.83-7.95-14.56Z"/><path fill="#ccc" d="M29.67,117.23c2.21,7.73,4.95,12.94,7.95,14.56-.66.36-1.33.54-2.01.54-8.64,0-15.65-29.51-15.65-65.91S26.97.5,35.61.5c.68,0,1.35.18,2.01.54-3,1.62-5.74,6.83-7.95,14.57-3.47,12.09-5.68,30.36-5.68,50.81s2.21,38.72,5.68,50.81Z"/></svg>
                    <span data-i18n="ams_popup_title">AMSËâ≤Ë®≠ÂÆöÔºà„Çπ„É©„Ç§„Çµ„ÉºÂêåÊúüÁî®Ôºâ</span>
                </h3>
            </div>
            
            <div class="ams-content">
                <!-- Â∑¶ÂÅ¥: „Ç´„É©„Éº„Éë„É¨„ÉÉ„Éà -->
                <div class="ams-palette-section">
                    <div class="ams-palette-title" data-i18n="ams_filament_select">„Éï„Ç£„É©„É°„É≥„ÉàÈÅ∏Êäû</div>
                    
                    <!-- „Éô„É≥„ÉÄ„Éº„ÉªÊùêÊñôÈÅ∏Êäû -->
                    <div style="margin-bottom:10px;">
                        <label style="font-size:0.65rem; color:#888;" data-i18n="ams_vendor">„Éô„É≥„ÉÄ„Éº</label>
                        <select id="ams-filament-vendor" style="width:100%; font-size:0.75rem; padding:4px; margin-top:2px;"></select>
                    </div>
                    <div style="margin-bottom:10px;">
                        <label style="font-size:0.65rem; color:#888;" data-i18n="ams_material">ÊùêÊñô</label>
                        <select id="ams-filament-material" style="width:100%; font-size:0.75rem; padding:4px; margin-top:2px;"></select>
                    </div>
                    
                    <div class="ams-palette-title" style="margin-top:10px;" data-i18n="ams_color_palette">„Ç´„É©„Éº„Éë„É¨„ÉÉ„ÉàÔºà„Éâ„É©„ÉÉ„Ç∞Ôºâ</div>
                    <div class="ams-palette-grid" id="ams-palette-grid">
                        <!-- JavaScript„ÅßÁîüÊàê -->
                    </div>
                    <div style="margin-top:15px;">
                        <label style="font-size:0.7rem; color:#888;" data-i18n="ams_add_custom">„Ç´„Çπ„Çø„É†Ëâ≤„ÇíËøΩÂä†</label>
                        <div style="display:flex; gap:5px; margin-top:5px;">
                            <input type="color" id="ams-custom-color" value="#ffffff" style="width:40px; height:30px; border:none; cursor:pointer;">
                            <button id="ams-add-custom-color" style="flex:1; background:#333; border:1px solid #555; color:#fff; border-radius:4px; cursor:pointer; font-size:0.75rem;" data-i18n="btn_add">ËøΩÂä†</button>
                        </div>
                    </div>
                </div>
                
                <!-- Âè≥ÂÅ¥: AMS„Çπ„É≠„ÉÉ„ÉàÔºàÊ®™‰∏¶„Å≥Ôºâ -->
                <div class="ams-slots-section">
                    <!-- AMS (4„Çπ„É≠„ÉÉ„Éà x ÊúÄÂ§ß4Âè∞) -->
                    <div class="ams-type-column">
                        <div class="ams-type-header">
                            <span class="ams-type-title">AMS</span>
                            <button class="ams-add-btn" id="ams-add-unit">+ <span data-i18n="btn_add">ËøΩÂä†</span></button>
                        </div>
                        <div class="ams-units-container" id="ams-units-container">
                            <!-- JavaScript„ÅßÁîüÊàê -->
                        </div>
                    </div>
                    
                    <!-- AMS HT (1„Çπ„É≠„ÉÉ„Éà x ÊúÄÂ§ß8Âè∞) -->
                    <div class="ams-type-column ht-column">
                        <div class="ams-type-header">
                            <span class="ams-type-title" style="color:#e91e63;">AMS HT</span>
                            <button class="ams-add-btn" id="ams-ht-add-unit">+ <span data-i18n="btn_add">ËøΩÂä†</span></button>
                        </div>
                        <div class="ams-units-container ht-grid" id="ams-ht-units-container">
                            <!-- JavaScript„ÅßÁîüÊàê -->
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="ams-popup-footer">
                <span class="wiki-hint" style="margin-right:10px;" data-help-url-ja="https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%E8%89%B2%E8%A8%AD%E5%AE%9A%E3%81%A7%E3%81%99%E3%80%82-,AMS%E3%82%B9%E3%83%AD%E3%83%83%E3%83%88%E8%A8%AD%E5%AE%9A%3A,-AMS%3A%20%E6%9C%80%E5%A4%A7" data-help-url-en="https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=Automatic%20Material%20System).-,AMS%20Slot%20Settings%3A,-Supports%20up%20to"><span class="kbd">F1</span> <span data-i18n="wiki_hint">Wiki„ÅßË©≥„Åó„ÅèË¶ã„Çã</span></span>
                <button class="ams-popup-btn" id="ams-screenshot-import" style="background:#333; border-color:#ff9800; color:#ff9800; margin-right:5px;" data-i18n="ams_capture_btn" title="Capture slicer screen to auto-detect colors">üì∑ ÁîªÈù¢„Åã„ÇâÂèñËæº</button>
                <button class="ams-popup-btn" id="ams-export-json" style="background:#333; border-color:#4caf50; color:#4caf50; margin-right:auto;" data-i18n="ams_export_json">üì• JSONÊõ∏Âá∫„Åó</button>
                <button class="ams-popup-btn cancel" id="ams-popup-cancel" data-i18n="popup_cancel">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="ams-popup-btn confirm" id="ams-popup-confirm" data-i18n="btn_apply">ÈÅ©Áî®</button>
            </div>
        </div>
    </div>
    
    <!-- V67: „Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„ÉàËâ≤Ê§úÂá∫„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó -->
    <div id="screenshot-overlay" class="export-popup-overlay" style="display:none;">
        <div class="export-popup" style="max-width:680px; width:90vw; max-height:85vh; overflow-y:auto;">
            <div class="export-popup-header" style="position:sticky; top:0; z-index:10; background:#1a1a2e; padding:6px 10px;">
                <h3 class="export-popup-title" style="font-size:0.8rem; margin:0;" data-i18n="screenshot_title">üì∑ Ëâ≤„ÇíÂèñËæº</h3>
            </div>
            <div style="padding:8px;">
                <!-- „Çπ„ÉÜ„ÉÉ„Éó1: „Ç≠„É£„Éó„ÉÅ„É£ -->
                <div id="screenshot-step1">
                    <p style="color:#888; font-size:0.65rem; margin:0 0 8px 0; text-align:center;" data-i18n="screenshot_step1_hint">
                        „Çπ„É©„Ç§„Çµ„Éº„Åß„Éï„Ç£„É©„É°„É≥„Éà‰∏ÄË¶ß„ÇíË°®Á§∫ ‚Üí ÂÖ±ÊúâÁîªÈù¢„Åß„Äå„Ç¶„Ç£„É≥„Éâ„Ç¶„Äç„Åã„ÇâBambu StudioÈÅ∏Êäû
                    </p>
                    <div style="display:flex; gap:8px; align-items:center; justify-content:center;">
                        <label style="color:#888; font-size:0.65rem;" data-i18n="screenshot_scale">Êã°Â§ß:</label>
                        <select id="screenshot-scale" style="padding:4px 8px; background:#333; border:1px solid #555; color:#fff; border-radius:3px; font-size:0.7rem;">
                            <option value="1">1x</option>
                            <option value="2" selected>2x</option>
                            <option value="3">3x</option>
                        </select>
                        <button id="screenshot-capture-btn" style="padding:8px 20px; font-size:0.8rem; background:linear-gradient(135deg, #ff9800, #f57c00); border:none; color:#fff; border-radius:4px; cursor:pointer; font-weight:bold;" data-i18n="screenshot_capture">
                            üñ•Ô∏è „Ç≠„É£„Éó„ÉÅ„É£
                        </button>
                    </div>
                </div>
                
                <!-- „Çπ„ÉÜ„ÉÉ„Éó2: „ÇØ„É™„ÉÉ„ÇØ„ÅßËâ≤„ÇíÂèñÂæó -->
                <div id="screenshot-step2" style="display:none;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                        <span style="color:#fff; font-size:0.7rem;" data-i18n="screenshot_step2_hint">Bambu Studio„ÅÆÁï™Âè∑È†Ü„Å´„ÇØ„É™„ÉÉ„ÇØ</span>
                        <span style="color:#00e5ff; font-size:0.75rem; font-weight:bold; background:#1a3a4a; padding:2px 8px; border-radius:3px;" id="screenshot-click-status" data-i18n="screenshot_click_palette">1Áï™„ÅÆ„Éë„É¨„ÉÉ„Éà„Çí„ÇØ„É™„ÉÉ„ÇØ</span>
                    </div>
                    <div id="screenshot-canvas-container" style="position:relative; background:#0a0a15; border-radius:3px; overflow:auto; max-height:300px; border:1px solid #333;">
                        <canvas id="screenshot-canvas" style="cursor:crosshair; display:block;"></canvas>
                    </div>
                    <div style="display:flex; gap:4px; align-items:center; margin-top:5px;">
                        <button id="screenshot-zoom-out" style="padding:3px 8px; background:#333; border:1px solid #555; color:#fff; border-radius:3px; cursor:pointer; font-size:0.7rem;">‚àí</button>
                        <span id="screenshot-zoom-level" style="color:#888; font-size:0.6rem; min-width:32px; text-align:center;">100%</span>
                        <button id="screenshot-zoom-in" style="padding:3px 8px; background:#333; border:1px solid #555; color:#fff; border-radius:3px; cursor:pointer; font-size:0.7rem;">+</button>
                        <button id="screenshot-zoom-fit" style="padding:3px 6px; background:#333; border:1px solid #555; color:#888; border-radius:3px; cursor:pointer; font-size:0.6rem;">Fit</button>
                        <div style="flex:1; display:flex; gap:2px; align-items:center; overflow-x:auto; padding:3px 5px; background:#1a1a2e; border-radius:3px; min-height:24px;">
                            <span style="color:#666; font-size:0.6rem;" data-i18n="screenshot_picked">ÂèñÂæó:</span>
                            <div id="screenshot-picked-colors" style="display:flex; gap:2px; align-items:center;"></div>
                            <span id="screenshot-color-count" style="color:#00e5ff; font-size:0.6rem; margin-left:auto;">0</span>
                        </div>
                    </div>
                    <div style="display:flex; gap:4px; margin-top:5px;">
                        <button id="screenshot-retry-btn" style="flex:1; padding:7px 0; background:#333; border:1px solid #555; color:#aaa; border-radius:3px; cursor:pointer; font-size:0.7rem;" data-i18n="screenshot_retry">üîÑÊúÄÂàù„Åã„Çâ</button>
                        <button id="screenshot-add-capture-btn" style="flex:1; padding:7px 0; background:#1a3a4a; border:1px solid #00e5ff; color:#00e5ff; border-radius:3px; cursor:pointer; font-size:0.7rem;" data-i18n="screenshot_add">üì∑ËøΩÂä†</button>
                        <button id="screenshot-undo-btn" style="flex:1; padding:7px 0; background:#333; border:1px solid #ff9800; color:#ff9800; border-radius:3px; cursor:pointer; font-size:0.7rem;" data-i18n="screenshot_undo">‚Ü©Êàª„Åô</button>
                        <button id="screenshot-done-btn" style="flex:1; padding:7px 0; background:#4caf50; border:none; color:#fff; border-radius:3px; cursor:pointer; font-weight:bold; font-size:0.7rem;">‚úì<span data-i18n="screenshot_done">ÂÆå‰∫Ü</span>(0)</button>
                    </div>
                </div>
                
                <!-- „Çπ„ÉÜ„ÉÉ„Éó3: ÁµêÊûúÁ¢∫Ë™ç -->
                <div id="screenshot-step3" style="display:none;">
                    <p style="color:#fff; font-size:0.7rem; margin-bottom:5px;" data-i18n="screenshot_step3_hint">
                        ÂèñÂæó„Åó„ÅüËâ≤„ÇíÁ¢∫Ë™çÔºà„Ç´„É©„Éº„Éî„ÉÉ„Ç´„Éº„Åß‰øÆÊ≠£ÂèØËÉΩÔºâ
                    </p>
                    <div id="screenshot-results" style="display:grid; grid-template-columns:repeat(4, 1fr); gap:4px; margin-bottom:6px; max-height:160px; overflow-y:auto; padding:3px; background:#1a1a2e; border-radius:3px;">
                    </div>
                    <div style="display:flex; gap:4px;">
                        <button id="screenshot-back-btn" style="flex:1; padding:7px 0; background:#333; border:1px solid #555; color:#aaa; border-radius:3px; cursor:pointer; font-size:0.7rem;" data-i18n="screenshot_back">‚ÜêÊàª„Çã</button>
                        <button id="screenshot-apply-btn" style="flex:2; padding:7px 0; background:#00e5ff; border:none; color:#000; border-radius:3px; cursor:pointer; font-weight:bold; font-size:0.7rem;" data-i18n="screenshot_apply">‚úìAMS„Å´ÈÅ©Áî®</button>
                    </div>
                </div>
            </div>
            <div style="padding:5px 8px; border-top:1px solid #333;">
                <button id="screenshot-cancel-btn" style="width:100%; padding:7px 0; background:#333; border:1px solid #555; color:#aaa; border-radius:3px; cursor:pointer; font-size:0.7rem;" data-i18n="btn_close">Èñâ„Åò„Çã</button>
            </div>
        </div>
    </div>

    <!-- V67: AMSË®≠ÂÆöÁ¢∫Ë™ç„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó -->
    <div id="ams-confirm-overlay" class="export-popup-overlay" style="display:none;">
        <div class="export-popup" style="max-width:400px;">
            <div class="export-popup-header">
                <h3 class="export-popup-title" id="ams-confirm-title" data-i18n="ams_confirm_title">üé® AMSË®≠ÂÆö</h3>
            </div>
            <div style="padding:20px; text-align:center;">
                <p id="ams-confirm-message" style="color:#fff; font-size:0.95rem; line-height:1.6; margin:0 0 20px 0;" data-i18n="ams_confirm_message">
                    AMS„ÅÆËâ≤„ÅåÂâ≤„ÇäÂΩì„Å¶„Çâ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ<br>Ë®≠ÂÆö„Åó„Åæ„Åô„ÅãÔºü
                </p>
                <p style="color:#888; font-size:0.8rem; margin:0;">
                    <span data-i18n="ams_confirm_hint">‚ÄªÂæå„Åã„ÇâË®≠ÂÆö„Çø„Éñ„ÅÆ„ÄåAMSË®≠ÂÆö„Äç„Éú„Çø„É≥„Åß„ÅÑ„Å§„Åß„ÇÇË®≠ÂÆö„Åß„Åç„Åæ„Åô</span>
                </p>
            </div>
            <div class="export-popup-buttons">
                <button class="export-popup-btn cancel" id="ams-confirm-later" data-i18n="ams_confirm_later">Âæå„ÅßË®≠ÂÆö</button>
                <button class="export-popup-btn confirm" id="ams-confirm-now" data-i18n="ams_confirm_now">‰ªä„Åô„ÅêË®≠ÂÆö</button>
            </div>
        </div>
    </div>

    <!-- V67: „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„Éº (Âè≥„ÇØ„É™„ÉÉ„ÇØ) -->
    <div id="context-menu" style="display:none; position:absolute; background:rgba(35,35,35,0.98); border:1px solid #555; border-radius:8px; padding:6px 0; min-width:200px; z-index:2000; box-shadow:0 8px 25px rgba(0,0,0,0.6); backdrop-filter:blur(10px);">
        <div class="ctx-item" id="ctx-focus-center" style="padding:10px 18px; cursor:pointer; color:#eee; font-size:0.85rem; transition: background 0.15s;" data-i18n="ctx_reset_camera">üéØ „Ç´„É°„É©„Çí„É™„Çª„ÉÉ„Éà</div>
        <div class="ctx-item" id="ctx-reset-rotation" style="padding:10px 18px; cursor:pointer; color:#eee; font-size:0.85rem; transition: background 0.15s;" data-i18n="ctx_top_view">üîÑ ÂõûËª¢„Çí„É™„Çª„ÉÉ„Éà (Top View)</div>
        <div style="height:1px; background:#444; margin:5px 0;"></div>
        <div class="ctx-item" id="ctx-rand-color" style="padding:10px 18px; cursor:pointer; color:#eee; font-size:0.85rem; transition: background 0.15s;" data-i18n="ctx_random_color">üé≤ „É©„É≥„ÉÄ„É†„Ç´„É©„Éº</div>
        <div class="ctx-item" id="ctx-toggle-wireframe" style="padding:10px 18px; cursor:pointer; color:#eee; font-size:0.85rem; transition: background 0.15s;" data-i18n="ctx_wireframe">üî≤ „ÉØ„Ç§„É§„Éº„Éï„É¨„Éº„É†ÂàáÊõø</div>
        <div style="height:1px; background:#444; margin:5px 0;"></div>
        <div class="ctx-item" id="ctx-save-gallery" style="padding:10px 18px; cursor:pointer; color:#00e5ff; font-size:0.85rem; transition: background 0.15s;" data-i18n="ctx_save_gallery">üíæ „ÇÆ„É£„É©„É™„Éº„Å´‰øùÂ≠ò</div>
    </div>

    <div id="top-right-panel">
        <button id="btn-toggle-stats" title="Toggle Stats">Ôºç</button> 
        <div class="cost-row"><span data-i18n="lbl_weight">Est. Weight:</span><span class="cost-val"><span id="info-weight">0.00</span> g</span></div>
        <div class="cost-row"><span data-i18n="lbl_cost">Est. Cost:</span><span class="cost-val"><span id="info-currency">¬•</span> <span id="info-cost">0</span></span></div>
        <div class="cost-sub" id="info-fil-name" style="margin-bottom:10px;">Select Material</div>
        <div class="fil-control"><label data-i18n="lbl_vendor">Vendor:</label><select id="fil-vendor"></select></div>
        <div class="fil-control"><label data-i18n="lbl_material">Material:</label><select id="fil-material"></select></div>
        <button id="btn-toggle-fil" data-i18n="btn_details">‚ñº Details / Edit</button>
        <div class="fil-details" id="fil-details-panel">
            <div style="font-size:0.7rem; color:#80deea; margin-bottom:5px;" data-i18n="lbl_manual_override">Manual Override</div>
            <div class="fil-input-row"><label data-i18n="lbl_price">Price</label><input type="number" id="fil-price" placeholder="Price"></div>
            <div class="fil-input-row"><label data-i18n="lbl_spool">Spool</label><input type="number" id="fil-capacity" placeholder="g"></div>
            <div class="fil-input-row"><label data-i18n="lbl_density">Dens.</label><input type="number" id="fil-density" placeholder="g/cm3" step="0.01"></div>
            <div style="text-align:right; font-size:0.65rem; color:#555; margin-top:2px;">*Updates calculations instantly</div>
        </div>
    </div>

    <div id="history-controls">
        <button class="hist-btn" id="btn-undo" title="Undo" disabled>‚Ü©</button>
        <button class="hist-btn" id="btn-redo" title="Redo" disabled>‚Ü™</button>
    </div>

    <div id="render-mode-controls">
        <select id="render-mode">
            <option value="standard">Standard</option>
            <option value="wireframe">Wireframe</option>
        </select>
    </div>
    
    <!-- „Ç¨„É†„Éú„Éº„É´„Çø„Éº„Ç≤„ÉÉ„ÉàÈÅ∏Êäû -->
    <div id="gumball-target-controls" style="display:none;">
        <select id="hud-gumball-target" title="Select Target">
            <option value="text" data-i18n="gumball_main_text">„É°„Ç§„É≥ÊñáÂ≠ó</option>
            <option value="text2" data-i18n="gumball_sub_text">„Çµ„ÉñÊñáÂ≠ó</option>
            <option value="side" data-i18n="gumball_side_print">„Çµ„Ç§„ÉâÂç∞Â≠ó</option>
            <option value="svg">SVG</option>
            <option value="model" data-i18n="gumball_model">„É¢„Éá„É´</option>
        </select>
    </div>

    <div id="preset-float-panel" style="position:absolute; top:110px; left:450px; z-index:10; transition:all 0.3s ease;">
        <button id="btn-show-presets" style="background:rgba(0,0,0,0.8); border:1px solid #ff9800; color:#ff9800; padding:8px 12px; border-radius:4px; cursor:pointer; font-size:0.8rem; display:none;">üìÅ <span data-i18n="btn_presets">„Éó„É™„Çª„ÉÉ„Éà</span> (<span id="preset-count">0</span>)</button>
        <div id="preset-dropdown" style="display:none; margin-top:5px; background:rgba(20,20,20,0.95); border:1px solid #ff9800; border-radius:6px; padding:10px; min-width:220px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                <div style="color:#ff9800; font-size:0.75rem; font-weight:bold;" data-i18n="preset_loaded">üìÅ Ë™≠„ÅøËæº„ÅøÊ∏à„Åø</div>
                <button id="btn-clear-all-presets" style="background:#ff5252; border:none; color:white; padding:3px 8px; border-radius:3px; cursor:pointer; font-size:0.65rem;" data-i18n="btn_clear_all">ÂÖ®ÂâäÈô§</button>
            </div>
            <div style="display:flex; gap:5px; align-items:center;">
                <select id="preset-switcher-float" style="flex:1; background:#111; border:1px solid #ff9800; color:#fff; padding:6px; font-size:0.8rem; border-radius:3px; cursor:pointer;"></select>
                <button id="btn-remove-preset" style="background:#ff5252; border:none; color:white; width:28px; height:28px; border-radius:3px; cursor:pointer; font-size:1rem;" title="Delete Selected">√ó</button>
            </div>
            <div id="preset-preview-float" style="margin-top:10px; font-size:0.7rem; color:#aaa; background:#000; padding:8px; border-radius:4px;">
                <div style="display:flex; justify-content:space-between; margin-bottom:3px;"><span data-i18n="pv_profile">Profile:</span><span id="pf-profile" style="color:#ff9800;">-</span></div>
                <div style="display:flex; justify-content:space-between; margin-bottom:3px;"><span data-i18n="pv_size">Size:</span><span id="pf-size" style="color:#ff9800;">-</span></div>
                <div style="display:flex; justify-content:space-between; margin-bottom:3px;"><span data-i18n="pv_shape">Shape:</span><span id="pf-shape" style="color:#ff9800;">-</span></div>
                <div style="display:flex; justify-content:space-between; margin-bottom:3px;"><span data-i18n="pv_text">Text:</span><span id="pf-text" style="color:#ff9800;">-</span></div>
                <div style="display:flex; justify-content:space-between; margin-bottom:3px;"><span data-i18n="pv_text2">Sub Text:</span><span id="pf-text2" style="color:#ff9800;">-</span></div>
                <div style="display:flex; justify-content:space-between; margin-bottom:3px;"><span data-i18n="pv_side">Side:</span><span id="pf-side" style="color:#ff9800;">-</span></div>
                <div style="display:flex; justify-content:space-between;"><span data-i18n="pv_svg">SVG:</span><span id="pf-svg" style="color:#ff9800;">-</span></div>
            </div>
            <div style="display:flex; gap:5px; margin-top:8px;">
                <button id="btn-prev-preset" style="flex:1; background:#222; border:1px solid #555; color:#fff; padding:5px; border-radius:3px; cursor:pointer;" data-i18n="btn_prev">‚óÄ Ââç„Å∏</button>
                <button id="btn-next-preset" style="flex:1; background:#222; border:1px solid #555; color:#fff; padding:5px; border-radius:3px; cursor:pointer;" data-i18n="btn_next">Ê¨°„Å∏ ‚ñ∂</button>
            </div>
        </div>
    </div>

    <div id="canvas-container">
        <!-- V67: View Cube („Éì„É•„Éº„Ç≠„É•„Éº„Éñ) -->
        <div id="view-cube-wrapper">
            <div id="view-cube">
                <!-- 3DËª∏Ôºà„Ç≠„É•„Éº„Éñ„Å®‰∏ÄÁ∑í„Å´ÂõûËª¢„ÄÅ„É©„Éô„É´„Å™„ÅóÔºâ -->
                <div class="cube-axis">
                    <div class="axis-line axis-x"></div>
                    <div class="axis-line axis-y"></div>
                    <div class="axis-line axis-z"></div>
                </div>
                
                <!-- Èù¢ -->
                <div class="cube-face face-front" data-view="front"><span data-i18n="view_front">Ââç</span></div>
                <div class="cube-face face-back" data-view="back"><span data-i18n="view_back">Âæå</span></div>
                <div class="cube-face face-right" data-view="right"><span data-i18n="view_right">Âè≥</span></div>
                <div class="cube-face face-left" data-view="left"><span data-i18n="view_left">Â∑¶</span></div>
                <div class="cube-face face-top" data-view="top"><span data-i18n="view_top">‰∏ä</span></div>
                <div class="cube-face face-bottom" data-view="bottom"><span data-i18n="view_bottom">‰∏ã</span></div>
                
                <!-- 8„Å§„ÅÆ„Ç≥„Éº„Éä„ÉºÔºàËßíÈÅ∏ÊäûÁî®Ôºâ -->
                <div class="cube-corner c-frt" data-view="iso-frt" title="Isometric View"></div>
                <div class="cube-corner c-flt" data-view="iso-flt" title="Isometric View"></div>
                <div class="cube-corner c-brt" data-view="iso-brt" title="Isometric View"></div>
                <div class="cube-corner c-blt" data-view="iso-blt" title="Isometric View"></div>
                <div class="cube-corner c-frb" data-view="iso-frb" title="Isometric View"></div>
                <div class="cube-corner c-flb" data-view="iso-flb" title="Isometric View"></div>
                <div class="cube-corner c-brb" data-view="iso-brb" title="Isometric View"></div>
                <div class="cube-corner c-blb" data-view="iso-blb" title="Isometric View"></div>
            </div>
        </div>
        <!-- Ëª∏„É©„Éô„É´Ôºà2D„ÄÅÂ∏∏„Å´„Ç´„É°„É©ÊñπÂêë„ÇíÂêë„ÅèÔºâ -->
        <div id="axis-labels-container">
            <span class="axis-label-2d label-x">X</span>
            <span class="axis-label-2d label-y">Y</span>
            <span class="axis-label-2d label-z">Z</span>
        </div>
        <!-- V66: Dimension Overlay (inside canvas for correct positioning) -->
        <div id="dimension-overlay" class="dimension-overlay" style="display:none;">
            <div class="dimension-row">
                <span class="dimension-label" style="color:#2196f3;">W:</span>
                <span class="dimension-value" id="dim-width">0.00 mm</span>
            </div>
            <div class="dimension-row">
                <span class="dimension-label" style="color:#4caf50;">D:</span>
                <span class="dimension-value" id="dim-depth">0.00 mm</span>
            </div>
            <div class="dimension-row">
                <span class="dimension-label" style="color:#ff9800;">H:</span>
                <span class="dimension-value" id="dim-height">0.00 mm</span>
            </div>
        </div>
    </div>
    <button id="btn-toggle-ui" title="Toggle Sidebar">‚óÄ</button>

    <div id="ui-panel">
        <div id="ui-header-area">
            <div class="header-row">
                <div class="title-block">
                    <svg id="app-logo" onclick="location.reload()" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 306.06 217.55">
                         <defs><style>.cls-1{stroke:#ccc;}.cls-1,.cls-2,.cls-3{stroke-miterlimit:10;}.cls-1,.cls-3{fill:none;}.cls-2{fill:aqua;}.cls-2,.cls-3{stroke:aqua;}.cls-3{stroke-width:4px;}.cls-4{fill:#b3b3b3;}</style></defs><g><g><polygon class="cls-4" points="273.2 41.92 305.59 144.63 149.26 216.93 148.91 216.18 151.25 80.26 273.2 41.92"/><polygon class="cls-4" points="273.2 41.92 151.25 80.26 35.16 29.06 152.73 .49 273.2 41.92"/><polygon class="cls-4" points="151.25 80.26 148.91 216.18 .25 136.62 .61 135.77 35.16 29.06 151.25 80.26"/></g><g><line class="cls-1" x1="35.16" y1="29.06" x2=".61" y2="135.77"/><line class="cls-1" x1=".25" y1="136.62" x2="148.91" y2="216.18"/><line class="cls-1" x1="151.25" y1="80.26" x2="35.16" y2="29.06"/><line class="cls-1" x1="148.91" y1="216.18" x2="151.25" y2="80.26"/><line class="cls-1" x1="273.2" y1="41.92" x2="151.25" y2="80.26"/><line class="cls-1" x1="305.59" y1="144.63" x2="273.2" y2="41.92"/><polyline class="cls-1" points="148.91 217.1 149.26 216.93 305.59 144.63"/><line class="cls-1" x1="152.73" y1=".49" x2="273.2" y2="41.92"/><line class="cls-1" x1="152.73" y1=".49" x2="35.16" y2="29.06"/></g></g><g><line class="cls-3" x1="86.1" y1="30.23" x2="119.97" y2="22"/><line class="cls-3" x1="155.68" y1="60.92" x2="86.1" y2="30.23"/><line class="cls-3" x1="224.32" y1="40.72" x2="154.45" y2="60.92"/><line class="cls-3" x1="224.32" y1="41.22" x2="198.07" y2="32.19"/><path class="cls-2" d="M167.62,24.24s-20.08-4.1-28.79,0c-8.7,4.1,7.85-6.02,3.19-9.13s11.8,5.35,23.8.19c12-5.15-13.25,5.77,1.79,8.94Z"/><path class="cls-2" d="M169.51,46.26s-18.64-3.8-26.72,0c-8.08,3.8,7.29-5.59,2.96-8.48-4.32-2.88,10.96,4.96,22.1.18,11.14-4.78-12.3,5.36,1.66,8.3Z"/></g>
                    </svg>
                    <div><h2>Keycap Gen</h2><span class="ver">V67</span></div>
                </div>
                <div style="display:flex; align-items:center;">
                    <div class="social-links">
                        <a href="https://keycapgeneratorwiki.com/" target="_blank" id="link-wiki" title="Go to Wiki"><svg class="social-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 306.06 217.55"><defs><style>.cls-1{stroke:#ccc;}.cls-1,.cls-2,.cls-3{stroke-miterlimit:10;}.cls-1,.cls-3{fill:none;}.cls-2{fill:aqua;}.cls-2,.cls-3{stroke:aqua;}.cls-3{stroke-width:4px;}.cls-4{fill:#b3b3b3;}</style></defs><g><g><polygon class="cls-4" points="273.2 41.92 305.59 144.63 149.26 216.93 148.91 216.18 151.25 80.26 273.2 41.92"/><polygon class="cls-4" points="273.2 41.92 151.25 80.26 35.16 29.06 152.73 .49 273.2 41.92"/><polygon class="cls-4" points="151.25 80.26 148.91 216.18 .25 136.62 .61 135.77 35.16 29.06 151.25 80.26"/></g><g><line class="cls-1" x1="35.16" y1="29.06" x2=".61" y2="135.77"/><line class="cls-1" x1=".25" y1="136.62" x2="148.91" y2="216.18"/><line class="cls-1" x1="151.25" y1="80.26" x2="35.16" y2="29.06"/><line class="cls-1" x1="148.91" y1="216.18" x2="151.25" y2="80.26"/><line class="cls-1" x1="273.2" y1="41.92" x2="151.25" y2="80.26"/><line class="cls-1" x1="305.59" y1="144.63" x2="273.2" y2="41.92"/><polyline class="cls-1" points="148.91 217.1 149.26 216.93 305.59 144.63"/><line class="cls-1" x1="152.73" y1=".49" x2="273.2" y2="41.92"/><line class="cls-1" x1="152.73" y1=".49" x2="35.16" y2="29.06"/></g></g><g><line class="cls-3" x1="86.1" y1="30.23" x2="119.97" y2="22"/><line class="cls-3" x1="155.68" y1="60.92" x2="86.1" y2="30.23"/><line class="cls-3" x1="224.32" y1="40.72" x2="154.45" y2="60.92"/><line class="cls-3" x1="224.32" y1="41.22" x2="198.07" y2="32.19"/><path class="cls-2" d="M167.62,24.24s-20.08-4.1-28.79,0c-8.7,4.1,7.85-6.02,3.19-9.13s11.8,5.35,23.8.19c12-5.15-13.25,5.77,1.79,8.94Z"/><path class="cls-2" d="M169.51,46.26s-18.64-3.8-26.72,0c-8.08,3.8,7.29-5.59,2.96-8.48-4.32-2.88,10.96,4.96,22.1.18,11.14-4.78-12.3,5.36,1.66,8.3Z"/><path class="cls-2" d="M134.59,37.59s-10.53-2.15-15.09,0,4.12-3.16,1.67-4.79c-2.44-1.63,6.19,2.8,12.48.1,6.29-2.7-6.94,3.03.94,4.69Z"/></g></svg></a>
                        <a href="https://github.com/hololocheck/Keycap_Generator" target="_blank" id="link-github" title="Go to GitHub"><svg class="social-icon github-icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M512 0C229.12 0 0 229.12 0 512C0 738.56 146.56 930.56 349.44 997.76C375.04 1002.24 384.64 986.88 384.64 973.44C384.64 961.28 384 920.96 384 878.08C256 901.12 222.72 846.72 212.48 817.92C206.72 803.2 181.76 757.76 159.36 745.6C140.8 735.36 114.56 710.4 158.72 709.12C199.68 707.84 228.48 748.8 238.08 764.16C284.16 840.96 357.76 819.84 387.2 806.4C391.68 773.76 405.12 751.36 419.84 737.92C300.16 724.48 174.08 678.4 174.08 472.96C174.08 414.08 195.2 366.08 229.76 328.32C224 314.88 205.44 259.84 234.88 184.96C234.88 184.96 280.32 170.88 383.36 240.64C426.24 228.48 472.32 222.72 517.76 222.72C563.2 222.72 609.28 228.48 652.8 240.64C755.2 170.24 800 184.96 800 184.96C829.44 259.84 810.88 314.88 805.76 328.32C840.32 366.08 860.8 414.08 860.8 472.96C860.8 679.04 734.08 723.84 613.76 737.92C633.6 753.92 650.88 786.56 650.88 837.12C650.88 908.8 650.24 967.04 650.24 973.44C650.24 987.52 659.84 1002.88 686.08 997.76C888.32 930.56 1033.6 738.56 1033.6 512C1033.6 229.12 804.48 0 512 0Z"/></svg></a>
                    </div>
                    <select id="language-select"><option value="ja">üáØüáµ Êó•Êú¨Ë™û</option><option value="en">üá∫üá∏ English</option></select>
                </div>
            </div>

            <div id="nav-bar">
                <div class="nav-row"><select id="section-select"><option value="" data-i18n="nav_jump">--- Jump to Section ---</option><option value="sec-basic" data-i18n="nav_basic">Basic Size</option><option value="sec-structure" data-i18n="nav_structure">Structure</option><option value="sec-shape" data-i18n="nav_shape">Shape</option><option value="sec-texture" data-i18n="nav_texture">Texture Map</option><option value="sec-utility" data-i18n="nav_utility">Utility</option><option value="sec-import" data-i18n="nav_import">Import 3D</option><option value="sec-stem" data-i18n="nav_stem">Stem</option><option value="sec-text" data-i18n="nav_text">Text / Legend</option><option value="sec-svg" data-i18n="nav_svg">SVG Icon</option><option value="sec-color" data-i18n="nav_color">Colors</option><option value="sec-preset" data-i18n="nav_preset">Presets</option><option value="sec-export" data-i18n="nav_export">Export</option></select></div>
                <div class="nav-row"><input type="text" id="search-box" placeholder="üîç Search settings..."></div>
                <div class="nav-row" style="justify-content:flex-start; padding:2px 0;"><label class="toggle-switch" style="width:auto; margin:0;"><input type="checkbox" id="enable-hints" class="toggle-input" checked><span class="toggle-knob" style="width:28px; height:14px;"></span><span class="toggle-label" style="font-size:0.7rem;" data-i18n="lbl_show_hints">üí° „Éí„É≥„ÉàË°®Á§∫</span></label></div>
                <!-- V66: Simple Mode Toggle -->
                <div class="nav-row" style="justify-content:flex-start; padding:2px 0; margin-top:5px; border-top:1px dashed #4caf50; padding-top:8px;">
                    <label class="toggle-switch" style="width:auto; margin:0;" data-hint="hint_simple_mode">
                        <input type="checkbox" id="enable-simple-mode" class="toggle-input">
                        <span class="toggle-knob" style="width:28px; height:14px;"></span>
                        <span class="toggle-label" style="font-size:0.7rem; color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_mode">üå± Á∞°Âçò„É¢„Éº„Éâ</span>
                    </label>
                </div>
            </div>
        </div>
        <div id="ui-scroll-area">
            <!-- V66: Simple Mode Panel (shown only in Simple Mode) -->
            <div id="simple-mode-panel" class="simple-mode-panel" style="display:none;">
                <h3 style="color:#4caf50; border-color:#4caf50;" data-i18n="h_simple_mode">üå± Á∞°Âçò„É¢„Éº„Éâ</h3>
                
                <!-- 1. Text Content -->
                <div class="control-group" data-hint="hint_text_input">
                    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:5px;">
                        <label style="color:#4caf50; font-weight:bold; margin:0;" data-i18n="lbl_simple_text">ÊñáÂ≠óÂÖ•Âäõ</label>
                        <label class="toggle-switch" style="margin:0; width:auto;">
                            <input type="checkbox" id="simple-enable-text" checked class="toggle-input">
                            <span class="toggle-knob" style="width:28px; height:14px;"></span>
                            <span class="toggle-label" style="font-size:0.75rem;" data-i18n="lbl_text_visible">ÊñáÂ≠óË°®Á§∫</span>
                        </label>
                    </div>
                    <textarea id="simple-text-content" rows="2" placeholder="A" style="font-size:1.2rem; text-align:center;"></textarea>
                </div>

                <!-- 1.2 Text Mode -->
                <div class="control-group" data-hint="hint_text_mode">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_gen_mode">ÁîüÊàê„É¢„Éº„ÉâÔºàÊñáÂ≠ó„Éª„Ç¢„Ç§„Ç≥„É≥Ôºâ</label>
                    <select id="simple-text-mode">
                        <option value="emboss" data-i18n="opt_mode_emboss">Emboss (ÊµÆ„ÅçÂá∫„Åó)</option>
                        <option value="engrave" data-i18n="opt_mode_engrave">Engrave (ÂàªÂç∞)</option>
                        <option value="doubleshot" data-i18n="opt_mode_doubleshot">Double-Shot (Âüã„ÇÅËæº„Åø)</option>
                        <option value="lithophane" data-i18n="opt_mode_lithophane">Lithophane (ÈÄèÈÅé)</option>
                    </select>
                </div>

                <!-- 1.5 Font Selection -->
                <div class="control-group" data-hint="hint_font">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_font">„Éï„Ç©„É≥„Éà</label>
                    <select id="simple-font-select" style="display:none;">
                        <option value="helvetiker">Helvetiker</option>
                        <option value="helvetiker_bold">Helvetiker Bold</option>
                        <option value="optimer">Optimer</option>
                        <option value="optimer_bold">Optimer Bold</option>
                        <option value="gentilis">Gentilis</option>
                        <option value="gentilis_bold">Gentilis Bold</option>
                        <option value="droid_sans">Droid Sans</option>
                        <option value="droid_sans_bold">Droid Sans Bold</option>
                        <option value="droid_serif">Droid Serif</option>
                        <option value="droid_serif_bold">Droid Serif Bold</option>
                    </select>
                    <div class="custom-select-container" id="simple-custom-font-ui">
                        <div class="custom-select-head" id="simple-custom-font-head">Helvetiker ‚ñº</div>
                        <div class="custom-select-list" id="simple-custom-font-list"></div>
                    </div>
                </div>

                <!-- 1.6 Stock Icons (Simple) -->
                <div class="control-group" style="margin-top:10px;" data-hint="hint_simple_icon">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_icon">„Ç¢„Ç§„Ç≥„É≥</label>
                    <select id="simple-icon-category" style="margin-bottom:5px;">
                        <option value="all" data-i18n="cat_all">„Åô„Åπ„Å¶</option>
                    </select>
                    <div id="simple-icon-grid" style="display:grid; grid-template-columns:repeat(6,1fr); gap:4px; max-height:120px; overflow-y:auto; background:#1a1a2e; padding:5px; border-radius:4px;"></div>
                    <button type="button" class="danger" id="btn-clear-simple-icon" style="margin-top:5px; width:100%; padding:5px;" data-i18n="btn_clear_icon">„Ç¢„Ç§„Ç≥„É≥Ëß£Èô§</button>
                </div>

                <!-- 2. Profile & Row -->
                <div class="control-group" style="margin-top:15px;" data-hint="hint_profile">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_profile">ÂΩ¢Áä∂</label>
                    <select id="simple-profile-select">
                        <option value="cherry">Cherry Profile</option>
                        <option value="oem">OEM Profile</option>
                        <option value="sa">SA Profile</option>
                        <option value="xda">XDA Profile</option>
                        <option value="dsa">DSA Profile</option>
                    </select>
                </div>
                <div class="control-group" data-hint="hint_row">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_row">Ë°å</label>
                    <select id="simple-row-select">
                        <option value="R4" data-i18n="row_r4">R4ÔºàÊúÄ‰∏äÊÆµ/Êï∞Â≠ó„Ç≠„ÉºÔºâ</option>
                        <option value="R3" data-i18n="row_r3">R3ÔºàÊñáÂ≠ó„Ç≠„Éº/EnterÔºâ</option>
                        <option value="R2" data-i18n="row_r2">R2Ôºà„Éõ„Éº„É†ÊÆµ/ASDFÔºâ</option>
                        <option value="R1" data-i18n="row_r1">R1ÔºàÊúÄ‰∏ãÊÆµ/SpaceÔºâ</option>
                    </select>
                </div>

                <!-- 2.5 Taper (Top Scale) -->
                <div class="control-group" data-hint="hint_taper">
                    <label style="color:#4caf50; font-weight:bold;"><span data-i18n="lbl_simple_taper">‰∏äÈù¢„Çµ„Ç§„Ç∫</span> <span id="v-simple-taper" class="val">1.00</span></label>
                    <input type="range" id="simple-taper" min="0.5" max="1.0" step="0.01" value="1.0">
                </div>

                <!-- 2.6 Dish Type -->
                <div class="control-group" data-hint="hint_dish_type">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_dish">‰∏äÈù¢ÂΩ¢Áä∂</label>
                    <select id="simple-dish-type">
                        <option value="cylindrical" data-i18n="opt_dish_cyl">Cylindrical (ÂÜÜÁ≠í)</option>
                        <option value="spherical" data-i18n="opt_dish_sph">Spherical (ÁêÉ)</option>
                        <option value="flat" data-i18n="opt_dish_flat">Flat (Âπ≥)</option>
                    </select>
                </div>

                <!-- 2.7 Fillet (Round Corner) -->
                <div class="control-group" data-hint="hint_fillet">
                    <label style="color:#4caf50; font-weight:bold;"><span data-i18n="lbl_simple_fillet">Ëßí„ÅÆ‰∏∏„Åø</span> <span id="v-simple-fillet" class="val">0.0</span>mm</label>
                    <input type="range" id="simple-fillet" min="0.0" max="7.0" step="0.1" value="0.0">
                </div>

                <!-- 3. Key Size (Buttons) -->
                <div class="control-group" style="margin-top:15px;" data-hint="hint_simple_key_size">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_key_size">„Ç≠„Éº„ÅÆÂπÖ</label>
                    <div class="key-size-buttons" id="simple-key-size-buttons">
                        <button type="button" class="key-size-btn active" data-size="1.0">
                            <span class="size-label">1U</span>
                            <span class="size-desc" data-i18n="size_standard">ÈÄöÂ∏∏</span>
                        </button>
                        <button type="button" class="key-size-btn" data-size="1.25">
                            <span class="size-label">1.25U</span>
                            <span class="size-desc">Ctrl/Alt</span>
                        </button>
                        <button type="button" class="key-size-btn" data-size="1.5">
                            <span class="size-label">1.5U</span>
                            <span class="size-desc">Tab</span>
                        </button>
                        <button type="button" class="key-size-btn" data-size="1.75">
                            <span class="size-label">1.75U</span>
                            <span class="size-desc">Caps</span>
                        </button>
                        <button type="button" class="key-size-btn" data-size="2.0">
                            <span class="size-label">2U</span>
                            <span class="size-desc">BS</span>
                        </button>
                        <button type="button" class="key-size-btn" data-size="2.25">
                            <span class="size-label">2.25U</span>
                            <span class="size-desc">Enter/Shift</span>
                        </button>
                        <button type="button" class="key-size-btn" data-size="2.75">
                            <span class="size-label">2.75U</span>
                            <span class="size-desc">Shift</span>
                        </button>
                        <button type="button" class="key-size-btn" data-size="6.25">
                            <span class="size-label">6.25U</span>
                            <span class="size-desc">Space</span>
                        </button>
                    </div>
                </div>

                <!-- 4. Colors - AMSÈÄ£Âãï -->
                <div class="control-group" style="margin-top:15px;" data-hint="hint_colors">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="batch_color_body_filament">üé® Êú¨‰Ωì„Éï„Ç£„É©„É°„É≥„Éà</label>
                    <p style="font-size:0.65rem; color:#888; margin:3px 0;" data-i18n="simple_ams_select">AMS„Çπ„É≠„ÉÉ„Éà„Åã„ÇâÈÅ∏Êäû</p>
                    <div id="simple-body-ams-palette" class="ams-select-palette" style="margin-top:8px;"></div>
                    <input type="color" id="simple-col-body" value="#333333" style="display:none;">
                </div>
                <div class="control-group">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="batch_color_text_filament">üìù ÊñáÂ≠ó„Éï„Ç£„É©„É°„É≥„Éà</label>
                    <p style="font-size:0.65rem; color:#888; margin:3px 0;" data-i18n="simple_ams_select">AMS„Çπ„É≠„ÉÉ„Éà„Åã„ÇâÈÅ∏Êäû</p>
                    <div id="simple-text-ams-palette" class="ams-select-palette" style="margin-top:8px;"></div>
                    <input type="color" id="simple-col-text" value="#00e5ff" style="display:none;">
                </div>
                
                <!-- AMSËâ≤Ë®≠ÂÆö„Éú„Çø„É≥ (Á∞°Âçò„É¢„Éº„ÉâÁî®) -->
                <button id="btn-simple-ams-config" style="margin-top:10px; width:100%; padding:10px; background:linear-gradient(135deg, #1a237e, #4a148c); border:1px solid #7c4dff; color:#fff; border-radius:6px; cursor:pointer; font-size:0.85rem; display:flex; align-items:center; justify-content:center; gap:8px; transition:all 0.2s;"
                    onmouseover="this.style.borderColor='#b388ff'; this.style.boxShadow='0 0 15px rgba(124,77,255,0.4)';"
                    onmouseout="this.style.borderColor='#7c4dff'; this.style.boxShadow='none';">
                    <svg viewBox="0 0 117 133" style="width:20px; height:20px;"><path fill="#00e5ff" d="M49.6,15.6l36.07-.03c-3.48,12.09-5.69,30.38-5.69,50.85s2.25,39.07,5.78,51.16l-36.19-.23c.07-.21.13-.43.19-.65V16.14c-.05-.18-.1-.36-.16-.54Z"/><path fill="#ccc" d="M100.54.5c8.65,0,15.65,29.51,15.65,65.92s-7,65.91-15.65,65.91c-.83,0-1.65-.28-2.45-.81,7.47-4.98,13.19-32.23,13.19-65.1S105.56,6.29,98.09,1.31c.8-.53,1.62-.81,2.45-.81Z"/><path fill="#ccc" d="M98.09,1.31c7.47,4.98,13.19,32.23,13.19,65.11s-5.72,60.12-13.19,65.1c-7.48-4.95-13.2-32.21-13.2-65.1S90.61,6.26,98.09,1.31ZM105.48,66.42c0-7.95-2.21-14.4-4.94-14.4s-4.93,6.45-4.93,14.4,2.21,14.39,4.93,14.39,4.94-6.44,4.94-14.39Z"/><path fill="#fff" d="M100.54,52.02c2.73,0,4.94,6.45,4.94,14.4s-2.21,14.39-4.94,14.39-4.93-6.44-4.93-14.39,2.21-14.4,4.93-14.4Z"/><path fill="#ccc" d="M85.67,15.57c2.7-9.41,6.18-15.07,9.96-15.07.84,0,1.66.28,2.46.81-7.48,4.95-13.2,32.22-13.2,65.11s5.72,60.15,13.2,65.1c-.8.53-1.62.81-2.46.81-3.74,0-7.18-5.53-9.87-14.75-3.53-12.09-5.78-30.52-5.78-51.16s2.21-38.76,5.69-50.85Z"/><path fill="#ccc" d="M49.6,15.6h-4.03c-2.21-7.73-4.95-12.93-7.95-14.56.66-.36,1.34-.54,2.02-.54,3.79,0,7.26,5.67,9.96,15.1Z"/><path fill="#ccc" d="M45.55,117.33l4.02.02c-2.7,9.36-6.16,14.98-9.93,14.98-.68,0-1.36-.18-2.02-.54,2.99-1.62,5.71-6.78,7.93-14.46Z"/><path fill="#00e5ff" d="M45.73,16.14v100.56l-.18.63-15.88-.1c-3.47-12.09-5.68-30.36-5.68-50.81s2.21-38.72,5.68-50.81h15.9c.06.17.11.35.16.53Z"/><path fill="#00e5ff" d="M45.57,15.6h4.03c.06.18.11.36.16.54v100.56c-.06.22-.12.44-.19.65l-4.02-.02.18-.63V16.14c-.05-.18-.1-.36-.16-.54Z"/><path fill="#ccc" d="M45.57,15.6h-15.9c2.21-7.73,4.95-12.94,7.95-14.56,3,1.63,5.74,6.83,7.95,14.56Z"/><path fill="#ccc" d="M29.67,117.23l15.88.1c-2.22,7.68-4.94,12.84-7.93,14.46-3-1.62-5.74-6.83-7.95-14.56Z"/><path fill="#ccc" d="M29.67,117.23c2.21,7.73,4.95,12.94,7.95,14.56-.66.36-1.33.54-2.01.54-8.64,0-15.65-29.51-15.65-65.91S26.97.5,35.61.5c.68,0,1.35.18,2.01.54-3,1.62-5.74,6.83-7.95,14.57-3.47,12.09-5.68,30.36-5.68,50.81s2.21,38.72,5.68,50.81Z"/></svg>
                    <span data-i18n="btn_ams_config">AMSËâ≤Ë®≠ÂÆö</span>
                </button>

                <!-- 5. Export Buttons -->
                <div class="control-group" style="margin-top:20px;">
                    <button id="btn-simple-export" style="background:linear-gradient(135deg, #4fc3f7, #4caf50); border:none; color:#000; font-weight:bold; font-size:1rem; padding:15px;" data-hint="hint_export" data-i18n="btn_export_single">
                        üì• „Ç®„ÇØ„Çπ„Éù„Éº„Éà
                    </button>
                </div>
            </div>

            <!-- Normal Mode Content (hidden in Simple Mode) -->
            <div id="normal-mode-content">
            <h3 id="sec-basic" data-i18n="h_basic" style="margin-top:0;">Âü∫Êú¨„Çµ„Ç§„Ç∫</h3>
            <div class="control-group"><label data-i18n="lbl_unit_size" data-hint="hint_unit_size">Âü∫Êú¨„Éî„ÉÉ„ÉÅ (Unit Size)</label><select id="unit-size-select"><option value="19.05">19.05mm (Standard MX)</option><option value="19.00">19.00mm (Just)</option><option value="18.00">18.00mm</option><option value="17.00">17.00mm (Choc/Narrow)</option><option value="16.00">16.00mm (Mini)</option></select></div>
            <div class="control-group"><label data-hint="hint_key_size"><span data-i18n="lbl_u_size">„Ç≠„Éº„Çµ„Ç§„Ç∫</span> <span id="v-u-size" class="val" data-target="u-size">1.0</span></label><input type="range" id="u-size" min="1.0" max="10.0" step="0.25" value="1.0"></div>
            <div class="control-group" style="margin-top:5px; padding-top:5px; border-top:1px dashed #333;"><label data-hint="hint_stabilizer" data-i18n="lbl_stabilizer">„Çπ„Çø„Éì„É©„Ç§„Ç∂„Éº</label><select id="stabilizer-type"><option value="auto" data-i18n="opt_stab_auto">Ëá™Âãï</option><option value="custom" data-i18n="opt_stab_custom">ÊâãÂãïË®≠ÂÆö</option></select><div id="stabilizer-custom-ui" style="display:none; margin-top:5px;"><label><span data-i18n="lbl_stab_pitch">„Éî„ÉÉ„ÉÅÔºà‰∏≠ÂøÉ„Ç™„Éï„Çª„ÉÉ„ÉàÔºâ</span> <span id="v-stabilizer-offset" class="val">0.0</span>mm</label><input type="range" id="stabilizer-offset" min="0" max="150" step="0.1" value="0"><div style="font-size:0.7em; color:#aaa;" data-i18n="note_stab_distance">‚Äª‰∏≠ÂøÉ„Åã„Çâ„Çπ„ÉÜ„É†‰∏≠ÂøÉ„Åæ„Åß„ÅÆË∑ùÈõ¢</div></div></div>
            <div class="control-group"><label data-i18n="lbl_profile" data-hint="hint_profile">„Éó„É≠„Éï„Ç°„Ç§„É´</label><select id="profile-select"><option value="cherry">Cherry Profile</option><option value="oem">OEM Profile</option><option value="sa">SA Profile</option><option value="xda">XDA Profile</option><option value="dsa">DSA Profile</option><option value="custom">Custom Profile (V64)</option></select></div>
            <div id="custom-profile-panel" class="v60-sub-panel" style="display:none; border-color:#4caf50;">
                <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_custom_profile">üÜï „Ç´„Çπ„Çø„É†„Éó„É≠„Éï„Ç°„Ç§„É´Ë®≠ÂÆö</label>
                <div class="control-group"><label data-i18n="lbl_custom_height">È´ò„Åï</label> <span id="v-custom-height" class="val">9.5</span>mm<input type="range" id="custom-height" min="5.0" max="20.0" step="0.5" value="9.5"></div>
                <div class="control-group"><label data-i18n="lbl_custom_angle">ËßíÂ∫¶</label> <span id="v-custom-angle" class="val">3</span>¬∞<input type="range" id="custom-angle" min="-15" max="15" step="1" value="3"></div>
            </div>
            <div class="control-group" id="row-group"><label data-i18n="lbl_row" data-hint="hint_row">Ë°å (Row)</label><select id="row-select"><option value="R4">R4 (ESC/Num)</option><option value="R3">R3 (QWERTY)</option><option value="R2">R2 (ASDF)</option><option value="R1">R1 (ZXCV/Space)</option></select></div>
            
            <h3 id="sec-structure" data-i18n="h_structure">ÊßãÈÄ†„Éª„Éú„ÉÉ„ÉÅ</h3>
            <div class="control-group"><label style="color:#00e5ff; font-weight:bold;" data-hint="hint_fillet"><span data-i18n="lbl_round_corner">Ëßí„ÅÆ‰∏∏„Åø (Fillet)</span> <span><span id="v-round-corner" class="val" data-target="round-corner">0.0</span>mm</span></label><input type="range" id="round-corner" min="0.0" max="7.0" step="0.1" value="0.0"><div style="font-size:0.7em; color:#aaa;" data-i18n="note_round">‚ÄªSquircle Mapping (È´òÈÄü„ÉªÂÆâÂÆö)</div></div>
            <div class="control-group"><label data-hint="hint_wall_thick"><span data-i18n="lbl_wall_thick">Â£Å„ÅÆÂéö„Åø</span> <span><span id="v-wall-thick" class="val" data-target="wall-thick">1.5</span>mm</span></label><input type="range" id="wall-thick" min="0.8" max="4.0" step="0.1" value="1.5"></div>
            <div class="control-group"><label style="color:#ff80ab;" data-hint="hint_rib_shorten"><span data-i18n="lbl_rib_shorten">„É™„ÉñÁü≠Á∏Æ (Â∫ï‰∏ä„Åí)</span> <span><span id="v-rib-shorten" class="val" data-target="rib-shorten">4.3</span>mm</span></label><input type="range" id="rib-shorten" min="0.0" max="10.0" step="0.1" value="4.3"></div>
            <label class="toggle-switch" data-hint="hint_enable_ribs"><input type="checkbox" id="enable-ribs" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_enable_ribs">Ë£úÂº∑„É™„Éñ (ÂçÅÂ≠ó)</span></label>
            <div class="control-group" style="margin-top:5px; border-top:1px solid #333; padding-top:5px;">
                <label class="toggle-switch" data-hint="hint_homing_bump"><input type="checkbox" id="homing-bump" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" style="color:#ff4081;" data-i18n="lbl_homing_bump">„Éõ„Éº„É†„Éù„Ç∏„Ç∑„Éß„É≥Á™ÅËµ∑</span></label>
                <select id="homing-type" style="margin-bottom: 5px;" data-hint="hint_bump_type"><option value="round" data-i18n="opt_bump_round">‰∏∏Âûã (Round)</option><option value="bar" data-i18n="opt_bump_bar">Èï∑ÊñπÂΩ¢ (Bar)</option></select>
                <div class="control-row"><div style="flex:1"><label><span data-i18n="lbl_pos_x">‰ΩçÁΩÆ X</span> <span id="v-bump-x" class="val" data-target="bump-x">0.0</span></label><input type="range" id="bump-x" min="-10" max="10" step="0.1" value="0.0"></div><div style="flex:1"><label><span data-i18n="lbl_pos_z">‰ΩçÁΩÆ Z</span> <span id="v-bump-z" class="val" data-target="bump-z">0.0</span></label><input type="range" id="bump-z" min="-10" max="10" step="0.1" value="0.0"></div></div>
                <div class="control-group"><label><span data-i18n="lbl_bump_offset">È´ò„ÅïÂæÆË™øÊï¥ (Offset)</span> <span><span id="v-bump-offset-y" class="val" data-target="bump-offset-y">0.0</span>mm</span></label><input type="range" id="bump-offset-y" min="-5.0" max="5.0" step="0.1" value="0.0"></div>
            </div>
            
            <h3 id="sec-shape" data-i18n="h_shape">ÂΩ¢Áä∂</h3>
            <div class="v60-sub-panel" style="border-color:#ba68c8; margin-bottom:10px;">
                <label style="color:#ba68c8; font-weight:bold;" data-i18n="lbl_key_shape_type" data-hint="hint_key_shape">üÜï „Ç≠„ÉºÂΩ¢Áä∂„Çø„Ç§„Éó (V64)</label>
                <select id="key-shape-type" style="margin-top:5px;">
                    <option value="rectangle" data-i18n="opt_shape_rect">ÂõõËßíÂΩ¢ (Rectangle)</option>
                    <option value="rounded" data-i18n="opt_shape_round">Ëßí‰∏∏ (Rounded)</option>
                    <option value="circle" data-i18n="opt_shape_circle">ÂÜÜÂΩ¢ (Circle)</option>
                    <option value="polygon" data-i18n="opt_shape_polygon">Â§öËßíÂΩ¢ (Polygon)</option>
                    <option value="star" data-i18n="opt_shape_star">ÊòüÂΩ¢ (Star)</option>
                    <option value="iso-enter" data-i18n="opt_shape_iso">ISO Enter (LÂ≠óÂΩ¢)</option>
                </select>
                <div id="shape-polygon-options" style="display:none; margin-top:8px;">
                    <label data-i18n="lbl_polygon_sides">Ëæ∫„ÅÆÊï∞</label> <span id="v-polygon-sides" class="val">6</span>
                    <input type="range" id="polygon-sides" min="3" max="12" step="1" value="6">
                </div>
                <div id="shape-star-options" style="display:none; margin-top:8px;">
                    <label data-i18n="lbl_star_points">È†ÇÁÇπÊï∞</label> <span id="v-star-points" class="val">5</span>
                    <input type="range" id="star-points" min="3" max="12" step="1" value="5">
                    <label data-i18n="lbl_star_inner">ÂÜÖÂæÑÊØî</label> <span id="v-star-inner" class="val">0.50</span>
                    <input type="range" id="star-inner" min="0.2" max="0.8" step="0.05" value="0.5">
                </div>
                <div id="shape-iso-options" style="display:none; margin-top:8px;">
                    <label style="color:#ff9800;" data-i18n="lbl_iso_settings">ISO/JIS Enter Ë®≠ÂÆö</label>
                    <div class="control-row">
                        <div style="flex:1"><label data-i18n="lbl_iso_top_w">‰∏äÈÉ®ÂπÖ</label> <span id="v-iso-top-width" class="val">1.50</span>U<input type="range" id="iso-top-width" min="1.25" max="2.0" step="0.25" value="1.5"></div>
                    </div>
                    <div class="control-row">
                        <div style="flex:1"><label data-i18n="lbl_iso_bottom_w">‰∏ãÈÉ®ÂπÖ</label> <span id="v-iso-bottom-width" class="val">1.25</span>U<input type="range" id="iso-bottom-width" min="1.0" max="1.5" step="0.25" value="1.25"></div>
                    </div>
                    <div class="control-row">
                        <div style="flex:1"><label data-i18n="lbl_iso_total_h">ÂÖ®‰Ωì„ÅÆÈ´ò„Åï</label> <span id="v-iso-height" class="val">2.00</span>U<input type="range" id="iso-height" min="1.5" max="2.5" step="0.25" value="2.0"></div>
                    </div>
                    <div style="display:flex; gap:8px; margin-top:5px;">
                        <div style="flex:1"><label data-i18n="lbl_stem_x">„Çπ„ÉÜ„É†X</label> <span id="v-iso-stem-x" class="val">2.4</span><input type="range" id="iso-stem-x" min="-15" max="15" step="0.5" value="2.4"></div>
                        <div style="flex:1"><label data-i18n="lbl_stem_z">„Çπ„ÉÜ„É†Z</label> <span id="v-iso-stem-z" class="val">0.0</span><input type="range" id="iso-stem-z" min="-20" max="25" step="0.5" value="0"></div>
                    </div>
                    <div style="display:flex; gap:8px; margin-top:5px;">
                        <div style="flex:1"><label data-i18n="lbl_stab_top_z">‰∏ä„Çπ„Çø„ÉìZ</label> <span id="v-iso-stab-top-z" class="val">-12.0</span><input type="range" id="iso-stab-top-z" min="-20" max="15" step="0.5" value="-12"></div>
                        <div style="flex:1"><label data-i18n="lbl_stab_bottom_z">‰∏ã„Çπ„Çø„ÉìZ</label> <span id="v-iso-stab-bottom-z" class="val">12.0</span><input type="range" id="iso-stab-bottom-z" min="-5" max="25" step="0.5" value="12"></div>
                    </div>
                </div>
            </div>
            <div class="control-group"><label data-hint="hint_taper"><span data-i18n="lbl_top_scale">‰∏äÈù¢„Çµ„Ç§„Ç∫</span> <span id="v-top-scale" class="val" data-target="top-scale">1.00</span></label><input type="range" id="top-scale" min="0.5" max="1.0" step="0.01" value="1.0"></div>
            <div class="control-group"><label data-i18n="lbl_dish_type" data-hint="hint_dish_type">‰∏äÈù¢ÂΩ¢Áä∂ (Dish Type)</label><select id="dish-type"><option value="cylindrical" data-i18n="opt_dish_cyl">Cylindrical (ÂÜÜÁ≠í)</option><option value="spherical" data-i18n="opt_dish_sph">Spherical (ÁêÉ)</option><option value="flat" data-i18n="opt_dish_flat">Flat (Âπ≥)</option></select></div>
            
            <div class="v61-texture-panel">
                <label style="color:#e91e63; font-weight:bold;" data-i18n="lbl_texture" data-hint="hint_texture">Ë°®Èù¢„ÉÜ„ÇØ„Çπ„ÉÅ„É£</label>
                <select id="texture-type" style="margin-bottom:5px;">
                    <option value="none" data-i18n="opt_tex_none">„Å™„Åó</option>
                    <option value="noise" data-i18n="opt_tex_noise">Ê¢®Âú∞</option>
                    <option value="grid" data-i18n="opt_tex_grid">„Ç∞„É™„ÉÉ„Éó</option>
                    <option value="knurling" data-i18n="opt_tex_knurling">„É≠„Éº„É¨„ÉÉ„Éà</option>
                    <option value="stripes" data-i18n="opt_tex_stripes">„Çπ„Éà„É©„Ç§„Éó</option>
                    <option value="ripple" data-i18n="opt_tex_ripple">Ê≥¢Á¥ã</option>
                    <option value="wood" data-i18n="opt_tex_wood">Êú®ÁõÆ</option>
                    <option value="hammered" data-i18n="opt_tex_hammered">ÊâìÁóï</option>
                    <option value="hexagon" data-i18n="opt_tex_hexagon">„Éè„Éã„Ç´„É†</option>
                    <option value="bricks" data-i18n="opt_tex_bricks">„É¨„É≥„Ç¨</option>
                </select>
                <div class="control-row">
                    <div style="flex:1"><label><span data-i18n="lbl_tex_scale">Scale</span> <span id="v-tex-scale" class="val">50</span></label><input type="range" id="tex-scale" min="1" max="100" step="1" value="50"></div>
                    <div style="flex:1"><label><span data-i18n="lbl_tex_strength">Strength</span> <span id="v-tex-strength" class="val">0.05</span></label><input type="range" id="tex-strength" min="0.01" max="0.5" step="0.01" value="0.05"></div>
                </div>
                 <label class="toggle-switch" style="margin-top:5px;">
                    <input type="checkbox" id="texture-global" class="toggle-input">
                    <span class="toggle-knob"></span>
                    <span class="toggle-label" data-i18n="lbl_global_apply">ÂÖ®‰Ωì„Å´ÈÅ©Áî® (Global Apply)</span>
                </label>
            </div>

            <h3 id="sec-texture" data-i18n="h_texture_map" style="color:#ba68c8; border-color:#ba68c8;">ÁîªÂÉè„ÉÜ„ÇØ„Çπ„ÉÅ„É£ (Image Map)</h3>
            <div class="v63-texture-map-panel">
                <div class="file-upload" data-hint="hint_img_upload"><label for="img-texture-input" class="file-upload-label" style="border-color:#ba68c8; color:#e1bee7;" data-i18n="btn_upload_img">üìÅ ÁîªÂÉèË™≠Ëæº (PNG/JPG)</label><input type="file" id="img-texture-input" accept="image/*"></div>
                <div class="control-row" style="margin-top:5px; align-items:center;">
                    <label class="toggle-switch" style="flex:1; margin:0;"><input type="checkbox" id="img-texture-visible" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_visible">Ë°®Á§∫ (Visible)</span></label>
                    <button class="danger btn-small" id="btn-clear-img-texture" style="width:30px; margin:0;">√ó</button>
                </div>
                <div class="control-group" style="margin-top:5px;"><label>Scale <span id="v-img-scale" class="val">1.0</span></label><input type="range" id="img-scale" min="0.1" max="3.0" step="0.1" value="1.0"></div>
                <div class="control-row"><div style="flex:1"><label>Pos X <span id="v-img-pos-x" class="val">0.0</span></label><input type="range" id="img-pos-x" min="-0.5" max="0.5" step="0.01" value="0.0"></div><div style="flex:1"><label>Pos Y <span id="v-img-pos-y" class="val">0.0</span></label><input type="range" id="img-pos-y" min="-0.5" max="0.5" step="0.01" value="0.0"></div></div>
                <div class="control-group"><label>Rotation <span id="v-img-rot" class="val">0</span>¬∞</label><input type="range" id="img-rot" min="-180" max="180" step="1" value="0"></div>
            </div>

            <div class="control-group" style="border-top:1px dashed #555; margin-top:5px; padding-top:5px;">
                <label style="color:#b2ff59;">Twist („Å≠„Åò„Çä)</label><input type="range" id="twist-factor" min="-90" max="90" step="1" value="0">
                <label style="color:#b2ff59; margin-top:5px;" data-i18n="lbl_tilt">Â§©Èù¢ËßíÂ∫¶Ë™øÊï¥</label><div class="control-row"><div style="flex:1"><label>X</label><input type="range" id="tilt-x" min="-20" max="20" step="0.5" value="0"></div><div style="flex:1"><label>Z</label><input type="range" id="tilt-z" min="-20" max="20" step="0.5" value="0"></div></div>
            </div>

            <h3 id="sec-stem" data-i18n="h_stem">„Çπ„ÉÜ„É†Ë®≠ÂÆö</h3>
            <!-- V67: Êã°Âºµ„Çπ„ÉÜ„É†„Çø„Ç§„ÉóÈÅ∏Êäû -->
            <div class="control-group" data-hint="hint_stem_type">
                <label style="color:#80deea;" data-i18n="lbl_stem_type_select">Ëª∏„Çø„Ç§„Éó (Stem Type) <span style="font-size:0.65rem; color:#888;">V67</span></label>
                <select id="stem-type-select">
                    <option value="mx">Cherry MX (Cross)</option>
                    <option value="choc">Kailh Choc V1 (2 Legs)</option>
                    <option value="choc_v2">Kailh Choc V2 (Cross)</option>
                    <option value="topre">Topre (Electro-Capacitive)</option>
                    <option value="alps">Alps (Rectangular)</option>
                    <option value="artisan">None / Flat (Artisan)</option>
                </select>
            </div>
            <div class="control-group"><label style="color:#ffeb3b;" data-hint="hint_stem_diameter"><span data-i18n="lbl_stem_diameter">„Çπ„ÉÜ„É†Â§ñÂæÑ (Diameter)</span> <span><span id="v-stem-diameter" class="val" data-target="stem-diameter">5.50</span>mm</span></label><input type="range" id="stem-diameter" min="5.0" max="7.0" step="0.05" value="5.50"></div>
            <div class="control-group"><label style="color:#ffeb3b;" data-hint="hint_clearance"><span data-i18n="lbl_clearance">„ÇØ„É™„Ç¢„É©„É≥„Çπ</span> <span><span id="v-stem-clearance" class="val" data-target="stem-clearance">0.30</span>mm</span></label><input type="range" id="stem-clearance" min="0.0" max="1.0" step="0.01" value="0.30"></div>
            <div class="control-group" style="border-top:1px solid #333; margin-top:5px; padding-top:5px;">
                <label class="toggle-switch" data-hint="hint_stem_ext"><input type="checkbox" id="enable-stem-extension" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" style="color:#80deea;" data-i18n="lbl_stem_extension">Èï∑„Åï„ÇíÊã°Âºµ</span></label>
                <div id="stem-ext-control" style="display:none; margin-top:5px;"><label>Extension <span id="v-stem-extension" class="val">1.0</span>mm</label><input type="range" id="stem-extension" min="0.0" max="5.0" step="0.1" value="1.0"></div>
            </div>
            <label class="toggle-switch" style="margin-top:5px;" data-hint="hint_box_stem"><input type="checkbox" id="box-stem" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" style="color:#ffeb3b;" data-i18n="lbl_box_stem">„Éú„ÉÉ„ÇØ„ÇπËª∏</span></label>
            <label class="toggle-switch" data-hint="hint_lego_stud"><input type="checkbox" id="lego-stud" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" style="color:#ff5722;" data-i18n="lbl_lego_stud">Â§©Èù¢„Éù„ÉÉ„ÉÅ</span></label>
            <div id="lego-adj-panel" style="display:none; background:rgba(255,87,34,0.1); padding:5px; border-radius:4px; margin-bottom:5px; border:1px dashed #ff5722;">
                <div class="control-row"><div style="flex:1"><label>Pos X <span id="v-lego-x" class="val">0.0</span></label><input type="range" id="lego-x" min="-10" max="10" step="0.1" value="0.0"></div><div style="flex:1"><label>Pos Z <span id="v-lego-z" class="val">0.0</span></label><input type="range" id="lego-z" min="-10" max="10" step="0.1" value="0.0"></div></div>
                <div class="control-row"><div style="flex:1"><label>Pos Y <span id="v-lego-y" class="val">0.0</span></label><input type="range" id="lego-y" min="-5" max="5" step="0.1" value="0.0"></div><div style="flex:1"><label>Clearance <span id="v-lego-clear" class="val">0.0</span></label><input type="range" id="lego-clear" min="-0.5" max="0.5" step="0.05" value="0.0"></div></div>
            </div>

            <!-- V66: Tolerance Test Kit -->
            <div class="tolerance-test-panel">
                <label style="color:#9c27b0; font-weight:bold;" data-i18n="lbl_tolerance_test">üîß „Çπ„ÉÜ„É†„ÉÜ„Çπ„Éà„Ç≠„ÉÉ„Éà (V66)</label>
                <p style="font-size:0.7rem; color:#aaa; margin:5px 0;" data-i18n="tolerance_desc">„Éó„É™„É≥„Çø„Éº„ÅÆÂÖ¨Â∑Æ„Çí„ÉÜ„Çπ„Éà„Åô„Çã„Åü„ÇÅ„ÅÆ„Çπ„ÉÜ„É†„Å†„Åë„Çí‰∏¶„Åπ„Åü„Éó„É¨„Éº„Éà„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ</p>
                <div class="control-row" style="margin-top:8px;">
                    <div style="flex:1"><label><span data-i18n="tolerance_start">ÈñãÂßãÂÄ§</span> <span id="v-tol-start" class="val">0.20</span>mm</label><input type="range" id="tol-start" min="0.1" max="0.5" step="0.05" value="0.2"></div>
                    <div style="flex:1"><label><span data-i18n="tolerance_step">Âàª„Åø</span> <span id="v-tol-step" class="val">0.05</span>mm</label><input type="range" id="tol-step" min="0.02" max="0.1" step="0.01" value="0.05"></div>
                </div>
                <button id="btn-gen-tolerance-test" style="border-color:#9c27b0; color:#9c27b0; margin-top:8px;" data-i18n="tolerance_generate" title="Generate Stem Test Kit">„Çπ„ÉÜ„É†„ÉÜ„Çπ„ÉàÁîüÊàê (5ÂÄã)</button>
            </div>

            <div class="section-sep"></div>
            <h3 id="sec-utility" style="color:#00e5ff;">Utility</h3>
            <div class="control-group" style="display:flex; gap:5px; align-items:center;">
                <button id="btn-random" class="accent" style="border-color:#e040fb; color:#e040fb; flex:1;" data-hint="hint_randomizer">üé≤ Randomizer</button>
                <button id="btn-reset-params" class="danger btn-square" title="Reset Params to Default" style="width:40px; margin-top:5px;" data-hint="hint_reset">√ó</button>
            </div>

            <!-- V66: Dimension Lines Toggle -->
            <div class="control-group" style="margin-top:10px;" data-hint="hint_dimension_lines">
                <label class="toggle-switch">
                    <input type="checkbox" id="show-dimensions" class="toggle-input">
                    <span class="toggle-knob"></span>
                    <span class="toggle-label" style="color:#2196f3;" data-i18n="lbl_dimension_lines">üìê ÂØ∏Ê≥ïÁ∑ö„ÇíË°®Á§∫ (V66)</span>
                </label>
            </div>
            
            <h3 id="sec-import" style="color:#ff9800; margin-top:10px; border-bottom:1px solid #ff9800;" data-i18n="h_import">Â§ñÈÉ®„É¢„Éá„É´ (Import 3D)</h3>
            <div class="v60-import-panel">
                <div class="control-group" style="display:flex; gap:5px; align-items: flex-end;">
                    <div class="file-upload" style="flex:1;" data-hint="hint_import_stl"><label for="model-file-input" class="file-upload-label" style="border-color:#ff9800; color:#ff9800;" data-i18n="btn_load_stl">üìÅ STL„É¢„Éá„É´Ë™≠Ëæº</label><input type="file" id="model-file-input" accept=".stl"></div>
                    <button class="danger btn-square" id="btn-clear-model" title="Delete Model">√ó</button>
                </div>
                <label class="toggle-switch" style="margin-top:5px;"><input type="checkbox" id="model-visible" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_visible">Ë°®Á§∫ (Visible)</span></label>
                <div class="control-group" style="margin-top:5px; background:rgba(0,0,0,0.2); padding:5px; border-radius:4px;" data-hint="hint_import_op"><label style="color:#ff9800;" data-i18n="lbl_import_op">ÂêàÊàê„É¢„Éº„Éâ</label><select id="model-operation"><option value="union" data-i18n="opt_union">ÁµêÂêàÔºàËøΩÂä†Ôºâ</option><option value="subtract" data-i18n="opt_subtract">ÂûãÊäú„ÅçÔºàÂΩ´ÂàªÔºâ</option></select><div style="font-size:0.7em; color:#aaa; margin-top:2px;" data-i18n="note_subtract">‚ÄªÂûãÊäú„Åç„ÅØÂá¶ÁêÜ„Å´ÊôÇÈñì„Åå„Åã„Åã„Çä„Åæ„Åô</div></div>
                <div class="control-group"><label>Pivot / Transform (‰ΩçÁΩÆ/ÂõûËª¢)</label><div class="control-row"><div style="flex:1"><label>Scale <span id="v-model-scale" class="val">1.0</span></label><input type="range" id="model-scale" min="0.1" max="5.0" step="0.1" value="1.0"></div></div><div class="control-row"><div style="flex:1"><label>X <span id="v-model-x" class="val">0.0</span></label><input type="range" id="model-x" min="-15" max="15" step="0.5" value="0"></div><div style="flex:1"><label>Z <span id="v-model-z" class="val">0.0</span></label><input type="range" id="model-z" min="-15" max="15" step="0.5" value="0"></div></div><div class="control-row"><div style="flex:1"><label>Y-Pos <span id="v-model-y" class="val">0.0</span></label><input type="range" id="model-y" min="-10" max="20" step="0.5" value="0"></div></div><div class="control-row"><div style="flex:1"><label>Rot X <span id="v-model-rx" class="val">0</span>¬∞</label><input type="range" id="model-rx" min="-180" max="180" step="15" value="0"></div><div style="flex:1"><label>Rot Y <span id="v-model-ry" class="val">0</span>¬∞</label><input type="range" id="model-ry" min="-180" max="180" step="15" value="0"></div><div style="flex:1"><label>Rot Z <span id="v-model-rz" class="val">0</span>¬∞</label><input type="range" id="model-rz" min="-180" max="180" step="15" value="0"></div></div></div>
            </div>

            <!-- V67: Áõ¥ÊÑüÊìç‰Ωú„Éë„Éç„É´ -->
            <div class="v67-placement-panel" id="v67-placement-panel" data-hint="hint_click_place">
                <label style="color:#00e5ff; font-weight:bold; display:block; margin-bottom:8px;" data-i18n="lbl_click_place">üñ±Ô∏è Áõ¥ÊÑüÊìç‰Ωú (Interactive) <span style="font-size:0.65rem; color:#888;">V67</span></label>
                <button id="btn-click-place-mode" style="width:100%; padding:8px; font-size:0.9rem;" data-i18n="btn_click_place_off">ÈÖçÁΩÆ„É¢„Éº„Éâ: OFF</button>
                <div style="font-size:0.7em; color:#aaa; margin-top:5px;" data-i18n="note_click_place">
                    ‚ÄªON„Å´„Åó„Å¶„É¢„Éá„É´‰∏ä„Çí„ÇØ„É™„ÉÉ„ÇØ„Åô„Çã„Å®„ÄÅÊñáÂ≠ó„ÇÑ„Ç¢„Ç§„Ç≥„É≥„Åå„Åù„ÅÆ‰ΩçÁΩÆ„Å´ÁßªÂãï„Åó„Åæ„Åô
                </div>
            </div>

            <h3 id="sec-text" data-i18n="h_text">ÊñáÂ≠óË®≠ÂÆö</h3>
            <div class="control-group">
                <label class="toggle-switch" data-hint="hint_enable_text"><input type="checkbox" id="enable-text" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_enable_text">ÊñáÂ≠ó„ÇíÁîüÊàê„Åô„Çã</span></label>
                <textarea id="text-content" rows="2" placeholder="‰æã: A&#13;&#10;{&#13;&#10;[" data-hint="hint_text_input"></textarea><div style="font-size:0.7em; color:#aaa; text-align:right;" data-i18n="note_multiline">‚ÄªÊîπË°å„Åß2ÊÆµÂç∞Â≠ó„ÅåÂèØËÉΩ</div>
            </div>
            
            <div class="control-group" data-hint="hint_font"><label data-i18n="lbl_font">„Éï„Ç©„É≥„Éà</label><select id="font-family" style="display:none;"><option value="helvetiker">Helvetiker</option><option value="helvetiker_bold">Helvetiker Bold</option><option value="optimer">Optimer</option><option value="optimer_bold">Optimer Bold</option><option value="gentilis">Gentilis</option><option value="gentilis_bold">Gentilis Bold</option><option value="droid_sans">Droid Sans</option><option value="droid_sans_bold">Droid Sans Bold</option><option value="droid_serif">Droid Serif</option><option value="droid_serif_bold">Droid Serif Bold</option></select><div class="custom-select-container" id="custom-font-ui"><div class="custom-select-head" id="custom-font-head">Helvetiker ‚ñº</div><div class="custom-select-list" id="custom-font-list"></div></div></div>
            <div class="control-group" style="border: 1px dashed #555; padding: 8px; border-radius: 4px; background: rgba(0,0,0,0.3); margin-top: 5px;"><div class="info-link" data-i18n="note_font_upload">‚Äª.ttf „Å™„Å©„Çí„Åù„ÅÆ„Åæ„ÅæË™≠„ÅøËæº„ÇÄ„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ<br><a href="http://gero3.github.io/facetype.js/" target="_blank">Facetype.js</a> „Å™„Å©„ÅßJSON„Å´Â§âÊèõ„Åó„Åü„Éï„Ç°„Ç§„É´„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</div><div class="file-upload" data-hint="hint_custom_font"><label for="font-file-input" class="file-upload-label" data-i18n="btn_upload_font">üìÅ „Ç´„Çπ„Çø„É†„Éï„Ç©„É≥„Éà (.json)</label><input type="file" id="font-file-input" accept=".json"></div></div>

            <div class="control-group" style="background:rgba(0,229,255,0.1); padding:5px; border-radius:4px; margin-bottom:5px; margin-top:5px;" data-hint="hint_text_mode">
                <label data-i18n="lbl_text_mode" style="color:#00e5ff; font-weight:bold;">ÁîüÊàê„É¢„Éº„Éâ (Mode)</label>
                <select id="text-mode">
                    <option value="emboss" data-i18n="opt_mode_emboss">Emboss (ÊµÆ„ÅçÂá∫„Åó)</option>
                    <option value="engrave" data-i18n="opt_mode_engrave">Engrave (ÂàªÂç∞/Êéò„ÇäËæº„Åø)</option>
                    <option value="doubleshot" data-i18n="opt_mode_doubleshot">Double-Shot (Âüã„ÇÅËæº„Åø)</option>
                    <option value="lithophane" data-i18n="opt_mode_lithophane">Lithophane („Éê„ÉÉ„ÇØ„É©„Ç§„ÉàÈÄèÈÅé)</option>
                </select>
                <div style="font-size:0.7em; color:#aaa; margin-top:3px;" data-i18n="note_engrave">‚ÄªEngrave„ÅØË®àÁÆóÂá¶ÁêÜ„Å´ÊôÇÈñì„Åå„Åã„Åã„Çä„Åæ„Åô</div>
            </div>

            <div class="control-group">
                <div class="control-row">
                    <div style="flex:1"><label><span data-i18n="lbl_size">„Çµ„Ç§„Ç∫</span> <span id="v-font-size" class="val" data-target="font-size">8.0</span></label><input type="range" id="font-size" min="3" max="20" step="0.5" value="8.0"></div>
                    <div style="flex:1" data-hint="hint_text_height">
                        <label><span data-i18n="lbl_thickness">Ê∑±„Åï/È´ò„Åï</span> <span id="v-text-height" class="val" data-target="text-height">0.5</span></label>
                        <div style="display:flex; align-items:center; gap:5px;"><input type="range" id="text-height" min="0.1" max="5.0" step="0.1" value="0.5" disabled><label class="toggle-switch" style="margin:0; width:auto;" title="Lock Thickness"><input type="checkbox" id="lock-thickness" checked class="toggle-input"><span class="toggle-knob" style="width:28px; height:14px;"></span></label></div>
                    </div>
                </div>
            </div>
            
            <label class="toggle-switch" data-hint="hint_conform"><input type="checkbox" id="text-conform" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_conform">Êõ≤Èù¢„Å´Âêà„Çè„Åõ„Çã (Conform)</span></label>
            <div class="control-group" data-hint="hint_align_preset"><label data-i18n="lbl_align_preset">ÊñáÂ≠óÈÖçÁΩÆ („Éó„É™„Çª„ÉÉ„Éà)</label>
                <div class="control-row" style="margin-bottom:2px;">
                    <button id="btn-align-tl" class="secondary btn-small" style="margin:0;" data-i18n="btn_align_tl">‚Üñ TL</button>
                    <button id="btn-align-tr" class="secondary btn-small" style="margin:0;" data-i18n="btn_align_tr">‚Üó TR</button>
                </div>
                <div class="control-row">
                    <button id="btn-align-bl" class="secondary btn-small" style="margin:0;" data-i18n="btn_align_bl">‚Üô BL</button>
                    <button id="btn-align-br" class="secondary btn-small" style="margin:0;" data-i18n="btn_align_br">‚Üò BR</button>
                </div>
                <button id="btn-align-center" class="secondary btn-small" style="margin-top:4px;" data-i18n="btn_align_center">Center (‰∏≠Â§Æ)</button>
            </div>
            <div class="control-group"><label data-i18n="lbl_pos_xz_fine">‰ΩçÁΩÆ X / Z (ÂæÆË™øÊï¥)</label><div class="control-row"><input type="range" id="pos-x" min="-15" max="15" step="0.5" value="0" title="X Position"><input type="range" id="pos-z" min="-15" max="15" step="0.5" value="0" title="Z Position"></div><div style="display:flex; justify-content:space-between; font-size:0.7em; color:#aaa;"><span>X: <span id="v-pos-x">0.0</span></span><span>Z: <span id="v-pos-z">0.0</span></span></div></div>
            <div class="control-group"><label style="color:#aaa; font-size:0.7rem;"><span data-i18n="lbl_offset_y">È´ò„ÅïÂæÆË™øÊï¥ (Offset Y)</span> <span id="v-text-offset-y" class="val">0.0</span></label><input type="range" id="text-offset-y" min="-5.0" max="5.0" step="0.01" value="0.0"></div>
            <div class="v60-sub-panel">
                <label class="toggle-switch" data-hint="hint_text2"><input type="checkbox" id="enable-text2" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label v60-label" data-i18n="lbl_sub_text">„Çµ„ÉñÊñáÂ≠ó (Legend 2)</span></label>
                <div class="control-group"><select id="text2-mode" style="margin-bottom:5px; font-size:0.75rem; padding:3px;"><option value="emboss">Emboss</option><option value="engrave">Engrave</option><option value="doubleshot">Double-Shot</option><option value="lithophane">Lithophane</option></select></div>
                <textarea id="text2-content" rows="1" placeholder="‰æã: „ÅÇ / @" style="margin-bottom:5px;"></textarea>
                <div class="control-row"><div style="flex:1"><label>Size <span id="v-text2-size" class="val">4.0</span></label><input type="range" id="text2-size" min="2" max="15" step="0.1" value="4.0"></div></div>
                <div class="control-row"><div style="flex:1"><label>X <span id="v-text2-x" class="val">3.5</span></label><input type="range" id="text2-x" min="-10" max="10" step="0.1" value="3.5"></div><div style="flex:1"><label>Z <span id="v-text2-z" class="val">3.5</span></label><input type="range" id="text2-z" min="-10" max="10" step="0.1" value="3.5"></div></div>
            </div>

            <div class="v60-sub-panel">
                <label class="toggle-switch" data-hint="hint_side_print"><input type="checkbox" id="enable-side" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label v60-label-side" data-i18n="lbl_side_print">„Çµ„Ç§„ÉâÂç∞Â≠ó (Side Print)</span></label>
                <div class="control-group"><select id="side-mode" style="margin-bottom:5px; font-size:0.75rem; padding:3px;"><option value="emboss">Emboss</option><option value="engrave">Engrave</option><option value="doubleshot">Double-Shot</option><option value="lithophane">Lithophane</option></select></div>
                <input type="text" id="side-text" placeholder="FRONT TEXT" style="margin-bottom:5px;">
                <div class="control-row"><div style="flex:1"><label>Size <span id="v-side-size" class="val">3.0</span></label><input type="range" id="side-size" min="1" max="10" step="0.1" value="3.0"></div><div style="flex:1"><label>Y-Ofs <span id="v-side-y" class="val">-2.0</span></label><input type="range" id="side-y" min="-10" max="5" step="0.1" value="-2.0"></div></div>
                <div class="control-group"><label>Rotate X <span id="v-side-rot" class="val">0</span>¬∞</label><input type="range" id="side-rot" min="-45" max="45" step="1" value="0"></div>
            </div>

            <h3 id="sec-svg" data-i18n="h_svg">SVG („Ç¢„Ç§„Ç≥„É≥) Ë®≠ÂÆö</h3>

            <!-- V66: Stock Icon Library (loaded from external JSON) -->
            <div class="v60-sub-panel" style="border-color:#ffeb3b; margin-bottom:10px;" data-hint="hint_stock_icons">
                <label style="color:#ffeb3b; font-weight:bold;" data-i18n="lbl_stock_icons">üì¶ ÂÜÖËîµ„Ç¢„Ç§„Ç≥„É≥ (V66)</label>
                <p style="font-size:0.65rem; color:#888; margin:3px 0;" data-i18n="lbl_click_to_apply">„ÇØ„É™„ÉÉ„ÇØ„ÅßSVG„Å®„Åó„Å¶ÈÅ©Áî®</p>
                <div class="control-group" style="margin:5px 0;">
                    <select id="stock-icon-category" style="font-size:0.75rem; padding:4px;">
                        <option value="all" data-i18n="cat_all">„Åô„Åπ„Å¶</option>
                    </select>
                </div>
                <div class="stock-icon-grid" id="stock-icon-grid">
                    <div style="grid-column: 1/-1; text-align:center; color:#666; padding:10px;" data-i18n="msg_loading">Ë™≠„ÅøËæº„Åø‰∏≠...</div>
                </div>
                <div class="control-group" style="margin-top:8px;">
                    <label style="font-size:0.75rem;"><span data-i18n="lbl_icon_size">„Ç¢„Ç§„Ç≥„É≥„Çµ„Ç§„Ç∫</span> <span id="v-stock-icon-scale" class="val">1.0</span></label>
                    <input type="range" id="stock-icon-scale" min="0.01" max="3" step="0.01" value="1.0">
                </div>
                <button id="btn-clear-stock-icon" class="secondary btn-small" style="margin-top:5px;" data-i18n="btn_clear_stock_icon">ÈÅ∏ÊäûËß£Èô§</button>
            </div>

            <div class="control-group" style="display:flex; gap:5px; align-items: flex-end;" data-hint="hint_svg_upload">
                <div class="file-upload" style="flex:1;"><label for="svg-file-input" class="file-upload-label" style="border-color:#ffeb3b; color:#ffeb3b;" data-i18n="btn_upload_svg">üìÅ SVGË™≠Ëæº</label><input type="file" id="svg-file-input" accept=".svg"></div>
                <button class="danger btn-square" id="btn-clear-svg" title="Delete SVG">√ó</button>
            </div>
            
            <label class="toggle-switch" style="margin-top:5px;"><input type="checkbox" id="svg-visible" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_visible">Ë°®Á§∫„Åô„Çã</span></label>
            
            <div class="control-group" style="background:rgba(0,229,255,0.1); padding:5px; border-radius:4px; margin-bottom:5px;" data-hint="hint_svg_mode">
                <label data-i18n="lbl_text_mode" style="color:#00e5ff; font-weight:bold;">ÁîüÊàê„É¢„Éº„Éâ (Mode)</label>
                <select id="svg-mode">
                    <option value="emboss">Emboss</option>
                    <option value="engrave">Engrave</option>
                    <option value="doubleshot">Double-Shot</option>
                    <option value="lithophane">Lithophane</option>
                </select>
            </div>

            <div class="control-row"><div style="flex:1"><label><span data-i18n="lbl_size">„Çµ„Ç§„Ç∫</span> <span id="v-svg-scale" class="val" data-target="svg-scale">1.0</span></label><input type="range" id="svg-scale" min="0.01" max="3" step="0.01" value="1.0"></div><div style="flex:1"><label><span data-i18n="lbl_thickness">Âéö„Åø</span> <span id="v-svg-thickness" class="val" data-target="svg-thickness">0.6</span></label><input type="range" id="svg-thickness" min="0.1" max="5.0" step="0.1" value="0.6"></div></div>
            <label class="toggle-switch"><input type="checkbox" id="svg-conform" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_conform">Êõ≤Èù¢„Å´Âêà„Çè„Åõ„Çã (Conform)</span></label>
            <div class="control-group"><label data-i18n="lbl_rotation">ÂõûËª¢ (XYZ) </label><div class="control-row"><div style="flex:1"><label>X <span id="v-svg-rot-x" class="val" data-target="svg-rot-x">0</span>¬∞</label><input type="range" id="svg-rot-x" min="-180" max="180" step="5" value="0"></div><div style="flex:1"><label>Y <span id="v-svg-rot-y" class="val" data-target="svg-rot-y">0</span>¬∞</label><input type="range" id="svg-rot-y" min="-180" max="180" step="5" value="0"></div><div style="flex:1"><label>Z <span id="v-svg-rot-z" class="val" data-target="svg-rot-z">0</span>¬∞</label><input type="range" id="svg-rot-z" min="-180" max="180" step="5" value="0"></div></div></div>
            <div class="control-group"><div class="control-row"><div style="flex:1"><label><span data-i18n="lbl_pos_x">‰ΩçÁΩÆ X</span> <span id="v-svg-pos-x" class="val" data-target="svg-pos-x">0.0</span></label><input type="range" id="svg-pos-x" min="-15" max="15" step="0.5" value="0"></div><div style="flex:1"><label><span data-i18n="lbl_pos_z">‰ΩçÁΩÆ Z</span> <span id="v-svg-pos-z" class="val" data-target="svg-pos-z">0.0</span></label><input type="range" id="svg-pos-z" min="-15" max="15" step="0.5" value="0"></div></div></div>
            <div class="control-group"><label style="color:#aaa; font-size:0.7rem;"><span data-i18n="lbl_offset_y">È´ò„ÅïÂæÆË™øÊï¥ (Offset Y)</span> <span id="v-svg-offset-y" class="val">0.0</span></label><input type="range" id="svg-offset-y" min="-5.0" max="5.0" step="0.01" value="0.0"></div>

            <h3 id="sec-color" data-i18n="h_colors">Ëâ≤Ë®≠ÂÆö</h3>
            
            <!-- V67: AMSÈÄ£Êê∫„Ç´„É©„Éº„Éë„É¨„ÉÉ„Éà -->
            <div class="control-group" data-hint="hint_colors">
                <label style="color:#00e5ff; font-weight:bold;" data-i18n="batch_color_body_filament">üé® Êú¨‰Ωì„Éï„Ç£„É©„É°„É≥„Éà</label>
                <p style="font-size:0.65rem; color:#888; margin:3px 0;" data-i18n="ams_register_hint">AMS„Çπ„É≠„ÉÉ„Éà„Åã„ÇâÈÅ∏ÊäûÔºàAMSË®≠ÂÆö„ÅßËâ≤„ÇíÁôªÈå≤Ôºâ</p>
                <div id="body-ams-palette" class="ams-select-palette" style="margin-top:8px;"></div>
            </div>
            
            <!-- ÊñáÂ≠ó„ÉªSVGËâ≤ -->
            <div class="control-group" style="margin-top:15px;">
                <label style="color:#ff9800; font-weight:bold;" data-i18n="lbl_text_svg_filament">üìù ÊñáÂ≠ó„ÉªSVG„Éï„Ç£„É©„É°„É≥„Éà</label>
                <p style="font-size:0.65rem; color:#888; margin:3px 0;" data-i18n="simple_ams_select">AMS„Çπ„É≠„ÉÉ„Éà„Åã„ÇâÈÅ∏Êäû</p>
                <div id="text-ams-palette" class="ams-select-palette" style="margin-top:8px;"></div>
            </div>
            
            <!-- AMSËâ≤Ë®≠ÂÆö„Éú„Çø„É≥ -->
            <button id="btn-ams-config" style="margin-top:10px; width:100%; padding:10px; background:linear-gradient(135deg, #1a237e, #4a148c); border:1px solid #7c4dff; color:#fff; border-radius:6px; cursor:pointer; font-size:0.85rem; display:flex; align-items:center; justify-content:center; gap:8px; transition:all 0.2s;"
                onmouseover="this.style.borderColor='#b388ff'; this.style.boxShadow='0 0 15px rgba(124,77,255,0.4)';"
                onmouseout="this.style.borderColor='#7c4dff'; this.style.boxShadow='none';"
                title="AMS Color Settings (Slicer Sync)">
                <svg viewBox="0 0 117 133" style="width:20px; height:20px;"><path fill="#00e5ff" d="M49.6,15.6l36.07-.03c-3.48,12.09-5.69,30.38-5.69,50.85s2.25,39.07,5.78,51.16l-36.19-.23c.07-.21.13-.43.19-.65V16.14c-.05-.18-.1-.36-.16-.54Z"/><path fill="#ccc" d="M100.54.5c8.65,0,15.65,29.51,15.65,65.92s-7,65.91-15.65,65.91c-.83,0-1.65-.28-2.45-.81,7.47-4.98,13.19-32.23,13.19-65.1S105.56,6.29,98.09,1.31c.8-.53,1.62-.81,2.45-.81Z"/><path fill="#ccc" d="M98.09,1.31c7.47,4.98,13.19,32.23,13.19,65.11s-5.72,60.12-13.19,65.1c-7.48-4.95-13.2-32.21-13.2-65.1S90.61,6.26,98.09,1.31ZM105.48,66.42c0-7.95-2.21-14.4-4.94-14.4s-4.93,6.45-4.93,14.4,2.21,14.39,4.93,14.39,4.94-6.44,4.94-14.39Z"/><path fill="#fff" d="M100.54,52.02c2.73,0,4.94,6.45,4.94,14.4s-2.21,14.39-4.94,14.39-4.93-6.44-4.93-14.39,2.21-14.4,4.93-14.4Z"/><path fill="#ccc" d="M85.67,15.57c2.7-9.41,6.18-15.07,9.96-15.07.84,0,1.66.28,2.46.81-7.48,4.95-13.2,32.22-13.2,65.11s5.72,60.15,13.2,65.1c-.8.53-1.62.81-2.46.81-3.74,0-7.18-5.53-9.87-14.75-3.53-12.09-5.78-30.52-5.78-51.16s2.21-38.76,5.69-50.85Z"/><path fill="#ccc" d="M49.6,15.6h-4.03c-2.21-7.73-4.95-12.93-7.95-14.56.66-.36,1.34-.54,2.02-.54,3.79,0,7.26,5.67,9.96,15.1Z"/><path fill="#ccc" d="M45.55,117.33l4.02.02c-2.7,9.36-6.16,14.98-9.93,14.98-.68,0-1.36-.18-2.02-.54,2.99-1.62,5.71-6.78,7.93-14.46Z"/><path fill="#00e5ff" d="M45.73,16.14v100.56l-.18.63-15.88-.1c-3.47-12.09-5.68-30.36-5.68-50.81s2.21-38.72,5.68-50.81h15.9c.06.17.11.35.16.53Z"/><path fill="#00e5ff" d="M45.57,15.6h4.03c.06.18.11.36.16.54v100.56c-.06.22-.12.44-.19.65l-4.02-.02.18-.63V16.14c-.05-.18-.1-.36-.16-.54Z"/><path fill="#ccc" d="M45.57,15.6h-15.9c2.21-7.73,4.95-12.94,7.95-14.56,3,1.63,5.74,6.83,7.95,14.56Z"/><path fill="#ccc" d="M29.67,117.23l15.88.1c-2.22,7.68-4.94,12.84-7.93,14.46-3-1.62-5.74-6.83-7.95-14.56Z"/><path fill="#ccc" d="M29.67,117.23c2.21,7.73,4.95,12.94,7.95,14.56-.66.36-1.33.54-2.01.54-8.64,0-15.65-29.51-15.65-65.91S26.97.5,35.61.5c.68,0,1.35.18,2.01.54-3,1.62-5.74,6.83-7.95,14.57-3.47,12.09-5.68,30.36-5.68,50.81s2.21,38.72,5.68,50.81Z"/></svg>
                <span data-i18n="btn_ams_config">AMSËâ≤Ë®≠ÂÆöÔºà„Çπ„É©„Ç§„Çµ„ÉºÂêåÊúüÁî®Ôºâ</span>
            </button>
            
            <!-- AMSË®≠ÂÆöJSONË™≠„ÅøËæº„Åø -->
            <div style="margin-top:8px;">
                <input type="file" id="ams-import-json-input" accept=".json" style="display:none;">
                <button id="btn-ams-import-json" style="width:100%; padding:8px; background:#222; border:1px dashed #4caf50; color:#4caf50; border-radius:6px; cursor:pointer; font-size:0.8rem; display:flex; align-items:center; justify-content:center; gap:6px; transition:all 0.2s;"
                    onmouseover="this.style.borderColor='#81c784'; this.style.background='#1b3d1b';"
                    onmouseout="this.style.borderColor='#4caf50'; this.style.background='#222';"
                    title="Import AMS Settings (JSON)">
                    <span>üì§</span>
                    <span data-i18n="btn_ams_import">AMSË®≠ÂÆö„ÇíË™≠„ÅøËæº„Åø (JSON)</span>
                </button>
            </div>

            <div class="section-sep"></div>
            <h3 id="sec-preset" data-i18n="h_preset">„Éó„É™„Çª„ÉÉ„ÉàÁÆ°ÁêÜ</h3>

            <!-- V66: Visual Preset Library -->
            <div class="v60-sub-panel" style="border-color:#e040fb; margin-bottom:10px;" data-hint="hint_visual_presets">
                <label style="color:#e040fb; font-weight:bold;" data-i18n="lbl_visual_presets">üé® „Éì„Ç∏„É•„Ç¢„É´„Éó„É™„Çª„ÉÉ„Éà (V66)</label>
                <div class="control-row" style="margin-top:8px; gap:5px;">
                    <div style="flex:1;"><label style="font-size:0.7rem; color:#aaa;" data-i18n="lbl_font">„Éï„Ç©„É≥„Éà</label><select id="preset-font" style="font-size:0.75rem; padding:4px;">
                        <option value="helvetiker">Helvetiker</option>
                        <option value="helvetiker_bold">Helvetiker Bold</option>
                        <option value="optimer">Optimer</option>
                        <option value="gentilis">Gentilis</option>
                        <option value="droid_sans">Droid Sans</option>
                    </select></div>
                    <div style="flex:1;"><label style="font-size:0.7rem; color:#aaa;" data-i18n="lbl_size">„Çµ„Ç§„Ç∫</label><select id="preset-size" style="font-size:0.75rem; padding:4px;">
                        <option value="6">6</option>
                        <option value="7">7</option>
                        <option value="8" selected>8</option>
                        <option value="9">9</option>
                        <option value="10">10</option>
                        <option value="12">12</option>
                    </select></div>
                </div>
                <div class="control-group" style="margin-top:5px;"><label style="font-size:0.7rem; color:#aaa;" data-i18n="lbl_text_mode">ÁîüÊàê„É¢„Éº„Éâ</label><select id="preset-mode" style="font-size:0.75rem; padding:4px;">
                    <option value="emboss" data-i18n="opt_mode_emboss">ÊµÆ„ÅçÂá∫„Åó</option>
                    <option value="engrave" data-i18n="opt_mode_engrave">ÂàªÂç∞</option>
                    <option value="doubleshot" data-i18n="opt_mode_doubleshot">Âüã„ÇÅËæº„Åø</option>
                    <option value="lithophane" data-i18n="opt_mode_lithophane">„Éê„ÉÉ„ÇØ„É©„Ç§„ÉàÈÄèÈÅé</option>
                </select></div>
                <div class="visual-preset-grid" id="visual-preset-grid" style="margin-top:8px;">
                    <button type="button" class="visual-preset-btn" data-preset="wasd">
                        <span class="preset-icon">W</span>
                        <span class="preset-name">WASD</span>
                    </button>
                    <button type="button" class="visual-preset-btn" data-preset="arrows">
                        <span class="preset-icon">‚Üë</span>
                        <span class="preset-name" data-i18n="preset_arrow">Áü¢Âç∞„Ç≠„Éº</span>
                    </button>
                    <button type="button" class="visual-preset-btn" data-preset="fn">
                        <span class="preset-icon">Fn</span>
                        <span class="preset-name" data-i18n="preset_fn">Fn„Ç≠„Éº</span>
                    </button>
                    <button type="button" class="visual-preset-btn" data-preset="mac-cmd">
                        <span class="preset-icon">‚åò</span>
                        <span class="preset-name">Command</span>
                    </button>
                    <button type="button" class="visual-preset-btn" data-preset="mac-opt">
                        <span class="preset-icon">‚å•</span>
                        <span class="preset-name">Option</span>
                    </button>
                    <button type="button" class="visual-preset-btn" data-preset="esc">
                        <span class="preset-icon">Esc</span>
                        <span class="preset-name">Escape</span>
                    </button>
                </div>
                <button type="button" class="danger" id="btn-clear-visual-preset" style="margin-top:8px; width:100%; padding:5px;" data-i18n="btn_clear_preset">„Éó„É™„Çª„ÉÉ„ÉàËß£Èô§</button>
            </div>

            <div class="v60-sub-panel" style="border-color:#4caf50; margin-bottom:10px;" data-hint="hint_url_share">
                <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_url_share">üîó URL„ÅßÂÖ±Êúâ (Share via URL)</label>
                <div class="control-row" style="margin-top:5px;">
                    <button id="btn-share-url" style="flex:1; border-color:#4caf50; color:#4caf50;" data-i18n="btn_share_url">üìã URL„Çí„Ç≥„Éî„Éº</button>
                    <button id="btn-share-x" style="flex:1; border-color:#1DA1F2; color:#1DA1F2;" data-i18n="btn_share_x">ùïè „Ç∑„Çß„Ç¢</button>
                </div>
                <div class="control-row" style="margin-top:5px;">
                    <input type="text" id="url-import-input" placeholder="ÂÖ±ÊúâURL„ÇíË≤º„Çä‰ªò„Åë..." style="flex:1; font-size:0.75rem;" data-i18n-placeholder="placeholder_url_import">
                    <button id="btn-import-url" style="width:80px; border-color:#4caf50; color:#4caf50; font-size:0.75rem;" data-i18n="btn_import_url">Ë™≠„ÅøËæº„Åø</button>
                </div>
            </div>
            <div class="v60-sub-panel" style="border-color:#ff9800; margin-bottom:10px;">
                <label style="color:#ff9800; font-weight:bold;" data-i18n="lbl_named_preset">üÜï ÂêçÂâç‰ªò„Åç„Éó„É™„Çª„ÉÉ„Éà‰øùÂ≠ò (V64)</label>
                <input type="text" id="preset-save-name" placeholder="„Éó„É™„Çª„ÉÉ„ÉàÂêç„ÇíÂÖ•Âäõ..." style="margin-top:5px;" data-i18n-placeholder="placeholder_preset_name">
                <button id="btn-save-named-preset" style="border-color:#ff9800; color:#ff9800; margin-top:5px;" data-i18n="btn_save_named">üíæ ÂêçÂâç„Çí‰ªò„Åë„Å¶‰øùÂ≠ò</button>
            </div>
            <div class="control-group" data-hint="hint_quick_save"><label data-i18n="lbl_browser_storage">„Éñ„É©„Ç¶„Ç∂„Å´‰øùÂ≠ò (Quick Save/Load)</label><div class="control-row"><button id="btn-quick-save" class="secondary btn-small" data-i18n="btn_quick_save">‰∏ÄÊôÇ‰øùÂ≠ò (Save)</button><button id="btn-quick-load" class="secondary btn-small" data-i18n="btn_quick_load">Âæ©ÂÖÉ (Load)</button></div></div>
            <div class="control-group" data-hint="hint_export_json"><label data-i18n="lbl_file_storage">„Éï„Ç°„Ç§„É´„Å´‰øùÂ≠ò (File I/O)</label><div class="control-row"><button id="btn-export-preset" class="secondary btn-small" data-i18n="btn_export_file">Êõ∏„ÅçÂá∫„Åó (.json)</button><div class="file-upload" style="flex:1;" data-hint="hint_import_json"><label for="preset-file-input" class="file-upload-label preset btn-small" data-i18n="btn_load_add">Ë™≠„ÅøËæº„Åø (ËøΩÂä†)</label><input type="file" id="preset-file-input" accept=".json" multiple></div></div></div>
            <div id="preset-switch-panel" style="display:none; margin-top:10px; background:rgba(255,152,0,0.1); padding:8px; border-radius:4px; border:1px solid #ff9800;">
                <label style="color:#ff9800; font-size:0.8rem;" data-i18n="lbl_loaded_presets">üìÅ Ë™≠„ÅøËæº„Çì„Å†„Éó„É™„Çª„ÉÉ„Éà:</label>
                <div style="display:flex; gap:5px; align-items:center; margin-top:5px;">
                    <select id="preset-switcher" style="flex:1;"></select>
                    <button id="btn-remove-preset-ui" class="danger btn-small" style="width:28px; height:28px; padding:0;" title="Remove">√ó</button>
                </div>
                <div id="preset-preview-mini" style="margin-top:8px; font-size:0.7rem; color:#aaa; background:#000; padding:6px; border-radius:3px;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;"><span data-i18n="pv_profile">Profile:</span><span id="pm-profile" style="color:#ff9800;">-</span></div>
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;"><span data-i18n="pv_size">Size:</span><span id="pm-size" style="color:#ff9800;">-</span></div>
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;"><span data-i18n="pv_shape">Shape:</span><span id="pm-shape" style="color:#ff9800;">-</span></div>
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;"><span data-i18n="pv_text">Text:</span><span id="pm-text" style="color:#ff9800;">-</span></div>
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;"><span data-i18n="pv_text2">Sub Text:</span><span id="pm-text2" style="color:#ff9800;">-</span></div>
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;"><span data-i18n="pv_side">Side:</span><span id="pm-side" style="color:#ff9800;">-</span></div>
                    <div style="display:flex; justify-content:space-between;"><span data-i18n="pv_svg">SVG:</span><span id="pm-svg" style="color:#ff9800;">-</span></div>
                </div>
            </div>

            <div class="section-sep"></div>
            <h3 id="sec-export" data-i18n="h_export">„Ç®„ÇØ„Çπ„Éù„Éº„Éà (STL/OBJ/3MF)</h3>
            <div class="control-group" data-hint="hint_print_orient"><label>ÂÖ®‰ΩìÂõûËª¢ (Print Orientation)</label><div class="control-row"><div style="flex:1"><label>Rot X</label><input type="range" id="global-rot-x" min="-180" max="180" step="15" value="0" title="Global Rot X"></div><div style="flex:1"><label>Rot Y</label><input type="range" id="global-rot-y" min="-180" max="180" step="15" value="0" title="Global Rot Y"></div></div></div>
            <div class="control-group" style="margin-bottom:10px;"><label data-i18n="lbl_filename">„Éï„Ç°„Ç§„É´ÂêçË®≠ÂÆö (Ëá™Âãï„Åß[ÊñáÂ≠ó]„Åå‰ªò‰∏é„Åï„Çå„Åæ„Åô)</label><input type="text" id="export-name" value="keycap" style="text-align:left;"></div>
            <button id="btn-export-single" class="primary" style="background:linear-gradient(135deg, #4fc3f7, #4caf50); border:none; color:#000; font-weight:bold;" data-i18n="btn_export_single" data-hint="hint_export">„Ç®„ÇØ„Çπ„Éù„Éº„Éà</button>
            <div class="control-row" data-hint="hint_export_parts"><button class="secondary" id="btn-export-body" data-i18n="btn_export_body">Êú¨‰Ωì„ÅÆ„Åø (STL)</button><button class="secondary" id="btn-export-text" data-i18n="btn_export_text">ÊñáÂ≠ó„ÅÆ„Åø (STL)</button></div>

            <!-- V66: Sprue Kit Generation -->
            <div class="sprue-kit-panel">
                <label style="color:#00bcd4; font-weight:bold;" data-i18n="lbl_sprue_kit">üîó „Çπ„Éó„É´„Éº„Éª„Ç≠„ÉÉ„ÉàÁîüÊàê (V66)</label>
                <p style="font-size:0.7rem; color:#aaa; margin:5px 0;" data-i18n="sprue_desc">Ë§áÊï∞„ÅÆ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Çí„Éó„É©„É¢„Éá„É´„ÅÆ„É©„É≥„Éä„Éº„ÅÆ„Çà„ÅÜ„Å´ÈÄ£Áµê„Åó„Å¶Âá∫Âäõ„Åó„Åæ„Åô„ÄÇ</p>
                
                <div class="control-group" style="margin-top:8px;">
                    <label style="color:#00bcd4;" data-i18n="sprue_printer_model">„Éó„É™„É≥„Çø„ÉºÊ©üÁ®Æ</label>
                    <div style="display:flex; gap:8px;">
                        <select id="sprue-printer-model" style="flex:1; font-size:0.8rem;">
                            <option value="x1p1a1">Bambu Lab X1/P1/A1</option>
                            <option value="a1mini">Bambu Lab A1 mini</option>
                            <option value="h2d">Bambu Lab H2D</option>
                            <option value="h2s">Bambu Lab H2S</option>
                            <option value="h2c">Bambu Lab H2C</option>
                            <option value="unlimited" data-i18n="sprue_unlimited">Âà∂Èôê„Å™„Åó</option>
                        </select>
                        <select id="sprue-printer-size" style="flex:1; font-size:0.8rem;">
                            <option value="256,256">256√ó256</option>
                        </select>
                    </div>
                    <div id="sprue-max-keys-info" style="font-size:0.7rem; color:#4fc3f7; margin-top:4px; text-align:right;">
                        <span data-i18n="sprue_max_keys">ÊúÄÂ§ßÈÖçÁΩÆÂèØËÉΩ</span>: <span id="sprue-max-keys">--</span>
                    </div>
                </div>
                
                <div class="control-group" style="margin-top:8px;">
                    <label><span data-i18n="sprue_key_count">„Ç≠„ÉÉ„ÉàÂÜÖ„ÅÆ„Ç≠„ÉºÊï∞</span> <span id="v-sprue-count" class="val">4</span></label>
                    <input type="range" id="sprue-count" min="2" max="100" step="1" value="4">
                </div>
                
                <div class="control-group" style="margin-top:8px;">
                    <label class="toggle-switch">
                        <input type="checkbox" id="sprue-repeat-mode" class="toggle-input">
                        <span class="toggle-knob"></span>
                        <span class="toggle-label" data-i18n="sprue_repeat_mode">Âêå„ÅòÊñáÂ≠ó„ÇíÈÄ£Á∂öÂá∫Âäõ</span>
                    </label>
                </div>
                
                <div class="control-group" id="sprue-chars-group">
                    <label data-i18n="sprue_char_list">ÊñáÂ≠ó„É™„Çπ„Éà („Ç´„É≥„ÉûÂå∫Âàá„Çä)</label>
                    <input type="text" id="sprue-chars" value="W,A,S,D" placeholder="W,A,S,D">
                </div>
                <div class="control-group" id="sprue-single-char-group" style="display:none;">
                    <label data-i18n="sprue_single_char">ÈÄ£Á∂öÂá∫Âäõ„Åô„ÇãÊñáÂ≠ó</label>
                    <input type="text" id="sprue-single-char" value="A" placeholder="A" maxlength="10" style="text-align:center; font-size:1.2rem; font-weight:bold;">
                </div>
                
                <button id="btn-gen-sprue-kit" style="border-color:#00bcd4; color:#00bcd4; margin-top:8px;" data-i18n="sprue_generate" title="Generate Sprue Kit">„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„ÉàÁîüÊàê</button>
                <button id="btn-custom-sprue-kit" style="border-color:#ff9800; color:#ff9800; margin-top:6px; width:100%;" data-i18n="sprue_custom">üé® „Ç´„Çπ„Çø„É†„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„Éà</button>
            </div>

            <div class="section-sep"></div>
            <h3 id="sec-batch" data-i18n="h_batch">„Éê„ÉÉ„ÉÅÂá∫Âäõ (Batch Export)</h3>
            <div class="control-group" data-hint="hint_batch_list"><label data-i18n="lbl_batch_list">ÊñáÂ≠ó„É™„Çπ„Éà („Ç´„É≥„Éû/ÊîπË°åÂå∫Âàá„Çä)</label><textarea id="batch-list" rows="3" placeholder="Q,W,E,R,T,Y..."></textarea><div style="font-size:0.7em; color:#aaa; text-align:right;" data-i18n="note_batch">‚ÄªÁèæÂú®„ÅÆË®≠ÂÆö„ÅßÈÄ£Á∂öÁîüÊàê„Åó„Åæ„Åô</div></div>
            <button id="btn-batch-export" class="accent" data-i18n="btn_batch_run" data-hint="hint_batch_run">‰∏ÄÊã¨ÁîüÊàê</button>
            </div><!-- end of normal-mode-content -->
        </div>
    </div>

    <!-- V67.3: MeshFixLib - „É°„ÉÉ„Ç∑„É•‰øÆÂæ©„É©„Ç§„Éñ„É©„É™ -->
    <script src="mesh-fix-lib.js"></script>

    <script type="module">
import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLExporter } from 'three/addons/exporters/STLExporter.js';
        import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { SUBTRACTION, ADDITION, Brush, Evaluator } from 'three-bvh-csg';
        
        // V67.3: MeshFixLib„Ç§„É≥„Çπ„Çø„É≥„ÇπÔºàÂ§ñÈÉ®„Éï„Ç°„Ç§„É´„Åã„ÇâË™≠„ÅøËæº„ÅøÔºâ
        const meshFixLib = new MeshFixLib();
        
        let manifoldModule = null;
        let Manifold = null;
        
        // MeshFix WASM for high-quality mesh repair
        let meshfixModule = null;
        let meshfixReady = false;
        
        async function initMeshFix() {
            try {
                console.log('MeshFix: Loading WASM module...');
                showToast('MeshFix‰øÆÂæ©„Ç®„É≥„Ç∏„É≥„ÇíÂàùÊúüÂåñ‰∏≠...', false);
                
                meshfixModule = await MeshFixModule();
                meshfixReady = true;
                
                console.log('MeshFix WASM: Ready!');
                showToast('MeshFix‰øÆÂæ©„Ç®„É≥„Ç∏„É≥Ê∫ñÂÇôÂÆå‰∫Ü', false);
            } catch (e) {
                console.error('MeshFix init failed:', e);
                meshfixReady = false;
            }
        }
        
        // MeshFix„Åß„É°„ÉÉ„Ç∑„É•„Çí‰øÆÂæ©ÔºàÈ´òÂìÅË≥™„ÄÅÂÖÉ„ÅÆ„Ç∏„Ç™„É°„Éà„É™„Çí‰øùÊåÅÔºâ
        // STL„Éï„Ç°„Ç§„É´ÁµåÁî±„Åß„Éá„Éº„Çø„ÇíÊ∏°„ÅôÊñπÂºè
        function repairWithMeshFix(geometry) {
            if (!meshfixReady || !meshfixModule) {
                console.log('MeshFix not ready');
                return null;
            }
            
            try {
                // BufferGeometry„Çí„Éê„Ç§„Éä„É™STL„Å´Â§âÊèõ
                const stlData = geometryToBinarySTL(geometry);
                if (!stlData) {
                    console.error('MeshFix: Failed to convert geometry to STL');
                    return null;
                }
                
                console.log(`MeshFix: STL size = ${stlData.byteLength} bytes`);
                
                // STL„Éá„Éº„Çø„ÇíWASM„É°„É¢„É™„Å´„Ç≥„Éî„Éº
                const stlPtr = meshfixModule._malloc(stlData.byteLength);
                const stlHeap = new Uint8Array(
                    meshfixModule.HEAPU8.buffer,
                    stlPtr,
                    stlData.byteLength
                );
                stlHeap.set(new Uint8Array(stlData));
                
                // ‰øÆÂæ©ÂÆüË°å (joinComponents=0, fillHoles=0)
                // Á©¥Âüã„ÇÅ„ÇíÁÑ°Âäπ„Å´„Åó„Å¶„Çπ„ÉÜ„É†Á©¥„Çí‰øùÊåÅ
                const result = meshfixModule._repair_mesh_from_stl(stlPtr, stlData.byteLength, 0, 0);
                
                // ÂÖ•Âäõ„Éê„ÉÉ„Éï„Ç°„ÇíËß£Êîæ
                meshfixModule._free(stlPtr);
                
                if (result !== 0) {
                    console.error('MeshFix: Repair failed with code', result);
                    meshfixModule._cleanup();
                    return null;
                }
                
                // Âá∫Âäõ„ÇíÂèñÂæó
                const outputVertexCount = meshfixModule._get_output_vertex_count();
                const outputFaceCount = meshfixModule._get_output_face_count();
                
                console.log(`MeshFix: Output ${outputVertexCount} vertices, ${outputFaceCount} faces`);
                
                const outputVertexPtr = meshfixModule._get_output_vertices();
                const outputFacePtr = meshfixModule._get_output_faces();
                
                // Âá∫Âäõ„Éá„Éº„Çø„Çí„Ç≥„Éî„Éº
                const outputVertices = new Float32Array(outputVertexCount * 3);
                const outputFaces = new Int32Array(outputFaceCount * 3);
                
                const outputVertexHeap = new Float32Array(
                    meshfixModule.HEAPF32.buffer,
                    outputVertexPtr,
                    outputVertexCount * 3
                );
                outputVertices.set(outputVertexHeap);
                
                const outputFaceHeap = new Int32Array(
                    meshfixModule.HEAP32.buffer,
                    outputFacePtr,
                    outputFaceCount * 3
                );
                outputFaces.set(outputFaceHeap);
                
                // „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
                meshfixModule._cleanup();
                
                // Êñ∞„Åó„ÅÑBufferGeometry„Çí‰ΩúÊàê
                const newGeometry = new THREE.BufferGeometry();
                newGeometry.setAttribute('position', new THREE.BufferAttribute(outputVertices, 3));
                newGeometry.setIndex(new THREE.BufferAttribute(outputFaces, 1));
                newGeometry.computeVertexNormals();
                
                console.log('MeshFix: Repair successful!');
                return newGeometry;
                
            } catch (error) {
                console.error('MeshFix: Error during repair:', error);
                if (meshfixModule) meshfixModule._cleanup();
                return null;
            }
        }
        
        // BufferGeometry„Çí„Éê„Ç§„Éä„É™STLÂΩ¢Âºè„Å´Â§âÊèõ
        function geometryToBinarySTL(geometry) {
            const position = geometry.getAttribute('position');
            const index = geometry.getIndex();
            
            let numTriangles;
            if (index) {
                numTriangles = index.count / 3;
            } else {
                numTriangles = position.count / 3;
            }
            
            // „Éê„Ç§„Éä„É™STL„Éï„Ç©„Éº„Éû„ÉÉ„Éà: 80„Éê„Ç§„Éà„Éò„ÉÉ„ÉÄ + 4„Éê„Ç§„Éà‰∏âËßíÂΩ¢Êï∞ + (50„Éê„Ç§„Éà √ó ‰∏âËßíÂΩ¢Êï∞)
            const bufferSize = 80 + 4 + (50 * numTriangles);
            const buffer = new ArrayBuffer(bufferSize);
            const view = new DataView(buffer);
            
            // „Éò„ÉÉ„ÉÄ„ÉºÔºà80„Éê„Ç§„Éà„ÄÅÁ©∫Ôºâ
            // „Åù„ÅÆ„Åæ„Åæ0„ÅßÂüã„ÇÅ„Çã
            
            // ‰∏âËßíÂΩ¢Êï∞Ôºà4„Éê„Ç§„Éà„ÄÅ„É™„Éà„É´„Ç®„É≥„Éá„Ç£„Ç¢„É≥Ôºâ
            view.setUint32(80, numTriangles, true);
            
            let offset = 84;
            
            const vA = new THREE.Vector3();
            const vB = new THREE.Vector3();
            const vC = new THREE.Vector3();
            const normal = new THREE.Vector3();
            const cb = new THREE.Vector3();
            const ab = new THREE.Vector3();
            
            for (let i = 0; i < numTriangles; i++) {
                let a, b, c;
                if (index) {
                    a = index.getX(i * 3);
                    b = index.getX(i * 3 + 1);
                    c = index.getX(i * 3 + 2);
                } else {
                    a = i * 3;
                    b = i * 3 + 1;
                    c = i * 3 + 2;
                }
                
                vA.fromBufferAttribute(position, a);
                vB.fromBufferAttribute(position, b);
                vC.fromBufferAttribute(position, c);
                
                // Ê≥ïÁ∑ö„ÇíË®àÁÆó
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                normal.crossVectors(cb, ab).normalize();
                
                // Ê≥ïÁ∑öÔºà12„Éê„Ç§„ÉàÔºâ
                view.setFloat32(offset, normal.x, true); offset += 4;
                view.setFloat32(offset, normal.y, true); offset += 4;
                view.setFloat32(offset, normal.z, true); offset += 4;
                
                // È†ÇÁÇπAÔºà12„Éê„Ç§„ÉàÔºâ
                view.setFloat32(offset, vA.x, true); offset += 4;
                view.setFloat32(offset, vA.y, true); offset += 4;
                view.setFloat32(offset, vA.z, true); offset += 4;
                
                // È†ÇÁÇπBÔºà12„Éê„Ç§„ÉàÔºâ
                view.setFloat32(offset, vB.x, true); offset += 4;
                view.setFloat32(offset, vB.y, true); offset += 4;
                view.setFloat32(offset, vB.z, true); offset += 4;
                
                // È†ÇÁÇπCÔºà12„Éê„Ç§„ÉàÔºâ
                view.setFloat32(offset, vC.x, true); offset += 4;
                view.setFloat32(offset, vC.y, true); offset += 4;
                view.setFloat32(offset, vC.z, true); offset += 4;
                
                // Â±ûÊÄß„Éê„Ç§„ÉàÔºà2„Éê„Ç§„Éà„ÄÅ0Ôºâ
                view.setUint16(offset, 0, true); offset += 2;
            }
            
            return buffer;
        }
        
        // Pyodide + trimesh for mesh repair
        let pyodide = null;
        let trimeshReady = false;
        
        async function initPyodide() {
            try {
                console.log('Pyodide: Loading with extended memory...');
                showToast('„É°„ÉÉ„Ç∑„É•‰øÆÂæ©„Ç®„É≥„Ç∏„É≥„ÇíÂàùÊúüÂåñ‰∏≠...', false);
                
                // Pyodide„Çí„É≠„Éº„ÉâÔºà„É°„É¢„É™„ÅØËá™ÂãïÊã°Âºµ„Åï„Çå„ÇãÔºâ
                pyodide = await loadPyodide({
                    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
                });
                
                console.log('Pyodide: Memory initialized');
                
                console.log('Pyodide: Installing packages...');
                
                // micropip„Åßtrimesh„Çí„Ç§„É≥„Çπ„Éà„Éº„É´
                await pyodide.loadPackage('micropip');
                await pyodide.loadPackage('networkx');  // networkx„ÅØPyodide„Å´Âê´„Åæ„Çå„Å¶„ÅÑ„Çã
                // scipy, scikit-image„ÅØ„Éú„ÇØ„Çª„É´‰øÆÂæ©Áî®„Å†„ÅåÂìÅË≥™„Åå‰Ωé‰∏ã„Åô„Çã„Åü„ÇÅ‰ΩøÁî®„Åó„Å™„ÅÑ
                console.log('Pyodide: Core packages loaded');
                await pyodide.runPythonAsync(`
import micropip
await micropip.install('trimesh')
await micropip.install('numpy')
                `);
                
                // ‰øÆÂæ©Èñ¢Êï∞„ÇíÂÆöÁæ©
                await pyodide.runPythonAsync(`
import trimesh
import numpy as np
import networkx as nx
from collections import defaultdict

def find_non_manifold_edges(faces):
    """ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„ÇíÊ§úÂá∫"""
    edge_faces = defaultdict(list)
    for fi, face in enumerate(faces):
        for i in range(3):
            v1, v2 = face[i], face[(i+1)%3]
            edge = tuple(sorted([v1, v2]))
            edge_faces[edge].append(fi)
    
    non_manifold = []
    boundary = []
    for edge, face_list in edge_faces.items():
        if len(face_list) > 2:
            non_manifold.append((edge, face_list))
        elif len(face_list) == 1:
            boundary.append((edge, face_list))
    return non_manifold, boundary, edge_faces

def split_non_manifold_vertices(vertices, faces):
    """
    ÈùûÂ§öÊßò‰ΩìÈ†ÇÁÇπ„ÇíÂàÜÈõ¢„Åó„Å¶Êñ∞„Åó„ÅÑÈ†ÇÁÇπ„Çí‰ΩúÊàê
    """
    vertices = np.array(vertices, dtype=np.float64)
    faces = np.array(faces, dtype=np.int32)
    
    non_manifold_edges, boundary_edges, edge_faces = find_non_manifold_edges(faces)
    
    if not non_manifold_edges:
        return vertices.tolist(), faces.tolist()
    
    # ÂïèÈ°å„ÅÆ„ÅÇ„ÇãÈù¢„ÇíÁâπÂÆö
    problem_faces = set()
    for edge, face_list in non_manifold_edges:
        for fi in face_list[2:]:
            problem_faces.add(fi)
    
    # ÂïèÈ°å„ÅÆ„ÅÇ„ÇãÈù¢„ÇíÂâäÈô§
    new_faces = []
    for fi, face in enumerate(faces):
        if fi not in problem_faces:
            new_faces.append(face.tolist())
    
    return vertices.tolist(), new_faces

def repair_with_voxels(mesh, pitch=0.1):
    """
    „Éú„ÇØ„Çª„É´Âåñ„Å´„Çà„Çã‰øÆÂæ©ÔºàÊúÄ„ÇÇÂº∑ÂäõÔºâ
    „É°„ÉÉ„Ç∑„É•„Çí„Éú„ÇØ„Çª„É´Âåñ„Åó„Å¶ÂÜçÊßãÁØâ„Åô„Çã„Åì„Å®„Åß
    ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„ÇíÂÆåÂÖ®„Å´Èô§Âéª
    """
    try:
        # „Éú„ÇØ„Çª„É´Âåñ
        voxelized = mesh.voxelized(pitch=pitch)
        # „Éû„Éº„ÉÅ„É≥„Ç∞„Ç≠„É•„Éº„Éñ„ÅßÂÜçÊßãÁØâ
        repaired = voxelized.marching_cubes
        return repaired
    except Exception as e:
        return None

def aggressive_repair(vertices, faces):
    """
    ÊúÄ„ÇÇÁ©çÊ•µÁöÑ„Å™ÈùûÂ§öÊßò‰Ωì‰øÆÂæ©
    """
    try:
        # Step 1: Âü∫Êú¨„É°„ÉÉ„Ç∑„É•‰ΩúÊàê
        mesh = trimesh.Trimesh(
            vertices=np.array(vertices, dtype=np.float64),
            faces=np.array(faces, dtype=np.int32),
            process=False
        )
        
        # Step 2: Âü∫Êú¨„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        mesh.merge_vertices()
        mesh.update_faces(mesh.nondegenerate_faces())
        try:
            mesh.update_faces(mesh.unique_faces()[0])
        except:
            pass
        mesh.remove_unreferenced_vertices()
        
        # Step 3: ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„ÇíÊ§úÂá∫„Éª‰øÆÂæ©
        max_iterations = 10
        iteration = 0
        for iteration in range(max_iterations):
            current_verts = mesh.vertices.copy()
            current_faces = mesh.faces.copy()
            
            nm_edges, boundary_edges, _ = find_non_manifold_edges(current_faces)
            
            if not nm_edges:
                break
            
            new_verts, new_faces = split_non_manifold_vertices(
                current_verts, current_faces
            )
            
            if len(new_faces) == len(current_faces):
                problem_faces = set()
                for edge, face_list in nm_edges:
                    for fi in face_list[2:]:
                        problem_faces.add(fi)
                
                new_faces = [f.tolist() for i, f in enumerate(current_faces) if i not in problem_faces]
            
            mesh = trimesh.Trimesh(
                vertices=np.array(new_verts, dtype=np.float64),
                faces=np.array(new_faces, dtype=np.int32),
                process=False
            )
            mesh.remove_unreferenced_vertices()
        
        # Step 4: Ê≥ïÁ∑ö‰øÆÊ≠£
        try:
            trimesh.repair.fix_normals(mesh)
            trimesh.repair.fix_winding(mesh)
        except:
            pass
        
        # Step 5: Á©¥Âüã„ÇÅ
        try:
            trimesh.repair.fill_holes(mesh)
        except:
            pass
        
        # Step 6: ÊúÄÁµÇ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        mesh.merge_vertices()
        mesh.update_faces(mesh.nondegenerate_faces())
        mesh.remove_unreferenced_vertices()
        
        # ÊúÄÁµÇÁ¢∫Ë™ç
        final_nm, final_boundary, _ = find_non_manifold_edges(mesh.faces)
        
        return {
            'vertices': mesh.vertices.tolist(),
            'faces': mesh.faces.tolist(),
            'is_watertight': mesh.is_watertight,
            'euler_number': int(mesh.euler_number) if hasattr(mesh, 'euler_number') else 0,
            'non_manifold_edges': len(final_nm),
            'boundary_edges': len(final_boundary),
            'iterations': iteration + 1
        }
    except Exception as e:
        return {'error': str(e)}

def voxel_repair(vertices, faces, pitch=0.05):
    """
    „Éú„ÇØ„Çª„É´Âåñ„Å´„Çà„ÇãÂÆåÂÖ®‰øÆÂæ©
    ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„Çí100%Èô§Âéª„Åß„Åç„Çã„Åå„ÄÅÂΩ¢Áä∂Á≤æÂ∫¶„ÅåËã•Âπ≤‰Ωé‰∏ã
    """
    try:
        mesh = trimesh.Trimesh(
            vertices=np.array(vertices, dtype=np.float64),
            faces=np.array(faces, dtype=np.int32),
            process=True
        )
        
        # ÂÖÉ„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂèñÂæó
        original_bounds = mesh.bounds
        original_extents = mesh.extents
        
        # „Éú„ÇØ„Çª„É´ÂåñÔºà„Éî„ÉÉ„ÉÅ„ÇíËá™ÂãïË™øÊï¥Ôºâ
        # „É°„ÉÉ„Ç∑„É•„Çµ„Ç§„Ç∫„Å´Âü∫„Å•„ÅÑ„Å¶„Éî„ÉÉ„ÉÅ„ÇíË™øÊï¥
        # „Éî„ÉÉ„ÉÅ„ÅåÂ§ß„Åç„ÅÑ„Åª„Å©„É°„É¢„É™‰ΩøÁî®Èáè„ÅåÊ∏õ„ÇãÔºàÁ≤æÂ∫¶„ÅØ‰∏ã„Åå„ÇãÔºâ
        auto_pitch = min(original_extents) / 50  # „É°„ÉÉ„Ç∑„É•„ÅÆÊúÄÂ∞èÂØ∏Ê≥ï„ÅÆ2%
        auto_pitch = max(auto_pitch, 0.1)  # ÊúÄÂ∞è0.1mmÔºà„É°„É¢„É™ÁØÄÁ¥Ñ„ÅÆ„Åü„ÇÅÂ§ß„Åç„ÅèÔºâ
        auto_pitch = min(auto_pitch, 0.5)   # ÊúÄÂ§ß0.5mm
        
        print(f"voxel_repair: Using pitch={auto_pitch:.3f}mm, extents={original_extents}")
        
        voxelized = mesh.voxelized(pitch=auto_pitch)
        repaired = voxelized.marching_cubes
        
        if repaired is None:
            return {'error': 'Marching cubes failed'}
        
        # ÂÖÉ„ÅÆ„Çπ„Ç±„Éº„É´„Å´Âêà„Çè„Åõ„Çã
        repaired_extents = repaired.extents
        scale_factor = original_extents / repaired_extents
        repaired.apply_scale(scale_factor)
        
        # ÂÖÉ„ÅÆ‰ΩçÁΩÆ„Å´Âêà„Çè„Åõ„Çã
        repaired_center = repaired.centroid
        original_center = (original_bounds[0] + original_bounds[1]) / 2
        repaired.apply_translation(original_center - repaired_center)
        
        # ÊúÄÁµÇÁ¢∫Ë™ç
        final_nm, final_boundary, _ = find_non_manifold_edges(repaired.faces)
        
        return {
            'vertices': repaired.vertices.tolist(),
            'faces': repaired.faces.tolist(),
            'is_watertight': repaired.is_watertight,
            'euler_number': int(repaired.euler_number) if hasattr(repaired, 'euler_number') else 0,
            'non_manifold_edges': len(final_nm),
            'boundary_edges': len(final_boundary),
            'pitch_used': auto_pitch
        }
    except Exception as e:
        return {'error': str(e)}

def fill_all_holes(vertices, faces):
    """
    „Åô„Åπ„Å¶„ÅÆÁ©¥ÔºàÂ¢ÉÁïå„Ç®„ÉÉ„Ç∏Ôºâ„ÇíÂüã„ÇÅ„Çã
    Bambu Studio/PrusaSlicer„ÅÆ‰øÆÂæ©Ê©üËÉΩ„Å®ÂêåÁ≠â
    """
    try:
        mesh = trimesh.Trimesh(
            vertices=np.array(vertices, dtype=np.float64),
            faces=np.array(faces, dtype=np.int32),
            process=True
        )
        
        # Á©¥Âüã„ÇÅ„ÇíÁπ∞„ÇäËøî„ÅóÂÆüË°å
        max_iterations = 20
        for i in range(max_iterations):
            # ÁèæÂú®„ÅÆÂ¢ÉÁïå„Ç®„ÉÉ„Ç∏Êï∞„ÇíÁ¢∫Ë™ç
            edges = mesh.edges_unique
            edges_face_count = mesh.edges_unique_length
            
            # Á©¥Âüã„ÇÅÂÆüË°å
            try:
                trimesh.repair.fill_holes(mesh)
            except:
                pass
            
            # Ê∞¥ÂØÜ„Å´„Å™„Å£„Åü„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if mesh.is_watertight:
                break
        
        # Ê≥ïÁ∑ö„Çí‰øÆÊ≠£
        trimesh.repair.fix_normals(mesh)
        trimesh.repair.fix_winding(mesh)
        
        # ÊúÄÁµÇÁ¢∫Ë™ç
        final_nm, final_boundary, _ = find_non_manifold_edges(mesh.faces)
        
        return {
            'vertices': mesh.vertices.tolist(),
            'faces': mesh.faces.tolist(),
            'is_watertight': mesh.is_watertight,
            'euler_number': int(mesh.euler_number) if hasattr(mesh, 'euler_number') else 0,
            'non_manifold_edges': len(final_nm),
            'boundary_edges': len(final_boundary)
        }
    except Exception as e:
        return {'error': str(e)}

def repair_mesh(vertices, faces):
    """Âü∫Êú¨‰øÆÂæ©"""
    try:
        mesh = trimesh.Trimesh(
            vertices=np.array(vertices, dtype=np.float64),
            faces=np.array(faces, dtype=np.int32),
            process=True
        )
        
        trimesh.repair.fill_holes(mesh)
        trimesh.repair.fix_winding(mesh)
        trimesh.repair.fix_normals(mesh)
        
        if not mesh.is_watertight:
            components = mesh.split(only_watertight=False)
            if len(components) > 1:
                mesh = trimesh.util.concatenate(components)
        
        return {
            'vertices': mesh.vertices.tolist(),
            'faces': mesh.faces.tolist(),
            'is_watertight': mesh.is_watertight,
            'euler_number': mesh.euler_number
        }
    except Exception as e:
        return {'error': str(e)}

def advanced_repair_mesh(vertices, faces):
    """
    ÊúÄÂ∞èÈôê„ÅÆ‰øÆÂæ©„ÅÆ„ÅøÔºàÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏‰øÆÂæ©„ÅØ„Çπ„Ç≠„ÉÉ„ÉóÔºâ
    Bambu Studio„Å´‰øÆÂæ©„Çí‰ªª„Åõ„Çã
    """
    print("advanced_repair_mesh: Minimal repair (let slicer handle non-manifold)...")
    
    mesh = trimesh.Trimesh(
        vertices=np.array(vertices, dtype=np.float64),
        faces=np.array(faces, dtype=np.int32),
        process=True
    )
    
    # Âü∫Êú¨„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„ÅÆ„Åø
    mesh.merge_vertices()
    mesh.update_faces(mesh.nondegenerate_faces())
    mesh.remove_unreferenced_vertices()
    
    # Ê≥ïÁ∑ö‰øÆÊ≠£
    try:
        trimesh.repair.fix_normals(mesh)
        trimesh.repair.fix_winding(mesh)
    except:
        pass
    
    # Á¢∫Ë™ç
    nm, boundary, _ = find_non_manifold_edges(mesh.faces)
    print(f"advanced_repair_mesh: Final - {len(nm)} non-manifold, {len(boundary)} boundary (no repair attempted)")
    
    return {
        'vertices': mesh.vertices.tolist(),
        'faces': mesh.faces.tolist(),
        'is_watertight': mesh.is_watertight,
        'euler_number': int(mesh.euler_number) if hasattr(mesh, 'euler_number') else 0,
        'non_manifold_edges': len(nm),
        'boundary_edges': len(boundary)
    }

def fill_holes_except_stem(vertices, faces):
    """
    „Çπ„ÉÜ„É†„ÅÆÂçÅÂ≠óÁ©¥„ÅÆ„Åø„ÇíÈô§Â§ñ„Åó„Å¶‰ªñ„ÅÆÁ©¥„ÇíÈñâ„Åò„Çã
    ÂçÅÂ≠óÁ©¥„ÅÆÊ§úÂá∫: „Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆXZ‰∏≠ÂøÉ‰ªòËøë„ÄÅYÂ∫ßÊ®ô„ÅåÂ∫ïÈù¢‰ªòËøë„Å´„ÅÇ„ÇãÁ©¥
    """
    try:
        mesh = trimesh.Trimesh(
            vertices=np.array(vertices, dtype=np.float64),
            faces=np.array(faces, dtype=np.int32),
            process=True
        )
        
        # „É°„ÉÉ„Ç∑„É•„ÅÆ„Éê„Ç¶„É≥„Éá„Ç£„É≥„Ç∞„Éú„ÉÉ„ÇØ„Çπ„ÇíÂèñÂæó
        bounds = mesh.bounds
        x_min, y_min, z_min = bounds[0]
        x_max, y_max, z_max = bounds[1]
        
        # „Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆ‰∏≠ÂøÉÔºàXZÂπ≥Èù¢Ôºâ- YËª∏„ÅØÈ´ò„Åï
        center_x = (x_min + x_max) / 2
        center_z = (z_min + z_max) / 2
        y_range = y_max - y_min
        
        # „Çπ„ÉÜ„É†ÂçÅÂ≠óÁ©¥„ÅÆÂà§ÂÆö„Éë„É©„É°„Éº„Çø
        # Cherry MX„Çπ„ÉÜ„É†„ÅÆÂçÅÂ≠óÁ©¥: Á¥Ñ4.0mm x 1.17mmÔºàÂ∫ïÈù¢‰∏≠ÂøÉ„Å´„ÅÇ„ÇãÔºâ
        stem_center_tolerance_xz = 2.0  # XZ‰∏≠ÂøÉ„Åã„Çâ2mm‰ª•ÂÜÖ
        stem_y_threshold = y_min + 1.0  # Â∫ïÈù¢„Åã„Çâ1mm‰ª•ÂÜÖÔºàÈùûÂ∏∏„Å´Âé≥„Åó„ÅèÔºâ
        stem_max_size_xz = 5.0  # XZÊñπÂêë„ÅÆÊúÄÂ§ß„Çµ„Ç§„Ç∫5mm‰ª•‰∏ã
        
        print(f"fill_holes_except_stem: bounds x=[{x_min:.2f}, {x_max:.2f}], y=[{y_min:.2f}, {y_max:.2f}], z=[{z_min:.2f}, {z_max:.2f}]")
        print(f"fill_holes_except_stem: XZ center=({center_x:.2f}, {center_z:.2f}), stem_y_threshold={stem_y_threshold:.2f}")
        
        # Â¢ÉÁïå„Ç®„ÉÉ„Ç∏„ÇíÊ§úÂá∫
        try:
            edges_sorted = np.sort(mesh.edges, axis=1)
            edges_tuple = [tuple(e) for e in edges_sorted]
            from collections import Counter
            edge_counts = Counter(edges_tuple)
            boundary_edges_list = [list(e) for e, count in edge_counts.items() if count == 1]
            boundary_edges = np.array(boundary_edges_list) if boundary_edges_list else np.array([]).reshape(0, 2)
        except Exception as e:
            print(f"fill_holes_except_stem: Edge detection error: {e}")
            boundary_edges = np.array([]).reshape(0, 2)
        
        if len(boundary_edges) == 0:
            print("fill_holes_except_stem: No boundary edges found")
            final_nm, final_boundary, _ = find_non_manifold_edges(mesh.faces)
            return {
                'vertices': mesh.vertices.tolist(),
                'faces': mesh.faces.tolist(),
                'is_watertight': mesh.is_watertight,
                'non_manifold_edges': len(final_nm),
                'boundary_edges': len(final_boundary)
            }
        
        print(f"fill_holes_except_stem: Found {len(boundary_edges)} boundary edges")
        
        # Â¢ÉÁïå„É´„Éº„Éó„ÇíÂΩ¢Êàê
        boundary_loops = []
        used_edges = set()
        
        for i in range(len(boundary_edges)):
            if i in used_edges:
                continue
            
            edge = boundary_edges[i]
            loop = [int(edge[0]), int(edge[1])]
            used_edges.add(i)
            
            max_iterations = len(boundary_edges) * 2
            iteration = 0
            
            while iteration < max_iterations:
                iteration += 1
                current_vertex = loop[-1]
                found_next = False
                
                for j in range(len(boundary_edges)):
                    if j in used_edges:
                        continue
                    
                    e = boundary_edges[j]
                    if int(e[0]) == current_vertex:
                        next_v = int(e[1])
                        if next_v == loop[0]:
                            used_edges.add(j)
                            found_next = False
                            break
                        loop.append(next_v)
                        used_edges.add(j)
                        found_next = True
                        break
                    elif int(e[1]) == current_vertex:
                        next_v = int(e[0])
                        if next_v == loop[0]:
                            used_edges.add(j)
                            found_next = False
                            break
                        loop.append(next_v)
                        used_edges.add(j)
                        found_next = True
                        break
                
                if not found_next:
                    break
            
            if len(loop) >= 3:
                boundary_loops.append(loop)
        
        print(f"fill_holes_except_stem: Found {len(boundary_loops)} boundary loops")
        
        # ÂêÑ„É´„Éº„Éó„ÇíÂàÜÈ°ûÔºà„Çπ„ÉÜ„É†ÂçÅÂ≠óÁ©¥ vs „Åù„ÅÆ‰ªñÔºâ
        stem_loops = []
        other_loops = []
        
        for loop in boundary_loops:
            loop_vertices = mesh.vertices[loop]
            
            # „É´„Éº„Éó„ÅÆ3D„Éê„Ç¶„É≥„Éá„Ç£„É≥„Ç∞„Éú„ÉÉ„ÇØ„Çπ
            loop_x_min, loop_y_min, loop_z_min = loop_vertices.min(axis=0)
            loop_x_max, loop_y_max, loop_z_max = loop_vertices.max(axis=0)
            
            # „É´„Éº„Éó„ÅÆ‰∏≠ÂøÉÔºà3DÔºâ
            loop_center_x = (loop_x_min + loop_x_max) / 2
            loop_center_y = (loop_y_min + loop_y_max) / 2
            loop_center_z = (loop_z_min + loop_z_max) / 2
            
            # „É´„Éº„Éó„ÅÆ„Çµ„Ç§„Ç∫
            loop_size_x = loop_x_max - loop_x_min
            loop_size_y = loop_y_max - loop_y_min
            loop_size_z = loop_z_max - loop_z_min
            loop_max_size_xz = max(loop_size_x, loop_size_z)
            
            # XZÂπ≥Èù¢„Åß„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó‰∏≠ÂøÉ„Åã„Çâ„ÅÆË∑ùÈõ¢
            dist_from_center_xz = ((loop_center_x - center_x)**2 + (loop_center_z - center_z)**2)**0.5
            
            # „Çπ„ÉÜ„É†ÂçÅÂ≠óÁ©¥Âà§ÂÆöÔºàÈùûÂ∏∏„Å´Âé≥„Åó„ÅèÔºâ:
            # 1. XZÂπ≥Èù¢„Åß„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆ‰∏≠ÂøÉ‰ªòËøë„Å´„ÅÇ„Çã
            # 2. YÂ∫ßÊ®ô„ÅåÂ∫ïÈù¢‰ªòËøë„Å´„ÅÇ„ÇãÔºà„Çπ„ÉÜ„É†„ÅØÂ∫ïÈù¢„Å´„ÅÇ„ÇãÔºâ
            # 3. XZ„Çµ„Ç§„Ç∫„Åå„Çπ„ÉÜ„É†Á©¥„Çµ„Ç§„Ç∫‰ª•‰∏ã
            is_at_xz_center = dist_from_center_xz < stem_center_tolerance_xz
            is_at_bottom = loop_y_max < stem_y_threshold  # ÊúÄÂ§ßYÂ∫ßÊ®ô„ÅåÈñæÂÄ§‰ª•‰∏ã
            is_stem_size = loop_max_size_xz < stem_max_size_xz
            
            is_stem_cross = is_at_xz_center and is_at_bottom and is_stem_size
            
            if is_stem_cross:
                stem_loops.append(loop)
                print(f"  STEM CROSS HOLE (preserved): {len(loop)} verts, Y_max={loop_y_max:.2f}")
            else:
                other_loops.append(loop)
        
        print(f"fill_holes_except_stem: {len(stem_loops)} stem cross holes (preserved), {len(other_loops)} other holes (to fill)")
        
        if len(other_loops) == 0:
            print("fill_holes_except_stem: No holes to fill")
            final_nm, final_boundary, _ = find_non_manifold_edges(mesh.faces)
            return {
                'vertices': mesh.vertices.tolist(),
                'faces': mesh.faces.tolist(),
                'is_watertight': mesh.is_watertight,
                'non_manifold_edges': len(final_nm),
                'boundary_edges': len(final_boundary)
            }
        
        # ÊâãÂãï„Åß„Éï„Ç°„É≥‰∏âËßíÂΩ¢„Çí‰ΩúÊàê„Åó„Å¶Á©¥„ÇíÂüã„ÇÅ„Çã
        new_vertices = mesh.vertices.tolist()
        new_faces = mesh.faces.tolist()
        filled_count = 0
        
        for loop in other_loops:
            if len(loop) < 3:
                continue
            
            # „É´„Éº„Éó„ÅÆÈ†ÇÁÇπÂ∫ßÊ®ô„ÇíÂèñÂæó
            loop_verts = np.array([new_vertices[i] for i in loop])
            
            # ‰∏≠ÂøÉÁÇπ„ÇíË®àÁÆó
            center = loop_verts.mean(axis=0)
            center_idx = len(new_vertices)
            new_vertices.append(center.tolist())
            
            # „É´„Éº„Éó„ÅÆÊ≥ïÁ∑ö„ÇíË®àÁÆóÔºàÈö£Êé•Èù¢„Åã„ÇâÊé®ÂÆöÔºâ
            # ÊúÄÂàù„ÅÆÊï∞È†ÇÁÇπ„ÅßÊ≥ïÁ∑öÊñπÂêë„ÇíÊé®ÂÆö
            v0 = loop_verts[0]
            v1 = loop_verts[1]
            v2 = loop_verts[len(loop)//2] if len(loop) > 2 else loop_verts[2]
            
            edge1 = v1 - v0
            edge2 = v2 - v0
            loop_normal = np.cross(edge1, edge2)
            loop_normal_len = np.linalg.norm(loop_normal)
            
            if loop_normal_len > 0:
                loop_normal = loop_normal / loop_normal_len
            else:
                loop_normal = np.array([0, 1, 0])  # „Éá„Éï„Ç©„É´„Éà„ÅØ‰∏äÂêë„Åç
            
            # „Éï„Ç°„É≥‰∏âËßíÂΩ¢„Çí‰ΩúÊàê
            for i in range(len(loop)):
                v1_idx = loop[i]
                v2_idx = loop[(i + 1) % len(loop)]
                
                # ‰∏âËßíÂΩ¢„ÅÆÊ≥ïÁ∑ö„ÇíË®àÁÆó„Åó„Å¶„ÄÅ„É´„Éº„ÉóÊ≥ïÁ∑ö„Å®‰∏ÄËá¥„Åï„Åõ„Çã
                tri_v0 = np.array(new_vertices[v1_idx])
                tri_v1 = np.array(new_vertices[v2_idx])
                tri_v2 = center
                
                tri_edge1 = tri_v1 - tri_v0
                tri_edge2 = tri_v2 - tri_v0
                tri_normal = np.cross(tri_edge1, tri_edge2)
                
                # Ê≥ïÁ∑ö„ÅÆÂêë„Åç„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                if np.dot(tri_normal, loop_normal) >= 0:
                    new_faces.append([v1_idx, v2_idx, center_idx])
                else:
                    new_faces.append([v2_idx, v1_idx, center_idx])
            
            filled_count += 1
        
        print(f"fill_holes_except_stem: Filled {filled_count} holes with fan triangles")
        
        # Êñ∞„Åó„ÅÑ„É°„ÉÉ„Ç∑„É•„Çí‰ΩúÊàê
        mesh = trimesh.Trimesh(
            vertices=np.array(new_vertices, dtype=np.float64),
            faces=np.array(new_faces, dtype=np.int32),
            process=True
        )
        
        # „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        mesh.merge_vertices()
        mesh.update_faces(mesh.nondegenerate_faces())
        mesh.remove_unreferenced_vertices()
        
        # Ê≥ïÁ∑ö‰øÆÊ≠£
        try:
            trimesh.repair.fix_normals(mesh)
            trimesh.repair.fix_winding(mesh)
        except:
            pass
        
        # ÊúÄÁµÇÁ¢∫Ë™ç
        final_nm, final_boundary, _ = find_non_manifold_edges(mesh.faces)
        
        print(f"fill_holes_except_stem: Final result - {len(final_nm)} non-manifold, {len(final_boundary)} boundary edges")
        
        return {
            'vertices': mesh.vertices.tolist(),
            'faces': mesh.faces.tolist(),
            'is_watertight': mesh.is_watertight,
            'euler_number': int(mesh.euler_number) if hasattr(mesh, 'euler_number') else 0,
            'non_manifold_edges': len(final_nm),
            'boundary_edges': len(final_boundary)
        }
    except Exception as e:
        import traceback
        print(f"fill_holes_except_stem error: {e}")
        traceback.print_exc()
        return {'error': str(e)}

def voxel_repair_with_pitch(vertices, faces, pitch):
    """
    ÊåáÂÆö„Åó„Åü„Éî„ÉÉ„ÉÅ„Åß„Éú„ÇØ„Çª„É´‰øÆÂæ©„ÇíÂÆüË°å
    """
    try:
        mesh = trimesh.Trimesh(
            vertices=np.array(vertices, dtype=np.float64),
            faces=np.array(faces, dtype=np.int32),
            process=True
        )
        
        original_bounds = mesh.bounds
        original_extents = mesh.extents
        
        print(f"voxel_repair_with_pitch: Using pitch={pitch:.3f}mm, extents={original_extents}")
        
        voxelized = mesh.voxelized(pitch=pitch)
        repaired = voxelized.marching_cubes
        
        if repaired is None:
            return {'error': 'Marching cubes failed'}
        
        # ÂÖÉ„ÅÆ„Çπ„Ç±„Éº„É´„Å´Âêà„Çè„Åõ„Çã
        repaired_extents = repaired.extents
        scale_factor = original_extents / repaired_extents
        repaired.apply_scale(scale_factor)
        
        # ÂÖÉ„ÅÆ‰ΩçÁΩÆ„Å´Âêà„Çè„Åõ„Çã
        repaired_center = repaired.centroid
        original_center = (original_bounds[0] + original_bounds[1]) / 2
        repaired.apply_translation(original_center - repaired_center)
        
        # ÊúÄÁµÇÁ¢∫Ë™ç
        final_nm, final_boundary, _ = find_non_manifold_edges(repaired.faces)
        
        return {
            'vertices': repaired.vertices.tolist(),
            'faces': repaired.faces.tolist(),
            'is_watertight': repaired.is_watertight,
            'euler_number': int(repaired.euler_number) if hasattr(repaired, 'euler_number') else 0,
            'non_manifold_edges': len(final_nm),
            'boundary_edges': len(final_boundary),
            'pitch_used': pitch
        }
    except Exception as e:
        return {'error': str(e)}
                `);
                
                trimeshReady = true;
                console.log('Pyodide + trimesh: Ready!');
                showToast('„É°„ÉÉ„Ç∑„É•‰øÆÂæ©„Ç®„É≥„Ç∏„É≥Ê∫ñÂÇôÂÆå‰∫Ü', false);
                return true;
            } catch (e) {
                console.warn('Pyodide initialization failed:', e);
                showToast('„É°„ÉÉ„Ç∑„É•‰øÆÂæ©„Ç®„É≥„Ç∏„É≥„ÅÆÂàùÊúüÂåñ„Å´Â§±Êïó', true);
                return false;
            }
        }
        
        // trimesh„Åß„É°„ÉÉ„Ç∑„É•„Çí‰øÆÂæ©
        async function repairMeshWithTrimesh(geometry) {
            if (!trimeshReady || !pyodide) {
                console.warn('repairMeshWithTrimesh: Pyodide not ready');
                return geometry;
            }
            
            try {
                console.log('repairMeshWithTrimesh: Starting repair...');
                
                let geo = geometry.clone();
                
                // „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ‰ΩúÊàê
                if (!geo.index) {
                    geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
                }
                
                const position = geo.attributes.position;
                const index = geo.index;
                
                if (!position || !index) {
                    console.warn('repairMeshWithTrimesh: No position or index');
                    return geometry;
                }
                
                // È†ÇÁÇπ„ÇíÈÖçÂàó„Å´Â§âÊèõ
                const vertices = [];
                for (let i = 0; i < position.count; i++) {
                    vertices.push([position.getX(i), position.getY(i), position.getZ(i)]);
                }
                
                // Èù¢„ÇíÈÖçÂàó„Å´Â§âÊèõ
                const faces = [];
                const indexArray = index.array;
                for (let i = 0; i < indexArray.length; i += 3) {
                    faces.push([indexArray[i], indexArray[i + 1], indexArray[i + 2]]);
                }
                
                console.log(`repairMeshWithTrimesh: Input - ${vertices.length} vertices, ${faces.length} faces`);
                
                // Python„Å´Ê∏°„Åó„Å¶‰øÆÂæ©
                pyodide.globals.set('input_vertices', vertices);
                pyodide.globals.set('input_faces', faces);
                
                const result = await pyodide.runPythonAsync(`
result = advanced_repair_mesh(input_vertices, input_faces)
result
                `);
                
                const resultObj = result.toJs({ dict_converter: Object.fromEntries });
                
                if (resultObj.error) {
                    console.warn('repairMeshWithTrimesh: Python error:', resultObj.error);
                    return geometry;
                }
                
                console.log(`repairMeshWithTrimesh: Output - ${resultObj.vertices.length} vertices, ${resultObj.faces.length} faces`);
                console.log(`repairMeshWithTrimesh: is_watertight=${resultObj.is_watertight}, euler_number=${resultObj.euler_number}`);
                console.log(`repairMeshWithTrimesh: non_manifold_edges=${resultObj.non_manifold_edges || 'N/A'}, boundary_edges=${resultObj.boundary_edges || 'N/A'}`);
                if (resultObj.pitch_used) {
                    console.log(`repairMeshWithTrimesh: VOXEL REPAIR used with pitch=${resultObj.pitch_used}mm`);
                }
                
                // Ê∞¥ÂØÜÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
                if (resultObj.is_watertight) {
                    console.log('repairMeshWithTrimesh: ‚úì Mesh is WATERTIGHT (no open holes)');
                } else {
                    console.warn(`repairMeshWithTrimesh: ‚úó Mesh is NOT watertight (${resultObj.boundary_edges || 'unknown'} boundary edges)`);
                }
                
                // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„ÅåÊÆã„Å£„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØË≠¶Âëä
                if (resultObj.non_manifold_edges > 0) {
                    console.warn(`repairMeshWithTrimesh: ${resultObj.non_manifold_edges} non-manifold edges still remain`);
                } else {
                    console.log('repairMeshWithTrimesh: SUCCESS - No non-manifold edges!');
                }
                
                // Three.js„Ç∏„Ç™„É°„Éà„É™„Å´Â§âÊèõ
                const newPositions = [];
                for (const v of resultObj.vertices) {
                    newPositions.push(v[0], v[1], v[2]);
                }
                
                const newIndices = [];
                for (const f of resultObj.faces) {
                    newIndices.push(f[0], f[1], f[2]);
                }
                
                const newGeo = new THREE.BufferGeometry();
                newGeo.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
                newGeo.setIndex(newIndices);
                newGeo.computeVertexNormals();
                
                return newGeo;
            } catch (e) {
                console.error('repairMeshWithTrimesh: Error:', e);
                return geometry;
            }
        }
        
        // ‚ñº‚ñº‚ñº V67: Êñ∞Ê©üËÉΩÁî®„Ç∞„É≠„Éº„Éê„É´Â§âÊï∞ ‚ñº‚ñº‚ñº
        let gumballControl;            // TransformControls („Ç¨„É†„Éú„Éº„É´)
        let raycaster, mouse;           // „ÇØ„É™„ÉÉ„ÇØÈÖçÁΩÆÁî®
        let isPlaceMode = false;        // ÈÖçÁΩÆ„É¢„Éº„Éâ„Éï„É©„Ç∞
        let gumballTarget = 'text';     // „Ç¨„É†„Éú„Éº„É´„ÅÆ„Çø„Éº„Ç≤„ÉÉ„Éà ('text', 'text2', 'side', 'svg', 'model')
        let gumballDummy = null;        // „Ç¨„É†„Éú„Éº„É´Áî®„ÉÄ„Éü„Éº„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
        let gumballDragging = false;    // „Ç¨„É†„Éú„Éº„É´„Éâ„É©„ÉÉ„Ç∞‰∏≠„Éï„É©„Ç∞
        let galleryDB;                  // IndexedDBÂèÇÁÖß
        
        async function initManifold() {
            try {
                const Module = await import('https://cdn.jsdelivr.net/npm/manifold-3d@3.0.0/manifold.js');
                manifoldModule = await Module.default();
                manifoldModule.setup();
                Manifold = manifoldModule.Manifold;
                console.log('Manifold WASM initialized successfully');
                return true;
            } catch (e) {
                console.warn('Manifold WASM failed to load:', e);
                return false;
            }
        }
        
        function geometryToManifold(geometry) {
            if (!Manifold || !geometry) return null;
            
            try {
                let geo = geometry.clone();
                
                if (!geo.index) {
                    geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
                }
                
                const position = geo.attributes.position;
                const index = geo.index;
                
                if (!position || !index) return null;
                
                const vertProperties = [];
                for (let i = 0; i < position.count; i++) {
                    vertProperties.push(position.getX(i), position.getY(i), position.getZ(i));
                }
                
                const triVerts = [];
                const indexArray = index.array;
                for (let i = 0; i < indexArray.length; i++) {
                    triVerts.push(indexArray[i]);
                }
                
                const mesh = new manifoldModule.Mesh({
                    numProp: 3,
                    vertProperties: new Float32Array(vertProperties),
                    triVerts: new Uint32Array(triVerts)
                });
                
                const manifold = new Manifold(mesh);
                mesh.delete();
                
                return manifold;
            } catch (e) {
                console.warn('geometryToManifold failed:', e);
                return null;
            }
        }
        
        function manifoldToGeometry(manifold) {
            if (!manifold) return null;
            
            try {
                const mesh = manifold.getMesh();
                
                const vertices = [];
                const indices = [];
                
                const vertProps = mesh.vertProperties;
                const numProp = mesh.numProp;
                
                for (let i = 0; i < vertProps.length; i += numProp) {
                    vertices.push(vertProps[i], vertProps[i + 1], vertProps[i + 2]);
                }
                
                const triVerts = mesh.triVerts;
                for (let i = 0; i < triVerts.length; i++) {
                    indices.push(triVerts[i]);
                }
                
                mesh.delete();
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                return geometry;
            } catch (e) {
                console.warn('manifoldToGeometry failed:', e);
                return null;
            }
        }
        
        function makeManifold(geometry) {
            if (!Manifold || !geometry) return geometry;
            
            try {
                const manifold = geometryToManifold(geometry);
                if (!manifold) return geometry;
                
                const status = manifold.status();
                if (status !== 0) {
                    console.log('Mesh is not manifold, status:', status);
                    manifold.delete();
                    return geometry;
                }
                
                const result = manifoldToGeometry(manifold);
                manifold.delete();
                
                return result || geometry;
            } catch (e) {
                console.warn('makeManifold failed:', e);
                return geometry;
            }
        }
        
        // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„ÇíÂº∑Âà∂ÁöÑ„Å´0„Å´„Åô„ÇãÈñ¢Êï∞Ôºà„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÁî®Ôºâ
        async function ensureManifold(geometry, maxRetries = 5) {
            if (!geometry) {
                console.warn('ensureManifold: No geometry provided');
                return null;
            }
            
            console.log('ensureManifold: Starting comprehensive mesh repair...');
            let currentGeo = geometry.clone();
            
            // Step 0: MeshFix WASM - ÁèæÂú®„ÅØÁÑ°ÂäπÔºà„Çπ„ÉÜ„É†Á©¥„ÇíÊåÅ„Å§„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Å´„ÅØ‰∏çÂêë„ÅçÔºâ
            // MeshFix„ÅØ„ÄåÊ∞¥ÂØÜ„Å™„ÇΩ„É™„ÉÉ„Éâ„Äç„ÇíÁîüÊàê„Åô„Çã„Åü„ÇÅ„ÄÅÊÑèÂõ≥ÁöÑ„Å™Á©¥„ÇíÂüã„ÇÅ„Å¶„Åó„Åæ„ÅÜ
            // if (meshfixReady && meshfixModule) { ... }
            
            // Step 0b: Pyodide + trimesh „Åß‰øÆÂæ©„ÇíË©¶„Åø„ÇãÔºà„É°„Ç§„É≥‰øÆÂæ©ÊñπÊ≥ïÔºâ
            if (trimeshReady && pyodide) {
                console.log('ensureManifold: Step 0 - Trimesh repair (main method)');
                showToast('trimesh„Åß„É°„ÉÉ„Ç∑„É•„Çí‰øÆÂæ©‰∏≠...', false);
                try {
                    const repairedGeo = await repairMeshWithTrimesh(currentGeo);
                    if (repairedGeo) {
                        currentGeo = repairedGeo;
                        
                        // ‰øÆÂæ©Âæå„ÅÆÂàÜÊûê
                        const analysis = analyzeNonManifoldEdges(currentGeo);
                        console.log(`ensureManifold: After trimesh - ${analysis.nonManifoldCount} non-manifold edges, ${analysis.boundaryCount} boundary edges`);
                        
                        // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„Åå„ÅÇ„Å£„Å¶„ÇÇ„ÄÅÈù¢ÂâäÈô§„Åõ„Åö„Å´„Åù„ÅÆ„Åæ„ÅæËøî„Åô
                        // Bambu Studio„ÅÆ„Çπ„É©„Ç§„Çµ„Éº„Å´‰øÆÂæ©„Çí‰ªª„Åõ„Çã
                        console.log('ensureManifold: Returning mesh without face removal (let slicer handle it)');
                        showToast('„É°„ÉÉ„Ç∑„É•Âá¶ÁêÜÂÆå‰∫Ü', false);
                        return currentGeo;
                    }
                } catch (e) {
                    console.warn('ensureManifold: Trimesh repair failed:', e);
                }
            }
            
            // trimesh„Åå‰Ωø„Åà„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø„ÄÅ‰ª•‰∏ã„ÅÆÂá¶ÁêÜ„ÇíÂÆüË°å
            
            // Step 1: Âü∫Êú¨ÁöÑ„Å™„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
            console.log('ensureManifold: Step 1 - Initial cleanup (fallback)');
            currentGeo = fullMeshCleanup(currentGeo);
            
            // Èù¢ÂâäÈô§„Å´„Çà„Çã‰øÆÂæ©„ÅØ„Çπ„Ç≠„ÉÉ„Éó
            console.log('ensureManifold: Skipping face removal to preserve mesh integrity');
            return currentGeo;
            
            /* 
            /* Step 2-5: ÁÑ°ÂäπÂåñÔºàÈù¢ÂâäÈô§„ÅßÂ¢ÉÁïå„Ç®„ÉÉ„Ç∏„ÅåÂ¢óÂä†„Åô„Çã„Åü„ÇÅÔºâ
            // Step 2: ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„ÇíÊ§úÂá∫„Åó„Å¶‰øÆÂæ©ÔºàË§áÊï∞ÂõûÁπ∞„ÇäËøî„ÅóÔºâ
            console.log('ensureManifold: Step 2 - Non-manifold edge repair');
            for (let iteration = 0; iteration < 5; iteration++) {
                const analysis = analyzeNonManifoldEdges(currentGeo);
                console.log(`ensureManifold: Iteration ${iteration + 1} - ${analysis.nonManifoldCount} non-manifold edges, ${analysis.boundaryCount} boundary edges`);
                
                if (analysis.nonManifoldCount === 0) {
                    console.log('ensureManifold: Mesh is now manifold!');
                    break;
                }
                
                // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„Çí‰øÆÂæ©
                currentGeo = repairNonManifoldEdges(currentGeo, analysis);
                currentGeo = fullMeshCleanup(currentGeo);
            }
            
            // Step 3: Manifold„É©„Ç§„Éñ„É©„É™„ÅßÊ§úË®º„Éª‰øÆÂæ©„ÇíË©¶„Åø„Çã
            if (Manifold && manifoldModule) {
                console.log('ensureManifold: Step 3 - Manifold library validation');
                for (let attempt = 0; attempt < maxRetries; attempt++) {
                    try {
                        const mergeDistance = 0.0001 * Math.pow(2, attempt);
                        let workGeo = BufferGeometryUtils.mergeVertices(currentGeo.clone(), mergeDistance);
                        workGeo = removeDegenerateTriangles(workGeo);
                        
                        // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„ÇíÂÜçÂ∫¶Á¢∫Ë™ç„Éª‰øÆÂæ©
                        const preAnalysis = analyzeNonManifoldEdges(workGeo);
                        if (preAnalysis.nonManifoldCount > 0) {
                            workGeo = repairNonManifoldEdges(workGeo, preAnalysis);
                            workGeo = fullMeshCleanup(workGeo);
                        }
                        
                        const position = workGeo.attributes.position;
                        const index = workGeo.index;
                        
                        if (!position || !index || index.count === 0) continue;
                        
                        const vertProperties = [];
                        for (let i = 0; i < position.count; i++) {
                            vertProperties.push(position.getX(i), position.getY(i), position.getZ(i));
                        }
                        
                        const triVerts = [];
                        const indexArray = index.array;
                        for (let i = 0; i < indexArray.length; i++) {
                            triVerts.push(indexArray[i]);
                        }
                        
                        const mesh = new manifoldModule.Mesh({
                            numProp: 3,
                            vertProperties: new Float32Array(vertProperties),
                            triVerts: new Uint32Array(triVerts)
                        });
                        
                        const manifold = new Manifold(mesh);
                        mesh.delete();
                        
                        const status = manifold.status();
                        
                        if (status === 0) {
                            console.log('ensureManifold: Manifold validation SUCCESS!');
                            const resultMesh = manifold.getMesh();
                            manifold.delete();
                            
                            const vertices = [];
                            const indices = [];
                            const vertProps = resultMesh.vertProperties;
                            const numProp = resultMesh.numProp;
                            
                            for (let i = 0; i < vertProps.length; i += numProp) {
                                vertices.push(vertProps[i], vertProps[i + 1], vertProps[i + 2]);
                            }
                            
                            const resultTriVerts = resultMesh.triVerts;
                            for (let i = 0; i < resultTriVerts.length; i++) {
                                indices.push(resultTriVerts[i]);
                            }
                            
                            resultMesh.delete();
                            
                            const resultGeometry = new THREE.BufferGeometry();
                            resultGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                            resultGeometry.setIndex(indices);
                            resultGeometry.computeVertexNormals();
                            
                            return resultGeometry;
                        }
                        
                        manifold.delete();
                        console.log('ensureManifold: Manifold attempt', attempt + 1, 'status:', status);
                        
                        // „Çà„ÇäÁ©çÊ•µÁöÑ„Å™‰øÆÂæ©„ÇíË©¶„Åø„Çã
                        currentGeo = aggressiveNonManifoldRepair(currentGeo, attempt);
                        
                    } catch (e) {
                        console.warn('ensureManifold: Manifold attempt', attempt + 1, 'error:', e.message || e);
                        // „Ç®„É©„ÉºÊôÇ„ÇÇÁ©çÊ•µÁöÑ„Å™‰øÆÂæ©„ÇíË©¶„Åø„Çã
                        currentGeo = aggressiveNonManifoldRepair(currentGeo, attempt);
                    }
                }
            }
            
            // Step 4: ÊúÄÁµÇ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„Å®ÁµêÊûú„ÇíËøî„Åô
            console.log('ensureManifold: Step 4 - Final cleanup');
            currentGeo = fullMeshCleanup(currentGeo);
            
            // Step 5: Á©¥Âüã„ÇÅÂá¶ÁêÜ„ÅØÁÑ°ÂäπÂåñ
            // „Çπ„ÉÜ„É†Á©¥„ÅØÊÑèÂõ≥ÁöÑ„Å™„Ç∏„Ç™„É°„Éà„É™„Åß„ÅÇ„Çä„ÄÅÂüã„ÇÅ„Çã„Å®Êñ∞„Åó„ÅÑÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„ÅåÁô∫Áîü„Åô„Çã
            // Bambu Studio„ÅÆ„ÄåÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„ÄçË≠¶Âëä„ÅØÂ¢ÉÁïå„Ç®„ÉÉ„Ç∏ÔºàÈñã„ÅÑ„ÅüÁ©¥Ôºâ„ÇÇÂê´„ÇÄ„Åå„ÄÅ
            // „Çπ„É©„Ç§„Çµ„Éº„ÅØËá™ÂãïÁöÑ„Å´Âá¶ÁêÜ„Åô„Çã„Åü„ÇÅ„ÄÅÂç∞Âà∑ÂìÅË≥™„Å´„ÅØÂΩ±Èüø„Åó„Å™„ÅÑ
            console.log('ensureManifold: Step 5 - Skipping hole filling (stem holes are intentional geometry)');
            
            const finalAnalysis = analyzeNonManifoldEdges(currentGeo);
            console.log(`ensureManifold: Final state - ${finalAnalysis.nonManifoldCount} non-manifold edges, ${finalAnalysis.boundaryCount} boundary edges`);
            
            return currentGeo;
            */
        }
        
        // ‰∏≠ÂøÉÈ†ÇÁÇπ„ÇíËøΩÂä†„Åó„Å¶Á©¥„ÇíÂüã„ÇÅ„ÇãÔºàÂÆâÂÖ®„Å™ÊñπÊ≥ïÔºâ
        function fillHolesWithCenterVertex(geometry) {
            const position = geometry.attributes.position;
            const index = geometry.index;
            
            if (!position || !index) return geometry;
            
            // Â¢ÉÁïå„Ç®„ÉÉ„Ç∏„ÇíÊ§úÂá∫
            const analysis = analyzeNonManifoldEdges(geometry);
            
            if (analysis.boundaryCount === 0) {
                console.log('fillHolesWithCenterVertex: No boundary edges found');
                return geometry;
            }
            
            console.log(`fillHolesWithCenterVertex: Found ${analysis.boundaryCount} boundary edges`);
            
            // Â¢ÉÁïå„Ç®„ÉÉ„Ç∏„ÇíÂèéÈõÜ
            const boundaryEdges = [];
            analysis.edges.forEach((faces, key) => {
                if (faces.length === 1) {
                    const [v1, v2] = key.split('-').map(Number);
                    const faceIdx = faces[0];
                    boundaryEdges.push({ v1, v2, faceIdx });
                }
            });
            
            // Â¢ÉÁïå„É´„Éº„Éó„ÇíÊ§úÂá∫
            const loops = detectBoundaryLoopsWithOrientation(boundaryEdges, position, index.array);
            console.log(`fillHolesWithCenterVertex: Found ${loops.length} boundary loops`);
            
            if (loops.length === 0) return geometry;
            
            // È†ÇÁÇπÈÖçÂàó„ÇíÊã°ÂºµÂèØËÉΩ„Å™ÂΩ¢Âºè„Å´Â§âÊèõ
            const vertices = [];
            for (let i = 0; i < position.count; i++) {
                vertices.push(position.getX(i), position.getY(i), position.getZ(i));
            }
            
            // „Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÈÖçÂàó„Çí„Ç≥„Éî„Éº
            const indices = Array.from(index.array);
            
            let addedFaces = 0;
            
            // ÂêÑ„É´„Éº„Éó„Å´ÂØæ„Åó„Å¶‰∏≠ÂøÉÈ†ÇÁÇπ„ÇíËøΩÂä†„Åó„Å¶Á©¥„ÇíÂüã„ÇÅ„Çã
            for (const loop of loops) {
                if (loop.vertices.length < 3) continue;
                
                // „É´„Éº„Éó„ÅÆ‰∏≠ÂøÉ„ÇíË®àÁÆó
                let cx = 0, cy = 0, cz = 0;
                for (const vi of loop.vertices) {
                    cx += position.getX(vi);
                    cy += position.getY(vi);
                    cz += position.getZ(vi);
                }
                cx /= loop.vertices.length;
                cy /= loop.vertices.length;
                cz /= loop.vertices.length;
                
                // ‰∏≠ÂøÉÈ†ÇÁÇπ„ÇíËøΩÂä†
                const centerIdx = vertices.length / 3;
                vertices.push(cx, cy, cz);
                
                // „É´„Éº„Éó„ÅÆÂêë„Åç„ÇíÊ±∫ÂÆöÔºàÊó¢Â≠ò„ÅÆÈù¢„ÅÆÊ≥ïÁ∑ö„Åã„ÇâÊé®Ê∏¨Ôºâ
                const loopNormal = calculateLoopNormal(loop.vertices, position);
                const faceNormal = loop.faceNormal;
                
                // Ê≥ïÁ∑ö„ÅåÂ§ñÂÅ¥„ÇíÂêë„Åè„Çà„ÅÜ„Å´‰∏âËßíÂΩ¢„ÇíËøΩÂä†
                const shouldReverse = loopNormal.dot(faceNormal) > 0;
                
                // ‰∏≠ÂøÉ„Åã„Çâ„Éï„Ç°„É≥ÂàÜÂâ≤„Åß‰∏âËßíÂΩ¢„ÇíËøΩÂä†
                for (let i = 0; i < loop.vertices.length; i++) {
                    const v1 = loop.vertices[i];
                    const v2 = loop.vertices[(i + 1) % loop.vertices.length];
                    
                    if (shouldReverse) {
                        indices.push(centerIdx, v1, v2);
                    } else {
                        indices.push(centerIdx, v2, v1);
                    }
                    addedFaces++;
                }
            }
            
            console.log(`fillHolesWithCenterVertex: Added ${addedFaces} faces, ${loops.length} center vertices`);
            
            // Êñ∞„Åó„ÅÑ„Ç∏„Ç™„É°„Éà„É™„Çí‰ΩúÊàê
            const newGeo = new THREE.BufferGeometry();
            newGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            newGeo.setIndex(indices);
            newGeo.computeVertexNormals();
            
            return newGeo;
        }
        
        // Âêë„ÅçÊÉÖÂ†±‰ªò„Åç„ÅßÂ¢ÉÁïå„É´„Éº„Éó„ÇíÊ§úÂá∫
        function detectBoundaryLoopsWithOrientation(boundaryEdges, position, indexArray) {
            const loops = [];
            const edgeUsed = new Array(boundaryEdges.length).fill(false);
            
            // ÂêÑ„Ç®„ÉÉ„Ç∏„Å´ÂØæ„Åó„Å¶„ÄÅ„Åù„ÅÆÈù¢„ÅÆÊ≥ïÁ∑ö„ÇíË®àÁÆó
            const edgeNormals = new Map();
            for (const edge of boundaryEdges) {
                const faceStart = edge.faceIdx * 3;
                const v0 = indexArray[faceStart];
                const v1 = indexArray[faceStart + 1];
                const v2 = indexArray[faceStart + 2];
                
                const p0 = new THREE.Vector3(position.getX(v0), position.getY(v0), position.getZ(v0));
                const p1 = new THREE.Vector3(position.getX(v1), position.getY(v1), position.getZ(v1));
                const p2 = new THREE.Vector3(position.getX(v2), position.getY(v2), position.getZ(v2));
                
                const e1 = new THREE.Vector3().subVectors(p1, p0);
                const e2 = new THREE.Vector3().subVectors(p2, p0);
                const normal = new THREE.Vector3().crossVectors(e1, e2).normalize();
                
                edgeNormals.set(`${edge.v1}-${edge.v2}`, normal);
            }
            
            // Èö£Êé•„Éû„ÉÉ„Éó„ÇíÊßãÁØâ
            const vertexToEdges = new Map();
            for (let i = 0; i < boundaryEdges.length; i++) {
                const edge = boundaryEdges[i];
                if (!vertexToEdges.has(edge.v1)) vertexToEdges.set(edge.v1, []);
                if (!vertexToEdges.has(edge.v2)) vertexToEdges.set(edge.v2, []);
                vertexToEdges.get(edge.v1).push(i);
                vertexToEdges.get(edge.v2).push(i);
            }
            
            // „É´„Éº„Éó„ÇíÊ§úÂá∫
            for (let startEdgeIdx = 0; startEdgeIdx < boundaryEdges.length; startEdgeIdx++) {
                if (edgeUsed[startEdgeIdx]) continue;
                
                const loopVertices = [];
                const loopNormals = [];
                const startEdge = boundaryEdges[startEdgeIdx];
                let currentVertex = startEdge.v1;
                let prevVertex = -1;
                let safetyCounter = 0;
                const maxIterations = boundaryEdges.length * 2;
                
                while (safetyCounter < maxIterations) {
                    safetyCounter++;
                    loopVertices.push(currentVertex);
                    
                    const connectedEdges = vertexToEdges.get(currentVertex) || [];
                    let nextVertex = -1;
                    let nextEdgeIdx = -1;
                    
                    for (const edgeIdx of connectedEdges) {
                        if (edgeUsed[edgeIdx]) continue;
                        
                        const edge = boundaryEdges[edgeIdx];
                        const otherVertex = edge.v1 === currentVertex ? edge.v2 : edge.v1;
                        
                        if (otherVertex !== prevVertex) {
                            nextVertex = otherVertex;
                            nextEdgeIdx = edgeIdx;
                            
                            // „Åì„ÅÆ„Ç®„ÉÉ„Ç∏„ÅÆÊ≥ïÁ∑ö„ÇíË®òÈå≤
                            const normalKey = `${edge.v1}-${edge.v2}`;
                            if (edgeNormals.has(normalKey)) {
                                loopNormals.push(edgeNormals.get(normalKey));
                            }
                            break;
                        }
                    }
                    
                    if (nextEdgeIdx === -1) break;
                    
                    edgeUsed[nextEdgeIdx] = true;
                    prevVertex = currentVertex;
                    currentVertex = nextVertex;
                    
                    if (currentVertex === loopVertices[0] && loopVertices.length >= 3) {
                        // „É´„Éº„Éó„ÅÆÂπ≥ÂùáÊ≥ïÁ∑ö„ÇíË®àÁÆó
                        const avgNormal = new THREE.Vector3();
                        for (const n of loopNormals) {
                            avgNormal.add(n);
                        }
                        avgNormal.normalize();
                        
                        loops.push({
                            vertices: [...loopVertices],
                            faceNormal: avgNormal
                        });
                        break;
                    }
                }
            }
            
            return loops;
        }
        
        // „É´„Éº„Éó„ÅÆÊ≥ïÁ∑ö„ÇíË®àÁÆóÔºàÈ†ÇÁÇπ„ÅÆÈ†ÜÂ∫è„Åã„ÇâÔºâ
        function calculateLoopNormal(loopVertices, position) {
            if (loopVertices.length < 3) return new THREE.Vector3(0, 1, 0);
            
            // Newell's method for polygon normal
            const normal = new THREE.Vector3();
            
            for (let i = 0; i < loopVertices.length; i++) {
                const curr = loopVertices[i];
                const next = loopVertices[(i + 1) % loopVertices.length];
                
                const cx = position.getX(curr);
                const cy = position.getY(curr);
                const cz = position.getZ(curr);
                const nx = position.getX(next);
                const ny = position.getY(next);
                const nz = position.getZ(next);
                
                normal.x += (cy - ny) * (cz + nz);
                normal.y += (cz - nz) * (cx + nx);
                normal.z += (cx - nx) * (cy + ny);
            }
            
            normal.normalize();
            return normal;
        }
        
        // ÂÆåÂÖ®„Å™„É°„ÉÉ„Ç∑„É•„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        function fullMeshCleanup(geometry) {
            let geo = geometry.clone();
            
            // „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ‰ΩúÊàê
            if (!geo.index) {
                const position = geo.attributes.position;
                const indices = [];
                for (let i = 0; i < position.count; i++) {
                    indices.push(i);
                }
                geo.setIndex(indices);
            }
            
            // È†ÇÁÇπ„Çí„Éû„Éº„Ç∏
            geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
            
            // Á∏ÆÈÄÄ‰∏âËßíÂΩ¢„ÇíÂâäÈô§
            geo = removeDegenerateTriangles(geo);
            
            // ÈáçË§á‰∏âËßíÂΩ¢„ÇíÂâäÈô§
            geo = removeDuplicateTriangles(geo);
            
            // Â≠§Á´ãÈ†ÇÁÇπ„ÇíÂâäÈô§
            geo = removeUnusedVertices(geo);
            
            // Ê≥ïÁ∑ö„ÇíÂÜçË®àÁÆó
            geo.computeVertexNormals();
            
            return geo;
        }
        
        // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„ÇíÂàÜÊûê
        function analyzeNonManifoldEdges(geometry) {
            const position = geometry.attributes.position;
            const index = geometry.index;
            
            if (!position || !index) {
                return { nonManifoldCount: 0, boundaryCount: 0, edges: new Map() };
            }
            
            const indexArray = index.array;
            const edgeMap = new Map(); // "minV-maxV" -> [faceIndices]
            
            // „Ç®„ÉÉ„Ç∏„Éû„ÉÉ„Éó„ÇíÊßãÁØâ
            for (let i = 0; i < indexArray.length; i += 3) {
                const faceIndex = Math.floor(i / 3);
                const v0 = indexArray[i];
                const v1 = indexArray[i + 1];
                const v2 = indexArray[i + 2];
                
                addEdge(edgeMap, v0, v1, faceIndex);
                addEdge(edgeMap, v1, v2, faceIndex);
                addEdge(edgeMap, v2, v0, faceIndex);
            }
            
            let nonManifoldCount = 0;
            let boundaryCount = 0;
            const nonManifoldEdges = [];
            
            edgeMap.forEach((faces, edgeKey) => {
                if (faces.length > 2) {
                    nonManifoldCount++;
                    nonManifoldEdges.push({ edge: edgeKey, faces: faces.slice() });
                } else if (faces.length === 1) {
                    boundaryCount++;
                }
            });
            
            return { nonManifoldCount, boundaryCount, edges: edgeMap, nonManifoldEdges };
        }
        
        function addEdge(edgeMap, v1, v2, faceIndex) {
            const key = v1 < v2 ? `${v1}-${v2}` : `${v2}-${v1}`;
            if (!edgeMap.has(key)) {
                edgeMap.set(key, []);
            }
            edgeMap.get(key).push(faceIndex);
        }
        
        // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„Çí‰øÆÂæ©
        function repairNonManifoldEdges(geometry, analysis) {
            if (analysis.nonManifoldCount === 0) return geometry;
            
            const position = geometry.attributes.position;
            const index = geometry.index;
            const indexArray = index.array;
            
            // ÂâäÈô§„Åô„Åπ„ÅçÈù¢„ÇíÁâπÂÆö
            const facesToRemove = new Set();
            
            // ÂêÑÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„Å´„Å§„ÅÑ„Å¶„ÄÅ‰ΩôÂàÜ„Å™Èù¢„ÇíÂâäÈô§
            analysis.nonManifoldEdges.forEach(({ edge, faces }) => {
                if (faces.length <= 2) return;
                
                // Èù¢„ÅÆÊ≥ïÁ∑ö„ÇíË®àÁÆó„Åó„Å¶„ÄÅ‰∏ÄË≤´ÊÄß„ÅÆ„ÅÇ„ÇãÈù¢„ÇíÊÆã„Åô
                const faceNormals = faces.map(fi => {
                    const i = fi * 3;
                    const v0 = new THREE.Vector3(
                        position.getX(indexArray[i]),
                        position.getY(indexArray[i]),
                        position.getZ(indexArray[i])
                    );
                    const v1 = new THREE.Vector3(
                        position.getX(indexArray[i + 1]),
                        position.getY(indexArray[i + 1]),
                        position.getZ(indexArray[i + 1])
                    );
                    const v2 = new THREE.Vector3(
                        position.getX(indexArray[i + 2]),
                        position.getY(indexArray[i + 2]),
                        position.getZ(indexArray[i + 2])
                    );
                    const e1 = new THREE.Vector3().subVectors(v1, v0);
                    const e2 = new THREE.Vector3().subVectors(v2, v0);
                    return new THREE.Vector3().crossVectors(e1, e2).normalize();
                });
                
                // Ê≥ïÁ∑ö„Åå‰ºº„Å¶„ÅÑ„ÇãÈù¢„Çí„Ç∞„É´„Éº„ÉóÂåñ„Åó„ÄÅÊúÄÂ§ß„ÅÆ„Ç∞„É´„Éº„Éó„Åã„Çâ2„Å§„ÇíÊÆã„Åô
                const groups = [];
                const used = new Set();
                
                for (let i = 0; i < faces.length; i++) {
                    if (used.has(i)) continue;
                    const group = [i];
                    used.add(i);
                    
                    for (let j = i + 1; j < faces.length; j++) {
                        if (used.has(j)) continue;
                        const dot = Math.abs(faceNormals[i].dot(faceNormals[j]));
                        if (dot > 0.9) {
                            group.push(j);
                            used.add(j);
                        }
                    }
                    groups.push(group);
                }
                
                // ÊúÄÂ§ß„ÅÆ„Ç∞„É´„Éº„Éó‰ª•Â§ñ„ÅÆÈù¢„ÇíÂâäÈô§
                groups.sort((a, b) => b.length - a.length);
                
                // ÊúÄÂàù„ÅÆ2„Å§„ÅÆÈù¢„Å†„Åë„ÇíÊÆã„Åô
                let kept = 0;
                for (const group of groups) {
                    for (const idx of group) {
                        if (kept < 2) {
                            kept++;
                        } else {
                            facesToRemove.add(faces[idx]);
                        }
                    }
                }
            });
            
            if (facesToRemove.size === 0) return geometry;
            
            console.log(`repairNonManifoldEdges: Removing ${facesToRemove.size} faces`);
            
            // Êñ∞„Åó„ÅÑ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Çí‰ΩúÊàê
            const newIndices = [];
            for (let i = 0; i < indexArray.length; i += 3) {
                const faceIndex = Math.floor(i / 3);
                if (!facesToRemove.has(faceIndex)) {
                    newIndices.push(indexArray[i], indexArray[i + 1], indexArray[i + 2]);
                }
            }
            
            const newGeo = geometry.clone();
            newGeo.setIndex(newIndices);
            
            return newGeo;
        }
        
        // „Çà„ÇäÁ©çÊ•µÁöÑ„Å™ÈùûÂ§öÊßò‰Ωì‰øÆÂæ©
        function aggressiveNonManifoldRepair(geometry, iteration) {
            console.log(`aggressiveNonManifoldRepair: Iteration ${iteration + 1}`);
            
            let geo = geometry.clone();
            
            // „Çà„ÇäÂº∑„ÅÑÈ†ÇÁÇπ„Éû„Éº„Ç∏
            const mergeDistance = 0.001 * (iteration + 1);
            geo = BufferGeometryUtils.mergeVertices(geo, mergeDistance);
            
            // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„ÇíÊ§úÂá∫
            const analysis = analyzeNonManifoldEdges(geo);
            
            if (analysis.nonManifoldCount > 0) {
                // ÂïèÈ°å„ÅÆ„ÅÇ„ÇãÈù¢„ÇíÂâäÈô§
                geo = repairNonManifoldEdges(geo, analysis);
            }
            
            // „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
            geo = removeDegenerateTriangles(geo);
            geo = removeDuplicateTriangles(geo);
            geo = removeUnusedVertices(geo);
            geo.computeVertexNormals();
            
            return geo;
        }
        
        // Á∏ÆÈÄÄ‰∏âËßíÂΩ¢„ÇíÂâäÈô§
        function removeDegenerateTriangles(geometry) {
            const position = geometry.attributes.position;
            const index = geometry.index;
            
            if (!position || !index) return geometry;
            
            const indexArray = index.array;
            const newIndices = [];
            const epsilon = 0.0001;
            
            for (let i = 0; i < indexArray.length; i += 3) {
                const i0 = indexArray[i];
                const i1 = indexArray[i + 1];
                const i2 = indexArray[i + 2];
                
                // Âêå„ÅòÈ†ÇÁÇπ„ÇíÂèÇÁÖß„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
                if (i0 === i1 || i1 === i2 || i2 === i0) continue;
                
                // È†ÇÁÇπÂ∫ßÊ®ô„ÇíÂèñÂæó
                const v0 = new THREE.Vector3(position.getX(i0), position.getY(i0), position.getZ(i0));
                const v1 = new THREE.Vector3(position.getX(i1), position.getY(i1), position.getZ(i1));
                const v2 = new THREE.Vector3(position.getX(i2), position.getY(i2), position.getZ(i2));
                
                // È†ÇÁÇπ„ÅåÂêå„Åò‰ΩçÁΩÆ„Å´„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
                if (v0.distanceTo(v1) < epsilon || v1.distanceTo(v2) < epsilon || v2.distanceTo(v0) < epsilon) continue;
                
                // Èù¢Á©ç„ÇíË®àÁÆó
                const e1 = new THREE.Vector3().subVectors(v1, v0);
                const e2 = new THREE.Vector3().subVectors(v2, v0);
                const cross = new THREE.Vector3().crossVectors(e1, e2);
                const area = cross.length() / 2;
                
                // Èù¢Á©ç„ÅåÈùûÂ∏∏„Å´Â∞è„Åï„ÅÑÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
                if (area < epsilon) continue;
                
                newIndices.push(i0, i1, i2);
            }
            
            if (newIndices.length === 0 || newIndices.length === indexArray.length) {
                return geometry;
            }
            
            const newGeo = geometry.clone();
            newGeo.setIndex(newIndices);
            
            return newGeo;
        }
        
        // ÈáçË§á‰∏âËßíÂΩ¢„ÇíÂâäÈô§
        function removeDuplicateTriangles(geometry) {
            const index = geometry.index;
            if (!index) return geometry;
            
            const indexArray = index.array;
            const seen = new Set();
            const newIndices = [];
            
            for (let i = 0; i < indexArray.length; i += 3) {
                const sorted = [indexArray[i], indexArray[i + 1], indexArray[i + 2]].sort((a, b) => a - b);
                const key = sorted.join(',');
                
                if (!seen.has(key)) {
                    seen.add(key);
                    newIndices.push(indexArray[i], indexArray[i + 1], indexArray[i + 2]);
                }
            }
            
            if (newIndices.length === indexArray.length) return geometry;
            
            const newGeo = geometry.clone();
            newGeo.setIndex(newIndices);
            
            return newGeo;
        }
        
        // ‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÈ†ÇÁÇπ„ÇíÂâäÈô§
        function removeUnusedVertices(geometry) {
            const position = geometry.attributes.position;
            const index = geometry.index;
            
            if (!position || !index) return geometry;
            
            const indexArray = index.array;
            const usedVertices = new Set();
            
            for (let i = 0; i < indexArray.length; i++) {
                usedVertices.add(indexArray[i]);
            }
            
            if (usedVertices.size === position.count) return geometry;
            
            const oldToNew = new Map();
            const newPositions = [];
            let newIndex = 0;
            
            for (let i = 0; i < position.count; i++) {
                if (usedVertices.has(i)) {
                    oldToNew.set(i, newIndex);
                    newPositions.push(position.getX(i), position.getY(i), position.getZ(i));
                    newIndex++;
                }
            }
            
            const newIndices = [];
            for (let i = 0; i < indexArray.length; i++) {
                newIndices.push(oldToNew.get(indexArray[i]));
            }
            
            const newGeo = new THREE.BufferGeometry();
            newGeo.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
            newGeo.setIndex(newIndices);
            newGeo.computeVertexNormals();
            
            return newGeo;
        }
        
        // „Ç®„ÇØ„Çπ„Éù„Éº„ÉàÂâç„ÅÆÈùûÂ§öÊßò‰Ωì„ÉÅ„Çß„ÉÉ„ÇØÈñ¢Êï∞
        async function validateAndFixGeometry(geometry, name = 'geometry') {
            if (!geometry) return null;
            
            console.log(`validateAndFixGeometry: Processing ${name}...`);
            
            // ÂàùÊúüÂàÜÊûê
            const initialAnalysis = analyzeNonManifoldEdges(geometry);
            console.log(`validateAndFixGeometry: ${name} initial - ${initialAnalysis.nonManifoldCount} non-manifold edges`);
            
            const result = await ensureManifold(geometry);
            
            if (!result) {
                console.warn(`validateAndFixGeometry: ${name} repair returned null`);
                // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
                let fallback = geometry.clone();
                fallback = BufferGeometryUtils.mergeVertices(fallback, 0.001);
                fallback.computeVertexNormals();
                return fallback;
            }
            
            // ÊúÄÁµÇÁ¢∫Ë™ç
            const finalAnalysis = analyzeNonManifoldEdges(result);
            console.log(`validateAndFixGeometry: ${name} final - ${finalAnalysis.nonManifoldCount} non-manifold edges`);
            
            return result;
        }
        
        function repairSVGMesh(geometry) {
            if (!geometry) return null;
            
            try {
                let geo = BufferGeometryUtils.mergeVertices(geometry, 0.001);
                
                if (geo.index) {
                    geo = geo.toNonIndexed();
                }
                
                const position = geo.attributes.position;
                const triangles = [];
                const epsilon = 0.0001;
                
                for (let i = 0; i < position.count; i += 3) {
                    const v0 = new THREE.Vector3(position.getX(i), position.getY(i), position.getZ(i));
                    const v1 = new THREE.Vector3(position.getX(i+1), position.getY(i+1), position.getZ(i+1));
                    const v2 = new THREE.Vector3(position.getX(i+2), position.getY(i+2), position.getZ(i+2));
                    
                    const e0 = v0.distanceTo(v1);
                    const e1 = v1.distanceTo(v2);
                    const e2 = v2.distanceTo(v0);
                    
                    if (e0 < epsilon || e1 < epsilon || e2 < epsilon) continue;
                    
                    const ab = new THREE.Vector3().subVectors(v1, v0);
                    const ac = new THREE.Vector3().subVectors(v2, v0);
                    const cross = new THREE.Vector3().crossVectors(ab, ac);
                    const area = cross.length() * 0.5;
                    
                    if (area < epsilon * epsilon) continue;
                    
                    triangles.push({ v0, v1, v2, area });
                }
                
                const uniqueTriangles = [];
                const seen = new Set();
                
                for (const tri of triangles) {
                    const vertices = [tri.v0, tri.v1, tri.v2].map(v => 
                        `${v.x.toFixed(4)},${v.y.toFixed(4)},${v.z.toFixed(4)}`
                    ).sort().join('|');
                    
                    if (!seen.has(vertices)) {
                        seen.add(vertices);
                        uniqueTriangles.push(tri);
                    }
                }
                
                const newPositions = [];
                for (const tri of uniqueTriangles) {
                    newPositions.push(tri.v0.x, tri.v0.y, tri.v0.z);
                    newPositions.push(tri.v1.x, tri.v1.y, tri.v1.z);
                    newPositions.push(tri.v2.x, tri.v2.y, tri.v2.z);
                }
                
                const newGeo = new THREE.BufferGeometry();
                newGeo.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
                
                const mergedGeo = BufferGeometryUtils.mergeVertices(newGeo, 0.08);
                mergedGeo.computeVertexNormals();
                
                console.log(`SVG Repair: ${position.count/3} -> ${uniqueTriangles.length} triangles`);
                
                return mergedGeo;
            } catch (e) {
                console.warn('repairSVGMesh failed:', e);
                return geometry;
            }
        }

        const translations = {
            ja: {
                nav_jump: "--- „Çª„ÇØ„Ç∑„Éß„É≥ÁßªÂãï ---", nav_basic: "Âü∫Êú¨„Çµ„Ç§„Ç∫", nav_structure: "ÊßãÈÄ†„Éª„Éú„ÉÉ„ÉÅ", nav_shape: "ÂΩ¢Áä∂",
                nav_texture: "ÁîªÂÉè„ÉÜ„ÇØ„Çπ„ÉÅ„É£", nav_utility: "„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£", nav_import: "Â§ñÈÉ®„É¢„Éá„É´", 
                nav_stem: "„Çπ„ÉÜ„É†", nav_text: "ÊñáÂ≠ó„ÉªÂàªÂç∞", nav_svg: "SVG„Ç¢„Ç§„Ç≥„É≥", nav_color: "Ëâ≤Ë®≠ÂÆö",
                nav_preset: "„Éó„É™„Çª„ÉÉ„Éà", nav_export: "Êõ∏„ÅçÂá∫„Åó",
                h_basic: "Âü∫Êú¨„Çµ„Ç§„Ç∫", lbl_u_size: "„Ç≠„Éº„Çµ„Ç§„Ç∫", lbl_profile: "„Éó„É≠„Éï„Ç°„Ç§„É´", lbl_row: "Ë°å", lbl_unit_size: "Âü∫Êú¨„Éî„ÉÉ„ÉÅ", 
                h_structure: "ÊßãÈÄ†„Éª„Éú„ÉÉ„ÉÅ", lbl_wall_thick: "Â£Å„ÅÆÂéö„Åø", lbl_rib_shorten: "„É™„ÉñÁü≠Á∏Æ", lbl_enable_ribs: "Ë£úÂº∑„É™„Éñ",
                lbl_homing_bump: "„Éõ„Éº„É†„Éù„Ç∏„Ç∑„Éß„É≥Á™ÅËµ∑", opt_bump_round: "‰∏∏Âûã", opt_bump_bar: "Èï∑ÊñπÂΩ¢",
                lbl_pos_x: "‰ΩçÁΩÆ X", lbl_pos_z: "‰ΩçÁΩÆ Z", lbl_bump_offset: "È´ò„ÅïÂæÆË™øÊï¥",
                lbl_round_corner: "Ëßí„ÅÆ‰∏∏„Åø", note_round: "‚ÄªSquircle MappingÔºàÈ´òÈÄü„ÉªÂÆâÂÆöÔºâ",
                h_shape: "ÂΩ¢Áä∂", lbl_top_scale: "‰∏äÈù¢„Çµ„Ç§„Ç∫", lbl_dish_type: "‰∏äÈù¢ÂΩ¢Áä∂",
                lbl_key_shape_type: "üÜï „Ç≠„ÉºÂΩ¢Áä∂„Çø„Ç§„Éó", opt_shape_rect: "ÂõõËßíÂΩ¢", opt_shape_round: "Ëßí‰∏∏", 
                opt_shape_circle: "ÂÜÜÂΩ¢", opt_shape_polygon: "Â§öËßíÂΩ¢", opt_shape_star: "ÊòüÂΩ¢", opt_shape_iso: "ISO EnterÔºàLÂ≠óÂΩ¢Ôºâ",
                lbl_polygon_sides: "Ëæ∫„ÅÆÊï∞", lbl_star_points: "È†ÇÁÇπÊï∞", lbl_star_inner: "ÂÜÖÂæÑÊØî",
                lbl_iso_settings: "ISO/JIS Enter Ë®≠ÂÆö", lbl_iso_top_w: "‰∏äÈÉ®ÂπÖ", lbl_iso_bottom_w: "‰∏ãÈÉ®ÂπÖ", lbl_iso_total_h: "ÂÖ®‰Ωì„ÅÆÈ´ò„Åï",
                lbl_stem_x: "„Çπ„ÉÜ„É†X", lbl_stem_z: "„Çπ„ÉÜ„É†Z", lbl_stab_top_z: "‰∏ä„Çπ„Çø„ÉìZ", lbl_stab_bottom_z: "‰∏ã„Çπ„Çø„ÉìZ",
                opt_dish_cyl: "ÂÜÜÁ≠í", opt_dish_sph: "ÁêÉ", opt_dish_flat: "Âπ≥",
                lbl_texture: "Ë°®Èù¢„ÉÜ„ÇØ„Çπ„ÉÅ„É£", opt_tex_none: "„Å™„Åó", opt_tex_noise: "Ê¢®Âú∞", opt_tex_grid: "„Ç∞„É™„ÉÉ„Éó",
                lbl_tex_scale: "Á¥∞„Åã„Åï", lbl_tex_strength: "Ê∑±„Åï",
                h_texture_map: "ÁîªÂÉè„ÉÜ„ÇØ„Çπ„ÉÅ„É£", btn_upload_img: "üìÅ ÁîªÂÉèË™≠Ëæº", 
                h_stem: "„Çπ„ÉÜ„É†Ë®≠ÂÆö", lbl_stem_type: "Ëª∏„Çø„Ç§„Éó: Cherry MXÔºàÂõ∫ÂÆöÔºâ", lbl_stem_type_select: "Ëª∏„Çø„Ç§„Éó (Stem Type)", lbl_clearance: "„ÇØ„É™„Ç¢„É©„É≥„Çπ", lbl_stem_diameter: "„Çπ„ÉÜ„É†Â§ñÂæÑ", 
                // V67.3: Êñ∞Ë¶è„É©„Éô„É´
                lbl_click_place: "üñ±Ô∏è Áõ¥ÊÑüÊìç‰Ωú (Interactive)", btn_click_place_off: "ÈÖçÁΩÆ„É¢„Éº„Éâ: OFF", btn_click_place_on: "ÈÖçÁΩÆ„É¢„Éº„Éâ: ON", note_click_place: "‚ÄªON„Å´„Åó„Å¶„É¢„Éá„É´‰∏ä„Çí„ÇØ„É™„ÉÉ„ÇØ„Åô„Çã„Å®„ÄÅÊñáÂ≠ó„ÇÑ„Ç¢„Ç§„Ç≥„É≥„Åå„Åù„ÅÆ‰ΩçÁΩÆ„Å´ÁßªÂãï„Åó„Åæ„Åô",
                btn_ams_config: "AMSËâ≤Ë®≠ÂÆöÔºà„Çπ„É©„Ç§„Çµ„ÉºÂêåÊúüÁî®Ôºâ", btn_ams_import: "AMSË®≠ÂÆö„ÇíË™≠„ÅøËæº„Åø (JSON)",
                sprue_desc: "Ë§áÊï∞„ÅÆ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Çí„Éó„É©„É¢„Éá„É´„ÅÆ„É©„É≥„Éä„Éº„ÅÆ„Çà„ÅÜ„Å´ÈÄ£Áµê„Åó„Å¶Âá∫Âäõ„Åó„Åæ„Åô„ÄÇ",
                h_text: "ÊñáÂ≠óË®≠ÂÆö", lbl_enable_text: "ÊñáÂ≠ó„ÇíÁîüÊàê„Åô„Çã", pl_text: "‰æã: A\n{\n[", note_multiline: "‚ÄªÊîπË°å„Åß2ÊÆµÂç∞Â≠ó„ÅåÂèØËÉΩ",
                lbl_font: "„Éï„Ç©„É≥„Éà", note_font_upload: "‚Äª.ttf „Å™„Å©„Çí„Åù„ÅÆ„Åæ„ÅæË™≠„ÅøËæº„ÇÄ„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ<br><a href='http://gero3.github.io/facetype.js/' target='_blank'>Facetype.js</a> „Å™„Å©„ÅßJSON„Å´Â§âÊèõ„Åó„Åü„Éï„Ç°„Ç§„É´„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                btn_upload_font: "üìÅ „Ç´„Çπ„Çø„É†„Éï„Ç©„É≥„Éà", lbl_size: "„Çµ„Ç§„Ç∫", lbl_thickness: "Ê∑±„Åï/È´ò„Åï", lbl_conform: "Êõ≤Èù¢„Å´Âêà„Çè„Åõ„Çã",
                lbl_align_preset: "ÊñáÂ≠óÈÖçÁΩÆ", btn_align_center: "‰∏≠Â§Æ", btn_align_tl: "Â∑¶‰∏ä",
                btn_align_tr: "Âè≥‰∏ä", btn_align_bl: "Â∑¶‰∏ã", btn_align_br: "Âè≥‰∏ã",
                lbl_pos_xz_fine: "‰ΩçÁΩÆ X / ZÔºàÂæÆË™øÊï¥Ôºâ", lbl_offset_y: "È´ò„ÅïÂæÆË™øÊï¥",
                lbl_text_mode: "ÁîüÊàê„É¢„Éº„Éâ", opt_mode_emboss: "ÊµÆ„ÅçÂá∫„Åó", opt_mode_engrave: "ÂàªÂç∞", opt_mode_doubleshot: "Âüã„ÇÅËæº„Åø", opt_mode_lithophane: "„Éê„ÉÉ„ÇØ„É©„Ç§„ÉàÈÄèÈÅé",
                note_engrave: "‚ÄªEngrave„ÅØË®àÁÆóÂá¶ÁêÜ„Å´ÊôÇÈñì„Åå„Åã„Åã„Çä„Åæ„Åô",
                h_svg: "SVG„Ç¢„Ç§„Ç≥„É≥Ë®≠ÂÆö", btn_upload_svg: "üìÅ SVGË™≠Ëæº", lbl_visible: "Ë°®Á§∫", lbl_rotation: "ÂõûËª¢",
                h_colors: "Ëâ≤Ë®≠ÂÆö", lbl_col_body: "Êú¨‰ΩìËâ≤", lbl_col_text: "ÊñáÂ≠ó„ÉªSVGËâ≤",
                h_preset: "„Éó„É™„Çª„ÉÉ„ÉàÁÆ°ÁêÜ", lbl_browser_storage: "„Éñ„É©„Ç¶„Ç∂„Å´‰øùÂ≠ò", btn_quick_save: "‰∏ÄÊôÇ‰øùÂ≠ò", btn_quick_load: "Âæ©ÂÖÉ",
                lbl_file_storage: "„Éï„Ç°„Ç§„É´„Å´‰øùÂ≠ò", btn_export_file: "Êõ∏„ÅçÂá∫„Åó", btn_import_file: "Ë™≠„ÅøËæº„Åø",
                lbl_url_share: "üîó URL„ÅßÂÖ±Êúâ", btn_share_url: "üìã URL„Çí„Ç≥„Éî„Éº", btn_share_x: "ùïè „Ç∑„Çß„Ç¢", btn_import_url: "Ë™≠„ÅøËæº„Åø", placeholder_url_import: "ÂÖ±ÊúâURL„ÇíË≤º„Çä‰ªò„Åë...",
                lbl_named_preset: "üÜï ÂêçÂâç‰ªò„Åç„Éó„É™„Çª„ÉÉ„Éà‰øùÂ≠ò", placeholder_preset_name: "„Éó„É™„Çª„ÉÉ„ÉàÂêç„ÇíÂÖ•Âäõ...", btn_save_named: "üíæ ÂêçÂâç„Çí‰ªò„Åë„Å¶‰øùÂ≠ò",
                lbl_loaded_presets: "üìÅ Ë™≠„ÅøËæº„Çì„Å†„Éó„É™„Çª„ÉÉ„Éà:", btn_load_add: "Ë™≠„ÅøËæº„ÅøÔºàËøΩÂä†Ôºâ",
                pv_profile: "„Éó„É≠„Éï„Ç°„Ç§„É´:", pv_size: "„Çµ„Ç§„Ç∫:", pv_shape: "ÂΩ¢Áä∂:", pv_text: "ÊñáÂ≠ó:", pv_text2: "„Çµ„ÉñÊñáÂ≠ó:", pv_side: "„Çµ„Ç§„Éâ:", pv_svg: "SVG:",
                msg_url_copied: "URL„Çí„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ", msg_url_invalid: "ÁÑ°Âäπ„Å™URL„Åß„Åô", msg_url_loaded: "URL„Åã„Çâ„Éó„É™„Çª„ÉÉ„Éà„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü", msg_x_shared: "X(Twitter)„ÅÆÊäïÁ®øÁîªÈù¢„ÇíÈñã„Åç„Åæ„Åó„Åü",
                hint_f1_notice: "Wiki„ÅßË©≥„Åó„ÅèË¶ã„Çã",
                btn_prev: "‚óÄ Ââç„Å∏", btn_next: "Ê¨°„Å∏ ‚ñ∂", btn_clear_all: "ÂÖ®ÂâäÈô§",
                h_export: "„Ç®„ÇØ„Çπ„Éù„Éº„Éà", lbl_filename: "„Éï„Ç°„Ç§„É´ÂêçË®≠ÂÆöÔºàËá™Âãï„Åß[ÊñáÂ≠ó]„Åå‰ªò‰∏é„Åï„Çå„Åæ„ÅôÔºâ", btn_export_single: "„Ç®„ÇØ„Çπ„Éù„Éº„Éà", btn_export_all: "ÂÖ®‰Ωì„ÇíSTL„Åß‰øùÂ≠ò", btn_export_obj: "ÂÖ®‰Ωì„ÇíOBJ„Åß‰øùÂ≠ò",
                btn_export_3mf: "ÂÖ®‰Ωì„Çí3MF„Åß‰øùÂ≠ò", btn_export_body: "Êú¨‰Ωì„ÅÆ„Åø", btn_export_text: "ÊñáÂ≠ó„ÅÆ„Åø",
                h_batch: "„Éê„ÉÉ„ÉÅÂá∫Âäõ", lbl_batch_list: "ÊñáÂ≠ó„É™„Çπ„ÉàÔºà„Ç´„É≥„Éû/ÊîπË°åÂå∫Âàá„ÇäÔºâ", pl_batch: "Q,W,E,R,T,Y...",
                lbl_batch_format: "Âá∫ÂäõÂΩ¢Âºè",
                note_batch: "‚ÄªÁèæÂú®„ÅÆË®≠ÂÆö„ÅßÈÄ£Á∂öÁîüÊàê„Åó„Åæ„Åô", btn_batch_run: "‰∏ÄÊã¨ÁîüÊàê", 
                batch_processing: "Âá¶ÁêÜ‰∏≠: ", batch_complete: "ÂÆå‰∫ÜÔºÅ",
                msg_save_ok: "Ë®≠ÂÆö„Çí„Éñ„É©„Ç¶„Ç∂„Å´‰∏ÄÊôÇ‰øùÂ≠ò„Åó„Åæ„Åó„Åü„ÄÇ", msg_load_ok: "Ë®≠ÂÆö„ÇíÂæ©ÂÖÉ„Åó„Åæ„Åó„Åü„ÄÇ", msg_load_err: "‰øùÂ≠ò„Åï„Çå„ÅüË®≠ÂÆö„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ",
                msg_import_err: "„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº: Ê≠£„Åó„ÅÑJSONÂΩ¢Âºè„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ", msg_batch_empty: "ÊñáÂ≠ó„É™„Çπ„Éà„ÅåÁ©∫„Åß„Åô„ÄÇ",
                toast_generating: "„É°„ÉÉ„Ç∑„É•„ÇíÁîüÊàê‰∏≠...", toast_stl_exported: "STL„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„ÅüÔºÅ", 
                toast_obj_exported: "OBJ„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„ÅüÔºÅ", toast_3mf_exported: "3MF„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„ÅüÔºÅ",
                toast_export_failed: "„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÂ§±Êïó: ", toast_no_body: "„Ç®„É©„Éº: „Éú„Éá„Ç£„Ç∏„Ç™„É°„Éà„É™„ÅåÁîüÊàê„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü",
                h_import: "Â§ñÈÉ®„É¢„Éá„É´", btn_load_stl: "üìÅ STL„É¢„Éá„É´Ë™≠Ëæº", lbl_weight: "‰∫àÊÉ≥ÈáçÈáè:", lbl_cost: "‰∫àÊÉ≥„Ç≥„Çπ„Éà:", 
                lbl_vendor: "„Éô„É≥„ÉÄ„Éº:", lbl_material: "ÊùêÊñô:", btn_details: "‚ñº Ë©≥Á¥∞ / Á∑®ÈõÜ",
                lbl_manual_override: "ÊâãÂãïË®≠ÂÆö", lbl_price: "‰æ°Ê†º", lbl_spool: "„É™„Éº„É´(g)", lbl_density: "ÂØÜÂ∫¶",
                link_wiki: "Wiki„Å∏ÁßªÂãï", link_github: "GitHub„Å∏ÁßªÂãï",
                lbl_show_hints: "üí° „Éí„É≥„ÉàË°®Á§∫",
                hint_lang: "Ë°®Á§∫Ë®ÄË™û„ÇíÊó•Êú¨Ë™û„Åæ„Åü„ÅØËã±Ë™û„Å´Âàá„ÇäÊõø„Åà„Åæ„Åô„ÄÇ",
                hint_section_jump: "Ë®≠ÂÆö„Åó„Åü„ÅÑÈ†ÖÁõÆ„Å∏Á¥†Êó©„ÅèÁßªÂãï„Åó„Åæ„Åô„ÄÇ",
                hint_search: "Ë®≠ÂÆöÈ†ÖÁõÆÂêç„ÅßÊ§úÁ¥¢„Åó„ÄÅË©≤ÂΩìÁÆáÊâÄ„Çí„Éè„Ç§„É©„Ç§„Éà„Åó„Åæ„Åô„ÄÇ",
                hint_stats: "ÁèæÂú®„ÅÆË®≠ÂÆö„Å´Âü∫„Å•„ÅÑ„Åü„ÄÅ„Éï„Ç£„É©„É°„É≥„Éà„ÅÆÊ¶ÇÁÆóÈáçÈáè„Å®„Ç≥„Çπ„Éà„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ„ÇØ„É™„ÉÉ„ÇØ„ÅßÊùêÊñôË®≠ÂÆö„ÇíÈñãÈñâ„Åß„Åç„Åæ„Åô„ÄÇ",
                hint_unit_size: "1U„ÅÆÂü∫Ê∫ñ„Çµ„Ç§„Ç∫„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇÈÄöÂ∏∏„ÅØ19.05mm„Åß„Åô„Åå„ÄÅChocÁ≥ª„Å™„Å©„ÅØÂ∞è„Åï„ÅèË®≠ÂÆö„Åó„Åæ„Åô„ÄÇ",
                hint_key_size: "„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÊ®™ÂπÖ„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇ1.0(ÈÄöÂ∏∏)„ÄÅ2.0(BackSpace)„ÄÅ6.25(Space)„Å™„Å©„ÄÇ",
                hint_stabilizer: "2U‰ª•‰∏ä„ÅÆ„Ç≠„Éº„Å´‰ªò„Åè„Çπ„Çø„Éì„É©„Ç§„Ç∂„Éº„ÅÆ‰ΩçÁΩÆË®≠ÂÆö„Åß„Åô„ÄÇÂü∫Êú¨„ÅØAuto„ÅßÂïèÈ°å„ÅÇ„Çä„Åæ„Åõ„Çì„Åå„ÄÅÁâπÊÆä„Å™ÈÖçÁΩÆ„ÅÆÂ†¥Âêà„ÅØCustom„ÅßË™øÊï¥„Åó„Åæ„Åô„ÄÇ",
                hint_profile: "„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂÖ®‰ΩìÂΩ¢Áä∂Ôºà„Éó„É≠„Éï„Ç°„Ç§„É´Ôºâ„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇCherry, OEM, SA, XDA, DSA„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
                hint_row: "„Ç≠„Éº„ÅÆÈ´ò„Åï„Å®ÂÇæÊñúËßíÂ∫¶ÔºàR1„ÄúR4Ôºâ„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇ„Éó„É≠„Éï„Ç°„Ç§„É´„Å´„Çà„Å£„Å¶ÂΩ¢Áä∂„ÅåÁï∞„Å™„Çä„Åæ„Åô„ÄÇ",
                hint_fillet: "„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂõõÈöÖ„Çí‰∏∏„Åè„Åó„Åæ„ÅôÔºàSquircleÂΩ¢Áä∂Ôºâ„ÄÇÂÄ§„ÇíÂ§ß„Åç„Åè„Åô„Çã„Å®‰∏∏„Åè„Å™„Çä„Åæ„Åô„ÄÇ",
                hint_wall_thick: "„Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÂÅ¥Èù¢„ÅÆÂéö„Åø„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇËñÑ„Åô„Åé„Çã„Å®Âº∑Â∫¶„ÅåËêΩ„Å°„ÄÅÂéö„Åô„Åé„Çã„Å®„Çπ„Ç§„ÉÉ„ÉÅ„Å®Âπ≤Ê∏â„Åô„ÇãÂ†¥Âêà„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ",
                hint_rib_shorten: "ÂÜÖÈÉ®„ÅÆ„É™„ÉñÔºàË£úÂº∑Ôºâ„ÅÆ‰∏ãÁ´Ø„Çí„Å©„ÅÆ„Åè„Çâ„ÅÑÊåÅ„Å°‰∏ä„Åí„Çã„ÅãË®≠ÂÆö„Åó„Åæ„Åô„ÄÇLED„Å®„ÅÆÂπ≤Ê∏â„ÇíÈò≤„ÅêÂ†¥Âêà„Å™„Å©„Å´Ë™øÊï¥„Åó„Åæ„Åô„ÄÇ",
                hint_enable_ribs: "ÂÜÖÈÉ®„Å´ÂçÅÂ≠ó„ÅÆË£úÂº∑Â£Å„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇÂº∑Â∫¶„ÅåÂêë‰∏ä„Åó„ÄÅÂèç„Çä„ÇíÈò≤„Åé„Åæ„Åô„ÄÇ",
                hint_homing_bump: "F„Ç≠„Éº„ÇÑJ„Ç≠„Éº„Å´‰ªò„ÅÑ„Å¶„ÅÑ„Çã„ÄÅÊåá„ÅÆÊÑüËß¶„Åß‰ΩçÁΩÆ„ÇíÁü•„Çã„Åü„ÇÅ„ÅÆÁ™ÅËµ∑„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ",
                hint_bump_type: "Á™ÅËµ∑„ÅÆÂΩ¢Áä∂„Çí„Äé‰∏∏Âûã„Äè„Åã„Äé„Éê„ÉºÔºàÈï∑ÊñπÂΩ¢Ôºâ„Äè„Åã„ÇâÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇ",
                hint_key_shape: "„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂü∫Êú¨ÂΩ¢Áä∂„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇÂõõËßíÂΩ¢„ÄÅËßí‰∏∏„ÄÅÂÜÜÂΩ¢„ÄÅÂ§öËßíÂΩ¢„ÄÅÊòüÂΩ¢„ÄÅISO EnterÔºàLÂ≠óÂΩ¢Ôºâ„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
                hint_taper: "„Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÂ§©Èù¢„ÅÆÂ∫É„Åï„ÇíË™øÊï¥„Åó„Åæ„Åô„ÄÇÂÄ§„ÇíÂ∞è„Åï„Åè„Åô„Çã„Å®Âè∞ÂΩ¢„Åå„Åç„Å§„Åè„Å™„Çä„Åæ„Åô„ÄÇ",
                hint_dish_type: "Êåá„ÇíÁΩÆ„ÅèÂ§©Èù¢„ÅÆ„Åè„Åº„ÅøÂΩ¢Áä∂„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇÂÜÜÁ≠í(Cylindrical)„ÄÅÁêÉ(Spherical)„ÄÅÂπ≥Âù¶(Flat)„Åã„ÇâÈÅ∏„Åπ„Åæ„Åô„ÄÇ",
                hint_texture: "Ë°®Èù¢„Å´„Ç∂„É©„Ç∂„É©„ÇÑÊ®°Êßò„Å™„Å©„ÅÆ„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíËá™ÂãïÁîüÊàê„Åó„Åæ„Åô„ÄÇ",
                hint_texture_global: "„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíÂ§©Èù¢„Å†„Åë„Åß„Å™„Åè„ÄÅÂÅ¥Èù¢„ÇíÂê´„ÇÄ„Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÂÖ®‰Ωì„Å´ÈÅ©Áî®„Åó„Åæ„Åô„ÄÇ",
                hint_twist: "„Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÂÖ®‰Ωì„Çí„Å≠„Åò„Çä„Åæ„Åô„ÄÇArtisan„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó‰ΩúÊàê„Å™„Å©„Å´‰Ωø„Åà„Åæ„Åô„ÄÇ",
                hint_tilt: "Â§©Èù¢„ÅÆÂÇæ„Åç„ÇíXËª∏„ÉªZËª∏ÊñπÂêë„Å∏ÊâãÂãï„ÅßÂæÆË™øÊï¥„Åó„Åæ„Åô„ÄÇ",
                hint_img_upload: "PNG„Åæ„Åü„ÅØJPGÁîªÂÉè„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„ÄÅ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆË°®Èù¢„Å´„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Å®„Åó„Å¶Ë≤º„Çä‰ªò„Åë„Åæ„Åô„ÄÇÂ•Ω„Åç„Å™ÊüÑ„ÇÑÂÜôÁúü„Çí„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÊ®°Êßò„Å´„Åß„Åç„Åæ„Åô„ÄÇ",
                hint_custom_font: "Facetype.js„Å™„Å©„ÅßÂ§âÊèõ„Åó„Åü„ÄéJSONÂΩ¢Âºè„Äè„ÅÆ„Éï„Ç©„É≥„Éà„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Åø„Åæ„Åô„ÄÇ‚ÄªPC„Å´ÂÖ•„Å£„Å¶„ÅÑ„ÇãTTF„ÇÑOTF„Éï„Ç°„Ç§„É´„ÅØÁõ¥Êé•‰ΩøÁî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇ",
                hint_stem_diameter: "„Çπ„Ç§„ÉÉ„ÉÅ„Å´Êåø„ÅôËª∏„ÅÆÂ§ñÂÅ¥„ÅÆÂ§™„Åï„ÇíË™øÊï¥„Åó„Åæ„Åô„ÄÇÊ®ôÊ∫ñ„ÅØ5.5mm„Åß„Åô„ÄÇ",
                hint_clearance: "ÂçÅÂ≠óÁ©¥„ÅÆÈöôÈñìÔºàÂÖ¨Â∑ÆÔºâ„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇ„Åç„Å§„Åè„Å¶ÂÖ•„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØÂÄ§„ÇíÂ§ß„Åç„Åè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                hint_stem_ext: "„Çπ„ÉÜ„É†„Å†„Åë„ÇíÂ∫ïÈù¢„Çà„ÇäÈï∑„Åè‰º∏„Å∞„Åó„Åæ„Åô„ÄÇÁâπÊÆä„Å™„Çπ„Ç§„ÉÉ„ÉÅ„ÇÑÈ´ò„ÅïË™øÊï¥„Å´‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ",
                hint_box_stem: "ÂçÅÂ≠ó„Çπ„ÉÜ„É†„ÅÆÂë®„Çä„ÇíÂõõËßí„ÅÑÂ£Å„ÅßÂõ≤„Åø„ÄÅÂº∑Â∫¶„Å®Èò≤Â°µÊÄß„ÇíÈ´ò„ÇÅ„Åæ„ÅôÔºàKailh Box„Çπ„Ç§„ÉÉ„ÉÅÈ¢®Ôºâ„ÄÇ",
                hint_lego_stud: "Â§©Èù¢„Å´„É¨„Ç¥„Éñ„É≠„ÉÉ„ÇØ‰∫íÊèõ„ÅÆ„Éù„ÉÉ„ÉÅ„ÇíËøΩÂä†„Åó„Åæ„Åô„ÄÇ",
                hint_enable_text: "ÊñáÂ≠ó„ÅÆÁîüÊàê„ÇíON/OFF„Åó„Åæ„Åô„ÄÇ",
                hint_text_input: "ÂàªÂç∞„Åó„Åü„ÅÑÊñáÂ≠ó„ÇíÂÖ•Âäõ„Åó„Åæ„Åô„ÄÇÊîπË°å„Åô„Çã„Å®2Ë°å„Å´„Å™„Çä„Åæ„Åô„ÄÇ",
                hint_font: "ÂàªÂç∞„Å´‰ΩøÁî®„Åô„Çã„Éï„Ç©„É≥„Éà„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇ",
                hint_text_mode: "Emboss(ÊµÆ„ÅçÂá∫„Åó)„ÄÅEngrave(ÂΩ´„ÇäËæº„Åø)„ÄÅDouble-Shot(Âà•„Éë„Éº„ÉÑÂåñ)„ÄÅLithophane(„Éê„ÉÉ„ÇØ„É©„Ç§„ÉàÈÄèÈÅé)„Åã„ÇâÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇ",
                hint_text_height: "ÊñáÂ≠ó„ÅÆÂéö„Åø„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇDouble-Shot„ÅÆÂ†¥Âêà„ÅØÂüã„ÇÅËæº„ÇÄÊ∑±„Åï„Å´„Å™„Çä„Åæ„Åô„ÄÇ",
                hint_conform: "„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂ§©Èù¢„ÅÆ„Ç´„Éº„Éñ„Å´Ê≤ø„Å£„Å¶ÊñáÂ≠ó„ÇíÂ§âÂΩ¢„Åï„Åõ„Åæ„Åô„ÄÇ",
                hint_align_preset: "‰∏≠Â§Æ„ÄÅÂ∑¶‰∏ä„ÄÅÂè≥‰∏ã„Å™„Å©„ÅÆÂÆö‰ΩçÁΩÆ„Å∏„ÉØ„É≥„ÇØ„É™„ÉÉ„ÇØ„ÅßÊñáÂ≠ó„ÇíÁßªÂãï„Åï„Åõ„Åæ„Åô„ÄÇ",
                hint_text2: "„É°„Ç§„É≥ÊñáÂ≠ó„Å®„ÅØÂà•„Å´„ÄÅÂè≥‰∏ã„Å™„Å©„Å´Â∞è„Åï„Å™ÊñáÂ≠ó„ÇíËøΩÂä†„Åó„Åæ„Åô„ÄÇ",
                hint_side_print: "„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÊâãÂâçÂÅ¥Èù¢Ôºà„Éï„É≠„É≥„ÉàÔºâ„Å´ÊñáÂ≠ó„ÇíÂÖ•„Çå„Åæ„Åô„ÄÇ",
                hint_svg_upload: "„Éô„ÇØ„Çø„ÉºÁîªÂÉè(.svg)„ÇíË™≠„ÅøËæº„Çì„ÅßÂàªÂç∞„Åó„Åæ„Åô„ÄÇ„É≠„Ç¥„ÇÑ„Ç¢„Ç§„Ç≥„É≥„Å´ÊúÄÈÅ©„Åß„Åô„ÄÇ",
                hint_svg_mode: "SVG„ÅÆÂá¶ÁêÜÊñπÊ≥ï„ÇíÈÅ∏„Å≥„Åæ„Åô„ÄÇDouble-Shot„Å´„Åô„Çã„Å®„Éû„É´„ÉÅ„Ç´„É©„ÉºÂç∞Âà∑Áî®„Å´Âà•„Éë„Éº„ÉÑ„Å®„Åó„Å¶Âá∫Âäõ„Åß„Åç„Åæ„Åô„ÄÇ",
                hint_colors: "„Éó„É¨„Éì„É•„ÉºÁîªÈù¢‰∏ä„ÅÆËâ≤„ÇíÂ§âÊõ¥„Åó„Åæ„Åô„ÄÇ‚ÄªSTLÂá∫Âäõ„Å´„ÅØÂΩ±Èüø„Åó„Åæ„Åõ„Çì„Åå„ÄÅOBJ/3MFÂá∫ÂäõÊôÇ„Å´„ÅØÂèçÊò†„Åï„Çå„Åæ„Åô„ÄÇ",
                hint_url_share: "ÁèæÂú®„ÅÆË®≠ÂÆö„ÇíURL„Å´„Ç®„É≥„Ç≥„Éº„Éâ„Åó„Å¶„Ç≥„Éî„Éº„Åó„Åæ„Åô„ÄÇSNS„Å™„Å©„ÅßÂÖ±Êúâ„Åß„Åç„Åæ„Åô„ÄÇ",
                hint_quick_save: "ÁèæÂú®„ÅÆË®≠ÂÆö„Çí„Éñ„É©„Ç¶„Ç∂„Å´‰∏ÄÊôÇÁöÑ„Å´‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ",
                hint_export_json: "Ë®≠ÂÆö„Çí„Éï„Ç°„Ç§„É´„Å®„Åó„Å¶‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇÂæå„ÅßË™≠„ÅøËæº„Çì„Å†„Çä„ÄÅ‰ªñ„ÅÆ‰∫∫„Å®ÂÖ±Êúâ„Åß„Åç„Åæ„Åô„ÄÇ",
                hint_import_json: "‰øùÂ≠ò„Åó„ÅüË®≠ÂÆö„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Åø„Åæ„Åô„ÄÇË§áÊï∞„Éï„Ç°„Ç§„É´„Çí„Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„Éó„Åô„Çã„Å®‰∏ÄÊã¨„Åß„É™„Çπ„Éà„Å´ËøΩÂä†„Åï„Çå„Åæ„Åô„ÄÇ",
                hint_print_orient: "3D„Éó„É™„É≥„ÉàÊôÇ„ÅÆÂêë„Åç„Å´Âêà„Çè„Åõ„Å¶„ÄÅ„É¢„Éá„É´ÂÖ®‰Ωì„ÇíÂõûËª¢„Åï„Åõ„Åæ„Åô„ÄÇ",
                hint_export_stl: "‰∏ÄËà¨ÁöÑ„Å™3D„Éó„É™„É≥„Çø„ÉºÁî®„ÅÆÂΩ¢Âºè(.stl)„Åß‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ",
                hint_export_3mf: "Ëâ≤ÊÉÖÂ†±„ÇíÂê´„Çì„Å†ÂΩ¢Âºè(.3mf)„Åß‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇBambu Lab„Å™„Å©„ÅÆ„Éû„É´„ÉÅ„Ç´„É©„ÉºÂç∞Âà∑„Å´ÊúÄÈÅ©„Åß„Åô„ÄÇ",
                hint_export_parts: "„Éë„Éº„ÉÑ„ÇíÂÄãÂà•„Å´STLÂá∫Âäõ„Åó„Åæ„Åô„ÄÇÁï∞„Å™„ÇãËâ≤„ÅÆ„Éï„Ç£„É©„É°„É≥„Éà„ÅßÂç∞Âà∑„Åô„ÇãÂ†¥Âêà„Å™„Å©„Å´‰Ωø„ÅÑ„Åæ„Åô„ÄÇ",
                hint_batch_list: "„Åì„Åì„Å´„Ç´„É≥„ÉûÂå∫Âàá„ÇäÔºàA,B,C...Ôºâ„ÅßÊñáÂ≠ó„ÇíÂÖ•„Çå„Çã„Å®„ÄÅÁèæÂú®„ÅÆË®≠ÂÆö„ÅßÈ†ÜÁï™„Å´Ëá™ÂãïÁîüÊàê„Åó„Åæ„Åô„ÄÇ",
                hint_batch_run: "„É™„Çπ„Éà„ÅÆÊñáÂ≠ó„ÇíÈÄ£Á∂ö„ÅßÁîüÊàê„Åó„ÄÅ„Åæ„Å®„ÇÅ„Å¶„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Åæ„Åô„ÄÇ",
                hint_randomizer: "„Åô„Åπ„Å¶„ÅÆ„Éë„É©„É°„Éº„Çø„Çí„É©„É≥„ÉÄ„É†„Å´Â§âÊõ¥„Åó„Åæ„Åô„ÄÇÊñ∞„Åó„ÅÑ„Ç¢„Ç§„Éá„Ç¢Êé¢„Åó„Å´„ÄÇ",
                hint_reset: "„Åô„Åπ„Å¶„ÅÆË®≠ÂÆö„ÇíÂàùÊúüÁä∂ÊÖã„Å´Êàª„Åó„Åæ„Åô„ÄÇ",
                hint_import_stl: "Ëá™‰Ωú„ÅÆ3D„É¢„Éá„É´(.stl)„ÇíË™≠„ÅøËæº„Çì„ÅßÂêàÊàê„Åó„Åæ„Åô„ÄÇ",
                hint_import_op: "UnionÔºàÁµêÂêàÔºâ„ÅØÁõõ„Çä‰∏ä„Åí„ÄÅSubtractÔºàÂûãÊäú„ÅçÔºâ„ÅØÂΩ´„ÇäËæº„Åø„Å´‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ‚ÄªSubtract„ÅØÂá¶ÁêÜÊôÇÈñì„Åå„Åã„Åã„Çä„Åæ„Åô„ÄÇ",
                // V66 Translations
                lbl_simple_mode: "üå± Á∞°Âçò„É¢„Éº„Éâ (Simple)",
                h_simple_mode: "üå± Á∞°Âçò„É¢„Éº„Éâ",
                lbl_simple_text: "ÊñáÂ≠óÂÖ•Âäõ",
                lbl_text_visible: "ÊñáÂ≠óË°®Á§∫",
                lbl_simple_font: "„Éï„Ç©„É≥„Éà",
                lbl_simple_icon: "„Ç¢„Ç§„Ç≥„É≥",
                btn_clear_icon: "„Ç¢„Ç§„Ç≥„É≥Ëß£Èô§",
                lbl_simple_profile: "ÂΩ¢Áä∂",
                lbl_simple_row: "Ë°å",
                lbl_simple_key_size: "„Ç≠„Éº„ÅÆÂπÖ",
                lbl_simple_body_color: "Êú¨‰ΩìËâ≤",
                lbl_simple_text_color: "ÊñáÂ≠óËâ≤",
                lbl_simple_text_mode: "ÁîüÊàê„É¢„Éº„Éâ",
                lbl_simple_gen_mode: "ÁîüÊàê„É¢„Éº„ÉâÔºàÊñáÂ≠ó„Éª„Ç¢„Ç§„Ç≥„É≥Ôºâ",
                view_front: "Ââç", view_back: "Âæå", view_right: "Âè≥", view_left: "Â∑¶", view_top: "‰∏ä", view_bottom: "‰∏ã",
                lbl_simple_taper: "‰∏äÈù¢„Çµ„Ç§„Ç∫",
                lbl_simple_dish: "‰∏äÈù¢ÂΩ¢Áä∂",
                lbl_simple_fillet: "Ëßí„ÅÆ‰∏∏„Åø",
                lbl_dimension_lines: "üìê ÂØ∏Ê≥ïÁ∑ö„ÇíË°®Á§∫ (V66)",
                lbl_layer_color: "üé® „É¨„Ç§„É§„Éº„Ç´„É©„Éº„Éª„Éó„É¨„Éì„É•„Éº",
                lbl_visual_presets: "üé® „Éì„Ç∏„É•„Ç¢„É´„Éó„É™„Çª„ÉÉ„Éà (V66)",
                lbl_stock_icons: "üì¶ ÂÜÖËîµ„Ç¢„Ç§„Ç≥„É≥ (V66)",
                lbl_tolerance_test: "üîß „Çπ„ÉÜ„É†„ÉÜ„Çπ„Éà„Ç≠„ÉÉ„Éà (V66)",
                lbl_sprue_kit: "üîó „Çπ„Éó„É´„Éº„Éª„Ç≠„ÉÉ„ÉàÁîüÊàê (V66)",
                hint_simple_mode: "Á∞°Âçò„É¢„Éº„Éâ„Åß„ÅØ„ÄÅÂàùÂøÉËÄÖÂêë„Åë„Å´ÂøÖË¶ÅÊúÄÂ∞èÈôê„ÅÆË®≠ÂÆöÈ†ÖÁõÆ„ÅÆ„ÅøË°®Á§∫„Åó„Åæ„Åô„ÄÇÁ¥∞„Åã„ÅÑË®≠ÂÆö„ÅØV65„ÅÆ„Éá„Éï„Ç©„É´„ÉàÂÄ§„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ",
                hint_dimension_lines: "3D„Éì„É•„Éº‰∏ä„Å´„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂØ∏Ê≥ïÁ∑ö„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇÂç∞Âà∑Ââç„ÅÆ„Çµ„Ç§„Ç∫Á¢∫Ë™ç„Å´‰æøÂà©„Åß„Åô„ÄÇ",
                hint_layer_color: "Bambu Lab AMS„Å™„Å©„Åß„Éï„Ç£„É©„É°„É≥„Éà‰∫§ÊèõÊôÇ„ÅÆËâ≤„ÅÆÂ§âÂåñ„Çí„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥„Åó„Åæ„Åô„ÄÇ",
                hint_visual_presets: "„Çà„Åè‰Ωø„ÅÜ„Ç≠„ÉºÔºàWASD„ÄÅÁü¢Âç∞„Ç≠„Éº„Å™„Å©Ôºâ„Çí„ÉØ„É≥„ÇØ„É™„ÉÉ„ÇØ„ÅßË®≠ÂÆö„Åß„Åç„Åæ„Åô„ÄÇ",
                hint_stock_icons: "„Çà„Åè‰Ωø„ÅÜ„Ç¢„Ç§„Ç≥„É≥ÔºàÁü¢Âç∞„ÄÅÂÜçÁîü„ÄÅCommand„Ç≠„Éº„Å™„Å©Ôºâ„ÅåÂÜÖËîµ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇSVG„ÇíÊé¢„ÅôÊâãÈñì„ÇíÁúÅ„Åë„Åæ„Åô„ÄÇ",
                hint_tolerance_test: "„Éó„É™„É≥„Çø„Éº„ÅÆÂÖ¨Â∑Æ„ÉÜ„Çπ„ÉàÁî®„ÅÆ„Çπ„ÉÜ„É†„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇÊúÄÈÅ©„Å™„ÇØ„É™„Ç¢„É©„É≥„ÇπÂÄ§„ÇíË¶ã„Å§„Åë„Çã„ÅÆ„Å´‰æøÂà©„Åß„Åô„ÄÇ",
                hint_sprue_kit: "Ë§áÊï∞„ÅÆ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Çí„Éó„É©„É¢„Éá„É´„ÅÆ„É©„É≥„Éä„Éº„ÅÆ„Çà„ÅÜ„Å´ÈÄ£Áµê„Åó„Å¶Âá∫Âäõ„Åó„Åæ„Åô„ÄÇ„ÇÆ„Éï„Éà„ÇÑË≤©Â£≤„Å´ÊúÄÈÅ©„ÄÇ",
                hint_simple_key_size: "„Çà„Åè‰Ωø„ÅÜ„Ç≠„Éº„Çµ„Ç§„Ç∫„Çí„Éú„Çø„É≥„ÅßÁ∞°Âçò„Å´ÈÅ∏Êäû„Åß„Åç„Åæ„Åô„ÄÇ",
                hint_snapshot: "ÁèæÂú®„ÅÆ3D„Éì„É•„Éº„ÇíÁîªÂÉè„Å®„Åó„Å¶‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ",
                hint_gallery_open: "‰øùÂ≠ò„Åó„Åü„Éó„É™„Çª„ÉÉ„Éà„ÅÆ„ÇÆ„É£„É©„É™„Éº„ÇíÈñã„Åç„Åæ„Åô„ÄÇ",
                hint_gallery_save: "ÁèæÂú®„ÅÆË®≠ÂÆö„Çí„ÇÆ„É£„É©„É™„Éº„Å´‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ",
                hint_gumball: "„ÉÜ„Ç≠„Çπ„Éà„ÇÑSVG„ÄÅ„Ç§„É≥„Éù„Éº„Éà„Åó„Åü„É¢„Éá„É´„ÅÆ‰ΩçÁΩÆ„Çí„Éâ„É©„ÉÉ„Ç∞„ÅßË™øÊï¥„Åß„Åç„Åæ„Åô„ÄÇ",
                hint_toggle_text: "3D„Éì„É•„Éº‰∏ä„ÅÆÊñáÂ≠ó„ÅÆË°®Á§∫/ÈùûË°®Á§∫„ÇíÂàá„ÇäÊõø„Åà„Åæ„Åô„ÄÇ",
                hint_toggle_svg: "3D„Éì„É•„Éº‰∏ä„ÅÆSVG„ÅÆË°®Á§∫/ÈùûË°®Á§∫„ÇíÂàá„ÇäÊõø„Åà„Åæ„Åô„ÄÇ",
                // V67.3: Êã°Âºµ„ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó
                hint_stem_type: "„Ç≠„Éº„Çπ„Ç§„ÉÉ„ÉÅ„ÅÆËª∏„Çø„Ç§„Éó„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇCherry MX„ÄÅKailh Choc„ÄÅTopre„ÄÅAlps„Å™„Å©ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
                hint_click_place: "ON„Å´„Åó„Å¶„É¢„Éá„É´‰∏ä„Çí„ÇØ„É™„ÉÉ„ÇØ„Åô„Çã„Å®„ÄÅÊñáÂ≠ó„ÇÑ„Ç¢„Ç§„Ç≥„É≥„Åå„Åù„ÅÆ‰ΩçÁΩÆ„Å´ÁßªÂãï„Åó„Åæ„Åô„ÄÇÁõ¥ÊÑüÁöÑ„Å™ÈÖçÁΩÆ„ÅåÂèØËÉΩ„Åß„Åô„ÄÇ",
                // Export Popup
                popup_export_confirm: "„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÁ¢∫Ë™ç",
                popup_cancel: "„Ç≠„É£„É≥„Çª„É´",
                popup_export: "„Ç®„ÇØ„Çπ„Éù„Éº„Éà",
                popup_est_weight: "‰∫àÊÉ≥ÈáçÈáè",
                popup_est_cost: "‰∫àÊÉ≥„Ç≥„Çπ„Éà",
                popup_body_color: "Êú¨‰ΩìËâ≤",
                popup_text_color: "ÊñáÂ≠óËâ≤",
                popup_vendor: "„Éô„É≥„ÉÄ„Éº",
                popup_material: "ÊùêÊñô",
                popup_profile: "„Éó„É≠„Éï„Ç°„Ç§„É´",
                popup_size: "„Çµ„Ç§„Ç∫",
                popup_row: "Ë°å",
                popup_text: "ÊñáÂ≠ó",
                popup_svg_icon: "SVG„Ç¢„Ç§„Ç≥„É≥",
                popup_printer: "„Éó„É™„É≥„Çø„Éº",
                popup_build_size: "ÈÄ†ÂΩ¢„Çµ„Ç§„Ç∫",
                popup_key_count: "„Ç≠„ÉºÊï∞",
                popup_layout: "ÈÖçÁΩÆ",
                popup_char_list: "ÊñáÂ≠ó„É™„Çπ„Éà",
                popup_format: "Âá∫ÂäõÂΩ¢Âºè",
                popup_file_count: "„Éï„Ç°„Ç§„É´Êï∞",
                // Sprue Kit
                sprue_printer_model: "„Éó„É™„É≥„Çø„ÉºÊ©üÁ®Æ",
                sprue_max_keys: "ÊúÄÂ§ßÈÖçÁΩÆÂèØËÉΩ",
                sprue_key_count: "„Ç≠„ÉÉ„ÉàÂÜÖ„ÅÆ„Ç≠„ÉºÊï∞",
                sprue_repeat_mode: "Âêå„ÅòÊñáÂ≠ó„ÇíÈÄ£Á∂öÂá∫Âäõ",
                sprue_char_list: "ÊñáÂ≠ó„É™„Çπ„Éà („Ç´„É≥„ÉûÂå∫Âàá„Çä)",
                sprue_single_char: "ÈÄ£Á∂öÂá∫Âäõ„Åô„ÇãÊñáÂ≠ó",
                sprue_output_format: "Âá∫ÂäõÂΩ¢Âºè",
                sprue_generate: "„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„ÉàÁîüÊàê",
                sprue_custom: "üé® „Ç´„Çπ„Çø„É†„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„Éà",
                sprue_generating: "„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„ÉàÁîüÊàê‰∏≠...",
                sprue_unlimited: "Âà∂Èôê„Å™„Åó",
                // Tolerance Test
                tolerance_desc: "„Éó„É™„É≥„Çø„Éº„ÅÆÂÖ¨Â∑Æ„Çí„ÉÜ„Çπ„Éà„Åô„Çã„Åü„ÇÅ„ÅÆ„Çπ„ÉÜ„É†„Å†„Åë„Çí‰∏¶„Åπ„Åü„Éó„É¨„Éº„Éà„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ",
                tolerance_output_format: "Âá∫ÂäõÂΩ¢Âºè",
                tolerance_generate: "„ÉÜ„Çπ„Éà„Ç≠„ÉÉ„ÉàÁîüÊàê",
                tolerance_start: "ÈñãÂßãÂÄ§",
                tolerance_step: "Âàª„Åø",
                tolerance_generating: "„Çπ„ÉÜ„É†„ÉÜ„Çπ„Éà„Ç≠„ÉÉ„Éà„ÇíÁîüÊàê‰∏≠...",
                tolerance_complete: "„Çπ„ÉÜ„É†„ÉÜ„Çπ„ÉàÁîüÊàêÂÆå‰∫Ü",
                popup_tol_start: "ÈñãÂßãÂÄ§",
                popup_tol_step: "Âàª„Åø",
                popup_tol_count: "ÁîüÊàêÊï∞",
                popup_tol_values: "„ÇØ„É™„Ç¢„É©„É≥„ÇπÂÄ§",
                // Row descriptions
                row_r4: "R4 (ÊúÄ‰∏äÊÆµ/Êï∞Â≠ó„Ç≠„Éº)",
                row_r3: "R3 (ÊñáÂ≠ó„Ç≠„Éº/Enter)",
                row_r2: "R2 („Éõ„Éº„É†ÊÆµ/ASDF)",
                row_r1: "R1 (ÊúÄ‰∏ãÊÆµ/Space)",
                // Additional UI
                lbl_custom_profile: "üÜï „Ç´„Çπ„Çø„É†„Éó„É≠„Éï„Ç°„Ç§„É´Ë®≠ÂÆö",
                lbl_icon_size: "„Ç¢„Ç§„Ç≥„É≥„Çµ„Ç§„Ç∫",
                lbl_sub_text: "„Çµ„ÉñÊñáÂ≠ó (Legend 2)",
                lbl_side_print: "„Çµ„Ç§„ÉâÂç∞Â≠ó (Side Print)",
                preset_arrow: "Áü¢Âç∞„Ç≠„Éº",
                arrow_select_title: "Áü¢Âç∞„ÅÆÊñπÂêë„ÇíÈÅ∏Êäû",
                wasd_select_title: "WASD„Ç≠„Éº„ÇíÈÅ∏Êäû",
                arrow_up: "‰∏ä",
                arrow_down: "‰∏ã",
                arrow_left: "Â∑¶",
                arrow_right: "Âè≥",
                // More UI
                lbl_global_apply: "ÂÖ®‰Ωì„Å´ÈÅ©Áî®",
                lbl_click_to_apply: "„ÇØ„É™„ÉÉ„ÇØ„ÅßSVG„Å®„Åó„Å¶ÈÅ©Áî®",
                btn_presets: "„Éó„É™„Çª„ÉÉ„Éà",
                btn_clear_stock_icon: "ÈÅ∏ÊäûËß£Èô§",
                btn_clear_preset: "„Éó„É™„Çª„ÉÉ„ÉàËß£Èô§",
                msg_preset_cleared: "ÂàùÊúüÁä∂ÊÖã„Å´Êàª„Åó„Åæ„Åó„Åü",
                msg_enter_repeat_char: "ÈÄ£Á∂öÂá∫Âäõ„Åô„ÇãÊñáÂ≠ó„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
                msg_enter_one_char: "1„Å§‰ª•‰∏ä„ÅÆÊñáÂ≠ó„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
                // New keys for mixed labels
                lbl_stabilizer: "„Çπ„Çø„Éì„É©„Ç§„Ç∂„Éº",
                opt_stab_auto: "Ëá™Âãï",
                opt_stab_custom: "ÊâãÂãïË®≠ÂÆö",
                lbl_stab_pitch: "„Éî„ÉÉ„ÉÅÔºà‰∏≠ÂøÉ„Ç™„Éï„Çª„ÉÉ„ÉàÔºâ",
                note_stab_distance: "‚Äª‰∏≠ÂøÉ„Åã„Çâ„Çπ„ÉÜ„É†‰∏≠ÂøÉ„Åæ„Åß„ÅÆË∑ùÈõ¢",
                opt_tex_knurling: "„É≠„Éº„É¨„ÉÉ„Éà",
                opt_tex_stripes: "„Çπ„Éà„É©„Ç§„Éó",
                opt_tex_ripple: "Ê≥¢Á¥ã",
                opt_tex_wood: "Êú®ÁõÆ",
                opt_tex_hammered: "ÊâìÁóï",
                opt_tex_hexagon: "„Éè„Éã„Ç´„É†",
                opt_tex_bricks: "„É¨„É≥„Ç¨",
                lbl_stem_extension: "Èï∑„Åï„ÇíÊã°Âºµ",
                lbl_box_stem: "„Éú„ÉÉ„ÇØ„ÇπËª∏",
                lbl_lego_stud: "Â§©Èù¢„Éù„ÉÉ„ÉÅ",
                lbl_tilt: "Â§©Èù¢ËßíÂ∫¶Ë™øÊï¥",
                lbl_import_op: "ÂêàÊàê„É¢„Éº„Éâ",
                opt_union: "ÁµêÂêàÔºàËøΩÂä†Ôºâ",
                opt_subtract: "ÂûãÊäú„ÅçÔºàÂΩ´ÂàªÔºâ",
                note_subtract: "‚ÄªÂûãÊäú„Åç„ÅØÂá¶ÁêÜ„Å´ÊôÇÈñì„Åå„Åã„Åã„Çä„Åæ„Åô",
                cat_all: "„Åô„Åπ„Å¶",
                msg_loading: "Ë™≠„ÅøËæº„Åø‰∏≠...",
                btn_simple_export_stl: "üì• STL„Åß‰øùÂ≠ò",
                btn_simple_export_3mf: "üé® 3MF„Åß‰øùÂ≠ò",
                // AMSÁ¢∫Ë™ç„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó
                ams_confirm_title: "üé® AMSË®≠ÂÆö",
                ams_confirm_message: "AMS„ÅÆËâ≤„ÅåÂâ≤„ÇäÂΩì„Å¶„Çâ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ<br>Ë®≠ÂÆö„Åó„Åæ„Åô„ÅãÔºü",
                ams_confirm_hint: "‚ÄªÂæå„Åã„ÇâË®≠ÂÆö„Çø„Éñ„ÅÆ„ÄåAMSË®≠ÂÆö„Äç„Éú„Çø„É≥„Åß„ÅÑ„Å§„Åß„ÇÇË®≠ÂÆö„Åß„Åç„Åæ„Åô",
                ams_confirm_later: "Âæå„ÅßË®≠ÂÆö",
                ams_confirm_now: "‰ªä„Åô„ÅêË®≠ÂÆö",
                // AMSË®≠ÂÆö„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó
                ams_popup_title: "AMSËâ≤Ë®≠ÂÆöÔºà„Çπ„É©„Ç§„Çµ„ÉºÂêåÊúüÁî®Ôºâ",
                ams_filament_select: "„Éï„Ç£„É©„É°„É≥„ÉàÈÅ∏Êäû",
                ams_vendor: "„Éô„É≥„ÉÄ„Éº",
                ams_material: "ÊùêÊñô",
                ams_color_palette: "„Ç´„É©„Éº„Éë„É¨„ÉÉ„ÉàÔºà„Éâ„É©„ÉÉ„Ç∞Ôºâ",
                ams_add_custom: "„Ç´„Çπ„Çø„É†Ëâ≤„ÇíËøΩÂä†",
                ams_capture_btn: "üì∑ ÁîªÈù¢„Åã„ÇâÂèñËæº",
                ams_export_json: "üì• JSONÊõ∏Âá∫„Åó",
                btn_add: "ËøΩÂä†",
                btn_apply: "ÈÅ©Áî®",
                wiki_hint: "Wiki„ÅßË©≥„Åó„ÅèË¶ã„Çã",
                // ‰∏ÄÊã¨Ëâ≤Ë®≠ÂÆö
                batch_color_title: "üé® ‰∏ÄÊã¨Ëâ≤Ë®≠ÂÆö",
                batch_color_click_select: "‚ñº „ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÅ∏Êäû",
                batch_color_body_filament: "üé® Êú¨‰Ωì„Éï„Ç£„É©„É°„É≥„Éà",
                batch_color_text_filament: "üìù ÊñáÂ≠ó„Éï„Ç£„É©„É°„É≥„Éà",
                gallery_batch_color: "Ëâ≤Ë®≠ÂÆö",
                gallery_batch_export: "‰∏ÄÊã¨Âá∫Âäõ",
                // „Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„ÉàËâ≤Ê§úÂá∫
                screenshot_title: "üì∑ Ëâ≤„ÇíÂèñËæº",
                screenshot_step1_hint: "„Çπ„É©„Ç§„Çµ„Éº„Åß„Éï„Ç£„É©„É°„É≥„Éà‰∏ÄË¶ß„ÇíË°®Á§∫ ‚Üí ÂÖ±ÊúâÁîªÈù¢„Åß„Äå„Ç¶„Ç£„É≥„Éâ„Ç¶„Äç„Åã„ÇâBambu StudioÈÅ∏Êäû",
                screenshot_scale: "Êã°Â§ß:",
                screenshot_capture: "üñ•Ô∏è „Ç≠„É£„Éó„ÉÅ„É£",
                screenshot_step2_hint: "Bambu Studio„ÅÆÁï™Âè∑È†Ü„Å´„ÇØ„É™„ÉÉ„ÇØ",
                screenshot_click_palette: "1Áï™„ÅÆ„Éë„É¨„ÉÉ„Éà„Çí„ÇØ„É™„ÉÉ„ÇØ",
                screenshot_picked: "ÂèñÂæó:",
                screenshot_retry: "üîÑÊúÄÂàù„Åã„Çâ",
                screenshot_add: "üì∑ËøΩÂä†",
                screenshot_undo: "‚Ü©Êàª„Åô",
                screenshot_done: "ÂÆå‰∫Ü",
                screenshot_step3_hint: "ÂèñÂæó„Åó„ÅüËâ≤„ÇíÁ¢∫Ë™çÔºà„Ç´„É©„Éº„Éî„ÉÉ„Ç´„Éº„Åß‰øÆÊ≠£ÂèØËÉΩÔºâ",
                screenshot_back: "‚ÜêÊàª„Çã",
                screenshot_apply: "‚úìAMS„Å´ÈÅ©Áî®",
                // „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„Éº
                ctx_reset_camera: "üéØ „Ç´„É°„É©„Çí„É™„Çª„ÉÉ„Éà",
                ctx_top_view: "üîÑ ÂõûËª¢„Çí„É™„Çª„ÉÉ„Éà (Top View)",
                ctx_random_color: "üé≤ „É©„É≥„ÉÄ„É†„Ç´„É©„Éº",
                ctx_wireframe: "üî≤ „ÉØ„Ç§„É§„Éº„Éï„É¨„Éº„É†ÂàáÊõø",
                ctx_save_gallery: "üíæ „ÇÆ„É£„É©„É™„Éº„Å´‰øùÂ≠ò",
                // ‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„Éà
                batch_export_title: "‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÁ¢∫Ë™ç",
                batch_export_format_select: "Âá∫ÂäõÂΩ¢Âºè„ÇíÈÅ∏Êäû",
                batch_export_start: "„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÈñãÂßã",
                // „ÇÆ„É£„É©„É™„Éº„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„Éº
                gallery_ctx_load: "üìÇ Ë™≠„ÅøËæº„ÇÄ",
                gallery_ctx_export: "üì• „Ç®„ÇØ„Çπ„Éù„Éº„Éà",
                gallery_ctx_delete: "üóëÔ∏è ÂâäÈô§",
                // CSKÔºà„Ç´„Çπ„Çø„É†„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„ÉàÔºâ
                csk_title: "üé® „Ç´„Çπ„Çø„É†„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„Éà",
                csk_gallery: "üì¶ „ÇÆ„É£„É©„É™„Éº",
                csk_printer: "Ê©üÁ®Æ",
                csk_batch_orient: "üé≤ ‰∏ÄÊã¨ÈÖçÁΩÆ",
                csk_runner_color: "üîó „É©„É≥„Éä„ÉºËâ≤:",
                csk_generate: "„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„ÉàÁîüÊàê",
                csk_orientation: "üéØ ÈÖçÁΩÆÊñπÂêë",
                csk_drag_rotate: "„Éâ„É©„ÉÉ„Ç∞„ÅßÂõûËª¢",
                csk_bottom_down: "‰∏ãÈù¢„Åå‰∏ã",
                csk_body_color: "üé® Êú¨‰ΩìËâ≤",
                csk_text_color: "üìù ÊñáÂ≠óËâ≤",
                csk_batch_orient_title: "üé≤ ‰∏ÄÊã¨ÈÖçÁΩÆÊñπÂêëË®≠ÂÆö",
                csk_selected_count: "0ÂÄãÈÅ∏Êäû‰∏≠",
                csk_select_all: "ÂÖ®ÈÅ∏Êäû",
                csk_deselect: "Ëß£Èô§",
                csk_batch_hint: "„Çø„Ç§„É´„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÅ∏Êäû<br>„Çµ„Ç§„Ç≥„É≠„ÇíÂãï„Åã„Åô„Å®Âç≥ÊôÇÂèçÊò†",
                csk_done: "ÁµÇ‰∫Ü",
                // „Ç¨„É†„Éú„Éº„É´„Çø„Éº„Ç≤„ÉÉ„Éà
                gumball_main_text: "„É°„Ç§„É≥ÊñáÂ≠ó",
                gumball_sub_text: "„Çµ„ÉñÊñáÂ≠ó",
                gumball_side_print: "„Çµ„Ç§„ÉâÂç∞Â≠ó",
                gumball_model: "„É¢„Éá„É´",
                // „Éó„É™„Çª„ÉÉ„Éà
                preset_loaded: "üìÅ Ë™≠„ÅøËæº„ÅøÊ∏à„Åø",
                // „Åù„ÅÆ‰ªñUI
                simple_ams_select: "AMS„Çπ„É≠„ÉÉ„Éà„Åã„ÇâÈÅ∏Êäû",
                btn_close: "Èñâ„Åò„Çã",
                // F5„Éá„Éê„ÉÉ„Ç∞„Éë„Éç„É´
                debug_title: "üõ†Ô∏è „Éá„Éê„ÉÉ„Ç∞ / „É°„É≥„ÉÜ„Éä„É≥„Çπ <span style=\"font-size:0.65rem; color:#888; font-weight:normal;\">(F5)</span>",
                debug_cache_section: "üóëÔ∏è „Ç≠„É£„ÉÉ„Ç∑„É• / „Éá„Éº„Çø„ÇØ„É™„Ç¢",
                debug_clear_all: "üóëÔ∏è ÂÖ®„Ç≠„É£„ÉÉ„Ç∑„É•„ÇØ„É™„Ç¢ÔºàlocalStorageÂÖ®ÂâäÈô§ + „Éö„Éº„Ç∏„É™„É≠„Éº„ÉâÔºâ",
                debug_clear_filament: "üé® „Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆö„ÇØ„É™„Ç¢ÔºàAMSË®≠ÂÆö„ÇíÂàùÊúüÂåñÔºâ",
                debug_clear_gallery: "üì¶ „ÇÆ„É£„É©„É™„ÉºÂÖ®ÂâäÈô§ÔºàÂÖ®„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÇíÂâäÈô§Ôºâ",
                debug_clear_csk: "üìê „Ç´„Çπ„Çø„É†„Çπ„Éó„É´„Ç≠„ÉÉ„ÉàÈÖçÁΩÆ„Çí„É™„Çª„ÉÉ„Éà",
                debug_reset_state: "üîÑ „Éë„É©„É°„Éº„ÇøÂàùÊúüÂåñÔºà„Éá„Éï„Ç©„É´„ÉàÂÄ§„Å´Êàª„ÅôÔºâ",
                debug_state_section: "üìä ÁèæÂú®„ÅÆÁä∂ÊÖãÊÉÖÂ†±",
                debug_tools_section: "üîß „ÉÑ„Éº„É´",
                debug_export_state: "üíæ ÁèæÂú®„ÅÆÂÖ®Áä∂ÊÖã„ÇíJSON„Åß„Ç®„ÇØ„Çπ„Éù„Éº„Éà",
                debug_import_state: "üìÇ JSON„Åã„ÇâÁä∂ÊÖã„Çí„Ç§„É≥„Éù„Éº„Éà",
                debug_force_rebuild: "‚ö° 3D„É¢„Éá„É´„ÇíÂº∑Âà∂ÂÜçÊßãÁØâ",
                debug_log_state: "üìã „Ç≥„É≥„ÇΩ„Éº„É´„Å´ÂÖ®stateÂá∫Âäõ",
                // ËøΩÂä†ÁøªË®≥„Ç≠„Éº
                preset_empty: "‰øùÂ≠ò„Åï„Çå„Åü„Éó„É™„Çª„ÉÉ„Éà„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÂè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº„Åæ„Åü„ÅØHUD„ÅÆüíæ„Éú„Çø„É≥„Åã„Çâ‰øùÂ≠ò„Åß„Åç„Åæ„Åô„ÄÇ",
                warning_not_set: "Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì",
                warning_body_filament: "Êú¨‰Ωì„Éï„Ç£„É©„É°„É≥„Éà",
                warning_text_filament: "ÊñáÂ≠ó„Éï„Ç£„É©„É°„É≥„Éà",
                warning_both_filament: "‰∏°Êñπ",
                click_to_select: "„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÅ∏Êäû",
                popup_body_color_set: "Êú¨‰ΩìËâ≤Ë®≠ÂÆö",
                popup_text_color_set: "ÊñáÂ≠óËâ≤Ë®≠ÂÆö",
                popup_save_location: "‰øùÂ≠òÂÖà",
                popup_download_folder: "„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Éï„Ç©„É´„ÉÄ",
                unit_items: "‰ª∂",
                ams_register_hint: "AMS„Çπ„É≠„ÉÉ„Éà„Åã„ÇâÈÅ∏ÊäûÔºàAMSË®≠ÂÆö„ÅßËâ≤„ÇíÁôªÈå≤Ôºâ",
                ams_register_colors: "AMSË®≠ÂÆö„ÅßËâ≤„ÇíÁôªÈå≤",
                ams_colors_applied: "Ëâ≤„ÇíAMS„Çπ„É≠„ÉÉ„Éà„Å´ÈÅ©Áî®„Åó„Åæ„Åó„Åü",
                selected_label: "ÈÅ∏Êäû‰∏≠",
                lbl_custom_height: "È´ò„Åï",
                lbl_custom_angle: "ËßíÂ∫¶",
                size_standard: "ÈÄöÂ∏∏",
                lbl_text_svg_filament: "üìù ÊñáÂ≠ó„ÉªSVG„Éï„Ç£„É©„É°„É≥„Éà",
                preset_fn: "Fn„Ç≠„Éº"
            },
            en: {
                nav_jump: "--- Jump to Section ---", nav_basic: "Basic Size", nav_structure: "Structure", nav_shape: "Shape",
                nav_texture: "Texture Map", nav_utility: "Utility", nav_import: "Import 3D", nav_stem: "Stem",
                nav_text: "Text / Legend", nav_svg: "SVG Icon", nav_color: "Colors", nav_preset: "Presets", nav_export: "Export",
                h_basic: "Basic Size", lbl_u_size: "Key Size (U)", lbl_profile: "Profile", lbl_row: "Row", lbl_unit_size: "Unit Size (Pitch)",
                h_structure: "Structure & Stem", lbl_wall_thick: "Wall Thickness", lbl_rib_shorten: "Rib Shorten (Lift)", lbl_enable_ribs: "Reinforcement Ribs",
                lbl_homing_bump: "Homing Bump", opt_bump_round: "Round", opt_bump_bar: "Bar",
                lbl_pos_x: "Pos X", lbl_pos_z: "Pos Z", lbl_bump_offset: "Bump Offset Y",
                lbl_round_corner: "Round Corner (Fillet)", note_round: "*Squircle Mapping (Fast & Stable)",
                h_shape: "Shape (Taper/Dish)", lbl_top_scale: "Top Scale (Taper)", lbl_dish_type: "Dish Type",
                lbl_key_shape_type: "üÜï Key Shape Type (V64)", opt_shape_rect: "Rectangle", opt_shape_round: "Rounded", 
                opt_shape_circle: "Circle", opt_shape_polygon: "Polygon", opt_shape_star: "Star", opt_shape_iso: "ISO Enter (L-Shape)",
                lbl_polygon_sides: "Sides", lbl_star_points: "Points", lbl_star_inner: "Inner Ratio",
                lbl_iso_settings: "ISO/JIS Enter Settings", lbl_iso_top_w: "Top Width", lbl_iso_bottom_w: "Bottom Width", lbl_iso_total_h: "Total Height",
                lbl_stem_x: "Stem X", lbl_stem_z: "Stem Z", lbl_stab_top_z: "Top Stab Z", lbl_stab_bottom_z: "Bottom Stab Z",
                opt_dish_cyl: "Cylindrical", opt_dish_sph: "Spherical", opt_dish_flat: "Flat",
                lbl_texture: "Surface Procedural", opt_tex_none: "None", opt_tex_noise: "Noise (Sand)", opt_tex_grid: "Grid (Studs)",
                lbl_tex_scale: "Scale", lbl_tex_strength: "Strength",
                h_texture_map: "Image Texture (Image Map)", btn_upload_img: "üìÅ Load Image (PNG/JPG)",
                h_stem: "Stem Settings", lbl_stem_type: "Stem Type: Cherry MX (Fixed)", lbl_stem_type_select: "Stem Type", lbl_clearance: "Clearance", lbl_stem_diameter: "Stem Diameter", 
                // V67.3: New labels
                lbl_click_place: "üñ±Ô∏è Interactive Placement", btn_click_place_off: "Placement Mode: OFF", btn_click_place_on: "Placement Mode: ON", note_click_place: "*Turn ON and click on the model to move text/icons to that position",
                btn_ams_config: "AMS Color Settings (Slicer Sync)", btn_ams_import: "Import AMS Settings (JSON)",
                sprue_desc: "Connect multiple keycaps like plastic model runners for output.",
                h_text: "Legend Settings", lbl_enable_text: "Enable Text", pl_text: "Ex: A\n{\n[", note_multiline: "*Use line breaks for multi-line.",
                lbl_font: "Font", note_font_upload: "*Cannot import .ttf directly. Convert to JSON using <a href='http://gero3.github.io/facetype.js/' target='_blank'>Facetype.js</a>.",
                btn_upload_font: "üìÅ Custom Font (.json)", lbl_size: "Size", lbl_thickness: "Thickness", lbl_conform: "Conform to Surface",
                lbl_align_preset: "Alignment Presets", btn_align_center: "Center", btn_align_tl: "Top-Left",
                btn_align_tr: "Top-Right", btn_align_bl: "Bottom-Left", btn_align_br: "Bottom-Right",
                lbl_pos_xz_fine: "Position X / Z (Fine)", lbl_offset_y: "Y Offset (Fine)",
                lbl_text_mode: "Generation Mode", opt_mode_emboss: "Emboss (Raised)", opt_mode_engrave: "Engrave (Inset)", opt_mode_doubleshot: "Double-Shot (Inlay)", opt_mode_lithophane: "Lithophane (Backlit)",
                note_engrave: "*Engrave requires more processing time.",
                h_svg: "SVG Icon Settings", btn_upload_svg: "üìÅ Load SVG", lbl_visible: "Visible", lbl_rotation: "Rotation (XYZ)",
                h_colors: "Color Settings", lbl_col_body: "Body Color", lbl_col_text: "Text/SVG Color",
                h_preset: "Preset Management", lbl_browser_storage: "Browser Storage (Quick)", btn_quick_save: "Quick Save", btn_quick_load: "Quick Load",
                lbl_file_storage: "File Storage", btn_export_file: "Export (.json)", btn_import_file: "Import (.json)",
                lbl_url_share: "üîó Share via URL", btn_share_url: "üìã Copy URL", btn_share_x: "ùïè Share", btn_import_url: "Load", placeholder_url_import: "Paste shared URL...",
                lbl_named_preset: "üÜï Save Named Preset", placeholder_preset_name: "Enter preset name...", btn_save_named: "üíæ Save with Name",
                lbl_loaded_presets: "üìÅ Loaded Presets:", btn_load_add: "Load (Add)",
                pv_profile: "Profile:", pv_size: "Size:", pv_shape: "Shape:", pv_text: "Text:", pv_text2: "Sub Text:", pv_side: "Side:", pv_svg: "SVG:",
                msg_url_copied: "URL copied to clipboard!", msg_url_invalid: "Invalid URL", msg_url_loaded: "Preset loaded from URL", msg_x_shared: "Opened X (Twitter) compose window",
                hint_f1_notice: "View details on Wiki",
                btn_prev: "‚óÄ Prev", btn_next: "Next ‚ñ∂", btn_clear_all: "Clear All",
                h_export: "Export (STL/OBJ/3MF)", lbl_filename: "File Name", btn_export_single: "Export", btn_export_all: "Export All (STL)", btn_export_obj: "Export All (OBJ w/ Color)",
                btn_export_3mf: "Export All (3MF w/ Color)", btn_export_body: "Body Only (STL)", btn_export_text: "Text Only (STL)",
                h_batch: "Batch Export", lbl_batch_list: "Character List (comma/newline)", pl_batch: "Q,W,E,R,T,Y...",
                lbl_batch_format: "Output Format",
                note_batch: "*Generate using current settings.", btn_batch_run: "Run Batch",
                batch_processing: "Processing: ", batch_complete: "Done!",
                msg_save_ok: "Settings saved to browser.", msg_load_ok: "Settings loaded.", msg_load_err: "No saved settings found.",
                msg_import_err: "Import Error: Invalid JSON format.", msg_batch_empty: "Character list is empty.",
                toast_generating: "Generating mesh...", toast_stl_exported: "STL exported!", 
                toast_obj_exported: "OBJ exported!", toast_3mf_exported: "3MF exported!",
                toast_export_failed: "Export failed: ", toast_no_body: "Error: No body geometry generated",
                h_import: "Import 3D", btn_load_stl: "üìÅ Load STL Model", lbl_weight: "Est. Weight:", lbl_cost: "Est. Cost:", 
                lbl_vendor: "Vendor:", lbl_material: "Material:", btn_details: "‚ñº Details / Edit",
                lbl_manual_override: "Manual Override", lbl_price: "Price", lbl_spool: "Spool(g)", lbl_density: "Dens.",
                link_wiki: "Go to Wiki", link_github: "Go to GitHub",
                lbl_show_hints: "üí° Show Hints",
                hint_lang: "Switch display language between Japanese and English.",
                hint_section_jump: "Quickly jump to the section you want to configure.",
                hint_search: "Search settings by name and highlight matches.",
                hint_stats: "Shows estimated filament weight and cost based on current settings. Click to open/close material settings.",
                hint_unit_size: "Set the base size for 1U. Usually 19.05mm, but smaller for Choc switches etc.",
                hint_key_size: "Set the keycap width. 1.0 (normal), 2.0 (BackSpace), 6.25 (Space), etc.",
                hint_stabilizer: "Position settings for stabilizers on 2U+ keys. Auto works for most cases, use Custom for special layouts.",
                hint_profile: "Select the overall keycap shape (profile). Supports Cherry, OEM, SA, XDA, DSA.",
                hint_row: "Set key height and tilt angle (R1-R4). Shape varies by profile.",
                hint_fillet: "Round the four corners of the keycap (Squircle shape). Higher values = rounder.",
                hint_wall_thick: "Set the side wall thickness. Too thin reduces strength, too thick may interfere with switches.",
                hint_rib_shorten: "Set how much to raise the bottom of internal ribs. Adjust to prevent LED interference.",
                hint_enable_ribs: "Create cross-shaped reinforcement walls inside. Improves strength and prevents warping.",
                hint_homing_bump: "Create the tactile bump found on F and J keys for finger positioning.",
                hint_bump_type: "Choose bump shape: Round or Bar (rectangle).",
                hint_key_shape: "Select the base keycap shape. Supports rectangle, rounded, circle, polygon, star, and ISO Enter (L-shape).",
                hint_taper: "Adjust the top surface size. Smaller values = steeper taper.",
                hint_dish_type: "Set the dish shape for finger placement. Choose Cylindrical, Spherical, or Flat.",
                hint_texture: "Auto-generate surface textures like sandpaper or patterns.",
                hint_texture_global: "Apply texture to the entire keycap including sides, not just the top.",
                hint_twist: "Twist the entire keycap. Useful for artisan keycaps.",
                hint_tilt: "Fine-tune the top surface tilt in X and Z directions.",
                hint_img_upload: "Upload PNG or JPG images to apply as a texture on the keycap surface. Turn your favorite patterns or photos into keycap designs.",
                hint_custom_font: "Load font files converted to JSON format using tools like Facetype.js. *TTF or OTF files from your PC cannot be used directly.",
                hint_stem_diameter: "Adjust the outer diameter of the switch stem. Standard is 5.5mm.",
                hint_clearance: "Set the cross-hole tolerance. Increase if too tight to fit.",
                hint_stem_ext: "Extend only the stem below the bottom. For special switches or height adjustment.",
                hint_box_stem: "Add square walls around the cross stem for strength and dust protection (Kailh Box style).",
                hint_lego_stud: "Add LEGO-compatible studs on the top surface.",
                hint_enable_text: "Turn text generation ON/OFF.",
                hint_text_input: "Enter the character to engrave. Use line breaks for multiple lines.",
                hint_font: "Select the font for engraving.",
                hint_text_mode: "Choose Emboss (raised), Engrave (inset), Double-Shot (separate part), or Lithophane (backlit).",
                hint_text_height: "Set text thickness. For Double-Shot, this is the embed depth.",
                hint_conform: "Deform text to follow the keycap's top surface curve.",
                hint_align_preset: "One-click positioning to center, top-left, bottom-right, etc.",
                hint_text2: "Add a secondary smaller text, typically in the bottom-right corner.",
                hint_side_print: "Add text on the front side of the keycap.",
                hint_svg_upload: "Load vector images (.svg) for engraving. Perfect for logos and icons.",
                hint_svg_mode: "Choose SVG processing method. Double-Shot exports as separate parts for multi-color printing.",
                hint_colors: "Change preview colors. *Does not affect STL output, but reflects in OBJ/3MF.",
                hint_url_share: "Encode current settings into a URL and copy. Share on social media.",
                hint_quick_save: "Temporarily save current settings in browser storage.",
                hint_export_json: "Save settings as a file. Load later or share with others.",
                hint_import_json: "Load saved setting files. Drag & drop multiple files to add to list.",
                hint_print_orient: "Rotate the entire model to match 3D print orientation.",
                hint_export_stl: "Save in standard 3D printer format (.stl).",
                hint_export_3mf: "Save with color information (.3mf). Ideal for Bambu Lab multi-color printing.",
                hint_export_parts: "Export parts separately as STL. Useful for printing with different filament colors.",
                hint_batch_list: "Enter comma-separated characters (A,B,C...) to auto-generate with current settings.",
                hint_batch_run: "Generate all characters in the list and download together.",
                hint_randomizer: "Randomly change all parameters. Great for finding new ideas.",
                hint_reset: "Reset all settings to defaults.",
                hint_import_stl: "Load custom 3D models (.stl) to combine.",
                hint_import_op: "Union adds geometry, Subtract carves out. *Subtract requires more processing time.",
                // V66 Translations
                lbl_simple_mode: "üå± Simple Mode",
                h_simple_mode: "üå± Simple Mode",
                lbl_simple_text: "Text",
                lbl_text_visible: "Show Text",
                lbl_simple_font: "Font",
                lbl_simple_icon: "Icon",
                btn_clear_icon: "Clear Icon",
                lbl_simple_profile: "Profile",
                lbl_simple_row: "Row",
                lbl_simple_key_size: "Key Size",
                lbl_simple_body_color: "Body Color",
                lbl_simple_text_color: "Text Color",
                lbl_simple_text_mode: "Text Mode",
                lbl_simple_gen_mode: "Mode (Text & Icon)",
                view_front: "Front", view_back: "Back", view_right: "Right", view_left: "Left", view_top: "Top", view_bottom: "Btm",
                lbl_simple_taper: "Top Size",
                lbl_simple_dish: "Dish Type",
                lbl_simple_fillet: "Corner Radius",
                lbl_dimension_lines: "üìê Show Dimensions (V66)",
                lbl_layer_color: "üé® Layer Color Preview",
                lbl_visual_presets: "üé® Visual Presets (V66)",
                lbl_stock_icons: "üì¶ Built-in Icons (V66)",
                lbl_tolerance_test: "üîß Tolerance Test Kit (V66)",
                lbl_sprue_kit: "üîó Sprue Kit Generation (V66)",
                hint_simple_mode: "Simple Mode shows only essential settings for beginners. Advanced settings use V65 defaults.",
                hint_dimension_lines: "Display dimension lines on the 3D view. Useful for size verification before printing.",
                hint_layer_color: "Simulate color changes at filament swap height for Bambu Lab AMS and similar systems.",
                hint_visual_presets: "One-click setup for common keys (WASD, arrows, etc.).",
                hint_stock_icons: "Built-in common icons (arrows, play, Command key, etc.). No need to search for SVGs.",
                hint_tolerance_test: "Generate stems for printer tolerance testing. Useful for finding the optimal clearance value.",
                hint_sprue_kit: "Connect multiple keycaps like model kit runners. Perfect for gifts or sales.",
                hint_simple_key_size: "Easily select common key sizes with buttons.",
                hint_snapshot: "Save the current 3D view as an image.",
                hint_gallery_open: "Open the gallery of saved presets.",
                hint_gallery_save: "Save the current settings to the gallery.",
                hint_gumball: "Drag to adjust the position of text, SVG, or imported models.",
                hint_toggle_text: "Toggle text visibility on the 3D view.",
                hint_toggle_svg: "Toggle SVG visibility on the 3D view.",
                // V67.3: Extended tooltips
                hint_stem_type: "Select the key switch stem type. Supports Cherry MX, Kailh Choc, Topre, Alps, etc.",
                hint_click_place: "Turn ON and click on the model to move text/icons to that position. Intuitive placement.",
                // Export Popup
                popup_export_confirm: "Export Confirmation",
                popup_cancel: "Cancel",
                popup_export: "Export",
                popup_est_weight: "Est. Weight",
                popup_est_cost: "Est. Cost",
                popup_body_color: "Body Color",
                popup_text_color: "Text Color",
                popup_vendor: "Vendor",
                popup_material: "Material",
                popup_profile: "Profile",
                popup_size: "Size",
                popup_row: "Row",
                popup_text: "Text",
                popup_svg_icon: "SVG Icon",
                popup_printer: "Printer",
                popup_build_size: "Build Size",
                popup_key_count: "Key Count",
                popup_layout: "Layout",
                popup_char_list: "Character List",
                popup_format: "Format",
                popup_file_count: "File Count",
                // Sprue Kit
                sprue_printer_model: "Printer Model",
                sprue_max_keys: "Max Keys",
                sprue_key_count: "Keys in Kit",
                sprue_repeat_mode: "Repeat Same Character",
                sprue_char_list: "Character List (comma separated)",
                sprue_single_char: "Character to Repeat",
                sprue_output_format: "Output Format",
                sprue_generate: "Generate Sprue Kit",
                sprue_custom: "üé® Custom Sprue Kit",
                sprue_generating: "Generating Sprue Kit...",
                sprue_unlimited: "Unlimited",
                // Tolerance Test
                tolerance_desc: "Generate a plate with stems only for testing printer tolerance.",
                tolerance_output_format: "Output Format",
                tolerance_generate: "Generate Test Kit",
                tolerance_start: "Start Value",
                tolerance_step: "Step",
                tolerance_generating: "Generating stem test kit...",
                tolerance_complete: "Stem test generated",
                popup_tol_start: "Start Value",
                popup_tol_step: "Step",
                popup_tol_count: "Count",
                popup_tol_values: "Clearance Values",
                // Row descriptions
                row_r4: "R4 (Top Row/Number)",
                row_r3: "R3 (Letters/Enter)",
                row_r2: "R2 (Home Row/ASDF)",
                row_r1: "R1 (Bottom/Space)",
                // Additional UI
                lbl_custom_profile: "üÜï Custom Profile Settings",
                lbl_icon_size: "Icon Size",
                lbl_sub_text: "Sub Text (Legend 2)",
                lbl_side_print: "Side Print",
                preset_arrow: "Arrow Key",
                arrow_select_title: "Select Arrow Direction",
                wasd_select_title: "Select WASD Key",
                arrow_up: "Up",
                arrow_down: "Down",
                arrow_left: "Left",
                arrow_right: "Right",
                // More UI
                lbl_global_apply: "Global Apply",
                lbl_click_to_apply: "Click to apply as SVG",
                btn_presets: "Presets",
                btn_clear_stock_icon: "Clear Selection",
                btn_clear_preset: "Clear Preset",
                msg_preset_cleared: "Reset to default",
                msg_enter_repeat_char: "Please enter character to repeat",
                msg_enter_one_char: "Please enter at least one character",
                // New keys for mixed labels
                lbl_stabilizer: "Stabilizer",
                opt_stab_auto: "Auto",
                opt_stab_custom: "Custom",
                lbl_stab_pitch: "Pitch (Center Offset)",
                note_stab_distance: "*Distance from center to stem center",
                opt_tex_knurling: "Knurling",
                opt_tex_stripes: "Stripes",
                opt_tex_ripple: "Ripple",
                opt_tex_wood: "Wood Grain",
                opt_tex_hammered: "Hammered",
                opt_tex_hexagon: "Hexagon",
                opt_tex_bricks: "Bricks",
                lbl_stem_extension: "Stem Extension",
                lbl_box_stem: "Box Stem",
                lbl_lego_stud: "Lego Stud",
                lbl_tilt: "Tilt Angle",
                lbl_import_op: "Operation Mode",
                opt_union: "Union (Add)",
                opt_subtract: "Subtract (Carve)",
                note_subtract: "*Subtract takes more processing time",
                cat_all: "All",
                msg_loading: "Loading...",
                btn_simple_export_stl: "üì• Save as STL",
                btn_simple_export_3mf: "üé® Save as 3MF",
                // AMSÁ¢∫Ë™ç„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó
                ams_confirm_title: "üé® AMS Settings",
                ams_confirm_message: "AMS colors are not configured.<br>Would you like to set them up?",
                ams_confirm_hint: "*You can configure this later from the Settings tab",
                ams_confirm_later: "Later",
                ams_confirm_now: "Set Up Now",
                // AMSË®≠ÂÆö„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó
                ams_popup_title: "AMS Color Settings (Slicer Sync)",
                ams_filament_select: "Filament Selection",
                ams_vendor: "Vendor",
                ams_material: "Material",
                ams_color_palette: "Color Palette (Drag)",
                ams_add_custom: "Add Custom Color",
                ams_capture_btn: "üì∑ Capture from Screen",
                ams_export_json: "üì• Export JSON",
                btn_add: "Add",
                btn_apply: "Apply",
                wiki_hint: "Learn more on Wiki",
                // ‰∏ÄÊã¨Ëâ≤Ë®≠ÂÆö
                batch_color_title: "üé® Batch Color Settings",
                batch_color_click_select: "‚ñº Click to Select",
                batch_color_body_filament: "üé® Body Filament",
                batch_color_text_filament: "üìù Text Filament",
                gallery_batch_color: "Colors",
                gallery_batch_export: "Export",
                // „Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„ÉàËâ≤Ê§úÂá∫
                screenshot_title: "üì∑ Capture Colors",
                screenshot_step1_hint: "Show filament list in slicer ‚Üí Share Screen ‚Üí Select Bambu Studio window",
                screenshot_scale: "Scale:",
                screenshot_capture: "üñ•Ô∏è Capture",
                screenshot_step2_hint: "Click in order of Bambu Studio numbers",
                screenshot_click_palette: "Click palette #1",
                screenshot_picked: "Picked:",
                screenshot_retry: "üîÑ Restart",
                screenshot_add: "üì∑ Add",
                screenshot_undo: "‚Ü© Undo",
                screenshot_done: "Done",
                screenshot_step3_hint: "Verify captured colors (editable with color picker)",
                screenshot_back: "‚Üê Back",
                screenshot_apply: "‚úì Apply to AMS",
                // „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„Éº
                ctx_reset_camera: "üéØ Reset Camera",
                ctx_top_view: "üîÑ Reset Rotation (Top View)",
                ctx_random_color: "üé≤ Random Color",
                ctx_wireframe: "üî≤ Toggle Wireframe",
                ctx_save_gallery: "üíæ Save to Gallery",
                // ‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„Éà
                batch_export_title: "Batch Export Confirmation",
                batch_export_format_select: "Select output format",
                batch_export_start: "Start Export",
                // „ÇÆ„É£„É©„É™„Éº„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„Éº
                gallery_ctx_load: "üìÇ Load",
                gallery_ctx_export: "üì• Export",
                gallery_ctx_delete: "üóëÔ∏è Delete",
                // CSKÔºà„Ç´„Çπ„Çø„É†„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„ÉàÔºâ
                csk_title: "üé® Custom Sprue Kit",
                csk_gallery: "üì¶ Gallery",
                csk_printer: "Printer",
                csk_batch_orient: "üé≤ Batch Orient",
                csk_runner_color: "üîó Runner Color:",
                csk_generate: "Generate Sprue Kit",
                csk_orientation: "üéØ Orientation",
                csk_drag_rotate: "Drag to rotate",
                csk_bottom_down: "Bottom facing down",
                csk_body_color: "üé® Body Color",
                csk_text_color: "üìù Text Color",
                csk_batch_orient_title: "üé≤ Batch Orientation Settings",
                csk_selected_count: "0 selected",
                csk_select_all: "Select All",
                csk_deselect: "Deselect",
                csk_batch_hint: "Click tiles to select<br>Rotating the dice applies immediately",
                csk_done: "Done",
                // „Ç¨„É†„Éú„Éº„É´„Çø„Éº„Ç≤„ÉÉ„Éà
                gumball_main_text: "Main Text",
                gumball_sub_text: "Sub Text",
                gumball_side_print: "Side Print",
                gumball_model: "Model",
                // „Éó„É™„Çª„ÉÉ„Éà
                preset_loaded: "üìÅ Loaded Presets",
                // „Åù„ÅÆ‰ªñUI
                simple_ams_select: "Select from AMS slots",
                btn_close: "Close",
                // F5„Éá„Éê„ÉÉ„Ç∞„Éë„Éç„É´
                debug_title: "üõ†Ô∏è Debug / Maintenance <span style=\"font-size:0.65rem; color:#888; font-weight:normal;\">(F5)</span>",
                debug_cache_section: "üóëÔ∏è Cache / Data Clear",
                debug_clear_all: "üóëÔ∏è Clear All Cache (Delete localStorage + Reload)",
                debug_clear_filament: "üé® Clear Filament Settings (Reset AMS)",
                debug_clear_gallery: "üì¶ Delete All Gallery (Remove all keycaps)",
                debug_clear_csk: "üìê Reset Custom Sprue Kit Layout",
                debug_reset_state: "üîÑ Reset Parameters (Restore defaults)",
                debug_state_section: "üìä Current State Info",
                debug_tools_section: "üîß Tools",
                debug_export_state: "üíæ Export All State as JSON",
                debug_import_state: "üìÇ Import State from JSON",
                debug_force_rebuild: "‚ö° Force Rebuild 3D Model",
                debug_log_state: "üìã Log All State to Console",
                // ËøΩÂä†ÁøªË®≥„Ç≠„Éº
                preset_empty: "No presets saved. Save from right-click menu or HUD's üíæ button.",
                warning_not_set: "Not configured",
                warning_body_filament: "body filament",
                warning_text_filament: "text filament",
                warning_both_filament: "both",
                click_to_select: "Click to select",
                popup_body_color_set: "Body Color Set",
                popup_text_color_set: "Text Color Set",
                popup_save_location: "Save Location",
                popup_download_folder: "Downloads Folder",
                unit_items: "items",
                ams_register_hint: "Select from AMS slots (Register colors in AMS settings)",
                ams_register_colors: "Register colors in AMS settings",
                ams_colors_applied: "colors applied to AMS slots",
                selected_label: "Selected",
                lbl_custom_height: "Height",
                lbl_custom_angle: "Angle",
                size_standard: "Standard",
                lbl_text_svg_filament: "üìù Text/SVG Filament",
                preset_fn: "Fn Key"
            }
        };
        
        // „Éñ„É©„Ç¶„Ç∂„ÅÆË®ÄË™ûË®≠ÂÆö„Åã„ÇâËá™ÂãïÊ§úÂá∫
        function detectUserLanguage() {
            const browserLang = navigator.language || navigator.userLanguage || 'ja';
            // Êó•Êú¨Ë™û‰ª•Â§ñ„ÅØËã±Ë™û„Å´„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
            return browserLang.startsWith('ja') ? 'ja' : 'en';
        }
        
        let currentLang = detectUserLanguage();
        function updateLanguageUI() {
            const t = translations[currentLang];
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (t[key]) {
                    if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') { if (el.placeholder) el.placeholder = t[key]; } 
                    else if (el.tagName === 'OPTION') { el.textContent = t[key]; } 
                    else { el.innerHTML = t[key]; }
                }
            });
            document.getElementById('text-content').placeholder = t.pl_text;
            updateFilamentDisplay(); updateCustomDropdownHead(); 
            const linkWiki = document.getElementById('link-wiki');
            const linkGithub = document.getElementById('link-github');
            if(linkWiki) linkWiki.title = t.link_wiki || "Wiki";
            if(linkGithub) linkGithub.title = t.link_github || "GitHub";
        }

        document.getElementById('language-select').addEventListener('change', (e) => { currentLang = e.target.value; updateLanguageUI(); });
        
        // Ë®ÄË™û„Çª„É¨„ÇØ„Éà„ÅÆÂàùÊúüÂÄ§„ÇíËá™ÂãïÊ§úÂá∫„Åó„ÅüË®ÄË™û„Å´Ë®≠ÂÆö
        document.addEventListener('DOMContentLoaded', () => {
            const langSelect = document.getElementById('language-select');
            if (langSelect) {
                langSelect.value = currentLang;
            }
        });
        
        window.onerror = (msg) => { document.getElementById('error-log').textContent += msg + "\n"; };
        setTimeout(() => { const b=document.getElementById('force-start-btn'); if(b)b.click(); }, 1000);

        // V67.3: „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº‰ªò„Åç„Éà„Éº„Çπ„ÉàÁî®„ÅÆÂ§âÊï∞
        let progressToastElement = null;
        
        function showToast(message, isError = false) {
            // V67.3: „Éó„É≠„Ç∞„É¨„Çπ„Éà„Éº„Çπ„ÉàË°®Á§∫‰∏≠„ÅØÈÄöÂ∏∏„Éà„Éº„Çπ„Éà„Çí„Çπ„Ç≠„ÉÉ„ÉóÔºàÈáçË§áÈò≤Ê≠¢Ôºâ
            if (progressToastElement && !isError) return;
            
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast' + (isError ? ' error' : '');
            toast.textContent = message;
            container.appendChild(toast);
            requestAnimationFrame(() => toast.classList.add('show'));
            setTimeout(() => { toast.classList.remove('show'); setTimeout(() => toast.remove(), 300); }, 3000);
        }
        
        // V67.3: „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº‰ªò„Åç„Éà„Éº„Çπ„Éà
        function showProgressToast(message, progress = 0) {
            const container = document.getElementById('toast-container');
            
            // Êó¢Â≠ò„ÅÆ„Éó„É≠„Ç∞„É¨„Çπ„Éà„Éº„Çπ„Éà„ÇíÂâäÈô§
            if (progressToastElement) {
                progressToastElement.remove();
            }
            
            const toast = document.createElement('div');
            toast.className = 'toast progress-toast';
            toast.innerHTML = `
                <div class="progress-message">${message}</div>
                <div class="progress-bar-container">
                    <div class="progress-bar-fill" style="width: ${progress}%"></div>
                </div>
                <div class="progress-percent">${Math.round(progress)}%</div>
            `;
            toast.style.cssText = `
                min-width: 280px;
                padding: 12px 16px;
            `;
            
            // „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº„ÅÆ„Çπ„Çø„Ç§„É´
            const barContainer = toast.querySelector('.progress-bar-container');
            barContainer.style.cssText = `
                width: 100%;
                height: 6px;
                background: rgba(255,255,255,0.2);
                border-radius: 3px;
                margin: 8px 0 4px 0;
                overflow: hidden;
            `;
            
            const barFill = toast.querySelector('.progress-bar-fill');
            barFill.style.cssText = `
                height: 100%;
                background: linear-gradient(90deg, #00bcd4, #4fc3f7);
                border-radius: 3px;
                transition: width 0.3s ease;
            `;
            
            const percentText = toast.querySelector('.progress-percent');
            percentText.style.cssText = `
                font-size: 0.75rem;
                opacity: 0.8;
                text-align: right;
            `;
            
            container.appendChild(toast);
            requestAnimationFrame(() => toast.classList.add('show'));
            
            progressToastElement = toast;
            return toast;
        }
        
        function updateProgressToast(message, progress) {
            if (!progressToastElement) {
                showProgressToast(message, progress);
                return;
            }
            
            const msgEl = progressToastElement.querySelector('.progress-message');
            const barFill = progressToastElement.querySelector('.progress-bar-fill');
            const percentText = progressToastElement.querySelector('.progress-percent');
            
            if (msgEl) msgEl.textContent = message;
            if (barFill) barFill.style.width = `${progress}%`;
            if (percentText) percentText.textContent = `${Math.round(progress)}%`;
        }
        
        function hideProgressToast(finalMessage = null, isError = false, delay = 1500) {
            if (progressToastElement) {
                if (finalMessage) {
                    const msgEl = progressToastElement.querySelector('.progress-message');
                    const barFill = progressToastElement.querySelector('.progress-bar-fill');
                    const percentText = progressToastElement.querySelector('.progress-percent');
                    
                    if (msgEl) msgEl.textContent = finalMessage;
                    if (barFill) barFill.style.width = '100%';
                    if (barFill) barFill.style.background = isError ? '#f44336' : '#4caf50';
                    if (percentText) percentText.textContent = isError ? '‚úó' : '‚úì';
                }
                
                setTimeout(() => {
                    if (progressToastElement) {
                        progressToastElement.classList.remove('show');
                        setTimeout(() => {
                            if (progressToastElement) {
                                progressToastElement.remove();
                                progressToastElement = null;
                            }
                        }, 300);
                    }
                }, delay);
            }
        }

        const SimpleNoise = {
            fract: (x) => x - Math.floor(x),
            hash: (x, z) => { return SimpleNoise.fract(Math.sin(x * 12.9898 + z * 78.233) * 43758.5453); },
            noise: (x, z) => {
                const iX = Math.floor(x); const iZ = Math.floor(z);
                const fX = SimpleNoise.fract(x); const fZ = SimpleNoise.fract(z);
                const a = SimpleNoise.hash(iX, iZ); const b = SimpleNoise.hash(iX + 1, iZ);
                const c = SimpleNoise.hash(iX, iZ + 1); const d = SimpleNoise.hash(iX + 1, iZ + 1);
                const uX = fX * fX * (3.0 - 2.0 * fX); const uZ = fZ * fZ * (3.0 - 2.0 * fZ);
                return (a * (1.0 - uX) + b * uX) * (1.0 - uZ) + (c * (1.0 - uX) + d * uX) * uZ;
            }
        };

        const initialState = {
            uSize: 1.0, profile: 'cherry', row: 'R3', unitSize: 19.05, topScale: 1.0, dishType: 'cylindrical',
            textureType: 'none', textureScale: 50, textureStrength: 0.05, textureGlobal: false,
            imgTextureVisible: false, imgScale: 1.0, imgPosX: 0.0, imgPosY: 0.0, imgRot: 0, imgContent: null,
            enableStemExtension: false, stemExtension: 1.0, stabilizerType: 'auto', stabilizerOffset: 0.0,
            twist: 0, tiltX: 0, tiltZ: 0, boxStem: false, legoStud: false, legoX: 0.0, legoY: 0.0, legoZ: 0.0, legoClear: 0.0,
            wallThickness: 1.5, ribShorten: 4.3, enableRibs: true,
            homingBump: false, homingType: 'round', bumpX: 0, bumpZ: 0, bumpOffsetY: 0.0, roundCorner: 0.0, 
            stemType: 'mx', stemDiameter: 5.50, stemClearance: 0.3,
            enableText: true, text: 'A', font: 'helvetiker', fontSize: 8.0, textHeight: 0.5, textMode: 'emboss',
            textThicknessLocked: true, textConform: true, posX: 0, posZ: 0, textOffsetY: 0.0,
            enableText2: false, text2: '„ÅÇ', text2Size: 4.0, text2X: 3.5, text2Z: 3.5, text2Mode: 'emboss',
            enableSide: false, sideText: 'FRONT', sideSize: 3.0, sideY: -2.0, sideRot: 0, sideMode: 'emboss',
            renderMode: 'standard', 
            modelVisible: true, modelScale: 1.0, modelX: 0, modelY: 0, modelZ: 0, modelRX: 0, modelRY: 0, modelRZ: 0, modelOperation: 'union', 
            globalRotX: 0, globalRotY: 0,
            svgContent: null, svgName: null, svgVisible: true, svgScale: 1.0, svgThickness: 0.6, svgMode: 'emboss', svgConform: true, 
            svgRotX: 0, svgRotY: 0, svgRotZ: 0, svgOffsetY: 0.0, svgPosX: 0, svgPosZ: 0,
            colBody: '#333333', colText: '#00e5ff',
            bodyExtruder: null, textExtruder: null,
            keyShapeType: 'rectangle', polygonSides: 6, starPoints: 5, starInner: 0.5,
            isoTopWidth: 1.5, isoBottomWidth: 1.25, isoHeight: 2.0,
            isoStemX: 2.4, isoStemZ: 0, isoStabTopZ: -12, isoStabBottomZ: 12,
            customHeight: 9.5, customAngle: 3
        };
        let state = JSON.parse(JSON.stringify(initialState));
        let importedModelBuffer = null;
        const csgEvaluator = new Evaluator();
        const history = [JSON.parse(JSON.stringify(initialState))];
        let historyIndex = 0;
        let loadedPresets = [];
        let currentPresetIndex = -1;

        const paramMap = {
            'u-size':'uSize', 'wall-thick':'wallThickness', 'rib-shorten':'ribShorten', 'top-scale':'topScale',
            'stem-clearance':'stemClearance', 'font-size':'fontSize', 'text-height':'textHeight',
            'text-offset-y':'textOffsetY', 'pos-x':'posX', 'pos-z':'posZ',
            'profile-select':'profile', 'row-select':'row', 'homing-type':'homingType', 'dish-type':'dishType', 'font-family':'font',
            'bump-x':'bumpX', 'bump-z':'bumpZ', 'bump-offset-y':'bumpOffsetY',
            'svg-scale':'svgScale', 'svg-thickness':'svgThickness', 
            'svg-rot-x':'svgRotX', 'svg-rot-y':'svgRotY', 'svg-rot-z':'svgRotZ',
            'svg-offset-y':'svgOffsetY', 'svg-pos-x':'svgPosX', 'svg-pos-z':'svgPosZ',
            'text2-size':'text2Size', 'text2-x':'text2X', 'text2-z':'text2Z',
            'side-size':'sideSize', 'side-y':'sideY', 'side-rot':'sideRot',
            'render-mode':'renderMode', 'side-text':'sideText',
            'model-scale':'modelScale', 'model-x':'modelX', 'model-y':'modelY', 'model-z':'modelZ',
            'model-rx':'modelRX', 'model-ry':'modelRY', 'model-rz':'modelRZ',
            'global-rot-x':'globalRotX', 'global-rot-y':'globalRotY', 'model-operation':'modelOperation',
            'texture-type':'textureType', 'tex-scale':'textureScale', 'tex-strength':'textureStrength',
            'stem-extension':'stemExtension', 'stabilizer-type':'stabilizerType', 'stabilizer-offset':'stabilizerOffset',
            'twist-factor': 'twist', 'tilt-x': 'tiltX', 'tilt-z': 'tiltZ', 'unit-size-select': 'unitSize', 'round-corner': 'roundCorner',
            'stem-diameter': 'stemDiameter', 'text-mode': 'textMode', 'text2-mode': 'text2Mode', 'side-mode': 'sideMode', 'svg-mode': 'svgMode',
            'img-scale': 'imgScale', 'img-pos-x': 'imgPosX', 'img-pos-y': 'imgPosY', 'img-rot': 'imgRot',
            'lego-x': 'legoX', 'lego-y': 'legoY', 'lego-z': 'legoZ', 'lego-clear': 'legoClear',
            'polygon-sides': 'polygonSides', 'star-points': 'starPoints', 'star-inner': 'starInner',
            'iso-top-width': 'isoTopWidth', 'iso-bottom-width': 'isoBottomWidth', 'iso-height': 'isoHeight',
            'iso-stem-x': 'isoStemX', 'iso-stem-z': 'isoStemZ', 'iso-stab-top-z': 'isoStabTopZ', 'iso-stab-bottom-z': 'isoStabBottomZ',
            'custom-height': 'customHeight', 'custom-angle': 'customAngle'
        };
        const boolMap = { 
            'enable-ribs':'enableRibs', 'homing-bump':'homingBump', 'enable-text':'enableText', 'svg-visible':'svgVisible', 
            'lock-thickness':'textThicknessLocked', 'text-conform':'textConform', 'svg-conform':'svgConform',
            'enable-text2':'enableText2', 'enable-side':'enableSide', 'model-visible':'modelVisible',
            'enable-stem-extension':'enableStemExtension', 'box-stem': 'boxStem', 'lego-stud': 'legoStud',
            'img-texture-visible': 'imgTextureVisible', 'texture-global': 'textureGlobal'
        };

        function commitHistory() { if (historyIndex < history.length - 1) history.splice(historyIndex + 1); history.push(JSON.parse(JSON.stringify(state))); historyIndex++; if (history.length > 50) { history.shift(); historyIndex--; } updateHistoryBtns(); }
        function undo() { if(historyIndex>0) { historyIndex--; state=JSON.parse(JSON.stringify(history[historyIndex])); syncUI(); updateCustomDropdown(); requestUpdate(); updateHistoryBtns(); } }
        function redo() { if(historyIndex<history.length-1) { historyIndex++; state=JSON.parse(JSON.stringify(history[historyIndex])); syncUI(); updateCustomDropdown(); requestUpdate(); updateHistoryBtns(); } }
        function updateHistoryBtns() { document.getElementById('btn-undo').disabled = historyIndex === 0; document.getElementById('btn-redo').disabled = historyIndex === history.length - 1; }
        
        function syncUI() {
            for (const [id, key] of Object.entries(paramMap)) { const el = document.getElementById(id); if(el) { el.value = state[key]; const span = document.getElementById('v-' + id); if(span) span.textContent = typeof state[key] === 'number' ? state[key].toFixed(2) : state[key]; if(id === 'tex-scale' || id === 'polygon-sides' || id === 'star-points') if(span) span.textContent = parseInt(state[key]); } }
            for (const [id, key] of Object.entries(boolMap)) { const el = document.getElementById(id); if(el) el.checked = state[key]; }
            const tHeight = document.getElementById('text-height'); if(tHeight) tHeight.disabled = state.textThicknessLocked;
            document.getElementById('stem-ext-control').style.display = state.enableStemExtension ? 'block' : 'none';
            document.getElementById('stabilizer-custom-ui').style.display = state.stabilizerType === 'custom' ? 'block' : 'none';
            document.getElementById('lego-adj-panel').style.display = state.legoStud ? 'block' : 'none';
            const customProfilePanel = document.getElementById('custom-profile-panel');
            if(customProfilePanel) customProfilePanel.style.display = state.profile === 'custom' ? 'block' : 'none';
            const shapePolygon = document.getElementById('shape-polygon-options');
            if(shapePolygon) shapePolygon.style.display = state.keyShapeType === 'polygon' ? 'block' : 'none';
            const shapeStar = document.getElementById('shape-star-options');
            if(shapeStar) shapeStar.style.display = state.keyShapeType === 'star' ? 'block' : 'none';
            const shapeIso = document.getElementById('shape-iso-options');
            if(shapeIso) shapeIso.style.display = state.keyShapeType === 'iso-enter' ? 'block' : 'none';
            const keyShapeSelect = document.getElementById('key-shape-type');
            if(keyShapeSelect) keyShapeSelect.value = state.keyShapeType;
            const colB = document.getElementById('col-body'); if(colB) colB.value = state.colBody;
            const colT = document.getElementById('col-text'); if(colT) colT.value = state.colText;
            const simpleColB = document.getElementById('simple-col-body'); if(simpleColB) simpleColB.value = state.colBody;
            const simpleColT = document.getElementById('simple-col-text'); if(simpleColT) simpleColT.value = state.colText;
            // Sync new simple mode controls
            const simpleTextMode = document.getElementById('simple-text-mode'); 
            if(simpleTextMode) {
                // SVG„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØsvgMode„ÄÅ„Å™„ÅÑÂ†¥Âêà„ÅØtextMode„ÇíË°®Á§∫
                simpleTextMode.value = state.svgContent ? state.svgMode : state.textMode;
            }
            const simpleTaper = document.getElementById('simple-taper'); if(simpleTaper) { simpleTaper.value = state.topScale; const v = document.getElementById('v-simple-taper'); if(v) v.textContent = state.topScale.toFixed(2); }
            const simpleDish = document.getElementById('simple-dish-type'); if(simpleDish) simpleDish.value = state.dishType;
            const simpleFillet = document.getElementById('simple-fillet'); if(simpleFillet) { simpleFillet.value = state.roundCorner; const v = document.getElementById('v-simple-fillet'); if(v) v.textContent = state.roundCorner.toFixed(1); }
            const txt = document.getElementById('text-content'); if(txt) txt.value = state.text;
            const txt2 = document.getElementById('text2-content'); if(txt2) txt2.value = state.text2;
            const sideT = document.getElementById('side-text'); if(sideT) sideT.value = state.sideText;
            // V67: „Çπ„ÉÜ„É†„Çø„Ç§„Éó„ÅÆÂêåÊúü
            const stemTypeSelect = document.getElementById('stem-type-select');
            if (stemTypeSelect) stemTypeSelect.value = state.stemType || 'mx';
            // Á∞°Âçò„É¢„Éº„Éâ„ÅÆ„Éï„Ç©„É≥„Éà„Éâ„É≠„ÉÉ„Éó„ÉÄ„Ç¶„É≥„Éò„ÉÉ„ÉÄ„Éº„ÇíÊõ¥Êñ∞
            if (typeof window.updateSimpleCustomDropdownHead === 'function') window.updateSimpleCustomDropdownHead();
            updateLanguageUI();
        }

        const filamentData = {
            'polymaker': { name: 'Polymaker', materials: { 'pla': { name: 'PolyLite PLA', d: 1.24, price_jp: 3800, price_us: 25 }, 'pla_matte': { name: 'PolyTerra PLA', d: 1.22, price_jp: 3800, price_us: 25 }, 'abs': { name: 'PolyLite ABS', d: 1.04, price_jp: 4000, price_us: 27 }, 'petg': { name: 'PolyLite PETG', d: 1.27, price_jp: 3800, price_us: 25 }, 'asa': { name: 'PolyLite ASA', d: 1.07, price_jp: 5500, price_us: 36 } } },
            'bambulab': { name: 'Bambu Lab', materials: { 'pla': { name: 'PLA Basic', d: 1.24, price_jp: 2240, price_us: 22 }, 'pla_matte': { name: 'PLA Matte', d: 1.22, price_jp: 2240, price_us: 22 }, 'abs': { name: 'Bambu ABS', d: 1.05, price_jp: 3300, price_us: 25 }, 'petg': { name: 'PETG Basic', d: 1.27, price_jp: 3000, price_us: 20 }, 'asa': { name: 'Bambu ASA', d: 1.07, price_jp: 4200, price_us: 30 } } },
            'elegoo': { name: 'Elegoo', materials: { 'pla': { name: 'Elegoo PLA', d: 1.24, price_jp: 2200, price_us: 14 }, 'pla_matte': { name: 'Elegoo Matte', d: 1.24, price_jp: 2800, price_us: 18 }, 'abs': { name: 'Elegoo ABS', d: 1.04, price_jp: 3000, price_us: 19 }, 'petg': { name: 'Elegoo PETG', d: 1.27, price_jp: 2400, price_us: 15 }, 'asa': null } },
            'esun': { name: 'eSun', materials: { 'pla': { name: 'PLA+', d: 1.24, price_jp: 3200, price_us: 23 }, 'pla_matte': { name: 'ePLA-Matte', d: 1.24, price_jp: 3500, price_us: 25 }, 'abs': { name: 'ABS+', d: 1.04, price_jp: 3200, price_us: 23 }, 'petg': { name: 'PETG', d: 1.27, price_jp: 3200, price_us: 23 }, 'asa': { name: 'eASA', d: 1.07, price_jp: 4000, price_us: 28 } } },
            'sunlu': { name: 'Sunlu', materials: { 'pla': { name: 'Sunlu PLA', d: 1.24, price_jp: 2500, price_us: 19 }, 'pla_matte': { name: 'Sunlu Matte', d: 1.24, price_jp: 2500, price_us: 19 }, 'abs': { name: 'Sunlu ABS', d: 1.04, price_jp: 2800, price_us: 20 }, 'petg': { name: 'Sunlu PETG', d: 1.27, price_jp: 2500, price_us: 18 }, 'asa': { name: 'Sunlu ASA', d: 1.07, price_jp: 3500, price_us: 25 } } },
            'overture': { name: 'Overture', materials: { 'pla': { name: 'Overture PLA', d: 1.24, price_jp: 2800, price_us: 19 }, 'pla_matte': { name: 'Matte PLA', d: 1.24, price_jp: 2800, price_us: 19 }, 'abs': { name: 'Overture ABS', d: 1.04, price_jp: 3000, price_us: 21 }, 'petg': { name: 'Overture PETG', d: 1.27, price_jp: 2800, price_us: 18 }, 'asa': { name: 'Overture ASA', d: 1.07, price_jp: 4500, price_us: 31 } } },
            'generic': { name: 'Generic (Manual)', materials: { 'pla': { name: 'Generic PLA', d: 1.24, price_jp: 2500, price_us: 20 }, 'pla_matte': { name: 'Generic Matte', d: 1.24, price_jp: 2500, price_us: 20 }, 'abs': { name: 'Generic ABS', d: 1.04, price_jp: 2500, price_us: 20 }, 'petg': { name: 'Generic PETG', d: 1.27, price_jp: 2500, price_us: 20 }, 'asa': { name: 'Generic ASA', d: 1.07, price_jp: 3000, price_us: 25 } } }
        };
        let selectedVendor = 'bambulab'; let selectedMaterial = 'pla';
        function initFilamentManager() {
            const vSel = document.getElementById('fil-vendor'); const mSel = document.getElementById('fil-material');
            Object.keys(filamentData).forEach(key => { const opt = document.createElement('option'); opt.value = key; opt.textContent = filamentData[key].name; vSel.appendChild(opt); });
            vSel.value = selectedVendor;
            const materials = [{id:'pla', label:'PLA'},{id:'pla_matte', label:'PLA Matte'},{id:'abs', label:'ABS'},{id:'petg', label:'PETG'},{id:'asa', label:'ASA'}];
            materials.forEach(m => { const opt = document.createElement('option'); opt.value = m.id; opt.textContent = m.label; mSel.appendChild(opt); });
            mSel.value = selectedMaterial;
            vSel.addEventListener('change', e => { selectedVendor = e.target.value; updateFilamentDisplay(); });
            mSel.addEventListener('change', e => { selectedMaterial = e.target.value; updateFilamentDisplay(); });
            const btn = document.getElementById('btn-toggle-fil'); const panel = document.getElementById('fil-details-panel');
            btn.addEventListener('click', () => { panel.classList.toggle('open'); });
            ['fil-price','fil-capacity','fil-density'].forEach(id => { document.getElementById(id).addEventListener('input', calculateStats); });
            updateFilamentDisplay();
        }
        function updateFilamentDisplay() {
            const data = filamentData[selectedVendor].materials[selectedMaterial];
            const nameEl = document.getElementById('info-fil-name'); const priceIn = document.getElementById('fil-price'); const denIn = document.getElementById('fil-density'); const currEl = document.getElementById('info-currency');
            const isJP = currentLang === 'ja'; currEl.textContent = isJP ? '¬•' : '$';
            if (!data) { nameEl.textContent = "N/A"; priceIn.value = ""; denIn.value = ""; calculateStats(); return; }
            nameEl.textContent = data.name; priceIn.value = isJP ? data.price_jp : data.price_us; denIn.value = data.d; document.getElementById('fil-capacity').value = 1000; calculateStats();
        }
        function calculateStats() {
            const price = parseFloat(document.getElementById('fil-price').value); const capacity = parseFloat(document.getElementById('fil-capacity').value); const density = parseFloat(document.getElementById('fil-density').value);
            const wEl = document.getElementById('info-weight'); const cEl = document.getElementById('info-cost');
            if (isNaN(price) || isNaN(capacity) || isNaN(density) || capacity <= 0) { wEl.textContent = "--"; cEl.textContent = "--"; return; }
            const p = getParams(); const baseVol = p.baseW * p.baseD * p.h; let fillFactor = 0.22 + (state.wallThickness - 1.5) * 0.1; if(state.boxStem) fillFactor += 0.05;
            const volCm3 = (baseVol * fillFactor) / 1000; const weight = volCm3 * density; const totalCost = weight * (price / capacity);
            wEl.textContent = weight.toFixed(2); cEl.textContent = (currentLang === 'ja') ? Math.ceil(totalCost) : totalCost.toFixed(2);
        }
        function randomizeParams() {
            state.uSize = 1.0; state.profile = ['cherry','oem','sa','xda','dsa'][Math.floor(Math.random()*5)];
            state.topScale = 0.6 + Math.random() * 0.4; state.dishType = ['cylindrical','spherical','flat'][Math.floor(Math.random()*3)];
            state.textureType = ['none','noise','grid','knurling','stripes','ripple','wood','hammered','hexagon','bricks'][Math.floor(Math.random()*10)];
            state.textureScale = 10 + Math.random() * 80; state.twist = Math.floor(Math.random() * 60) - 30; state.tiltX = Math.floor(Math.random() * 20) - 10;
            state.colBody = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'); state.colText = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            syncUI(); updateModel();
        }
        function resetParams() { if(confirm("Reset all parameters?")) { state = JSON.parse(JSON.stringify(initialState)); syncUI(); updateModel(); } }

        let committedFont = state.font;
        let customDropdownInitialized = false;
        function setupCustomDropdown() {
            const head = document.getElementById('custom-font-head'); const list = document.getElementById('custom-font-list'); const hiddenSelect = document.getElementById('font-family');
            if(!head || !list || !hiddenSelect) return;
            function populate() {
                list.innerHTML = ''; Array.from(hiddenSelect.options).forEach(opt => {
                    if(!loadedFonts[opt.value]) return;
                    const div = document.createElement('div'); div.className = 'custom-option'; div.textContent = opt.text; if(opt.value === state.font) div.classList.add('selected');
                    div.addEventListener('mouseenter', () => { state.font = opt.value; requestUpdate(); });
                    div.addEventListener('click', () => { 
                        committedFont = opt.value; 
                        state.font = committedFont; 
                        hiddenSelect.value = committedFont; 
                        list.classList.remove('open'); 
                        updateCustomDropdownHead(); 
                        // Á∞°Âçò„É¢„Éº„Éâ„ÅÆ„Éï„Ç©„É≥„Éà„Çª„É¨„ÇØ„Çø„Éº„ÇÇÂêåÊúü
                        const simpleFont = document.getElementById('simple-font-select');
                        if (simpleFont) simpleFont.value = committedFont;
                        if (typeof window.updateSimpleCustomDropdownHead === 'function') window.updateSimpleCustomDropdownHead();
                        commitHistory(); 
                        requestUpdate(); 
                    });
                    list.appendChild(div);
                });
            }
            if(!customDropdownInitialized) {
                head.addEventListener('click', () => { if(!list.classList.contains('open')) { committedFont = state.font; populate(); list.classList.add('open'); } else { list.classList.remove('open'); } });
                list.addEventListener('mouseleave', () => { state.font = committedFont; requestUpdate(); });
                document.addEventListener('click', (e) => { const ui = document.getElementById('custom-font-ui'); if(ui && !ui.contains(e.target) && list.classList.contains('open')) { list.classList.remove('open'); state.font = committedFont; requestUpdate(); } });
                customDropdownInitialized = true;
            }
            updateCustomDropdownHead();
        }
        function updateCustomDropdown() { committedFont = state.font; updateCustomDropdownHead(); }
        function updateCustomDropdownHead() { const hiddenSelect = document.getElementById('font-family'); const head = document.getElementById('custom-font-head'); if(hiddenSelect && head) { const opt = hiddenSelect.querySelector(`option[value="${state.font}"]`); if(opt) head.textContent = opt.text + " ‚ñº"; } }

        function initNavigation() {
            const select = document.getElementById('section-select'); select.addEventListener('change', (e) => { const id = e.target.value; if(id) { const el = document.getElementById(id); if(el) { el.scrollIntoView({ behavior: 'smooth' }); el.style.color = '#fff'; setTimeout(() => el.style.color = '', 1000); } select.value = ""; } });
            const search = document.getElementById('search-box'); search.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase(); const labels = document.querySelectorAll('#ui-panel label, #ui-panel h3'); document.querySelectorAll('.search-highlight').forEach(el => el.classList.remove('search-highlight'));
                if(!query) return; let firstMatch = null; labels.forEach(lbl => { const text = lbl.textContent.toLowerCase(); if(text.includes(query)) { lbl.classList.add('search-highlight'); if(!firstMatch) firstMatch = lbl; } });
                if(firstMatch) firstMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
        }
        
        const PROFILES = { cherry: { R4: {h:11.5, a:6}, R3: {h:9.5, a:3}, R2: {h:8.5, a:-3}, R1: {h:9.5, a:-6}, dish:'cylindrical' }, oem: { R4: {h:12.5, a:8}, R3: {h:11.0, a:4}, R2: {h:10.0, a:-4}, R1: {h:11.0, a:-8}, dish:'cylindrical' }, sa: { R4: {h:16.5, a:7}, R3: {h:14.0, a:0}, R2: {h:14.0, a:0}, R1: {h:14.0, a:-7}, dish:'spherical' }, xda: { all:{h:9.0, a:0}, dish:'spherical' }, dsa: { all:{h:7.5, a:0}, dish:'spherical' }, custom: { all:{h:9.5, a:3}, dish:'cylindrical' } };
        const HTML_COLORS = ['#000000','#333333','#666666','#ffffff','#ff0000','#ff8000','#ffff00','#00ff00','#00ffff','#0000ff','#8000ff','#ff00ff','#800000','#008000','#000080','#808000'];
        const container = document.getElementById('canvas-container'); const scene = new THREE.Scene(); scene.background = new THREE.Color(0x121212);
        const camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 1000); camera.position.set(20, 30, 30);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(container.clientWidth, container.clientHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.autoClear = false; container.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true;
        
        // V67: „Éì„É•„Éº„Ç≠„É•„Éº„ÉñÂàùÊúüÂåñÔºàViewHelper„ÇíÁΩÆ„ÅçÊèõ„ÅàÔºâ
        initViewCube();
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.4)); const dl = new THREE.DirectionalLight(0xffffff, 1.0); dl.position.set(10,50,20); dl.castShadow=true; scene.add(dl); const bl = new THREE.DirectionalLight(0x00bcd4, 0.5); bl.position.set(0,-20,0); scene.add(bl); scene.add(new THREE.GridHelper(200, 200, 0x444444, 0x222222));
        const mainGroup = new THREE.Group(); scene.add(mainGroup); const fontLoader = new FontLoader(); const loadedFonts = {}; const textureLoader = new THREE.TextureLoader();

        function getParams() { 
            const p = PROFILES[state.profile]; 
            let r;
            if (state.profile === 'custom') {
                r = { h: state.customHeight, a: state.customAngle };
            } else {
                r = p.all ? p.all : p[state.row]; 
            }
            const unit = parseFloat(state.unitSize) || 19.05;
            
            if(state.keyShapeType === 'iso-enter') {
                const fullW = (unit * state.isoTopWidth) - 0.5;
                const totalH = (unit * state.isoHeight) - 0.5;
                return { h: r.h, angle: 0, baseW: fullW, baseD: totalH };
            }
            
            return { h: r.h, angle: r.a, baseW: (unit * state.uSize) - 0.5, baseD: unit - 0.5 }; 
        }
        function getStabilizerOffset(u) { if (state.stabilizerType === 'custom') return state.stabilizerOffset; if (u < 2.0) return 0; if (u < 3.0) return 11.9; if (u < 6.0) return 19.05; if (u == 6.25) return 50.0; if (u >= 7.0) return 57.15; return 38.1; }
        const DISH_DEPTH = 0.8; 
        function getDishOffset(x, z, p) { const wHalf = p.baseW * state.topScale * 0.5; const dHalf = p.baseD * state.topScale * 0.5; const nx = x / (wHalf || 1); const nz = z / (dHalf || 1); let offset = 0; const type = state.dishType; if(type === 'flat') offset = 0; else if(type === 'cylindrical') { if(Math.abs(nx) < 2.0) offset = DISH_DEPTH * (Math.pow(nx, 2) - 1.0); } else { const dist = Math.sqrt(nx*nx + nz*nz); if(dist < 2.0) offset = DISH_DEPTH * (Math.pow(dist, 2) - 1.0); } return offset; }
        function getSurfaceHeight(x, z, p) { 
            if(state.keyShapeType === 'iso-enter') {
                return p.h;
            }
            const tiltXRad = THREE.MathUtils.degToRad(state.tiltX); 
            const tiltZRad = THREE.MathUtils.degToRad(state.tiltZ); 
            const baseTilt = Math.tan(THREE.MathUtils.degToRad(p.angle)) * z; 
            const customTilt = (Math.tan(tiltXRad) * z) + (Math.tan(tiltZRad) * x); 
            return (p.h - baseTilt - customTilt) + getDishOffset(x, z, p); 
        }
        
        function safeMerge(geometries) { const clean = []; geometries.forEach(g => { if(g) { if(g.index) g = g.toNonIndexed(); clean.push(g); } }); if(clean.length === 0) return null; return BufferGeometryUtils.mergeGeometries(clean, false); }

        // V67.3: „Ç®„ÇØ„Çπ„Éù„Éº„ÉàÂ∞ÇÁî®„ÅÆÊ∞¥ÂØÜ„Éú„Éá„Ç£ÁîüÊàêÔºàÈ†ÇÁÇπÂÖ±ÊúâÊñπÂºèÔºâ
        // V67.3: „Ç®„ÇØ„Çπ„Éù„Éº„ÉàÂ∞ÇÁî®„ÅÆÊ∞¥ÂØÜ„Éú„Éá„Ç£ÁîüÊàêÔºà„Ç∑„É≥„Éó„É´„Å™CSGÊñπÂºèÔºâ
        function createWatertightBodyForExport(p) {
            const thick = state.wallThickness;
            // „Çª„Ç∞„É°„É≥„ÉàÊï∞„ÇíÊúÄÈÅ©ÂåñÔºà„Éï„Ç£„É¨„ÉÉ„Éà„ÅåÂäπ„Åè„Çà„ÅÜ„Å´„ÄÅ„Åã„Å§Â¢ÉÁïå„Ç®„ÉÉ„Ç∏„ÇíÊäë„Åà„ÇãÔºâ
            const segXZ = 24;
            const segY = 24;
            
            console.log("V67.3: Creating watertight shell using CSG subtraction...");
            
            // Â§ñÂÅ¥„ÅÆ„ÇΩ„É™„ÉÉ„Éâ„Éú„ÉÉ„ÇØ„Çπ
            const outerGeo = new THREE.BoxGeometry(p.baseW, p.h, p.baseD, segXZ, segY, segXZ);
            outerGeo.translate(0, p.h / 2, 0);
            
            // ÂÜÖÂÅ¥„ÅÆÁ©∫Ê¥ûÔºàÂ∞ë„ÅóÂ∞è„Åï„ÅÑ„ÄÅÂ∫ïÈù¢„ÅåÈñã„ÅÑ„Å¶„ÅÑ„ÇãÔºâ
            const innerW = p.baseW - thick * 2;
            const innerD = p.baseD - thick * 2;
            const innerH = p.h - thick + 0.1;
            const innerGeo = new THREE.BoxGeometry(innerW, innerH, innerD, segXZ, segY, segXZ);
            innerGeo.translate(0, innerH / 2 - 0.05, 0);
            
            // CSGÁî®„Å´Ê∫ñÂÇôÔºànormalÂ±ûÊÄß„ÅåÂøÖË¶ÅÔºâ
            outerGeo.computeVertexNormals();
            innerGeo.computeVertexNormals();
            
            // CSGÊ∏õÁÆó„Åß‰∏≠Á©∫„ÅÆ„Ç∑„Çß„É´„Çí‰ΩúÊàê
            try {
                const outerBrush = new Brush(outerGeo);
                outerBrush.updateMatrixWorld();
                const innerBrush = new Brush(innerGeo);
                innerBrush.updateMatrixWorld();
                
                const result = csgEvaluator.evaluate(outerBrush, innerBrush, SUBTRACTION);
                let resultGeo = result.geometry;
                
                // UV„ÇíÂâäÈô§Ôºà„Éû„Éº„Ç∏ÊôÇ„ÅÆ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅÔºâ
                if (resultGeo.attributes.uv) {
                    resultGeo.deleteAttribute('uv');
                }
                
                // Ê≥ïÁ∑ö„ÇíË®àÁÆó
                resultGeo.computeVertexNormals();
                
                console.log("V67.3: CSG shell created with", resultGeo.attributes.position.count, "vertices");
                return resultGeo;
            } catch(e) {
                console.error("V67.3: CSG failed:", e);
                return null;
            }
        }

        // ==========================================
        // V67.1: Ê∞¥ÂØÜ„Å™„Ç∑„Çß„É´„Ç∏„Ç™„É°„Éà„É™ÁîüÊàê
        // ==========================================
        function createWatertightBody(p) {
            const thick = state.wallThickness;
            const w = p.baseW;
            const d = p.baseD;
            const h = p.h;
            const segments = 16; // ÂêÑËæ∫„ÅÆÂàÜÂâ≤Êï∞
            
            // È†ÇÁÇπÈÖçÂàó„Å®„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÈÖçÂàó
            const vertices = [];
            const indices = [];
            
            // È´ò„ÅïÊñπÂêë„ÅÆÂàÜÂâ≤
            const hSegments = 16;
            
            // Â§ñÂÅ¥„Å®ÂÜÖÂÅ¥„ÅÆÈ†ÇÁÇπ„ÇíÁîüÊàê
            // Â∫ïÈù¢Ôºày=0Ôºâ„Åã„Çâ‰∏äÈù¢Ôºày=hÔºâ„Åæ„Åß
            
            // Â§ñÂÅ¥„ÅÆÈ†ÇÁÇπ„Ç∞„É™„ÉÉ„Éâ: (segments+1) x (hSegments+1) x 4Èù¢
            // ÂÜÖÂÅ¥„ÅÆÈ†ÇÁÇπ„Ç∞„É™„ÉÉ„Éâ: ÂêåÊßò
            
            // „Ç∑„É≥„Éó„É´„Å™ÂÆüË£Ö: Â§ñÂÅ¥„Å®ÂÜÖÂÅ¥„ÅÆÁÆ±„ÇíÁîüÊàê„Åó„ÄÅÂ∫ïÈù¢„ÇíÈñã„Åë„Çã
            
            // Â§ñÂÅ¥„ÅÆÂØ∏Ê≥ï
            const outerW = w / 2;
            const outerD = d / 2;
            
            // ÂÜÖÂÅ¥„ÅÆÂØ∏Ê≥ïÔºàÂ£Å„ÅÆÂéö„ÅïÂàÜ„Å†„ÅëÂ∞è„Åï„ÅÑÔºâ
            const innerW = outerW - thick;
            const innerD = outerD - thick;
            const innerH = h - thick; // ÂÜÖÂÅ¥„ÅÆÈ´ò„ÅïÔºà‰∏äÈù¢„ÅÆÂéö„ÅïÂàÜ„Å†„Åë‰Ωé„ÅÑÔºâ
            
            // È†ÇÁÇπ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆ„Ç™„Éï„Çª„ÉÉ„ÉàËøΩË∑°
            let vertexOffset = 0;
            
            // === Â§ñÂÅ¥„ÅÆÈù¢Ôºà‰∏äÈù¢ + 4ÂÅ¥Èù¢Ôºâ===
            
            // ‰∏äÈù¢ÔºàÂ§ñÂÅ¥Ôºâ: y = h
            // 4„Å§„ÅÆ„Ç≥„Éº„Éä„Éº + ‰∏≠Èñì„ÅÆÈ†ÇÁÇπ
            const topOuterVerts = [];
            for (let iz = 0; iz <= segments; iz++) {
                for (let ix = 0; ix <= segments; ix++) {
                    const x = -outerW + (2 * outerW * ix / segments);
                    const z = -outerD + (2 * outerD * iz / segments);
                    topOuterVerts.push({ x, y: h, z, idx: vertices.length / 3 });
                    vertices.push(x, h, z);
                }
            }
            
            // ‰∏äÈù¢„ÅÆ‰∏âËßíÂΩ¢ÔºàÂ§ñÂêë„ÅçÊ≥ïÁ∑ö = ‰∏äÂêë„ÅçÔºâ
            for (let iz = 0; iz < segments; iz++) {
                for (let ix = 0; ix < segments; ix++) {
                    const a = iz * (segments + 1) + ix;
                    const b = a + 1;
                    const c = a + (segments + 1);
                    const d = c + 1;
                    // ‰∏äÂêë„ÅçÊ≥ïÁ∑ö„ÅÆ„Åü„ÇÅ„ÅÆÈ†ÇÁÇπÈ†ÜÂ∫è
                    indices.push(a, c, b);
                    indices.push(b, c, d);
                }
            }
            
            vertexOffset = vertices.length / 3;
            
            // ÂÜÖÂÅ¥„ÅÆ‰∏äÈù¢Ôºày = innerH„ÄÅÂÜÖÈÉ®Á©∫Ê¥û„ÅÆÂ§©‰∫ïÔºâ
            const topInnerVerts = [];
            for (let iz = 0; iz <= segments; iz++) {
                for (let ix = 0; ix <= segments; ix++) {
                    const x = -innerW + (2 * innerW * ix / segments);
                    const z = -innerD + (2 * innerD * iz / segments);
                    topInnerVerts.push({ x, y: innerH, z, idx: vertices.length / 3 });
                    vertices.push(x, innerH, z);
                }
            }
            
            // ÂÜÖÂÅ¥‰∏äÈù¢„ÅÆ‰∏âËßíÂΩ¢Ôºà‰∏ãÂêë„ÅçÊ≥ïÁ∑öÔºâ
            for (let iz = 0; iz < segments; iz++) {
                for (let ix = 0; ix < segments; ix++) {
                    const a = vertexOffset + iz * (segments + 1) + ix;
                    const b = a + 1;
                    const c = a + (segments + 1);
                    const d = c + 1;
                    // ‰∏ãÂêë„ÅçÊ≥ïÁ∑ö„ÅÆ„Åü„ÇÅ„ÅÆÈ†ÇÁÇπÈ†ÜÂ∫èÔºàÂèçËª¢Ôºâ
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            vertexOffset = vertices.length / 3;
            
            // === ÂÅ¥Èù¢ÔºàÂ§ñÂÅ¥4Èù¢ + ÂÜÖÂÅ¥4Èù¢Ôºâ===
            
            // Â§ñÂÅ¥ÂâçÈù¢ (z = outerD)
            const frontOuterVerts = [];
            for (let iy = 0; iy <= hSegments; iy++) {
                for (let ix = 0; ix <= segments; ix++) {
                    const x = -outerW + (2 * outerW * ix / segments);
                    const y = h * iy / hSegments;
                    frontOuterVerts.push({ x, y, z: outerD, idx: vertices.length / 3 });
                    vertices.push(x, y, outerD);
                }
            }
            
            // Â§ñÂÅ¥ÂâçÈù¢„ÅÆ‰∏âËßíÂΩ¢ÔºàÂâçÂêë„ÅçÊ≥ïÁ∑öÔºâ
            for (let iy = 0; iy < hSegments; iy++) {
                for (let ix = 0; ix < segments; ix++) {
                    const a = vertexOffset + iy * (segments + 1) + ix;
                    const b = a + 1;
                    const c = a + (segments + 1);
                    const d = c + 1;
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            vertexOffset = vertices.length / 3;
            
            // Â§ñÂÅ¥ÂæåÈù¢ (z = -outerD)
            for (let iy = 0; iy <= hSegments; iy++) {
                for (let ix = 0; ix <= segments; ix++) {
                    const x = outerW - (2 * outerW * ix / segments); // ÂèçËª¢
                    const y = h * iy / hSegments;
                    vertices.push(x, y, -outerD);
                }
            }
            
            for (let iy = 0; iy < hSegments; iy++) {
                for (let ix = 0; ix < segments; ix++) {
                    const a = vertexOffset + iy * (segments + 1) + ix;
                    const b = a + 1;
                    const c = a + (segments + 1);
                    const d = c + 1;
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            vertexOffset = vertices.length / 3;
            
            // Â§ñÂÅ¥Â∑¶Èù¢ (x = -outerW)
            for (let iy = 0; iy <= hSegments; iy++) {
                for (let iz = 0; iz <= segments; iz++) {
                    const z = outerD - (2 * outerD * iz / segments); // ÂèçËª¢
                    const y = h * iy / hSegments;
                    vertices.push(-outerW, y, z);
                }
            }
            
            for (let iy = 0; iy < hSegments; iy++) {
                for (let iz = 0; iz < segments; iz++) {
                    const a = vertexOffset + iy * (segments + 1) + iz;
                    const b = a + 1;
                    const c = a + (segments + 1);
                    const d = c + 1;
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            vertexOffset = vertices.length / 3;
            
            // Â§ñÂÅ¥Âè≥Èù¢ (x = outerW)
            for (let iy = 0; iy <= hSegments; iy++) {
                for (let iz = 0; iz <= segments; iz++) {
                    const z = -outerD + (2 * outerD * iz / segments);
                    const y = h * iy / hSegments;
                    vertices.push(outerW, y, z);
                }
            }
            
            for (let iy = 0; iy < hSegments; iy++) {
                for (let iz = 0; iz < segments; iz++) {
                    const a = vertexOffset + iy * (segments + 1) + iz;
                    const b = a + 1;
                    const c = a + (segments + 1);
                    const d = c + 1;
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            vertexOffset = vertices.length / 3;
            
            // === ÂÜÖÂÅ¥Èù¢Ôºà4Èù¢Ôºâ===
            
            // ÂÜÖÂÅ¥ÂâçÈù¢ (z = innerD)
            for (let iy = 0; iy <= hSegments; iy++) {
                for (let ix = 0; ix <= segments; ix++) {
                    const x = innerW - (2 * innerW * ix / segments); // ÂèçËª¢ÔºàÂÜÖÂêë„ÅçÊ≥ïÁ∑öÔºâ
                    const y = innerH * iy / hSegments;
                    vertices.push(x, y, innerD);
                }
            }
            
            for (let iy = 0; iy < hSegments; iy++) {
                for (let ix = 0; ix < segments; ix++) {
                    const a = vertexOffset + iy * (segments + 1) + ix;
                    const b = a + 1;
                    const c = a + (segments + 1);
                    const d = c + 1;
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            vertexOffset = vertices.length / 3;
            
            // ÂÜÖÂÅ¥ÂæåÈù¢ (z = -innerD)
            for (let iy = 0; iy <= hSegments; iy++) {
                for (let ix = 0; ix <= segments; ix++) {
                    const x = -innerW + (2 * innerW * ix / segments);
                    const y = innerH * iy / hSegments;
                    vertices.push(x, y, -innerD);
                }
            }
            
            for (let iy = 0; iy < hSegments; iy++) {
                for (let ix = 0; ix < segments; ix++) {
                    const a = vertexOffset + iy * (segments + 1) + ix;
                    const b = a + 1;
                    const c = a + (segments + 1);
                    const d = c + 1;
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            vertexOffset = vertices.length / 3;
            
            // ÂÜÖÂÅ¥Â∑¶Èù¢ (x = -innerW)
            for (let iy = 0; iy <= hSegments; iy++) {
                for (let iz = 0; iz <= segments; iz++) {
                    const z = -innerD + (2 * innerD * iz / segments);
                    const y = innerH * iy / hSegments;
                    vertices.push(-innerW, y, z);
                }
            }
            
            for (let iy = 0; iy < hSegments; iy++) {
                for (let iz = 0; iz < segments; iz++) {
                    const a = vertexOffset + iy * (segments + 1) + iz;
                    const b = a + 1;
                    const c = a + (segments + 1);
                    const d = c + 1;
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            vertexOffset = vertices.length / 3;
            
            // ÂÜÖÂÅ¥Âè≥Èù¢ (x = innerW)
            for (let iy = 0; iy <= hSegments; iy++) {
                for (let iz = 0; iz <= segments; iz++) {
                    const z = innerD - (2 * innerD * iz / segments); // ÂèçËª¢
                    const y = innerH * iy / hSegments;
                    vertices.push(innerW, y, z);
                }
            }
            
            for (let iy = 0; iy < hSegments; iy++) {
                for (let iz = 0; iz < segments; iz++) {
                    const a = vertexOffset + iy * (segments + 1) + iz;
                    const b = a + 1;
                    const c = a + (segments + 1);
                    const d = c + 1;
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            vertexOffset = vertices.length / 3;
            
            // === ‰∏äÈÉ®„ÅÆÁ∏ÅÔºàÂ§ñÂÅ¥‰∏äÈù¢„Å®ÂÜÖÂÅ¥‰∏äÈù¢„ÇíÊé•Á∂öÔºâ===
            // ÂâçÁ∏Å
            for (let ix = 0; ix <= segments; ix++) {
                const xOuter = -outerW + (2 * outerW * ix / segments);
                const xInner = -innerW + (2 * innerW * ix / segments);
                vertices.push(xOuter, h, outerD);      // Â§ñÂÅ¥
                vertices.push(xInner, innerH, innerD); // ÂÜÖÂÅ¥
            }
            
            for (let ix = 0; ix < segments; ix++) {
                const a = vertexOffset + ix * 2;
                const b = a + 2;
                const c = a + 1;
                const d = a + 3;
                indices.push(a, b, c);
                indices.push(b, d, c);
            }
            
            vertexOffset = vertices.length / 3;
            
            // ÂæåÁ∏Å
            for (let ix = 0; ix <= segments; ix++) {
                const xOuter = outerW - (2 * outerW * ix / segments);
                const xInner = innerW - (2 * innerW * ix / segments);
                vertices.push(xOuter, h, -outerD);
                vertices.push(xInner, innerH, -innerD);
            }
            
            for (let ix = 0; ix < segments; ix++) {
                const a = vertexOffset + ix * 2;
                const b = a + 2;
                const c = a + 1;
                const d = a + 3;
                indices.push(a, b, c);
                indices.push(b, d, c);
            }
            
            vertexOffset = vertices.length / 3;
            
            // Â∑¶Á∏Å
            for (let iz = 0; iz <= segments; iz++) {
                const zOuter = outerD - (2 * outerD * iz / segments);
                const zInner = innerD - (2 * innerD * iz / segments);
                vertices.push(-outerW, h, zOuter);
                vertices.push(-innerW, innerH, zInner);
            }
            
            for (let iz = 0; iz < segments; iz++) {
                const a = vertexOffset + iz * 2;
                const b = a + 2;
                const c = a + 1;
                const d = a + 3;
                indices.push(a, b, c);
                indices.push(b, d, c);
            }
            
            vertexOffset = vertices.length / 3;
            
            // Âè≥Á∏Å
            for (let iz = 0; iz <= segments; iz++) {
                const zOuter = -outerD + (2 * outerD * iz / segments);
                const zInner = -innerD + (2 * innerD * iz / segments);
                vertices.push(outerW, h, zOuter);
                vertices.push(innerW, innerH, zInner);
            }
            
            for (let iz = 0; iz < segments; iz++) {
                const a = vertexOffset + iz * 2;
                const b = a + 2;
                const c = a + 1;
                const d = a + 3;
                indices.push(a, b, c);
                indices.push(b, d, c);
            }
            
            vertexOffset = vertices.length / 3;
            
            // === Â∫ïÈÉ®„ÅÆÁ∏ÅÔºàÂ§ñÂÅ¥Â∫ïÈù¢„Å®ÂÜÖÂÅ¥Â∫ïÈù¢„ÇíÊé•Á∂ö„ÄÅÈñãÂè£ÈÉ®Ôºâ===
            // ÂâçÁ∏ÅÔºàÂ∫ïÔºâ
            for (let ix = 0; ix <= segments; ix++) {
                const xOuter = -outerW + (2 * outerW * ix / segments);
                const xInner = -innerW + (2 * innerW * ix / segments);
                vertices.push(xOuter, 0, outerD);
                vertices.push(xInner, 0, innerD);
            }
            
            for (let ix = 0; ix < segments; ix++) {
                const a = vertexOffset + ix * 2;
                const b = a + 2;
                const c = a + 1;
                const d = a + 3;
                // ‰∏ãÂêë„ÅçÔºàÂÜÖÂêë„ÅçÔºâÊ≥ïÁ∑ö
                indices.push(a, c, b);
                indices.push(b, c, d);
            }
            
            vertexOffset = vertices.length / 3;
            
            // ÂæåÁ∏ÅÔºàÂ∫ïÔºâ
            for (let ix = 0; ix <= segments; ix++) {
                const xOuter = outerW - (2 * outerW * ix / segments);
                const xInner = innerW - (2 * innerW * ix / segments);
                vertices.push(xOuter, 0, -outerD);
                vertices.push(xInner, 0, -innerD);
            }
            
            for (let ix = 0; ix < segments; ix++) {
                const a = vertexOffset + ix * 2;
                const b = a + 2;
                const c = a + 1;
                const d = a + 3;
                indices.push(a, c, b);
                indices.push(b, c, d);
            }
            
            vertexOffset = vertices.length / 3;
            
            // Â∑¶Á∏ÅÔºàÂ∫ïÔºâ
            for (let iz = 0; iz <= segments; iz++) {
                const zOuter = outerD - (2 * outerD * iz / segments);
                const zInner = innerD - (2 * innerD * iz / segments);
                vertices.push(-outerW, 0, zOuter);
                vertices.push(-innerW, 0, zInner);
            }
            
            for (let iz = 0; iz < segments; iz++) {
                const a = vertexOffset + iz * 2;
                const b = a + 2;
                const c = a + 1;
                const d = a + 3;
                indices.push(a, c, b);
                indices.push(b, c, d);
            }
            
            vertexOffset = vertices.length / 3;
            
            // Âè≥Á∏ÅÔºàÂ∫ïÔºâ
            for (let iz = 0; iz <= segments; iz++) {
                const zOuter = -outerD + (2 * outerD * iz / segments);
                const zInner = -innerD + (2 * innerD * iz / segments);
                vertices.push(outerW, 0, zOuter);
                vertices.push(innerW, 0, zInner);
            }
            
            for (let iz = 0; iz < segments; iz++) {
                const a = vertexOffset + iz * 2;
                const b = a + 2;
                const c = a + 1;
                const d = a + 3;
                indices.push(a, c, b);
                indices.push(b, c, d);
            }
            
            // BufferGeometry„Çí‰ΩúÊàê
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            
            // È†ÇÁÇπ„Çí„Éû„Éº„Ç∏„Åó„Å¶ÈáçË§á„ÇíÈô§Âéª
            const mergedGeo = BufferGeometryUtils.mergeVertices(geometry, 0.0001);
            mergedGeo.computeVertexNormals();
            
            console.log("createWatertightBody: Generated watertight shell geometry");
            
            return mergedGeo;
        }
        
        function csgUnion(geometries) {
            const valid = geometries.filter(g => g !== null && g !== undefined);
            if (valid.length === 0) return null;
            if (valid.length === 1) {
                let geo = valid[0].clone();
                if (geo.index) geo = geo.toNonIndexed();
                geo = BufferGeometryUtils.mergeVertices(geo, 0.001);
                geo.computeVertexNormals();
                return geo;
            }
            
            try {
                let resultBrush = new Brush(valid[0]);
                resultBrush.updateMatrixWorld();
                
                for (let i = 1; i < valid.length; i++) {
                    const brush = new Brush(valid[i]);
                    brush.updateMatrixWorld();
                    const result = csgEvaluator.evaluate(resultBrush, brush, ADDITION);
                    resultBrush = result;
                }
                
                let finalGeo = resultBrush.geometry;
                finalGeo = BufferGeometryUtils.mergeVertices(finalGeo, 0.001);
                finalGeo.computeVertexNormals();
                return finalGeo;
            } catch (e) {
                console.warn("CSG Union failed, falling back to safeMerge:", e);
                return safeMerge(geometries);
            }
        }
        
        function applySquircle(x, z, w, d, r) { 
            if (r <= 0.01) return {x, z}; 
            
            const halfW = w / 2;
            const halfD = d / 2;
            const innerW = halfW - r; 
            const innerD = halfD - r; 
            const absX = Math.abs(x); 
            const absZ = Math.abs(z);
            
            if (absX > innerW && absZ > innerD) { 
                const dx = absX - innerW; 
                const dz = absZ - innerD; 
                const dist = Math.sqrt(dx*dx + dz*dz); 
                if (dist > 0) { 
                    const clampedDist = Math.min(dist, r);
                    const newX = innerW + (dx / dist) * clampedDist; 
                    const newZ = innerD + (dz / dist) * clampedDist; 
                    return { x: Math.sign(x) * newX, z: Math.sign(z) * newZ }; 
                } 
            }
            else if (absX > innerW) {
                const edgeDist = absZ / innerD;
                if (edgeDist > 0.9) {
                    const blend = (edgeDist - 0.9) / 0.1;
                    const maxX = halfW - (1 - Math.sqrt(1 - blend*blend)) * r * 0.1;
                    if (absX > maxX) {
                        return { x: Math.sign(x) * maxX, z };
                    }
                }
            }
            else if (absZ > innerD) {
                const edgeDist = absX / innerW;
                if (edgeDist > 0.9) {
                    const blend = (edgeDist - 0.9) / 0.1;
                    const maxZ = halfD - (1 - Math.sqrt(1 - blend*blend)) * r * 0.1;
                    if (absZ > maxZ) {
                        return { x, z: Math.sign(z) * maxZ };
                    }
                }
            }
            
            return {x, z}; 
        }
        
        function createKeyShape(p, isInner = false, wallThick = 0) {
            const shape = new THREE.Shape();
            const w = p.baseW, d = p.baseD, hw = w / 2, hd = d / 2;
            const offset = isInner ? wallThick : 0;
            
            switch(state.keyShapeType) {
                case 'circle':
                    const r = Math.min(hw, hd) - offset;
                    if(r > 0) shape.absarc(0, 0, r, 0, Math.PI * 2, false);
                    return shape;
                    
                case 'polygon':
                    const sides = state.polygonSides;
                    const pr = Math.min(hw, hd) - offset;
                    if(pr > 0) {
                        for(let i = 0; i < sides; i++) {
                            const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                            const px = Math.cos(angle) * pr;
                            const py = Math.sin(angle) * pr;
                            if(i === 0) shape.moveTo(px, py);
                            else shape.lineTo(px, py);
                        }
                        shape.closePath();
                    }
                    return shape;
                    
                case 'star':
                    const points = state.starPoints;
                    const outer = Math.min(hw, hd) - offset;
                    const inner = outer * state.starInner;
                    if(outer > 0) {
                        for(let i = 0; i < points * 2; i++) {
                            const angle = (i / (points * 2)) * Math.PI * 2 - Math.PI / 2;
                            const rad = i % 2 === 0 ? outer : inner;
                            const sx = Math.cos(angle) * rad;
                            const sy = Math.sin(angle) * rad;
                            if(i === 0) shape.moveTo(sx, sy);
                            else shape.lineTo(sx, sy);
                        }
                        shape.closePath();
                    }
                    return shape;
                    
                case 'iso-enter':
                    const unit = parseFloat(state.unitSize) || 19.05;
                    const isoFullW = (unit * state.isoTopWidth) - 0.5;
                    const isoNarrowW = (unit * state.isoBottomWidth) - 0.5;
                    const isoTotalH = (unit * state.isoHeight) - 0.5;
                    
                    const ihw = isoFullW / 2;
                    const ihh = isoTotalH / 2;
                    
                    const cornerY = ihh - (unit - 0.5);
                    const cornerX = ihw - isoNarrowW;

                    if (!isInner) {
                        shape.moveTo(-ihw, ihh);
                        shape.lineTo(-ihw, cornerY);
                        shape.lineTo(cornerX, cornerY);
                        shape.lineTo(cornerX, -ihh);
                        shape.lineTo(ihw, -ihh);
                        shape.lineTo(ihw, ihh);
                        shape.closePath();
                    } else {
                        const t = wallThick;
                        
                        const inLeft = -ihw + t;
                        const inRight = ihw - t;
                        const inTop = ihh - t;
                        const inBottom = -ihh + t;
                        
                        const inCornerX = cornerX + t;
                        const inCornerY = cornerY + t;

                        shape.moveTo(inLeft, inTop);
                        shape.lineTo(inRight, inTop);
                        shape.lineTo(inRight, inBottom);
                        shape.lineTo(inCornerX, inBottom);
                        shape.lineTo(inCornerX, inCornerY);
                        shape.lineTo(inLeft, inCornerY);
                        shape.closePath();
                    }
                    return shape;
                    
                case 'rounded':
                    const hwi = hw - offset;
                    const hdi = hd - offset;
                    const rad = Math.min(state.roundCorner, Math.min(hwi, hdi) * 0.5);
                    if(hwi > 0 && hdi > 0) {
                        if(rad > 0.1) {
                            shape.moveTo(-hwi + rad, -hdi);
                            shape.lineTo(hwi - rad, -hdi);
                            shape.quadraticCurveTo(hwi, -hdi, hwi, -hdi + rad);
                            shape.lineTo(hwi, hdi - rad);
                            shape.quadraticCurveTo(hwi, hdi, hwi - rad, hdi);
                            shape.lineTo(-hwi + rad, hdi);
                            shape.quadraticCurveTo(-hwi, hdi, -hwi, hdi - rad);
                            shape.lineTo(-hwi, -hdi + rad);
                            shape.quadraticCurveTo(-hwi, -hdi, -hwi + rad, -hdi);
                        } else {
                            shape.moveTo(-hwi, -hdi);
                            shape.lineTo(hwi, -hdi);
                            shape.lineTo(hwi, hdi);
                            shape.lineTo(-hwi, hdi);
                            shape.closePath();
                        }
                    }
                    return shape;
                    
                default:
                    const hwj = hw - offset;
                    const hdj = hd - offset;
                    if(hwj > 0 && hdj > 0) {
                        shape.moveTo(-hwj, -hdj);
                        shape.lineTo(hwj, -hdj);
                        shape.lineTo(hwj, hdj);
                        shape.lineTo(-hwj, hdj);
                        shape.closePath();
                    }
                    return shape;
            }
        }

        function createBodyParts(p, useCSG = false) {
            const thick = state.wallThickness; 
            const segXZ = 32;  
            const segY = 32;   
            
            const isNonRectangular = state.keyShapeType === 'circle' || 
                                     state.keyShapeType === 'polygon' || 
                                     state.keyShapeType === 'star' ||
                                     state.keyShapeType === 'iso-enter' ||
                                     (state.keyShapeType === 'rounded' && state.roundCorner > 0.1);
            
            if(isNonRectangular) {
                const outerShape = createKeyShape(p, false, 0);
                const innerShape = createKeyShape(p, true, thick);
                
                let solidGeo = new THREE.ExtrudeGeometry(outerShape, {
                    depth: p.h,
                    bevelEnabled: false,
                    curveSegments: 48
                });
                solidGeo.rotateX(-Math.PI / 2);
                
                let holeGeo = new THREE.ExtrudeGeometry(innerShape, {
                    depth: p.h - thick + 0.1,
                    bevelEnabled: false,
                    curveSegments: 48
                });
                holeGeo.rotateX(-Math.PI / 2);
                holeGeo.translate(0, -0.05, 0);
                
                let resultGeo;
                try {
                    const solidBrush = new Brush(solidGeo);
                    solidBrush.updateMatrixWorld();
                    const holeBrush = new Brush(holeGeo);
                    holeBrush.updateMatrixWorld();
                    const result = csgEvaluator.evaluate(solidBrush, holeBrush, SUBTRACTION);
                    resultGeo = result.geometry;
                    resultGeo = BufferGeometryUtils.mergeVertices(resultGeo, 0.001);
                } catch(e) {
                    console.warn("CSG failed, using merge method:", e);
                    outerShape.holes.push(innerShape);
                    const wallH = p.h - thick;
                    let wallGeo = new THREE.ExtrudeGeometry(outerShape, {
                        depth: wallH,
                        bevelEnabled: false,
                        curveSegments: 48
                    });
                    wallGeo.rotateX(-Math.PI / 2);
                    
                    const capShape = createKeyShape(p, false, 0);
                    let topGeo = new THREE.ExtrudeGeometry(capShape, {
                        depth: thick,
                        bevelEnabled: false,
                        curveSegments: 48
                    });
                    topGeo.rotateX(-Math.PI / 2);
                    topGeo.translate(0, wallH, 0);
                    
                    resultGeo = safeMerge([wallGeo, topGeo]);
                }
                
                if(resultGeo && !useCSG) {
                    deformMesh(resultGeo, p);
                }
                return resultGeo;
            }
            
            // Èï∑ÊñπÂΩ¢ÔºöÂæìÊù•„ÅÆBoxGeometryÊñπÂºè
            const topBox = new THREE.BoxGeometry(p.baseW, thick, p.baseD, segXZ, 2, segXZ); 
            topBox.translate(0, p.h - thick/2, 0);
            
            const wH = p.h - thick;
            
            const front = new THREE.BoxGeometry(p.baseW, wH, thick, segXZ, segY, 2); 
            front.translate(0, wH/2, p.baseD/2 - thick/2);
            
            const back = new THREE.BoxGeometry(p.baseW, wH, thick, segXZ, segY, 2); 
            back.translate(0, wH/2, -(p.baseD/2 - thick/2));
            
            const sideDepth = p.baseD - thick * 2;
            const left = new THREE.BoxGeometry(thick, wH, sideDepth, 2, segY, segXZ); 
            left.translate(-(p.baseW/2 - thick/2), wH/2, 0);
            
            const right = new THREE.BoxGeometry(thick, wH, sideDepth, 2, segY, segXZ); 
            right.translate((p.baseW/2 - thick/2), wH/2, 0);
            
            let resultGeo = safeMerge([topBox, front, back, left, right]);
            
            if(resultGeo && !useCSG) deformMesh(resultGeo, p); 
            return resultGeo;
        }

        function deformMesh(geo, p) {
            const pos = geo.attributes.position; const v = new THREE.Vector3(); const thick = state.wallThickness; geo.computeBoundingBox(); const uvs = geo.attributes.uv;
            const useImageTexture = state.imgContent && state.imgTextureVisible; const useProcedural = state.textureType !== 'none';
            const texScale = state.textureScale * 0.1; const texStr = state.textureStrength; const twistRad = THREE.MathUtils.degToRad(state.twist); const twistPerUnit = twistRad / p.h; const filletR = state.roundCorner; const hasFillet = filletR > 0.05;
            
            const wallTopY = p.h - thick;
            
            for(let i=0; i<pos.count; i++){
                v.fromBufferAttribute(pos, i);
                
                if (Math.abs(state.twist) > 0.1 && state.keyShapeType !== 'iso-enter') { 
                    const angle = twistPerUnit * v.y; 
                    const sinA = Math.sin(angle); const cosA = Math.cos(angle); 
                    const tx = v.x * cosA - v.z * sinA; 
                    const tz = v.x * sinA + v.z * cosA; 
                    v.x = tx; v.z = tz; 
                }
                
                const ratioY = Math.max(0, Math.min(1, v.y / p.h));
                
                const currentScale = THREE.MathUtils.lerp(1.0, state.topScale, ratioY);
                
                if (Math.abs(currentScale - 1.0) > 0.0001) { 
                    v.x *= currentScale; 
                    v.z *= currentScale; 
                }
                
                if (hasFillet && state.keyShapeType === 'rectangle') { 
                    const currentW = p.baseW * currentScale; 
                    const currentD = p.baseD * currentScale; 
                    const scaledR = filletR * currentScale; 
                    const deformed = applySquircle(v.x, v.z, currentW, currentD, scaledR); 
                    v.x = deformed.x; 
                    v.z = deformed.z; 
                }
                
                if (v.y > 0.01 && state.keyShapeType !== 'iso-enter') {
                    const surfY = getSurfaceHeight(v.x, v.z, p);
                    const origY = v.y;
                    
                    if (origY >= wallTopY) {
                        const topRatio = (origY - wallTopY) / thick;
                        v.y = THREE.MathUtils.lerp(surfY - thick, surfY, Math.min(1, topRatio));
                    } else {
                        const wallRatio = origY / wallTopY;
                        const targetTopY = surfY - thick;
                        v.y = wallRatio * targetTopY;
                    }
                }
                
                if (useProcedural && ratioY > 0.01) {
                    const isTop = ratioY > 0.95 && v.y > wallTopY;
                    if (state.textureGlobal || isTop) {
                        let noiseVal = 0; const type = state.textureType;
                        let mapX = v.x * texScale; let mapZ = v.z * texScale; let mapY = v.y * texScale;
                        if (!isTop && !state.textureGlobal) mapY = Math.atan2(v.z, v.x) * 10; 
                        if (type === 'noise') noiseVal = SimpleNoise.noise(mapX, isTop?mapZ:mapY);
                        else if (type === 'grid') noiseVal = Math.sin(mapX) * Math.sin(isTop?mapZ:mapY);
                        else if (type === 'knurling') noiseVal = Math.sin((mapX + (isTop?mapZ:mapY))) * Math.sin((mapX - (isTop?mapZ:mapY)));
                        else if (type === 'stripes') noiseVal = Math.sin(mapX);
                        else if (type === 'ripple') { const dist = Math.sqrt(mapX*mapX + (isTop?mapZ:mapY)*(isTop?mapZ:mapY)); noiseVal = Math.sin(dist); }
                        else if (type === 'wood') { noiseVal = Math.sin(mapX * 2 + SimpleNoise.noise(mapX, isTop?mapZ:mapY) * 3); }
                        else if (type === 'hammered') { noiseVal = 1.0 - Math.abs(SimpleNoise.noise(mapX*0.5, isTop?mapZ*0.5:mapY*0.5)); }
                        else if (type === 'hexagon') { const u = mapX * 1.5; const vC = (isTop?mapZ:mapY) * 1.5; noiseVal = Math.max(Math.abs(Math.sin(u)*Math.cos(vC)), Math.abs(Math.cos(u)*Math.sin(vC))); }
                        else if (type === 'bricks') { const bx = Math.floor(mapX); const by = Math.floor(isTop?mapZ:mapY); const off = (by % 2) * 0.5; noiseVal = (mapX + off) - Math.floor(mapX + off) > 0.1 && (isTop?mapZ:mapY) - by > 0.1 ? 1 : 0; }
                        if (isTop) v.y += noiseVal * texStr;
                        else if (ratioY > 0.1 && state.textureGlobal) { const norm = new THREE.Vector3(v.x, 0, v.z).normalize(); v.x += norm.x * noiseVal * texStr; v.z += norm.z * noiseVal * texStr; }
                    }
                }
                
                pos.setXYZ(i, v.x, v.y, v.z);
                if (useImageTexture && uvs) { const cosR = Math.cos(THREE.MathUtils.degToRad(-state.imgRot)); const sinR = Math.sin(THREE.MathUtils.degToRad(-state.imgRot)); let ux = v.x; let uz = v.z; const rx = ux * cosR - uz * sinR; const rz = ux * sinR + uz * cosR; const mapSize = 19.05 * state.uSize; let u = (rx / mapSize) + 0.5; let v_uv = (rz / mapSize) + 0.5; u = (u - 0.5) / state.imgScale + 0.5 - state.imgPosX; v_uv = (v_uv - 0.5) / state.imgScale + 0.5 - state.imgPosY; uvs.setXY(i, u, v_uv); }
            }
            geo.computeVertexNormals();
        }

        function createStemUnit(height, rOuter, clear) { const shape = new THREE.Shape(); shape.absarc(0,0, rOuter, 0, Math.PI*2); const w = (1.15 + clear)/2; const l = (4.1 + clear)/2; const hole = new THREE.Path(); hole.moveTo(-w,-l); hole.lineTo(w,-l); hole.lineTo(w,-w); hole.lineTo(l,-w); hole.lineTo(l,w); hole.lineTo(w,w); hole.lineTo(w,l); hole.lineTo(-w,l); hole.lineTo(-w,w); hole.lineTo(-l,w); hole.lineTo(-l,-w); hole.lineTo(-w,-w); hole.lineTo(-w,-l); shape.holes.push(hole); const geo = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled:false, curveSegments:24 }); geo.rotateX(Math.PI/2); geo.translate(0, height, 0); return geo; }

        // ==========================================
        // V67: Extended Stem Types (Êã°Âºµ„Çπ„ÉÜ„É†)
        // ==========================================
        function createExtendedStem(height, rOuter, clear, p = null) {
            const type = state.stemType || 'mx';
            
            // Artisan: „Çπ„ÉÜ„É†„Å™„Åó
            if (type === 'artisan') return null;

            // Cherry MX / Choc V2 (Ê®ôÊ∫ñ„ÇØ„É≠„Çπ)
            if (type === 'mx' || type === 'choc_v2') {
                return createStemUnit(height, rOuter, clear);
            }

            // Kailh Choc V1 (2Êú¨„ÅÆÈï∑ÊñπÂΩ¢„ÅÆËÑö)
            if (type === 'choc') {
                // Ê®ôÊ∫ñÁöÑ„Å™Choc V1„ÅÆÂØ∏Ê≥ï
                // „Éî„ÉÉ„ÉÅ: 5.7mm (center to center)
                // ËÑö„Çµ„Ç§„Ç∫: Á¥Ñ1.2mm x 3.0mm
                const pitch = 5.7;
                const legW = 1.25 - clear * 0.5;
                const legD = 3.0 - clear * 0.5;
                const legH = height;
                
                // Â∑¶„ÅÆËÑö
                const lLeg = new THREE.BoxGeometry(legW, legH, legD);
                lLeg.translate(-pitch/2, legH/2, 0);
                
                // Âè≥„ÅÆËÑö
                const rLeg = new THREE.BoxGeometry(legW, legH, legD);
                rLeg.translate(pitch/2, legH/2, 0);
                
                return safeMerge([lLeg, rLeg]);
            }

            // Topre (ÂÜÜÁ≠íÂΩ¢ + „Çπ„É™„ÉÉ„Éà)
            if (type === 'topre') {
                const outerR = 4.0;
                const innerR = 3.2 - clear;
                const shape = new THREE.Shape();
                shape.absarc(0, 0, outerR, 0, Math.PI * 2);
                const hole = new THREE.Path();
                hole.absarc(0, 0, innerR, 0, Math.PI * 2);
                shape.holes.push(hole);
                const cylinderGeo = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled: false, curveSegments: 24 });
                cylinderGeo.rotateX(Math.PI / 2);
                cylinderGeo.translate(0, height, 0);
                
                // „Çπ„É™„ÉÉ„ÉàÔºàÂàá„ÇåËæº„ÅøÔºâ„Çí‰ΩúÊàê„Åó„Å¶CSG„ÅßÂºï„Åè
                const slitWidth = 1.5 + clear;
                const slitBox = new THREE.BoxGeometry(outerR * 2.2, height, slitWidth);
                slitBox.translate(0, height/2, 0);
                
                try {
                    const brush1 = new Brush(cylinderGeo);
                    brush1.updateMatrixWorld();
                    const brush2 = new Brush(slitBox);
                    brush2.updateMatrixWorld();
                    const res = csgEvaluator.evaluate(brush1, brush2, SUBTRACTION);
                    return res.geometry;
                } catch(e) {
                    console.warn("Topre CSG failed", e);
                    return cylinderGeo;
                }
            }

            // Alps (Èï∑ÊñπÂΩ¢)
            if (type === 'alps') {
                const w = 4.45 - clear;
                const d = 2.25 - clear;
                const outerW = w + 2;
                const outerD = d + 2;
                
                const shape = new THREE.Shape();
                shape.moveTo(-outerW/2, -outerD/2);
                shape.lineTo(outerW/2, -outerD/2);
                shape.lineTo(outerW/2, outerD/2);
                shape.lineTo(-outerW/2, outerD/2);
                shape.closePath();
                
                const hole = new THREE.Path();
                hole.moveTo(-w/2, -d/2);
                hole.lineTo(w/2, -d/2);
                hole.lineTo(w/2, d/2);
                hole.lineTo(-w/2, d/2);
                hole.closePath();
                shape.holes.push(hole);
                
                const geo = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled: false });
                geo.rotateX(Math.PI / 2);
                geo.translate(0, height, 0);
                return geo;
            }

            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
            return createStemUnit(height, rOuter, clear);
        }

        // ==========================================
        // V67: Click-to-Place („ÇØ„É™„ÉÉ„ÇØÈÖçÁΩÆ)
        // ==========================================
        function onCanvasPointerDown(event) {
            if (event.button === 2) return;
            
            const ctxMenu = document.getElementById('context-menu');
            if (ctxMenu) ctxMenu.style.display = 'none';

            if (!isPlaceMode) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(mainGroup.children, true);
            const bodyHit = intersects.find(hit => hit.object.name === 'KeycapBody');

            if (bodyHit) {
                const p = bodyHit.point;
                showClickEffect(event.clientX, event.clientY);
                
                // „Ç¨„É†„Éú„Éº„É´„ÅÆ„Çø„Éº„Ç≤„ÉÉ„Éà„Å´Âøú„Åò„Å¶‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞
                let targetLabel = '';
                if (gumballTarget === 'text' && state.enableText) {
                    state.posX = parseFloat(p.x.toFixed(2));
                    state.posZ = parseFloat(p.z.toFixed(2));
                    targetLabel = '„É°„Ç§„É≥ÊñáÂ≠ó';
                } else if (gumballTarget === 'text2' && state.enableText2) {
                    state.text2X = parseFloat(p.x.toFixed(2));
                    state.text2Z = parseFloat(p.z.toFixed(2));
                    targetLabel = '„Çµ„ÉñÊñáÂ≠ó';
                } else if (gumballTarget === 'side' && state.enableSide) {
                    // „Çµ„Ç§„ÉâÂç∞Â≠ó: „ÇØ„É™„ÉÉ„ÇØ‰ΩçÁΩÆ„ÅÆYÂ∫ßÊ®ô„ÇíÂü∫Ê∫ñ‰ΩçÁΩÆ(4.5)„Åã„Çâ„ÅÆ„Ç™„Éï„Çª„ÉÉ„Éà„Å´Â§âÊèõ
                    state.sideY = parseFloat((p.y - 4.5).toFixed(2));
                    targetLabel = '„Çµ„Ç§„ÉâÂç∞Â≠ó';
                } else if (gumballTarget === 'svg' && state.svgVisible && state.svgContent) {
                    state.svgPosX = parseFloat(p.x.toFixed(2));
                    state.svgPosZ = parseFloat(p.z.toFixed(2));
                    targetLabel = 'SVG';
                } else if (gumballTarget === 'model' && state.modelVisible) {
                    state.modelX = parseFloat(p.x.toFixed(2));
                    state.modelZ = parseFloat(p.z.toFixed(2));
                    targetLabel = '„É¢„Éá„É´';
                } else {
                    // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „É°„Ç§„É≥„ÉÜ„Ç≠„Çπ„Éà„Åæ„Åü„ÅØSVG
                    if (state.enableText) {
                        state.posX = parseFloat(p.x.toFixed(2));
                        state.posZ = parseFloat(p.z.toFixed(2));
                        targetLabel = '„É°„Ç§„É≥ÊñáÂ≠ó';
                    } else if (state.svgVisible && state.svgContent) {
                        state.svgPosX = parseFloat(p.x.toFixed(2));
                        state.svgPosZ = parseFloat(p.z.toFixed(2));
                        targetLabel = 'SVG';
                    }
                }
                
                syncUI();
                requestUpdate();
                commitHistory();
                if (targetLabel) {
                    showToast(`${targetLabel}„ÅÆ‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞: X=${p.x.toFixed(1)}, Z=${p.z.toFixed(1)}`);
                }
            }
        }

        function showClickEffect(x, y) {
            const effect = document.createElement('div');
            effect.className = 'click-effect';
            effect.style.left = x + 'px';
            effect.style.top = y + 'px';
            document.body.appendChild(effect);
            setTimeout(() => effect.remove(), 500);
        }

        // ==========================================
        // V67: Context Menu (Âè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº)
        // ==========================================
        let contextMenuMouseDownPos = null;
        
        function onCanvasMouseDown(event) {
            if (event.button === 2) { // Âè≥„ÇØ„É™„ÉÉ„ÇØ
                contextMenuMouseDownPos = { x: event.clientX, y: event.clientY };
            }
        }
        
        function onCanvasContextMenu(event) {
            event.preventDefault();
            
            // „Éë„É≥Êìç‰Ωú‰∏≠Ôºà„Éû„Ç¶„Çπ„ÅåÁßªÂãï„Åó„ÅüÂ†¥ÂêàÔºâ„ÅØ„É°„Éã„É•„Éº„ÇíË°®Á§∫„Åó„Å™„ÅÑ
            if (contextMenuMouseDownPos) {
                const dx = Math.abs(event.clientX - contextMenuMouseDownPos.x);
                const dy = Math.abs(event.clientY - contextMenuMouseDownPos.y);
                if (dx > 5 || dy > 5) {
                    contextMenuMouseDownPos = null;
                    return; // „Éë„É≥Êìç‰Ωú„Å†„Å£„Åü„ÅÆ„Åß„É°„Éã„É•„ÉºË°®Á§∫„Çí„Çπ„Ç≠„ÉÉ„Éó
                }
            }
            contextMenuMouseDownPos = null;
            
            const menu = document.getElementById('context-menu');
            if (!menu) return;
            
            menu.style.display = 'block';
            menu.style.left = event.clientX + 'px';
            menu.style.top = event.clientY + 'px';
        }

        function initContextMenu() {
            window.addEventListener('click', (e) => {
                const menu = document.getElementById('context-menu');
                if (menu && !e.target.closest('#context-menu')) {
                    menu.style.display = 'none';
                }
            });

            document.getElementById('ctx-focus-center')?.addEventListener('click', () => {
                controls.reset();
                document.getElementById('context-menu').style.display = 'none';
            });
            
            document.getElementById('ctx-reset-rotation')?.addEventListener('click', () => {
                mainGroup.rotation.set(0, 0, 0);
                state.globalRotX = 0;
                state.globalRotY = 0;
                syncUI();
                document.getElementById('context-menu').style.display = 'none';
            });
            
            document.getElementById('ctx-rand-color')?.addEventListener('click', () => {
                const randomHex = () => '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
                state.colBody = randomHex();
                state.colText = randomHex();
                const colB = document.getElementById('col-body');
                const colT = document.getElementById('col-text');
                if (colB) colB.value = state.colBody;
                if (colT) colT.value = state.colText;
                const simpleColB = document.getElementById('simple-col-body');
                const simpleColT = document.getElementById('simple-col-text');
                if (simpleColB) simpleColB.value = state.colBody;
                if (simpleColT) simpleColT.value = state.colText;
                // „Éï„Ç£„É©„É°„É≥„Éà„Éë„É¨„ÉÉ„Éà„ÇíÊõ¥Êñ∞
                if (window.refreshFilamentPalette) window.refreshFilamentPalette();
                updateModel();
                document.getElementById('context-menu').style.display = 'none';
            });
            
            document.getElementById('ctx-toggle-wireframe')?.addEventListener('click', () => {
                state.renderMode = (state.renderMode === 'wireframe') ? 'standard' : 'wireframe';
                document.getElementById('render-mode').value = state.renderMode;
                requestUpdate();
                document.getElementById('context-menu').style.display = 'none';
            });
            
            document.getElementById('ctx-save-gallery')?.addEventListener('click', () => {
                saveToGallery();
                document.getElementById('context-menu').style.display = 'none';
            });
        }

        // ==========================================
        // V67: Gumball („Ç¨„É†„Éú„Éº„É´)
        // ==========================================
        function initGumball() {
            gumballControl = new TransformControls(camera, renderer.domElement);
            
            // „ÉÄ„Éü„Éº„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà‰ΩúÊàêÔºà„Ç¨„É†„Éú„Éº„É´„ÅÆ„Ç¢„Çø„ÉÉ„ÉÅÂÖàÔºâ
            gumballDummy = new THREE.Object3D();
            gumballDummy.name = 'GumballDummy';
            scene.add(gumballDummy);
            
            gumballControl.addEventListener('dragging-changed', function (event) {
                controls.enabled = !event.value;
                gumballDragging = event.value;
            });
            
            gumballControl.addEventListener('objectChange', function () {
                if (!gumballControl.object || !gumballDragging) return;
                const pos = gumballControl.object.position;
                
                if (gumballTarget === 'text') {
                    state.posX = parseFloat(pos.x.toFixed(2));
                    state.posZ = parseFloat(pos.z.toFixed(2));
                } else if (gumballTarget === 'text2') {
                    state.text2X = parseFloat(pos.x.toFixed(2));
                    state.text2Z = parseFloat(pos.z.toFixed(2));
                } else if (gumballTarget === 'side') {
                    // „Çµ„Ç§„ÉâÂç∞Â≠ó: YËª∏ÔºàÁ∑ëÁü¢Âç∞Ôºâ„ÅßÈ´ò„Åï„ÇíÂà∂Âæ°
                    state.sideY = parseFloat((pos.y - 4.5).toFixed(2));
                } else if (gumballTarget === 'svg') {
                    state.svgPosX = parseFloat(pos.x.toFixed(2));
                    state.svgPosZ = parseFloat(pos.z.toFixed(2));
                } else if (gumballTarget === 'model') {
                    state.modelX = parseFloat(pos.x.toFixed(2));
                    state.modelY = parseFloat(pos.y.toFixed(2));
                    state.modelZ = parseFloat(pos.z.toFixed(2));
                }
                
                // „Éâ„É©„ÉÉ„Ç∞‰∏≠„ÅØUI„ÅÆ„ÅøÊõ¥Êñ∞Ôºà„É¢„Éá„É´„ÅØÊõ¥Êñ∞„Åó„Å™„ÅÑÔºâ
                syncUI();
            });
            
            gumballControl.addEventListener('mouseUp', function() {
                // „Éâ„É©„ÉÉ„Ç∞ÁµÇ‰∫ÜÊôÇ„Å´„É¢„Éá„É´„ÇíÊõ¥Êñ∞
                syncUI();
                requestUpdate();
                commitHistory();
            });
            
            scene.add(gumballControl);
            
            // „Çø„Éº„Ç≤„ÉÉ„ÉàÈÅ∏Êäû„Éâ„É≠„ÉÉ„Éó„ÉÄ„Ç¶„É≥„ÅÆ„Ç§„Éô„É≥„Éà
            const targetSelect = document.getElementById('hud-gumball-target');
            if (targetSelect) {
                targetSelect.addEventListener('change', (e) => {
                    gumballTarget = e.target.value;
                    updateGumballAttachment();
                    showToast(`Êìç‰ΩúÂØæË±°: ${getTargetLabel(gumballTarget)}`);
                });
            }
        }
        
        function getTargetLabel(target) {
            const labels = {
                'text': '„É°„Ç§„É≥ÊñáÂ≠ó',
                'text2': '„Çµ„ÉñÊñáÂ≠ó',
                'side': '„Çµ„Ç§„ÉâÂç∞Â≠ó',
                'svg': 'SVG',
                'model': '„É¢„Éá„É´'
            };
            return labels[target] || target;
        }
        
        function getAvailableTargets() {
            const targets = [];
            if (state.enableText && state.text) targets.push('text');
            if (state.enableText2 && state.text2) targets.push('text2');
            if (state.enableSide && state.sideText) targets.push('side');
            if (state.svgContent && state.svgVisible) targets.push('svg');
            if (importedModelBuffer && state.modelVisible) targets.push('model');
            return targets;
        }
        
        function updateGumballTargetDropdown() {
            const targetSelect = document.getElementById('hud-gumball-target');
            if (!targetSelect) return;
            
            const available = getAvailableTargets();
            
            // ÂêÑ„Ç™„Éó„Ç∑„Éß„É≥„ÅÆÊúâÂäπ/ÁÑ°Âäπ„ÇíÊõ¥Êñ∞
            Array.from(targetSelect.options).forEach(opt => {
                opt.disabled = !available.includes(opt.value);
                opt.style.color = available.includes(opt.value) ? '#fff' : '#666';
            });
            
            // ÁèæÂú®„ÅÆ„Çø„Éº„Ç≤„ÉÉ„Éà„ÅåÁÑ°Âäπ„Å™„Çâ„ÄÅÊúâÂäπ„Å™„ÇÇ„ÅÆ„Å´Âàá„ÇäÊõø„Åà
            if (!available.includes(gumballTarget) && available.length > 0) {
                gumballTarget = available[0];
                targetSelect.value = gumballTarget;
            }
        }

        function updateGumballAttachment() {
            if (!gumballControl || !gumballDummy) return;
            gumballControl.detach();
            
            const btn = document.getElementById('hud-gumball-toggle');
            const targetSelect = document.getElementById('hud-gumball-target');
            
            if (!btn || !btn.classList.contains('active')) {
                return;
            }
            
            // ÊúâÂäπ„Å™„Çø„Éº„Ç≤„ÉÉ„Éà„ÇíÊõ¥Êñ∞
            updateGumballTargetDropdown();
            
            const available = getAvailableTargets();
            if (available.length === 0) {
                showToast('Êìç‰ΩúÂØæË±°„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                return;
            }
            
            // „Çø„Éº„Ç≤„ÉÉ„Éà„Å´Âøú„Åò„Å¶„ÉÄ„Éü„Éº„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ‰ΩçÁΩÆ„ÇíË®≠ÂÆö
            let posX = 0, posY = 5, posZ = 0;
            
            if (gumballTarget === 'text') {
                posX = state.posX;
                posZ = state.posZ;
            } else if (gumballTarget === 'text2') {
                posX = state.text2X;
                posZ = state.text2Z;
            } else if (gumballTarget === 'side') {
                // „Çµ„Ç§„ÉâÂç∞Â≠ó: „Ç≠„É£„ÉÉ„ÉóÂâçÈù¢„ÄÅÈ´ò„Åï = Âü∫Ê∫ñ(4.5) + sideY„Ç™„Éï„Çª„ÉÉ„Éà
                posX = 0;
                posY = 4.5 + state.sideY; // ÂÆüÈöõ„ÅÆÊèèÁîª‰ΩçÁΩÆ
                posZ = 9; // „Ç≠„É£„ÉÉ„ÉóÂâçÈù¢‰ªòËøë
            } else if (gumballTarget === 'svg') {
                posX = state.svgPosX;
                posZ = state.svgPosZ;
            } else if (gumballTarget === 'model') {
                posX = state.modelX;
                posY = state.modelY;
                posZ = state.modelZ;
            }
            
            gumballDummy.position.set(posX, posY, posZ);
            gumballControl.attach(gumballDummy);
            
            // „Éâ„É≠„ÉÉ„Éó„ÉÄ„Ç¶„É≥„ÅÆÂÄ§„ÇíÂêåÊúü
            if (targetSelect) targetSelect.value = gumballTarget;
        }

        // ==========================================
        // V67: Gallery („ÇÆ„É£„É©„É™„Éº)
        // ==========================================
        function initGalleryDB() {
            const request = indexedDB.open("KeycapGalleryDB_V67", 1);
            
            request.onupgradeneeded = function(event) {
                const db = event.target.result;
                if (!db.objectStoreNames.contains("presets")) {
                    db.createObjectStore("presets", { keyPath: "id", autoIncrement: true });
                }
            };
            
            request.onsuccess = function(event) {
                galleryDB = event.target.result;
                console.log("V67 Gallery DB initialized");
                loadGallery();
            };
            
            request.onerror = function(event) {
                console.warn("Gallery DB error:", event.target.error);
            };
        }

        function saveToGallery() {
            if (!galleryDB) {
                showToast("„ÇÆ„É£„É©„É™„ÉºDB„ÅåÂàùÊúüÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì", true);
                return;
            }
            
            renderer.render(scene, camera);
            const thumbnail = renderer.domElement.toDataURL("image/png", 0.4);
            
            const presetName = state.text || state.svgName || "Preset";
            
            const item = {
                timestamp: Date.now(),
                name: presetName,
                thumbnail: thumbnail,
                state: JSON.parse(JSON.stringify(state))
            };
            
            const tx = galleryDB.transaction(["presets"], "readwrite");
            const store = tx.objectStore("presets");
            store.add(item);
            
            tx.oncomplete = () => {
                showToast(`„Äå${presetName}„Äç„Çí„ÇÆ„É£„É©„É™„Éº„Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü`);
                loadGallery();
                // ‰øùÂ≠òÂæå„Å´„ÇÆ„É£„É©„É™„Éº„ÇíËá™ÂãïË°®Á§∫
                const strip = document.getElementById('gallery-strip');
                if (strip && !strip.classList.contains('show')) {
                    strip.style.display = 'block';
                    strip.classList.add('show');
                    // „ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞
                    if (typeof window.updateHintTooltipPosition === 'function') {
                        window.updateHintTooltipPosition();
                    }
                    // ViewHelper‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞
                    if (typeof window.updateViewHelperPosition === 'function') {
                        window.updateViewHelperPosition();
                    }
                }
            };
            
            tx.onerror = (e) => {
                showToast("‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü", true);
                console.error("Gallery save error:", e);
            };
        }

        function loadGallery() {
            if (!galleryDB) return;
            
            const container = document.getElementById('gallery-content');
            if (!container) return;
            container.innerHTML = '';
            
            const tx = galleryDB.transaction(["presets"], "readonly");
            const store = tx.objectStore("presets");
            const req = store.getAll();
            
            req.onsuccess = function() {
                const items = req.result;
                
                if (items.length === 0) {
                    const t = translations[currentLang] || translations.ja;
                    container.innerHTML = `<div style="color:#aaa; padding:20px; display:flex; align-items:center;">${t.preset_empty || '‰øùÂ≠ò„Åï„Çå„Åü„Éó„É™„Çª„ÉÉ„Éà„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÂè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº„Åæ„Åü„ÅØHUD„ÅÆüíæ„Éú„Çø„É≥„Åã„Çâ‰øùÂ≠ò„Åß„Åç„Åæ„Åô„ÄÇ'}</div>`;
                    return;
                }
                
                items.sort((a, b) => b.timestamp - a.timestamp);
                
                items.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'gallery-item';
                    div.title = `${item.name}\n${new Date(item.timestamp).toLocaleString()}`;
                    
                    const img = document.createElement('img');
                    img.src = item.thumbnail;
                    img.alt = item.name;
                    
                    const nameLabel = document.createElement('div');
                    nameLabel.className = 'gallery-name';
                    nameLabel.textContent = item.name;
                    
                    const delBtn = document.createElement('button');
                    delBtn.className = 'gallery-delete';
                    delBtn.textContent = '√ó';
                    delBtn.title = 'ÂâäÈô§';
                    delBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteFromGallery(item.id);
                    };
                    
                    div.onclick = (e) => {
                        e.stopPropagation();
                        loadFromGallery(item);
                    };
                    
                    // Âè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº
                    div.oncontextmenu = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        showGalleryContextMenu(e, item);
                    };
                    
                    div.appendChild(img);
                    div.appendChild(nameLabel);
                    div.appendChild(delBtn);
                    container.appendChild(div);
                });
            };
        }

        function loadFromGallery(item) {
            Object.assign(state, item.state);
            
            // „ÇÆ„É£„É©„É™„Éº„Å´„Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆö„Åå„ÅÇ„ÇãÂ†¥Âêà„ÄÅamsConfig„Å´„ÇÇÂèçÊò†
            if (state.bodyExtruder) {
                amsConfig.bodyExtruder = state.bodyExtruder;
                amsConfig.bodyExtruderSet = true;
            }
            if (state.textExtruder) {
                amsConfig.textExtruder = state.textExtruder;
                amsConfig.textExtruderSet = true;
            }
            
            syncUI();
            if (typeof updateSettingsTabPalette === 'function') updateSettingsTabPalette();
            requestUpdate();
            showToast(`„Äå${item.name}„Äç„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü`);
        }

        function deleteFromGallery(id) {
            if (!galleryDB) return;
            
            const tx = galleryDB.transaction(["presets"], "readwrite");
            tx.objectStore("presets").delete(id);
            
            tx.oncomplete = () => {
                showToast("„Éó„É™„Çª„ÉÉ„Éà„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü");
                loadGallery();
            };
        }

        // „ÇÆ„É£„É©„É™„Éº„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„ÉºÈñ¢ÈÄ£
        let currentGalleryItem = null;
        
        function showGalleryContextMenu(e, item) {
            currentGalleryItem = item;
            const menu = document.getElementById('gallery-context-menu');
            if (!menu) return;
            
            menu.style.display = 'block';
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';
            
            // ÁîªÈù¢Â§ñ„Å´„ÅØ„ÅøÂá∫„Åï„Å™„ÅÑ„Çà„ÅÜ„Å´Ë™øÊï¥
            const rect = menu.getBoundingClientRect();
            if (rect.right > window.innerWidth) {
                menu.style.left = (e.clientX - rect.width) + 'px';
            }
            if (rect.bottom > window.innerHeight) {
                menu.style.top = (e.clientY - rect.height) + 'px';
            }
        }
        
        function hideGalleryContextMenu() {
            const menu = document.getElementById('gallery-context-menu');
            if (menu) menu.style.display = 'none';
            currentGalleryItem = null;
        }
        
        async function exportGalleryItem(item, format) {
            // „Åæ„ÅöÁä∂ÊÖã„ÇíÈÅ©Áî®
            Object.assign(state, item.state);
            
            // „ÇÆ„É£„É©„É™„Éº„Å´„Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆö„Åå„ÅÇ„ÇãÂ†¥Âêà„ÄÅamsConfig„Å´„ÇÇÂèçÊò†
            if (state.bodyExtruder) {
                amsConfig.bodyExtruder = state.bodyExtruder;
                amsConfig.bodyExtruderSet = true;
            }
            if (state.textExtruder) {
                amsConfig.textExtruder = state.textExtruder;
                amsConfig.textExtruderSet = true;
            }
            
            syncUI();
            if (typeof updateSettingsTabPalette === 'function') updateSettingsTabPalette();
            requestUpdate();
            
            // „É¢„Éá„É´Êõ¥Êñ∞„ÇíÂæÖ„Å§
            await new Promise(resolve => setTimeout(resolve, 400));
            
            // ÈÄöÂ∏∏„ÅÆ„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÁ¢∫Ë™çÁîªÈù¢„Çí‰ΩøÁî®
            const result = await showExportPopup({ type: 'single', format: format.toUpperCase() });
            
            if (result.confirmed) {
                if (format === 'stl') {
                    galleryExportSTL(item.name);
                } else if (format === '3mf') {
                    await galleryExport3MF(item.name);
                } else if (format === 'obj') {
                    galleryExportOBJ(item.name);
                }
                showToast(`„Äå${item.name}„Äç„Çí${format.toUpperCase()}„Åß„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„Åü`);
            }
        }
        
        // „ÇÆ„É£„É©„É™„ÉºÂ∞ÇÁî®„Éï„Ç°„Ç§„É´‰øùÂ≠ò
        function gallerySaveBlob(blob, name) {
            if (typeof saveAs !== 'undefined') {
                saveAs(blob, name);
            } else {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = name;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
            }
        }
        
        // „ÇÆ„É£„É©„É™„ÉºÂ∞ÇÁî®STL„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÔºà„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Å™„ÅóÔºâ
        async function galleryExportSTL(itemName) {
            let { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
            
            // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„Çí‰øÆÊ≠£
            if (bodyGeo) {
                bodyGeo = await validateAndFixGeometry(bodyGeo, 'Êú¨‰Ωì');
                if (!bodyGeo) return;
            }
            if (textGeo) {
                textGeo = await validateAndFixGeometry(textGeo, 'ÊñáÂ≠ó');
                if (!textGeo) return;
            }
            if (importedGeo) {
                importedGeo = await validateAndFixGeometry(importedGeo, '„Ç§„É≥„Éù„Éº„Éà„É¢„Éá„É´');
                if (!importedGeo) return;
            }
            
            const clone = new THREE.Group();
            if (bodyGeo) clone.add(new THREE.Mesh(bodyGeo, new THREE.MeshBasicMaterial()));
            if (textGeo) clone.add(new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial()));
            if (importedGeo) clone.add(new THREE.Mesh(importedGeo, new THREE.MeshBasicMaterial()));
            
            const res = new STLExporter().parse(clone, {binary:true});
            const fileName = `${itemName}.stl`;
            gallerySaveBlob(new Blob([res], {type:'application/octet-stream'}), fileName);
        }
        
        // „ÇÆ„É£„É©„É™„ÉºÂ∞ÇÁî®OBJ„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÔºà„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Å™„ÅóÔºâ
        async function galleryExportOBJ(itemName) {
            let { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
            
            // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„Çí‰øÆÊ≠£
            if (bodyGeo) {
                bodyGeo = await validateAndFixGeometry(bodyGeo, 'Êú¨‰Ωì');
                if (!bodyGeo) return;
            }
            if (textGeo) {
                textGeo = await validateAndFixGeometry(textGeo, 'ÊñáÂ≠ó');
                if (!textGeo) return;
            }
            if (importedGeo) {
                importedGeo = await validateAndFixGeometry(importedGeo, '„Ç§„É≥„Éù„Éº„Éà„É¢„Éá„É´');
                if (!importedGeo) return;
            }
            
            const clone = new THREE.Group();
            if (bodyGeo) {
                const mesh = new THREE.Mesh(bodyGeo, new THREE.MeshBasicMaterial({ color: state.colBody }));
                mesh.name = "KeycapBody";
                clone.add(mesh);
            }
            if (textGeo) {
                const mesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial({ color: state.colText }));
                mesh.name = "KeycapText";
                clone.add(mesh);
            }
            if (importedGeo) {
                const mesh = new THREE.Mesh(importedGeo, new THREE.MeshBasicMaterial({ color: state.colText }));
                mesh.name = "ImportedModel";
                clone.add(mesh);
            }
            
            const res = new OBJExporter().parse(clone);
            const fileName = `${itemName}.obj`;
            gallerySaveBlob(new Blob([res], {type:'text/plain'}), fileName);
        }
        
        // „ÇÆ„É£„É©„É™„ÉºÂ∞ÇÁî®3MF„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÔºà„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Å™„Åó„ÄÅExtruderÁï™Âè∑ÂØæÂøúÔºâ
        async function galleryExport3MF(itemName) {
            let { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
            
            // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„Çí‰øÆÊ≠£
            if (bodyGeo) {
                bodyGeo = await validateAndFixGeometry(bodyGeo, 'Êú¨‰Ωì');
                if (!bodyGeo) return;
            }
            if (textGeo) {
                textGeo = await validateAndFixGeometry(textGeo, 'ÊñáÂ≠ó');
                if (!textGeo) return;
            }
            if (importedGeo) {
                importedGeo = await validateAndFixGeometry(importedGeo, '„Ç§„É≥„Éù„Éº„Éà„É¢„Éá„É´');
                if (!importedGeo) return;
            }
            
            const zip = new JSZip();
            const bodyExtruder = state.bodyExtruder || 1;
            const textExtruder = state.textExtruder || 2;
            
            function geoToMesh(geometry) {
                if (!geometry) return null;
                let geo = geometry.clone();
                if (!geo.index) geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
                const position = geo.attributes.position;
                if (!position) return null;
                
                const vertices = [];
                const triangles = [];
                const index = geo.index;
                
                if (index && index.array) {
                    for (let i = 0; i < position.count; i++) {
                        vertices.push(`        <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                    }
                    for (let i = 0; i < index.array.length; i += 3) {
                        triangles.push(`        <triangle v1="${index.array[i]}" v2="${index.array[i+1]}" v3="${index.array[i+2]}" />`);
                    }
                }
                return { vertices, triangles };
            }
            
            let objects = '';
            let componentRefs = [];
            let partConfigs = [];
            let objectId = 1;
            
            // Êú¨‰ΩìÔºàBambu Studio„Åß„ÅØÈÄÜÈ†Ü„ÅßËß£Èáà„Åï„Çå„Çã„Åü„ÇÅ„ÄÅText„Å®„ÅÑ„ÅÜÂêçÂâç„Çí‰ΩøÁî®Ôºâ
            if (bodyGeo) {
                const mesh = geoToMesh(bodyGeo);
                if (mesh) {
                    objects += `    <object id="${objectId}" type="model">
      <mesh>
        <vertices>
${mesh.vertices.join('\n')}
        </vertices>
        <triangles>
${mesh.triangles.join('\n')}
        </triangles>
      </mesh>
    </object>
`;
                    componentRefs.push({ id: objectId, name: 'Text' });
                    partConfigs.push({ partId: partConfigs.length, extruder: bodyExtruder, name: 'Text' });
                    objectId++;
                }
            }
            
            // ÊñáÂ≠ó„Å®„Ç§„É≥„Éù„Éº„ÉàÔºàBambu Studio„Åß„ÅØÈÄÜÈ†Ü„ÅßËß£Èáà„Åï„Çå„Çã„Åü„ÇÅ„ÄÅBody„Å®„ÅÑ„ÅÜÂêçÂâç„Çí‰ΩøÁî®Ôºâ
            let combinedTextGeo = textGeo;
            if (importedGeo) {
                if (combinedTextGeo) {
                    combinedTextGeo = BufferGeometryUtils.mergeGeometries([combinedTextGeo, importedGeo]);
                } else {
                    combinedTextGeo = importedGeo;
                }
            }
            
            if (combinedTextGeo) {
                const mesh = geoToMesh(combinedTextGeo);
                if (mesh) {
                    objects += `    <object id="${objectId}" type="model">
      <mesh>
        <vertices>
${mesh.vertices.join('\n')}
        </vertices>
        <triangles>
${mesh.triangles.join('\n')}
        </triangles>
      </mesh>
    </object>
`;
                    componentRefs.push({ id: objectId, name: 'Body' });
                    partConfigs.push({ partId: partConfigs.length, extruder: textExtruder, name: 'Body' });
                    objectId++;
                }
            }
            
            // „Ç¢„Çª„É≥„Éñ„É™„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
            const assemblyId = objectId;
            let componentsXml = '';
            componentRefs.forEach(comp => {
                componentsXml += `        <component objectid="${comp.id}" transform="1 0 0 0 1 0 0 0 1 0 0 0" />\n`;
            });
            
            const modelXml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02" 
  xmlns:p="http://schemas.microsoft.com/3dmanufacturing/production/2015/06">
  <metadata name="Application">Keycap Engine</metadata>
  <resources>
${objects}    <object id="${assemblyId}" type="model">
      <components>
${componentsXml}      </components>
    </object>
  </resources>
  <build><item objectid="${assemblyId}" /></build>
</model>`;
            
            // Slic3r PE configÔºàpartÂΩ¢ÂºèÔºâ
            let slic3rConfig = `<?xml version="1.0" encoding="UTF-8"?>\n<config>\n  <object id="${assemblyId}">\n    <metadata type="object" key="name" value="${itemName}"/>\n`;
            partConfigs.forEach((part) => {
                slic3rConfig += `    <part id="${part.partId}">\n      <metadata type="part" key="name" value="${part.name}"/>\n      <metadata type="part" key="extruder" value="${part.extruder}"/>\n    </part>\n`;
            });
            slic3rConfig += `  </object>\n</config>`;
            
            zip.file("3D/3dmodel.model", modelXml);
            zip.file("[Content_Types].xml", `<?xml version="1.0" encoding="UTF-8"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml"/></Types>`);
            zip.file("_rels/.rels", `<?xml version="1.0" encoding="UTF-8"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel"/></Relationships>`);
            zip.file("Metadata/Slic3r_PE_model.config", slic3rConfig);
            
            const blob = await zip.generateAsync({type:"blob", mimeType:"application/vnd.ms-package.3dmanufacturing"});
            const fileName = `${itemName}.3mf`;
            gallerySaveBlob(blob, fileName);
        }
        
        async function batchExportGallery(format) {
            if (!galleryDB) return;
            
            const tx = galleryDB.transaction(["presets"], "readonly");
            const store = tx.objectStore("presets");
            const req = store.getAll();
            
            req.onsuccess = async function() {
                const items = req.result;
                if (items.length === 0) {
                    showToast("„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åô„Çã„Éó„É™„Çª„ÉÉ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì");
                    return;
                }
                
                showToast(`${items.length}‰ª∂„Çí${format.toUpperCase()}„Åß‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÈñãÂßã...`);
                
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    Object.assign(state, item.state);
                    syncUI();
                    requestUpdate();
                    
                    // „É¢„Éá„É´Êõ¥Êñ∞„ÇíÂæÖ„Å§
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // „ÇÆ„É£„É©„É™„ÉºÂ∞ÇÁî®„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÈñ¢Êï∞„Çí‰ΩøÁî®Ôºà„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Å™„ÅóÔºâ
                    if (format === 'stl') {
                        galleryExportSTL(item.name);
                    } else if (format === '3mf') {
                        await galleryExport3MF(item.name);
                    } else if (format === 'obj') {
                        galleryExportOBJ(item.name);
                    }
                    
                    // „ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÈñìÈöî„ÇíÁ©∫„Åë„Çã
                    await new Promise(resolve => setTimeout(resolve, 800));
                }
                
                showToast(`${items.length}‰ª∂„ÅÆ„Ç®„ÇØ„Çπ„Éù„Éº„Éà„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü`);
            };
        }
        
        // ‰∏ÄÊã¨Ëâ≤Ë®≠ÂÆöÁîªÈù¢„ÇíË°®Á§∫Ôºà‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÁ¢∫Ë™çÁîªÈù¢„Å®Âêå„ÅòÂΩ¢ÂºèÔºâ
        function showBatchColorPopup() {
            if (!galleryDB) {
                showToast("„ÇÆ„É£„É©„É™„ÉºDB„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì", true);
                return;
            }
            
            const tx = galleryDB.transaction(["presets"], "readonly");
            const store = tx.objectStore("presets");
            const req = store.getAll();
            
            req.onsuccess = function() {
                const items = req.result;
                
                if (items.length === 0) {
                    showToast("Ëâ≤„ÇíË®≠ÂÆö„Åô„Çã„Éó„É™„Çª„ÉÉ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì");
                    return;
                }
                
                items.sort((a, b) => b.timestamp - a.timestamp);
                
                const overlay = document.getElementById('batch-color-overlay');
                const popup = document.getElementById('batch-color-popup');
                const previewEl = document.getElementById('batch-color-preview');
                const countEl = document.getElementById('batch-color-count');
                const bodyPalette = document.getElementById('batch-color-body-palette');
                const textPalette = document.getElementById('batch-color-text-palette');
                const selectedItemInfo = document.getElementById('batch-color-item-info');
                const applyBtn = document.getElementById('batch-color-apply-btn');
                const cancelBtn = document.getElementById('batch-color-cancel-btn');
                const preview3dEl = document.getElementById('batch-color-3d-preview');
                const selectedNameEl = document.getElementById('batch-color-selected-name');
                
                // ÈÅ∏Êäû‰∏≠„ÅÆ„Ç¢„Ç§„ÉÜ„É†„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
                let selectedIndex = 0;
                
                // 3D„Éó„É¨„Éì„É•„ÉºÁî®„ÅÆÂ§âÊï∞
                let thumbRenderer, thumbScene, thumbCam, previewGroup;
                
                // „Éï„Ç°„Ç§„É´Êï∞Ë°®Á§∫
                countEl.textContent = `${items.length}‰ª∂`;
                
                // ÂêÑ„Ç¢„Ç§„ÉÜ„É†„ÅÆËâ≤Ë®≠ÂÆö„Éá„Éº„Çø„ÇíÂàùÊúüÂåñÔºàÂàùÊúüÁä∂ÊÖã„Åß„ÅØÊú™Ë®≠ÂÆöÔºâ
                items.forEach(item => {
                    if (!item.data) item.data = {};
                });
                
                // 3D„Éó„É¨„Éì„É•„Éº„Çí‰ΩúÊàê„Åô„ÇãÈñ¢Êï∞
                function create3DPreview(itemState) {
                    // Êó¢Â≠ò„ÅÆ„É¨„É≥„ÉÄ„É©„Éº„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
                    if (thumbRenderer) {
                        thumbRenderer.dispose();
                        preview3dEl.innerHTML = '';
                    }
                    
                    // Êñ∞„Åó„ÅÑ„É¨„É≥„ÉÄ„É©„Éº„Çí‰ΩúÊàê
                    thumbRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                    thumbRenderer.setSize(180, 180);
                    thumbRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    preview3dEl.appendChild(thumbRenderer.domElement);
                    
                    // „Ç∑„Éº„É≥„Å®„Ç´„É°„É©„Çí‰ΩúÊàê
                    thumbScene = new THREE.Scene();
                    thumbScene.background = new THREE.Color(0x111111);
                    thumbCam = new THREE.PerspectiveCamera(35, 1, 0.1, 1000);
                    thumbCam.position.set(25, 20, 30);
                    thumbCam.lookAt(0, 0, 0);
                    
                    // „É©„Ç§„Éà„ÇíËøΩÂä†
                    const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
                    thumbScene.add(ambLight);
                    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    dirLight.position.set(5, 10, 7);
                    thumbScene.add(dirLight);
                    
                    // „Éó„É¨„Éì„É•„Éº„Ç∞„É´„Éº„Éó„Çí‰ΩúÊàê
                    previewGroup = new THREE.Group();
                    thumbScene.add(previewGroup);
                    
                    // state„Çí‰∏ÄÊôÇÁöÑ„Å´Ë®≠ÂÆö„Åó„Å¶„Ç∏„Ç™„É°„Éà„É™„ÇíÁîüÊàê
                    const savedState = JSON.parse(JSON.stringify(state));
                    Object.assign(state, itemState);
                    
                    // „Ç∏„Ç™„É°„Éà„É™„ÇíÊßãÁØâ
                    const { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
                    
                    // „Éû„ÉÜ„É™„Ç¢„É´„Çí‰ΩúÊàê„Åó„Å¶ËøΩÂä†
                    const selectedItem = items[selectedIndex];
                    const bodyColor = selectedItem.data?.colBody || itemState.colBody || '#333333';
                    const textColor = selectedItem.data?.colText || itemState.colText || '#ffffff';
                    
                    if (bodyGeo) {
                        const mesh = new THREE.Mesh(bodyGeo, new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.4 }));
                        mesh.name = 'KeycapBody';
                        previewGroup.add(mesh);
                    }
                    if (textGeo) {
                        const mesh = new THREE.Mesh(textGeo, new THREE.MeshStandardMaterial({ color: textColor, roughness: 0.3 }));
                        mesh.name = 'KeycapText';
                        previewGroup.add(mesh);
                    }
                    if (importedGeo) {
                        const mesh = new THREE.Mesh(importedGeo, new THREE.MeshStandardMaterial({ color: textColor, roughness: 0.3 }));
                        mesh.name = 'ImportedModel';
                        previewGroup.add(mesh);
                    }
                    
                    // ‰∏≠Â§Æ„Å´ÈÖçÁΩÆ
                    const box = new THREE.Box3().setFromObject(previewGroup);
                    const center = box.getCenter(new THREE.Vector3());
                    previewGroup.position.sub(center);
                    
                    // state„ÇíÂæ©ÂÖÉ
                    Object.assign(state, savedState);
                    
                    // „É¨„É≥„ÉÄ„É™„É≥„Ç∞
                    thumbRenderer.render(thumbScene, thumbCam);
                }
                
                // 3D„Éó„É¨„Éì„É•„Éº„ÅÆËâ≤„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
                function update3DPreviewColors() {
                    if (!previewGroup || !thumbRenderer || !thumbScene || !thumbCam) return;
                    
                    const selectedItem = items[selectedIndex];
                    const bodyColor = selectedItem.data?.colBody || selectedItem.state?.colBody || '#333333';
                    const textColor = selectedItem.data?.colText || selectedItem.state?.colText || '#ffffff';
                    
                    previewGroup.children.forEach(child => {
                        if (child.material) {
                            if (child.name === 'KeycapBody') {
                                child.material.color.set(bodyColor);
                            } else if (child.name === 'KeycapText' || child.name === 'ImportedModel') {
                                child.material.color.set(textColor);
                            }
                        }
                    });
                    
                    thumbRenderer.render(thumbScene, thumbCam);
                }
                
                // ÈÅ∏Êäû‰∏≠„Ç¢„Ç§„ÉÜ„É†„ÅÆ3D„Éó„É¨„Éì„É•„Éº„ÇíÊõ¥Êñ∞
                function updateSelectedPreview() {
                    const selectedItem = items[selectedIndex];
                    if (!selectedItem) return;
                    
                    selectedNameEl.textContent = selectedItem.name;
                    create3DPreview(selectedItem.state);
                }
                
                // AMS„Éë„É¨„ÉÉ„Éà„ÇíÊèèÁîª„Åô„ÇãÈñ¢Êï∞
                function renderBatchColorPalette() {
                    if (!bodyPalette || !textPalette) return;
                    
                    // ÈÅ∏Êäû‰∏≠„ÅÆ„Ç¢„Ç§„ÉÜ„É†
                    const selectedItem = items[selectedIndex];
                    if (!selectedItem) return;
                    
                    // AMS„Çπ„É≠„ÉÉ„Éà„ÇíÂèéÈõÜ
                    const allSlots = [];
                    amsConfig.units.forEach(unit => {
                        unit.slots.forEach(slotData => allSlots.push(slotData));
                    });
                    amsConfig.htUnits.forEach(unit => {
                        unit.slots.forEach(slotData => allSlots.push(slotData));
                    });
                    
                    const renderPalette = (container, type) => {
                        container.innerHTML = '';
                        let hasSlots = false;
                        
                        // ÁèæÂú®„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÅÆËâ≤„ÇíÂèñÂæóÔºàdata„ÅÆ„ÅøÂèÇÁÖß„ÄÅÂàùÊúüÁä∂ÊÖã„Åß„ÅØÊú™ÈÅ∏ÊäûÔºâ
                        const currentBodyColor = selectedItem.data?.colBody || null;
                        const currentTextColor = selectedItem.data?.colText || null;
                        
                        allSlots.forEach((slotData, idx) => {
                            if (!slotData || !slotData.color) return;
                            hasSlots = true;
                            
                            const item = document.createElement('div');
                            item.className = 'ams-select-item';
                            item.style.cssText = 'width:48px; height:52px; padding:3px;';
                            item.dataset.slot = idx + 1;
                            item.dataset.color = slotData.color;
                            
                            // ÈÅ∏ÊäûÁä∂ÊÖã„ÇíÁ¢∫Ë™çÔºàdata„Å´Ëâ≤„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅÆ„ÅøÔºâ
                            const targetColor = type === 'body' ? currentBodyColor : currentTextColor;
                            if (targetColor && slotData.color.toLowerCase() === targetColor.toLowerCase()) {
                                item.classList.add(type === 'body' ? 'body-selected' : 'text-selected');
                            }
                            
                            const material = slotData.material || '';
                            item.innerHTML = `
                                <span class="ams-select-item-num" style="font-size:0.6rem;">${idx + 1}</span>
                                <div class="ams-select-item-color" style="width:24px; height:24px; background:${slotData.color}"></div>
                                <div class="ams-select-item-material" style="font-size:0.5rem; max-width:44px;">${material}</div>
                            `;
                            
                            item.onclick = () => {
                                // ÈÅ∏Êäû‰∏≠„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÅÆËâ≤„ÇíÊõ¥Êñ∞
                                if (!selectedItem.data) selectedItem.data = {};
                                if (type === 'body') {
                                    selectedItem.data.colBody = slotData.color;
                                    selectedItem.data.bodyExtruder = idx + 1;
                                } else {
                                    selectedItem.data.colText = slotData.color;
                                    selectedItem.data.textExtruder = idx + 1;
                                }
                                renderBatchColorPalette();
                                updateColorPreviewColors();
                                update3DPreviewColors(); // 3D„Éó„É¨„Éì„É•„Éº„ÇÇÊõ¥Êñ∞
                            };
                            
                            container.appendChild(item);
                        });
                        
                        if (!hasSlots) {
                            const tAms = translations[currentLang] || translations.ja;
                            container.innerHTML = `<div style="color:#666; font-size:0.7rem; padding:5px;">${tAms.ams_register_colors || 'AMSË®≠ÂÆö„ÅßËâ≤„ÇíÁôªÈå≤'}</div>`;
                        }
                    };
                    
                    renderPalette(bodyPalette, 'body');
                    renderPalette(textPalette, 'text');
                    
                    // ÈÅ∏Êäû‰∏≠„ÅÆ„Ç¢„Ç§„ÉÜ„É†ÊÉÖÂ†±„ÇíÊõ¥Êñ∞
                    selectedItemInfo.innerHTML = `ÈÅ∏Êäû‰∏≠: <strong>${selectedItem.name}</strong> (${selectedIndex + 1}/${items.length})`;
                }
                
                // „Éó„É¨„Éì„É•„Éº„ÅÆËâ≤„ÇíÊõ¥Êñ∞
                function updateColorPreviewColors() {
                    // AMS„Çπ„É≠„ÉÉ„ÉàÊÉÖÂ†±„ÇíÂèéÈõÜ
                    const allSlots = [];
                    amsConfig.units.forEach(unit => {
                        unit.slots.forEach(slot => allSlots.push(slot));
                    });
                    amsConfig.htUnits.forEach(unit => {
                        unit.slots.forEach(slot => allSlots.push(slot));
                    });
                    
                    const previewItems = previewEl.querySelectorAll('.batch-preview-item');
                    previewItems.forEach((div, idx) => {
                        const item = items[idx];
                        
                        // Êó¢Â≠ò„ÅÆ„Éû„Éº„ÇØ„Å®„Ç™„Éº„Éê„Éº„É¨„Ç§„ÇíÂâäÈô§
                        div.querySelectorAll('.color-changed-mark, .color-overlay').forEach(m => m.remove());
                        
                        if (item && item.data) {
                            // „Ç¢„Ç§„ÉÜ„É†Ëá™Ë∫´„Å´„Ç®„ÇØ„Çπ„Éà„É´„Éº„ÉÄ„ÉºË®≠ÂÆö„Åå„ÅÇ„Çã„Åã„ÄÅAMS„ÅßÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆö„Åï„Çå„Åü„Åã
                            const itemHasBody = !!(item.data.bodyExtruder);
                            const itemHasText = !!(item.data.textExtruder);
                            const bodyExt = item.data.bodyExtruder || (amsConfig.bodyExtruderSet ? amsConfig.bodyExtruder : null);
                            const textExt = item.data.textExtruder || (amsConfig.textExtruderSet ? amsConfig.textExtruder : null);
                            
                            // ÂØæÂøú„Åô„Çã„Çπ„É≠„ÉÉ„Éà„Å´Ëâ≤„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                            const hasBodyColor = bodyExt && bodyExt >= 1 && bodyExt <= allSlots.length && allSlots[bodyExt - 1] && allSlots[bodyExt - 1].color;
                            const hasTextColor = textExt && textExt >= 1 && textExt <= allSlots.length && allSlots[textExt - 1] && allSlots[textExt - 1].color;
                            
                            // „Ç´„É©„Éº„Ç™„Éº„Éê„Éº„É¨„Ç§„ÇíËøΩÂä†ÔºàÊú¨‰ΩìËâ≤„Å®ÊñáÂ≠óËâ≤„ÇíË°®Á§∫Ôºâ
                            if (hasBodyColor || hasTextColor) {
                                const overlay = document.createElement('div');
                                overlay.className = 'color-overlay';
                                overlay.style.cssText = 'position:absolute; bottom:14px; left:50%; transform:translateX(-50%); display:flex; gap:2px; background:rgba(0,0,0,0.7); padding:2px 3px; border-radius:3px;';
                                
                                if (hasBodyColor) {
                                    const bodyBox = document.createElement('div');
                                    bodyBox.style.cssText = `width:14px; height:14px; background:${item.data.colBody}; border-radius:2px; border:1px solid #00e5ff;`;
                                    bodyBox.title = 'Êú¨‰ΩìËâ≤';
                                    overlay.appendChild(bodyBox);
                                }
                                
                                if (hasTextColor) {
                                    const textBox = document.createElement('div');
                                    textBox.style.cssText = `width:14px; height:14px; background:${item.data.colText}; border-radius:2px; border:1px solid #ff9800;`;
                                    textBox.title = 'ÊñáÂ≠óËâ≤';
                                    overlay.appendChild(textBox);
                                }
                                
                                div.appendChild(overlay);
                            }
                            
                            // Êú¨‰Ωì„Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆöÊôÇ: „Ç∑„Ç¢„É≥Ëâ≤„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØÔºàÂè≥‰∏ä„Éª‰∏äÊÆµÔºâ
                            if (hasBodyColor) {
                                const bodyMark = document.createElement('div');
                                bodyMark.className = 'color-changed-mark';
                                bodyMark.style.cssText = 'position:absolute; top:2px; right:2px; width:12px; height:12px; background:#00e5ff; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:8px; color:#000; font-weight:bold; box-shadow:0 1px 3px rgba(0,0,0,0.5);';
                                bodyMark.textContent = '‚úì';
                                bodyMark.title = 'Êú¨‰ΩìËâ≤Ë®≠ÂÆöÊ∏à„Åø';
                                div.appendChild(bodyMark);
                            }
                            
                            // ÊñáÂ≠ó„Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆöÊôÇ: „Ç™„É¨„É≥„Ç∏Ëâ≤„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØÔºàÂè≥‰∏ä„Éª‰∏ãÊÆµÔºâ
                            if (hasTextColor) {
                                const textMark = document.createElement('div');
                                textMark.className = 'color-changed-mark';
                                textMark.style.cssText = 'position:absolute; top:16px; right:2px; width:12px; height:12px; background:#ff9800; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:8px; color:#000; font-weight:bold; box-shadow:0 1px 3px rgba(0,0,0,0.5);';
                                textMark.textContent = '‚úì';
                                textMark.title = 'ÊñáÂ≠óËâ≤Ë®≠ÂÆöÊ∏à„Åø';
                                div.appendChild(textMark);
                            }
                        }
                    });
                    
                    // Ë≠¶Âëä„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊõ¥Êñ∞
                    updateColorWarningMessage();
                }
                
                // Ë≠¶Âëä„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
                function updateColorWarningMessage() {
                    const warningEl = document.getElementById('batch-color-warning');
                    if (!warningEl) return;
                    
                    // AMS„Çπ„É≠„ÉÉ„Éà„Å´„Éï„Ç£„É©„É°„É≥„Éà„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                    const allSlots = [];
                    amsConfig.units.forEach(unit => {
                        unit.slots.forEach(slot => allSlots.push(slot));
                    });
                    amsConfig.htUnits.forEach(unit => {
                        unit.slots.forEach(slot => allSlots.push(slot));
                    });
                    
                    const warnings = [];
                    
                    items.forEach((item, idx) => {
                        // „Ç¢„Ç§„ÉÜ„É†Ëá™Ë∫´„Å´„Ç®„ÇØ„Çπ„Éà„É´„Éº„ÉÄ„ÉºË®≠ÂÆö„Åå„ÅÇ„Çã„Åã„ÄÅAMS„ÅßÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆö„Åï„Çå„Åü„Åã
                        const bodyExt = (item.data && item.data.bodyExtruder) || (amsConfig.bodyExtruderSet ? amsConfig.bodyExtruder : null);
                        const textExt = (item.data && item.data.textExtruder) || (amsConfig.textExtruderSet ? amsConfig.textExtruder : null);
                        
                        // ÂØæÂøú„Åô„Çã„Çπ„É≠„ÉÉ„Éà„Å´Ëâ≤„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                        const hasBodyColor = bodyExt && bodyExt >= 1 && bodyExt <= allSlots.length && allSlots[bodyExt - 1] && allSlots[bodyExt - 1].color;
                        const hasTextColor = textExt && textExt >= 1 && textExt <= allSlots.length && allSlots[textExt - 1] && allSlots[textExt - 1].color;
                        
                        if (!hasBodyColor && !hasTextColor) {
                            warnings.push(`${idx + 1}Áï™ÁõÆ„Äå${item.name}„Äç„ÅÆÊú¨‰Ωì„Éï„Ç£„É©„É°„É≥„Éà„ÄÅÊñáÂ≠ó„Éï„Ç£„É©„É°„É≥„Éà‰∏°Êñπ`);
                        } else if (!hasBodyColor) {
                            warnings.push(`${idx + 1}Áï™ÁõÆ„Äå${item.name}„Äç„ÅÆÊú¨‰Ωì„Éï„Ç£„É©„É°„É≥„Éà`);
                        } else if (!hasTextColor) {
                            warnings.push(`${idx + 1}Áï™ÁõÆ„Äå${item.name}„Äç„ÅÆÊñáÂ≠ó„Éï„Ç£„É©„É°„É≥„Éà`);
                        }
                    });
                    
                    if (warnings.length > 0) {
                        warningEl.style.display = 'block';
                        const tw = translations[currentLang] || translations.ja;
                        warningEl.innerHTML = `<span style="color:#ff5252;">‚ö†Ô∏è ${tw.warning_not_set || 'Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì'}:</span><br>` + 
                            warnings.map(w => `<span style="color:#ffab40; font-size:0.7rem;">‚Ä¢ ${w}</span>`).join('<br>');
                    } else {
                        warningEl.style.display = 'none';
                    }
                }
                
                // „Éó„É¨„Éì„É•„ÉºÁîüÊàê
                previewEl.innerHTML = '';
                const tPrev = translations[currentLang] || translations.ja;
                items.forEach((item, idx) => {
                    const div = document.createElement('div');
                    div.className = 'batch-preview-item';
                    if (idx === 0) div.classList.add('selected');
                    div.title = `${item.name} - ${tPrev.click_to_select || '„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÅ∏Êäû'}`;
                    div.dataset.index = idx;
                    
                    const img = document.createElement('img');
                    img.src = item.thumbnail;
                    img.alt = item.name;
                    
                    const nameLabel = document.createElement('div');
                    nameLabel.className = 'batch-preview-name';
                    nameLabel.textContent = item.name;
                    
                    div.appendChild(img);
                    div.appendChild(nameLabel);
                    
                    // „ÇØ„É™„ÉÉ„ÇØ„ÅßÈÅ∏Êäû
                    div.onclick = () => {
                        // ‰ª•Ââç„ÅÆÈÅ∏Êäû„ÇíËß£Èô§
                        previewEl.querySelectorAll('.batch-preview-item').forEach(el => {
                            el.classList.remove('selected');
                        });
                        // Êñ∞„Åó„ÅÑÈÅ∏Êäû
                        div.classList.add('selected');
                        selectedIndex = idx;
                        renderBatchColorPalette();
                        updateSelectedPreview(); // 3D„Éó„É¨„Éì„É•„Éº„ÇíÊõ¥Êñ∞
                    };
                    
                    previewEl.appendChild(div);
                });
                
                // AMS„Éë„É¨„ÉÉ„Éà„ÇíÂàùÊúüÊèèÁîª
                renderBatchColorPalette();
                
                // ÂàùÊúü„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÇíË°®Á§∫
                updateColorPreviewColors();
                
                // ÂàùÊúü3D„Éó„É¨„Éì„É•„Éº„ÇíË°®Á§∫
                updateSelectedPreview();
                
                // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóË°®Á§∫
                overlay.style.display = 'flex';
                requestAnimationFrame(() => {
                    overlay.style.background = 'rgba(0,0,0,0.7)';
                    popup.classList.add('show');
                });
                
                // „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÈñ¢Êï∞
                const cleanup = () => {
                    // 3D„É¨„É≥„ÉÄ„É©„Éº„ÇíÁ†¥Ê£Ñ
                    if (thumbRenderer) {
                        thumbRenderer.dispose();
                        thumbRenderer = null;
                    }
                    if (preview3dEl) preview3dEl.innerHTML = '';
                    
                    overlay.style.background = 'rgba(0,0,0,0)';
                    popup.classList.remove('show');
                    setTimeout(() => {
                        overlay.style.display = 'none';
                    }, 300);
                    applyBtn.onclick = null;
                    cancelBtn.onclick = null;
                };
                
                // ÈÅ©Áî®„Éú„Çø„É≥
                applyBtn.onclick = async () => {
                    // Ëâ≤Ë®≠ÂÆö„Çí„ÇÆ„É£„É©„É™„ÉºDB„Å´‰øùÂ≠ò
                    const txWrite = galleryDB.transaction(["presets"], "readwrite");
                    const storeWrite = txWrite.objectStore("presets");
                    
                    for (let i = 0; i < items.length; i++) {
                        const item = items[i];
                        
                        // Ëâ≤Ë®≠ÂÆö„Åå„ÅÇ„Çå„Å∞Êõ¥Êñ∞
                        if (item.data && (item.data.bodyExtruder || item.data.textExtruder)) {
                            if (item.data.colBody) item.state.colBody = item.data.colBody;
                            if (item.data.colText) item.state.colText = item.data.colText;
                            if (item.data.bodyExtruder) item.state.bodyExtruder = item.data.bodyExtruder;
                            if (item.data.textExtruder) item.state.textExtruder = item.data.textExtruder;
                            
                            await new Promise((resolve, reject) => {
                                const req = storeWrite.put(item);
                                req.onsuccess = resolve;
                                req.onerror = reject;
                            });
                        }
                    }
                    
                    cleanup();
                    showToast("Ëâ≤Ë®≠ÂÆö„ÇíÈÅ©Áî®„Åó„Åæ„Åó„Åü");
                    loadGallery(); // „ÇÆ„É£„É©„É™„Éº„ÇíÂÜçË™≠„ÅøËæº„Åø
                };
                
                cancelBtn.onclick = () => {
                    cleanup();
                };
                
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        cleanup();
                    }
                };
            };
        }
        
        // ‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÁ¢∫Ë™çÁîªÈù¢„ÇíË°®Á§∫
        function showBatchExportPopup() {
            return new Promise((resolve) => {
                if (!galleryDB) {
                    resolve({ confirmed: false });
                    return;
                }
                
                const tx = galleryDB.transaction(["presets"], "readonly");
                const store = tx.objectStore("presets");
                const req = store.getAll();
                
                req.onsuccess = function() {
                    const items = req.result;
                    
                    if (items.length === 0) {
                        showToast("„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åô„Çã„Éó„É™„Çª„ÉÉ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì");
                        resolve({ confirmed: false });
                        return;
                    }
                    
                    items.sort((a, b) => b.timestamp - a.timestamp);
                    
                    // ÂêÑ„Ç¢„Ç§„ÉÜ„É†„ÅÆËâ≤Ë®≠ÂÆö„Éá„Éº„Çø„ÇíÂàùÊúüÂåñÔºàÂàùÊúüÁä∂ÊÖã„Åß„ÅØÊú™Ë®≠ÂÆöÔºâ
                    items.forEach(item => {
                        if (!item.data) item.data = {};
                    });
                    
                    const overlay = document.getElementById('batch-export-overlay');
                    const popup = document.getElementById('batch-export-popup');
                    const previewEl = document.getElementById('batch-export-preview');
                    const infoEl = document.getElementById('batch-export-info');
                    const fileCountEl = document.getElementById('batch-export-file-count');
                    const formatBadge = document.getElementById('batch-export-format-badge');
                    const confirmBtn = document.getElementById('batch-export-confirm-btn');
                    const cancelBtn = document.getElementById('batch-export-cancel-btn');
                    const bodyPalette = document.getElementById('batch-export-body-palette');
                    const textPalette = document.getElementById('batch-export-text-palette');
                    const selectedItemInfo = document.getElementById('batch-selected-item-info');
                    const preview3dEl = document.getElementById('batch-export-3d-preview');
                    const selectedNameEl = document.getElementById('batch-export-selected-name');
                    
                    // ÈÅ∏Êäû‰∏≠„ÅÆ„Ç¢„Ç§„ÉÜ„É†„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
                    let selectedIndex = 0;
                    
                    // 3D„Éó„É¨„Éì„É•„ÉºÁî®„ÅÆÂ§âÊï∞
                    let thumbRenderer, thumbScene, thumbCam, previewGroup;
                    
                    // „Éï„Ç°„Ç§„É´Êï∞Ë°®Á§∫
                    fileCountEl.textContent = `${items.length}‰ª∂`;
                    
                    // 3D„Éó„É¨„Éì„É•„Éº„Çí‰ΩúÊàê„Åô„ÇãÈñ¢Êï∞
                    function create3DPreview(itemState) {
                        // Êó¢Â≠ò„ÅÆ„É¨„É≥„ÉÄ„É©„Éº„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
                        if (thumbRenderer) {
                            thumbRenderer.dispose();
                            preview3dEl.innerHTML = '';
                        }
                        
                        // Êñ∞„Åó„ÅÑ„É¨„É≥„ÉÄ„É©„Éº„Çí‰ΩúÊàê
                        thumbRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                        thumbRenderer.setSize(180, 180);
                        thumbRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                        preview3dEl.appendChild(thumbRenderer.domElement);
                        
                        // „Ç∑„Éº„É≥„Å®„Ç´„É°„É©„Çí‰ΩúÊàê
                        thumbScene = new THREE.Scene();
                        thumbScene.background = new THREE.Color(0x111111);
                        thumbCam = new THREE.PerspectiveCamera(35, 1, 0.1, 1000);
                        thumbCam.position.set(25, 20, 30);
                        thumbCam.lookAt(0, 0, 0);
                        
                        // „É©„Ç§„Éà„ÇíËøΩÂä†
                        const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
                        thumbScene.add(ambLight);
                        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                        dirLight.position.set(5, 10, 7);
                        thumbScene.add(dirLight);
                        
                        // „Éó„É¨„Éì„É•„Éº„Ç∞„É´„Éº„Éó„Çí‰ΩúÊàê
                        previewGroup = new THREE.Group();
                        thumbScene.add(previewGroup);
                        
                        // state„Çí‰∏ÄÊôÇÁöÑ„Å´Ë®≠ÂÆö„Åó„Å¶„Ç∏„Ç™„É°„Éà„É™„ÇíÁîüÊàê
                        const savedState = JSON.parse(JSON.stringify(state));
                        Object.assign(state, itemState);
                        
                        // „Ç∏„Ç™„É°„Éà„É™„ÇíÊßãÁØâ
                        const { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
                        
                        // „Éû„ÉÜ„É™„Ç¢„É´„Çí‰ΩúÊàê„Åó„Å¶ËøΩÂä†
                        const selectedItem = items[selectedIndex];
                        const bodyColor = selectedItem.data?.colBody || itemState.colBody || '#333333';
                        const textColor = selectedItem.data?.colText || itemState.colText || '#ffffff';
                        
                        if (bodyGeo) {
                            const mesh = new THREE.Mesh(bodyGeo, new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.4 }));
                            mesh.name = 'KeycapBody';
                            previewGroup.add(mesh);
                        }
                        if (textGeo) {
                            const mesh = new THREE.Mesh(textGeo, new THREE.MeshStandardMaterial({ color: textColor, roughness: 0.3 }));
                            mesh.name = 'KeycapText';
                            previewGroup.add(mesh);
                        }
                        if (importedGeo) {
                            const mesh = new THREE.Mesh(importedGeo, new THREE.MeshStandardMaterial({ color: textColor, roughness: 0.3 }));
                            mesh.name = 'ImportedModel';
                            previewGroup.add(mesh);
                        }
                        
                        // ‰∏≠Â§Æ„Å´ÈÖçÁΩÆ
                        const box = new THREE.Box3().setFromObject(previewGroup);
                        const center = box.getCenter(new THREE.Vector3());
                        previewGroup.position.sub(center);
                        
                        // state„ÇíÂæ©ÂÖÉ
                        Object.assign(state, savedState);
                        
                        // „É¨„É≥„ÉÄ„É™„É≥„Ç∞
                        thumbRenderer.render(thumbScene, thumbCam);
                    }
                    
                    // 3D„Éó„É¨„Éì„É•„Éº„ÅÆËâ≤„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
                    function update3DPreviewColors() {
                        if (!previewGroup || !thumbRenderer || !thumbScene || !thumbCam) return;
                        
                        const selectedItem = items[selectedIndex];
                        const bodyColor = selectedItem.data?.colBody || selectedItem.state?.colBody || '#333333';
                        const textColor = selectedItem.data?.colText || selectedItem.state?.colText || '#ffffff';
                        
                        previewGroup.children.forEach(child => {
                            if (child.material) {
                                if (child.name === 'KeycapBody') {
                                    child.material.color.set(bodyColor);
                                } else if (child.name === 'KeycapText' || child.name === 'ImportedModel') {
                                    child.material.color.set(textColor);
                                }
                            }
                        });
                        
                        thumbRenderer.render(thumbScene, thumbCam);
                    }
                    
                    // ÈÅ∏Êäû‰∏≠„Ç¢„Ç§„ÉÜ„É†„ÅÆ3D„Éó„É¨„Éì„É•„Éº„ÇíÊõ¥Êñ∞
                    function updateSelectedPreview() {
                        const selectedItem = items[selectedIndex];
                        if (!selectedItem) return;
                        
                        selectedNameEl.textContent = selectedItem.name;
                        create3DPreview(selectedItem.state);
                    }
                    
                    // AMS„Éë„É¨„ÉÉ„Éà„ÇíÊèèÁîª„Åô„ÇãÈñ¢Êï∞
                    function renderBatchAMSPalette() {
                        if (!bodyPalette || !textPalette) return;
                        
                        // ÈÅ∏Êäû‰∏≠„ÅÆ„Ç¢„Ç§„ÉÜ„É†
                        const selectedItem = items[selectedIndex];
                        if (!selectedItem) return;
                        
                        // AMS„Çπ„É≠„ÉÉ„Éà„ÇíÂèéÈõÜ
                        const allSlots = [];
                        amsConfig.units.forEach(unit => {
                            unit.slots.forEach(slotData => allSlots.push(slotData));
                        });
                        amsConfig.htUnits.forEach(unit => {
                            unit.slots.forEach(slotData => allSlots.push(slotData));
                        });
                        
                        const renderPalette = (container, type) => {
                            container.innerHTML = '';
                            let hasSlots = false;
                            
                            // ÁèæÂú®„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÅÆËâ≤„ÇíÂèñÂæóÔºàdata„ÅÆ„ÅøÂèÇÁÖß„ÄÅÂàùÊúüÁä∂ÊÖã„Åß„ÅØÊú™ÈÅ∏ÊäûÔºâ
                            const currentBodyColor = selectedItem.data?.colBody || null;
                            const currentTextColor = selectedItem.data?.colText || null;
                            
                            allSlots.forEach((slotData, idx) => {
                                if (!slotData || !slotData.color) return;
                                hasSlots = true;
                                
                                const item = document.createElement('div');
                                item.className = 'ams-select-item';
                                item.style.cssText = 'width:48px; height:52px; padding:3px;';
                                item.dataset.slot = idx + 1;
                                item.dataset.color = slotData.color;
                                
                                // ÈÅ∏ÊäûÁä∂ÊÖã„ÇíÁ¢∫Ë™çÔºàdata„Å´Ëâ≤„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅÆ„ÅøÔºâ
                                const targetColor = type === 'body' ? currentBodyColor : currentTextColor;
                                if (targetColor && slotData.color.toLowerCase() === targetColor.toLowerCase()) {
                                    item.classList.add(type === 'body' ? 'body-selected' : 'text-selected');
                                }
                                
                                const material = slotData.material || '';
                                item.innerHTML = `
                                    <span class="ams-select-item-num" style="font-size:0.6rem;">${idx + 1}</span>
                                    <div class="ams-select-item-color" style="width:24px; height:24px; background:${slotData.color}"></div>
                                    <div class="ams-select-item-material" style="font-size:0.5rem; max-width:44px;">${material}</div>
                                `;
                                
                                item.onclick = () => {
                                    // ÈÅ∏Êäû‰∏≠„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÅÆËâ≤„ÇíÊõ¥Êñ∞
                                    if (!selectedItem.data) selectedItem.data = {};
                                    if (type === 'body') {
                                        selectedItem.data.colBody = slotData.color;
                                        selectedItem.data.bodyExtruder = idx + 1;
                                    } else {
                                        selectedItem.data.colText = slotData.color;
                                        selectedItem.data.textExtruder = idx + 1;
                                    }
                                    renderBatchAMSPalette();
                                    updatePreviewColors();
                                    updateBatchExportInfo();
                                    update3DPreviewColors(); // 3D„Éó„É¨„Éì„É•„Éº„ÇÇÊõ¥Êñ∞
                                };
                                
                                container.appendChild(item);
                            });
                            
                            if (!hasSlots) {
                                const tAms2 = translations[currentLang] || translations.ja;
                                container.innerHTML = `<div style="color:#666; font-size:0.7rem; padding:5px;">${tAms2.ams_register_colors || 'AMSË®≠ÂÆö„ÅßËâ≤„ÇíÁôªÈå≤'}</div>`;
                            }
                        };
                        
                        renderPalette(bodyPalette, 'body');
                        renderPalette(textPalette, 'text');
                        
                        // ÈÅ∏Êäû‰∏≠„ÅÆ„Ç¢„Ç§„ÉÜ„É†ÊÉÖÂ†±„ÇíÊõ¥Êñ∞
                        const tSel = translations[currentLang] || translations.ja;
                        selectedItemInfo.innerHTML = `${tSel.selected_label || 'ÈÅ∏Êäû‰∏≠'}: <strong>${selectedItem.name}</strong> (${selectedIndex + 1}/${items.length})`;
                    }
                    
                    // „Éó„É¨„Éì„É•„Éº„ÅÆËâ≤„ÇíÊõ¥Êñ∞
                    function updatePreviewColors() {
                        // AMS„Çπ„É≠„ÉÉ„ÉàÊÉÖÂ†±„ÇíÂèéÈõÜ
                        const allSlots = [];
                        amsConfig.units.forEach(unit => {
                            unit.slots.forEach(slot => allSlots.push(slot));
                        });
                        amsConfig.htUnits.forEach(unit => {
                            unit.slots.forEach(slot => allSlots.push(slot));
                        });
                        
                        const previewItems = previewEl.querySelectorAll('.batch-preview-item');
                        previewItems.forEach((div, idx) => {
                            const item = items[idx];
                            
                            // Êó¢Â≠ò„ÅÆ„Éû„Éº„ÇØ„Å®„Ç™„Éº„Éê„Éº„É¨„Ç§„ÇíÂâäÈô§
                            div.querySelectorAll('.color-changed-mark, .color-overlay').forEach(m => m.remove());
                            
                            if (item && item.data) {
                                // „Ç¢„Ç§„ÉÜ„É†Ëá™Ë∫´„Å´„Ç®„ÇØ„Çπ„Éà„É´„Éº„ÉÄ„ÉºË®≠ÂÆö„Åå„ÅÇ„Çã„Åã„ÄÅAMS„ÅßÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆö„Åï„Çå„Åü„Åã
                                const bodyExt = item.data.bodyExtruder || (amsConfig.bodyExtruderSet ? amsConfig.bodyExtruder : null);
                                const textExt = item.data.textExtruder || (amsConfig.textExtruderSet ? amsConfig.textExtruder : null);
                                
                                // ÂØæÂøú„Åô„Çã„Çπ„É≠„ÉÉ„Éà„Å´Ëâ≤„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                                const hasBodyColor = bodyExt && bodyExt >= 1 && bodyExt <= allSlots.length && allSlots[bodyExt - 1] && allSlots[bodyExt - 1].color;
                                const hasTextColor = textExt && textExt >= 1 && textExt <= allSlots.length && allSlots[textExt - 1] && allSlots[textExt - 1].color;
                                
                                // „Ç´„É©„Éº„Ç™„Éº„Éê„Éº„É¨„Ç§„ÇíËøΩÂä†ÔºàÊú¨‰ΩìËâ≤„Å®ÊñáÂ≠óËâ≤„ÇíË°®Á§∫Ôºâ
                                if (hasBodyColor || hasTextColor) {
                                    const overlay = document.createElement('div');
                                    overlay.className = 'color-overlay';
                                    overlay.style.cssText = 'position:absolute; bottom:14px; left:50%; transform:translateX(-50%); display:flex; gap:2px; background:rgba(0,0,0,0.7); padding:2px 3px; border-radius:3px;';
                                    
                                    if (hasBodyColor) {
                                        const bodyBox = document.createElement('div');
                                        bodyBox.style.cssText = `width:14px; height:14px; background:${item.data.colBody}; border-radius:2px; border:1px solid #00e5ff;`;
                                        bodyBox.title = 'Êú¨‰ΩìËâ≤';
                                        overlay.appendChild(bodyBox);
                                    }
                                    
                                    if (hasTextColor) {
                                        const textBox = document.createElement('div');
                                        textBox.style.cssText = `width:14px; height:14px; background:${item.data.colText}; border-radius:2px; border:1px solid #ff9800;`;
                                        textBox.title = 'ÊñáÂ≠óËâ≤';
                                        overlay.appendChild(textBox);
                                    }
                                    
                                    div.appendChild(overlay);
                                }
                                
                                // Êú¨‰Ωì„Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆöÊôÇ: „Ç∑„Ç¢„É≥Ëâ≤„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØÔºàÂè≥‰∏ä„Éª‰∏äÊÆµÔºâ
                                if (hasBodyColor) {
                                    const bodyMark = document.createElement('div');
                                    bodyMark.className = 'color-changed-mark';
                                    bodyMark.style.cssText = 'position:absolute; top:2px; right:2px; width:12px; height:12px; background:#00e5ff; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:8px; color:#000; font-weight:bold; box-shadow:0 1px 3px rgba(0,0,0,0.5);';
                                    bodyMark.textContent = '‚úì';
                                    bodyMark.title = 'Êú¨‰ΩìËâ≤Ë®≠ÂÆöÊ∏à„Åø';
                                    div.appendChild(bodyMark);
                                }
                                
                                // ÊñáÂ≠ó„Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆöÊôÇ: „Ç™„É¨„É≥„Ç∏Ëâ≤„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØÔºàÂè≥‰∏ä„Éª‰∏ãÊÆµÔºâ
                                if (hasTextColor) {
                                    const textMark = document.createElement('div');
                                    textMark.className = 'color-changed-mark';
                                    textMark.style.cssText = 'position:absolute; top:16px; right:2px; width:12px; height:12px; background:#ff9800; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:8px; color:#000; font-weight:bold; box-shadow:0 1px 3px rgba(0,0,0,0.5);';
                                    textMark.textContent = '‚úì';
                                    textMark.title = 'ÊñáÂ≠óËâ≤Ë®≠ÂÆöÊ∏à„Åø';
                                    div.appendChild(textMark);
                                }
                            }
                        });
                        
                        // Ë≠¶Âëä„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊõ¥Êñ∞
                        updateWarningMessage();
                    }
                    
                    // Ë≠¶Âëä„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
                    function updateWarningMessage() {
                        const warningEl = document.getElementById('batch-export-warning');
                        if (!warningEl) return;
                        
                        // AMS„Çπ„É≠„ÉÉ„ÉàÊÉÖÂ†±„ÇíÂèéÈõÜ
                        const allSlots = [];
                        amsConfig.units.forEach(unit => {
                            unit.slots.forEach(slot => allSlots.push(slot));
                        });
                        amsConfig.htUnits.forEach(unit => {
                            unit.slots.forEach(slot => allSlots.push(slot));
                        });
                        
                        const warnings = [];
                        const tWarn = translations[currentLang] || translations.ja;
                        
                        items.forEach((item, idx) => {
                            // „Ç¢„Ç§„ÉÜ„É†Ëá™Ë∫´„Å´„Ç®„ÇØ„Çπ„Éà„É´„Éº„ÉÄ„ÉºË®≠ÂÆö„Åå„ÅÇ„Çã„Åã„ÄÅAMS„ÅßÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆö„Åï„Çå„Åü„Åã
                            const bodyExt = (item.data && item.data.bodyExtruder) || (amsConfig.bodyExtruderSet ? amsConfig.bodyExtruder : null);
                            const textExt = (item.data && item.data.textExtruder) || (amsConfig.textExtruderSet ? amsConfig.textExtruder : null);
                            
                            // ÂØæÂøú„Åô„Çã„Çπ„É≠„ÉÉ„Éà„Å´Ëâ≤„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                            const hasBodyColor = bodyExt && bodyExt >= 1 && bodyExt <= allSlots.length && allSlots[bodyExt - 1] && allSlots[bodyExt - 1].color;
                            const hasTextColor = textExt && textExt >= 1 && textExt <= allSlots.length && allSlots[textExt - 1] && allSlots[textExt - 1].color;
                            
                            const itemNum = `#${idx + 1}`;
                            const bodyFil = tWarn.warning_body_filament || 'Êú¨‰Ωì„Éï„Ç£„É©„É°„É≥„Éà';
                            const textFil = tWarn.warning_text_filament || 'ÊñáÂ≠ó„Éï„Ç£„É©„É°„É≥„Éà';
                            const bothFil = tWarn.warning_both_filament || '‰∏°Êñπ';
                            
                            if (!hasBodyColor && !hasTextColor) {
                                warnings.push(`${itemNum}„Äå${item.name}„Äç${bodyFil}, ${textFil} ${bothFil}`);
                            } else if (!hasBodyColor) {
                                warnings.push(`${itemNum}„Äå${item.name}„Äç${bodyFil}`);
                            } else if (!hasTextColor) {
                                warnings.push(`${itemNum}„Äå${item.name}„Äç${textFil}`);
                            }
                        });
                        
                        if (warnings.length > 0) {
                            warningEl.style.display = 'block';
                            warningEl.innerHTML = `<span style="color:#ff5252;">‚ö†Ô∏è ${tWarn.warning_not_set || 'Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì'}:</span><br>` + 
                                warnings.map(w => `<span style="color:#ffab40; font-size:0.7rem;">‚Ä¢ ${w}</span>`).join('<br>');
                        } else {
                            warningEl.style.display = 'none';
                        }
                    }
                    
                    // ÊÉÖÂ†±Ë°®Á§∫„ÇíÊõ¥Êñ∞
                    function updateBatchExportInfo() {
                        const t = translations[currentLang] || translations.ja;
                        const nameList = items.map(item => item.name).join(', ');
                        const truncatedNames = nameList.length > 60 ? nameList.substring(0, 60) + '...' : nameList;
                        
                        // Ëâ≤Â§âÊõ¥„Åï„Çå„Åü„Ç¢„Ç§„ÉÜ„É†Êï∞„Çí„Ç´„Ç¶„É≥„Éà
                        const bodyColorCount = items.filter(item => item.data && item.data.colBody).length;
                        const textColorCount = items.filter(item => item.data && item.data.colText).length;
                        
                        infoEl.innerHTML = `
                            <div class="export-info-item">
                                <span class="export-info-label">${t.popup_file_count || '„Éï„Ç°„Ç§„É´Êï∞'}</span>
                                <span class="export-info-value highlight">${items.length} ${t.unit_items || '‰ª∂'}</span>
                            </div>
                            <div class="export-info-item">
                                <span class="export-info-label">üé® ${t.popup_body_color_set || 'Êú¨‰ΩìËâ≤Ë®≠ÂÆö'}</span>
                                <span class="export-info-value" style="color:#00e5ff;">${bodyColorCount} ${t.unit_items || '‰ª∂'}</span>
                            </div>
                            <div class="export-info-item">
                                <span class="export-info-label">üìù ${t.popup_text_color_set || 'ÊñáÂ≠óËâ≤Ë®≠ÂÆö'}</span>
                                <span class="export-info-value" style="color:#ff9800;">${textColorCount} ${t.unit_items || '‰ª∂'}</span>
                            </div>
                            <div class="export-info-item">
                                <span class="export-info-label">${t.popup_save_location || '‰øùÂ≠òÂÖà'}</span>
                                <span class="export-info-value">${t.popup_download_folder || '„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Éï„Ç©„É´„ÉÄ'}</span>
                            </div>
                        `;
                    }
                    
                    // „Éó„É¨„Éì„É•„ÉºÁîüÊàê
                    previewEl.innerHTML = '';
                    const t2 = translations[currentLang] || translations.ja;
                    items.forEach((item, idx) => {
                        const div = document.createElement('div');
                        div.className = 'batch-preview-item';
                        if (idx === 0) div.classList.add('selected');
                        div.title = `${item.name} - ${t2.click_to_select || '„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÅ∏Êäû'}`;
                        div.dataset.index = idx;
                        
                        const img = document.createElement('img');
                        img.src = item.thumbnail;
                        img.alt = item.name;
                        
                        const nameLabel = document.createElement('div');
                        nameLabel.className = 'batch-preview-name';
                        nameLabel.textContent = item.name;
                        
                        div.appendChild(img);
                        div.appendChild(nameLabel);
                        
                        // „ÇØ„É™„ÉÉ„ÇØ„ÅßÈÅ∏Êäû
                        div.onclick = () => {
                            // ‰ª•Ââç„ÅÆÈÅ∏Êäû„ÇíËß£Èô§
                            previewEl.querySelectorAll('.batch-preview-item').forEach(el => {
                                el.classList.remove('selected');
                            });
                            // Êñ∞„Åó„ÅÑÈÅ∏Êäû
                            div.classList.add('selected');
                            selectedIndex = idx;
                            renderBatchAMSPalette();
                            updateSelectedPreview(); // 3D„Éó„É¨„Éì„É•„Éº„ÇíÊõ¥Êñ∞
                        };
                        
                        previewEl.appendChild(div);
                    });
                    
                    // ÂàùÊúüÊÉÖÂ†±Ë°®Á§∫
                    updateBatchExportInfo();
                    
                    // AMS„Éë„É¨„ÉÉ„Éà„ÇíÂàùÊúüÊèèÁîª
                    renderBatchAMSPalette();
                    
                    // ÂàùÊúü„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØ„Å®Ë≠¶Âëä„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫
                    updatePreviewColors();
                    
                    // ÂàùÊúü3D„Éó„É¨„Éì„É•„Éº„ÇíË°®Á§∫
                    updateSelectedPreview();
                    
                    // „Éï„Ç©„Éº„Éû„ÉÉ„ÉàÈÅ∏Êäû„ÅÆÂ§âÊõ¥„ÇíÁõ£Ë¶ñ
                    const formatInputs = document.querySelectorAll('input[name="batch-export-format"]');
                    const updateFormatBadge = () => {
                        const selected = document.querySelector('input[name="batch-export-format"]:checked');
                        if (selected) {
                            const format = selected.value.toUpperCase();
                            formatBadge.textContent = format;
                            if (format === '3MF') {
                                formatBadge.style.background = '#4caf50';
                            } else if (format === 'OBJ') {
                                formatBadge.style.background = '#ff9800';
                            } else {
                                formatBadge.style.background = '#4fc3f7';
                            }
                        }
                    };
                    formatInputs.forEach(input => {
                        input.addEventListener('change', updateFormatBadge);
                    });
                    updateFormatBadge();
                    
                    // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóË°®Á§∫
                    overlay.style.display = 'flex';
                    requestAnimationFrame(() => {
                        overlay.style.background = 'rgba(0,0,0,0.7)';
                        popup.classList.add('show');
                    });
                    
                    // „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÈñ¢Êï∞
                    const cleanup = () => {
                        // 3D„É¨„É≥„ÉÄ„É©„Éº„ÇíÁ†¥Ê£Ñ
                        if (thumbRenderer) {
                            thumbRenderer.dispose();
                            thumbRenderer = null;
                        }
                        if (preview3dEl) preview3dEl.innerHTML = '';
                        
                        overlay.style.background = 'rgba(0,0,0,0)';
                        popup.classList.remove('show');
                        setTimeout(() => {
                            overlay.style.display = 'none';
                        }, 300);
                        confirmBtn.onclick = null;
                        cancelBtn.onclick = null;
                        formatInputs.forEach(input => {
                            input.removeEventListener('change', updateFormatBadge);
                        });
                    };
                    
                    confirmBtn.onclick = () => {
                        const selectedFormat = document.querySelector('input[name="batch-export-format"]:checked');
                        const format = selectedFormat ? selectedFormat.value : 'stl';
                        cleanup();
                        resolve({ confirmed: true, format: format, items: items });
                    };
                    
                    cancelBtn.onclick = () => {
                        cleanup();
                        resolve({ confirmed: false });
                    };
                    
                    overlay.onclick = (e) => {
                        if (e.target === overlay) {
                            cleanup();
                            resolve({ confirmed: false });
                        }
                    };
                };
            });
        }
        
        // ‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÂÆüË°åÔºàÁ¢∫Ë™çÁîªÈù¢ÁµåÁî±Ôºâ
        async function executeBatchExport() {
            const result = await showBatchExportPopup();
            
            if (!result.confirmed) return;
            
            const { format, items } = result;
            
            showToast(`${items.length}‰ª∂„Çí${format.toUpperCase()}„Åß‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÈñãÂßã...`);
            
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                Object.assign(state, item.state);
                
                // Á¢∫Ë™çÁîªÈù¢„ÅßÂ§âÊõ¥„Åï„Çå„ÅüËâ≤ÊÉÖÂ†±„ÇíÈÅ©Áî®
                if (item.data) {
                    if (item.data.colBody) state.colBody = item.data.colBody;
                    if (item.data.colText) state.colText = item.data.colText;
                    if (item.data.bodyExtruder) state.bodyExtruder = item.data.bodyExtruder;
                    if (item.data.textExtruder) state.textExtruder = item.data.textExtruder;
                }
                
                syncUI();
                requestUpdate();
                
                // „É¢„Éá„É´Êõ¥Êñ∞„ÇíÂæÖ„Å§
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // „ÇÆ„É£„É©„É™„ÉºÂ∞ÇÁî®„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÈñ¢Êï∞„Çí‰ΩøÁî®
                if (format === 'stl') {
                    galleryExportSTL(item.name);
                } else if (format === '3mf') {
                    await galleryExport3MF(item.name);
                } else if (format === 'obj') {
                    galleryExportOBJ(item.name);
                }
                
                // „ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÈñìÈöî„ÇíÁ©∫„Åë„Çã
                await new Promise(resolve => setTimeout(resolve, 800));
            }
            
            showToast(`${items.length}‰ª∂„ÅÆ„Ç®„ÇØ„Çπ„Éù„Éº„Éà„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü`);
        }

        function createStemAndRibs(p, useCSG = false) {
            const thick = state.wallThickness; 
            const rawH = p.h; 
            const clear = state.stemClearance; 
            const ext = state.enableStemExtension ? state.stemExtension : 0.0; 
            const rOuter = state.stemDiameter / 2;
            const stemGeos = []; 
            const type = state.stemType || 'mx';
            
            // „Çπ„ÉÜ„É†„ÅÆÂü∫Êú¨È´ò„Åï„ÇíË®àÁÆóÔºàÁ™Å„ÅçÊäú„ÅëÈò≤Ê≠¢„ÅÆ„Åü„ÇÅ„ÄÅ„Éó„É≠„Éï„Ç°„Ç§„É´È´ò„Åï„Åã„Çâ„Éà„ÉÉ„ÉóÂéö„Åø„ÇíÂºï„ÅèÔºâ
            const safeTopY = getSurfaceHeight(0, 0, p) - thick - 0.2;
            let totalStemH = rawH + ext;
            
            // Choc/Topre„ÅÆÂ†¥Âêà„ÅØÈ´ò„Åï„ÇíÂà∂Èôê
            const isRestrictedStem = (type === 'choc' || type === 'topre');
            if (isRestrictedStem) {
                totalStemH = Math.min(totalStemH, safeTopY + ext);
            }
            
            if(state.keyShapeType === 'iso-enter') {
                const isoStemH = (rawH - thick) + ext;
                
                const stemX = state.isoStemX;
                const switchZ = state.isoStemZ;
                const stabTopZ = state.isoStabTopZ;
                const stabBottomZ = state.isoStabBottomZ;
                
                const mainStem = createStemUnit(isoStemH, rOuter, clear);
                if(ext > 0) mainStem.translate(0, -ext, 0);
                mainStem.translate(stemX, 0, switchZ); 
                stemGeos.push(mainStem);
                
                const stabTop = createStemUnit(isoStemH, rOuter, clear);
                if(ext > 0) stabTop.translate(0, -ext, 0);
                stabTop.translate(stemX, 0, stabTopZ);
                stemGeos.push(stabTop);

                const stabBottom = createStemUnit(isoStemH, rOuter, clear);
                if(ext > 0) stabBottom.translate(0, -ext, 0);
                stabBottom.translate(stemX, 0, stabBottomZ);
                stemGeos.push(stabBottom);

            } else {
                // V67: Êã°Âºµ„Çπ„ÉÜ„É†„Çø„Ç§„ÉóÂØæÂøú
                const cStem = createExtendedStem(totalStemH, rOuter, clear, p); 
                if (cStem) {
                    if (ext > 0) cStem.translate(0, -ext, 0);
                    if (state.boxStem) { 
                        const boxSize = 5.6 + clear; const boxH = totalStemH * 0.8; const wWall = 0.8; const bS = boxSize + wWall*2; 
                        const front = new THREE.BoxGeometry(bS, boxH, wWall); front.translate(0, boxH/2-ext, boxSize/2+wWall/2); 
                        const back = new THREE.BoxGeometry(bS, boxH, wWall); back.translate(0, boxH/2-ext, -(boxSize/2+wWall/2)); 
                        const left = new THREE.BoxGeometry(wWall, boxH, boxSize); left.translate(-(boxSize/2+wWall/2), boxH/2-ext, 0); 
                        const right = new THREE.BoxGeometry(wWall, boxH, boxSize); right.translate(boxSize/2+wWall/2, boxH/2-ext, 0); 
                        stemGeos.push(front, back, left, right); 
                    }
                    stemGeos.push(cStem);

                    // „Çπ„Çø„Éì„É©„Ç§„Ç∂„ÉºÔºàChoc„Å®Topre„ÅØ„Çπ„Çø„Éì„ÅåË§áÈõë„Å™„ÅÆ„ÅßÁúÅÁï•Ôºâ
                    if (!isRestrictedStem) {
                        const stabOffset = getStabilizerOffset(state.uSize);
                        if(stabOffset > 0) { 
                            const sL = createExtendedStem(totalStemH, rOuter, clear, p); if(sL) { if(ext > 0) sL.translate(0, -ext, 0); sL.translate(-stabOffset, 0, 0); stemGeos.push(sL); }
                            const sR = createExtendedStem(totalStemH, rOuter, clear, p); if(sR) { if(ext > 0) sR.translate(0, -ext, 0); sR.translate(stabOffset, 0, 0); stemGeos.push(sR); }
                        }
                    }
                }
            }
            
            const ribGeos = [];
            
            const isNonRectangularNoRib = state.keyShapeType === 'circle' || 
                                          state.keyShapeType === 'polygon' || 
                                          state.keyShapeType === 'star' ||
                                          state.keyShapeType === 'iso-enter' ||
                                          (state.keyShapeType === 'rounded' && state.roundCorner > 0.1);

            if(state.enableRibs && !state.boxStem && !isNonRectangularNoRib) {
                const shorten = state.ribShorten;
                // Topre/Choc„ÅÆÂ†¥Âêà„ÅØ„É™„Éñ„Çí„Åï„Çâ„Å´Áü≠„ÅèÔºàÂ∫ï‰∏ä„ÅíÔºâ„Åó„Å¶Âπ≤Ê∏â„ÇíÈò≤„Åê
                const extraShorten = isRestrictedStem ? 2.0 : 0.0;
                
                const ribH = rawH - shorten - extraShorten; 
                const ribY = shorten + extraShorten; 
                const ribThick = 1.2;
                const overlap = useCSG ? 0.8 : 0.4;
                
                // Â§©Èù¢„ÇíÁ™Å„ÅçÊäú„Åë„Å™„ÅÑ„Çà„ÅÜ„Å´È´ò„Åï„Çí„ÇØ„É©„É≥„Éó
                const maxRibH = safeTopY - ribY;
                const finalRibH = Math.min(ribH, maxRibH);
                
                if(finalRibH > 0.1) {
                    const endX = (p.baseW/2)-thick+0.5; const lx = (endX + overlap) - (rOuter - overlap); 
                    if(lx>0) { 
                        const rX = new THREE.BoxGeometry(lx, finalRibH, ribThick); const cx = (rOuter - overlap) + lx/2; 
                        const r1 = rX.clone(); r1.translate(cx, ribY+finalRibH/2, 0); 
                        const r2 = rX.clone(); r2.translate(-cx, ribY+finalRibH/2, 0); 
                        ribGeos.push(r1, r2); 
                    }
                    // Choc„ÅÆÂ†¥Âêà„ÅØZÊñπÂêë„ÅÆ„É™„Éñ„ÇíÈÅø„Åë„ÇãÔºà„Çπ„ÉÜ„É†„Å®Âπ≤Ê∏â„Åô„Çã„Åü„ÇÅÔºâ
                    if (type !== 'choc') {
                        const endZ = (p.baseD/2)-thick+0.5; const lz = (endZ + overlap) - (rOuter - overlap); 
                        if(lz>0) { 
                            const rZ = new THREE.BoxGeometry(ribThick, finalRibH, lz); const cz = (rOuter - overlap) + lz/2; 
                            const r3 = rZ.clone(); r3.translate(0, ribY+finalRibH/2, cz); 
                            const r4 = rZ.clone(); r4.translate(0, ribY+finalRibH/2, -cz); 
                            ribGeos.push(r3, r4); 
                        }
                    }
                }
            }
            
            let merged;
            if (useCSG) {
                merged = csgUnion([...stemGeos, ...ribGeos]);
                if (merged) {
                    merged = BufferGeometryUtils.mergeVertices(merged, 0.0001);
                    merged.computeVertexNormals();
                }
                return merged;
            } else {
                merged = safeMerge([...stemGeos, ...ribGeos]);
            }
            
            if(merged && !useCSG) { 
                const pos = merged.attributes.position; 
                const v = new THREE.Vector3(); 
                merged.computeBoundingBox(); 
                const maxY = merged.boundingBox.max.y; 
                const twistRad = THREE.MathUtils.degToRad(state.twist); 
                const twistPerUnit = twistRad / p.h; 
                
                for(let i=0; i<pos.count; i++){ 
                    v.fromBufferAttribute(pos, i); 
                    
                    if (Math.abs(state.twist) > 0.1 && state.keyShapeType !== 'iso-enter') { 
                        const angle = twistPerUnit * v.y; 
                        const sinA = Math.sin(angle); 
                        const cosA = Math.cos(angle); 
                        const tx = v.x * cosA - v.z * sinA; 
                        const tz = v.x * sinA + v.z * cosA; 
                        v.x = tx; 
                        v.z = tz; 
                    } 
                    
                    const ratioY = Math.max(0, v.y / p.h); 
                    const dist = Math.sqrt(v.x*v.x + v.z*v.z); 
                    
                    if(dist > rOuter + 0.5) { 
                        const taper = THREE.MathUtils.lerp(1.0, state.topScale, ratioY); 
                        v.x *= taper; 
                        v.z *= taper; 
                    } 
                    
                    if(state.keyShapeType !== 'iso-enter' && v.y > maxY - 1.0) { 
                        const sy = getSurfaceHeight(v.x, v.z, p); 
                        v.y = sy - thick; 
                    } 
                    
                    pos.setXYZ(i, v.x, v.y, v.z); 
                } 
                merged.computeVertexNormals(); 
            }
            return merged;
        }

        function createHomingBump(p) { if (state.legoStud) { const r = 2.4 + (state.legoClear || 0); const stud = new THREE.CylinderGeometry(r, r, 1.8, 24); const bx = state.legoX; const bz = state.legoZ; const y = getSurfaceHeight(bx, bz, p); stud.translate(bx, y + 0.9 + state.legoY, bz); stud.rotateX(THREE.MathUtils.degToRad(p.angle)); return stud; } if(!state.homingBump) return null; const bx = state.bumpX; const bz = state.bumpZ; const y = getSurfaceHeight(bx, bz, p); let geo; if(state.homingType === 'round') { geo = new THREE.SphereGeometry(0.6, 12, 12); geo.scale(1, 0.6, 1); } else { geo = new THREE.BoxGeometry(4.0, 0.5, 0.8); } geo.translate(bx, y + state.bumpOffsetY, bz); geo.rotateX(THREE.MathUtils.degToRad(p.angle)); if (Math.abs(state.twist) > 0.1) { const twistRad = THREE.MathUtils.degToRad(state.twist); const angle = (twistRad / p.h) * y; geo.rotateY(-angle); } return geo; }

        function createConformedText(p, textVal, sizeVal, xVal, zVal, mode) {
            if (!loadedFonts[state.font] || !textVal) return null;
            
            let genHeight = state.textHeight;
            let yEmbedOffset = 0;

            if (mode === 'engrave') {
                genHeight = state.textHeight + 5.0;
                yEmbedOffset = -state.textHeight;
            } else if (mode === 'doubleshot') {
                genHeight = state.wallThickness + 0.5;
                yEmbedOffset = -genHeight + 0.02;
            } else if (mode === 'lithophane') {
                const thinLayer = 0.3;
                genHeight = state.wallThickness - thinLayer + 0.5;
                yEmbedOffset = -(state.wallThickness - thinLayer);
            }
            
            yEmbedOffset += state.textOffsetY;

            const lines = textVal.split('\n'); 
            const font = loadedFonts[state.font]; 
            const size = sizeVal; 
            const lineHeight = size * 1.2; 
            const lineGeos = [];
            
            lines.forEach((lineText, i) => { 
                if(!lineText) return; 
                const geo = new TextGeometry(lineText, { font: font, size: size, height: genHeight, curveSegments: 6, bevelEnabled: false }); 
                geo.computeBoundingBox(); 
                const cx = -0.5 * (geo.boundingBox.max.x + geo.boundingBox.min.x); 
                const cy = -0.5 * (geo.boundingBox.max.y + geo.boundingBox.min.y); 
                geo.translate(cx, cy, 0); 
                lineGeos.push({ geo: geo, index: i }); 
            });
            
            const mergedLines = []; 
            const blockYOffset = (lines.length - 1) * lineHeight / 2;
            lineGeos.forEach(item => { 
                const yPos = blockYOffset - (item.index * lineHeight); 
                item.geo.translate(0, yPos, 0); 
                mergedLines.push(item.geo); 
            });
            
            if(mergedLines.length === 0) return null; 
            const combinedGeo = BufferGeometryUtils.mergeGeometries(mergedLines);
            
            if (!state.textConform) {
                combinedGeo.rotateX(-Math.PI/2);
                const sy = getSurfaceHeight(xVal, zVal, p);
                combinedGeo.translate(xVal, sy + yEmbedOffset, zVal);
                combinedGeo.rotateX(THREE.MathUtils.degToRad(p.angle));
                return combinedGeo;
            } else {
                const pos = combinedGeo.attributes.position; 
                const v = new THREE.Vector3();
                const twistRad = THREE.MathUtils.degToRad(state.twist); 
                const twistPerUnit = twistRad / p.h;
                
                for(let i=0; i<pos.count; i++) {
                    v.fromBufferAttribute(pos, i);
                    const targetX = v.x + xVal;
                    const targetZ = -v.y + zVal;
                    const thicknessOffset = v.z;
                    const surfY = getSurfaceHeight(targetX, targetZ, p);
                    let finalX = targetX; 
                    let finalZ = targetZ;
                    if (Math.abs(state.twist) > 0.1) {
                        const angle = twistPerUnit * surfY;
                        const sinA = Math.sin(angle); 
                        const cosA = Math.cos(angle);
                        finalX = targetX * cosA - targetZ * sinA;
                        finalZ = targetX * sinA + targetZ * cosA;
                    }
                    pos.setXYZ(i, finalX, surfY + thicknessOffset + yEmbedOffset, finalZ);
                }
                combinedGeo.computeVertexNormals();
                return combinedGeo;
            }
        }

        function createSidePrint(p, mode) { 
            if (!state.enableSide || !state.sideText || !loadedFonts[state.font]) return null; 
            const geo = new TextGeometry(state.sideText, {font: loadedFonts[state.font], size: state.sideSize, height: 0.5, curveSegments: 4, bevelEnabled: false}); 
            geo.computeBoundingBox(); 
            geo.translate(-0.5*(geo.boundingBox.max.x+geo.boundingBox.min.x), -0.5*(geo.boundingBox.max.y+geo.boundingBox.min.y), 0); 
            geo.rotateX(THREE.MathUtils.degToRad(state.sideRot)); 
            geo.translate(0, p.h/2 + state.sideY, 0); 
            const pos = geo.attributes.position; 
            const v = new THREE.Vector3(); 
            let depthOffset = 0.05; 
            if (mode === 'doubleshot') depthOffset = -0.5; 
            else if (mode === 'engrave') depthOffset = -0.4; 
            for(let i=0; i<pos.count; i++) { 
                v.fromBufferAttribute(pos, i); 
                const s = THREE.MathUtils.lerp(1.0, state.topScale, Math.max(0,Math.min(1,v.y/p.h))); 
                v.z += (p.baseD/2)*s + depthOffset; 
                pos.setXYZ(i, v.x, v.y, v.z); 
            } 
            geo.computeVertexNormals(); 
            return geo; 
        }
        function createConformedSVG(p, mode) {
            if (!state.svgContent || !state.svgVisible) return null;
            const loader = new SVGLoader();
            const data = loader.parse(state.svgContent);
            const thick = state.wallThickness;
            
            let globalMinX = Infinity, globalMaxX = -Infinity, globalMinY = Infinity, globalMaxY = -Infinity;
            const allShapes = [];
            data.paths.forEach(path => {
                const pathShapes = SVGLoader.createShapes(path);
                pathShapes.forEach(shape => {
                    allShapes.push(shape);
                    const pts = shape.getPoints();
                    pts.forEach(pt => {
                        if(pt.x < globalMinX) globalMinX = pt.x;
                        if(pt.x > globalMaxX) globalMaxX = pt.x;
                        if(pt.y < globalMinY) globalMinY = pt.y;
                        if(pt.y > globalMaxY) globalMaxY = pt.y;
                    });
                });
            });
            if (allShapes.length === 0) return null;
            
            const globalW = globalMaxX - globalMinX;
            const globalH = globalMaxY - globalMinY;
            const globalArea = globalW * globalH;
            
            const shapeData = allShapes.map((shape, idx) => {
                const pts = shape.getPoints();
                let sMinX = Infinity, sMaxX = -Infinity, sMinY = Infinity, sMaxY = -Infinity;
                pts.forEach(pt => {
                    if(pt.x < sMinX) sMinX = pt.x; if(pt.x > sMaxX) sMaxX = pt.x;
                    if(pt.y < sMinY) sMinY = pt.y; if(pt.y > sMaxY) sMaxY = pt.y;
                });
                return { shape, idx, areaRatio: (globalArea > 0) ? ((sMaxX-sMinX)*(sMaxY-sMinY) / globalArea) : 0 };
            });
            
            const validShapes = [];
            shapeData.forEach((sd, i) => {
                const isBackground = (sd.areaRatio > 0.80 && allShapes.length > 1) || (i === 0 && sd.areaRatio > 0.70 && allShapes.length > 1);
                if (!isBackground) validShapes.push(sd.shape);
            });
            if(validShapes.length === 0) return null;
            
            const maxEngraveDepth = thick - 0.5;
            let effectiveSvgThickness = state.svgThickness;
            if ((mode === 'engrave' || mode === 'doubleshot') && effectiveSvgThickness > maxEngraveDepth) {
                effectiveSvgThickness = maxEngraveDepth;
            }
            let genThick = effectiveSvgThickness;
            let yEmbedOffset = (mode === 'engrave' || mode === 'doubleshot') ? 0.02 : 0;
            yEmbedOffset += state.svgOffsetY;
            
            let geo = new THREE.ExtrudeGeometry(validShapes, {depth: genThick, bevelEnabled: false});
            geo.computeBoundingBox();
            const c = new THREE.Vector3();
            geo.boundingBox.getCenter(c);
            geo.translate(-c.x, -c.y, 0);
            geo.scale(0.1*state.svgScale, -0.1*state.svgScale, 1.0);
            geo.rotateZ(THREE.MathUtils.degToRad(state.svgRotZ));
            geo = BufferGeometryUtils.mergeVertices(geo, 0.001);
            geo.computeVertexNormals();
            
            if(!state.svgConform) {
                geo.rotateX(Math.PI/2);
                geo.rotateX(THREE.MathUtils.degToRad(state.svgRotX));
                geo.rotateY(THREE.MathUtils.degToRad(state.svgRotY));
                if (mode === 'engrave' || mode === 'doubleshot') { geo.scale(1, -1, 1); geo.translate(0, genThick, 0); }
                geo.rotateX(THREE.MathUtils.degToRad(p.angle));
                const sy = getSurfaceHeight(state.svgPosX, state.svgPosZ, p);
                geo.translate(state.svgPosX, sy + yEmbedOffset, state.svgPosZ);
                return geo;
            } else {
                const pos = geo.attributes.position;
                const v = new THREE.Vector3();
                for(let i=0; i<pos.count; i++) {
                    v.fromBufferAttribute(pos, i);
                    const tx = v.x + state.svgPosX;
                    const tz = -v.y + state.svgPosZ;
                    const sy = getSurfaceHeight(tx, tz, p);
                    const depthOffset = (mode === 'engrave' || mode === 'doubleshot') ? -v.z : v.z;
                    pos.setXYZ(i, tx, sy + depthOffset + yEmbedOffset, tz);
                }
                geo.computeVertexNormals();
                return geo;
            }
        }

        function createConformedSVGForExport(p, mode) {
            if (!state.svgContent || !state.svgVisible) return null;
            const loader = new SVGLoader();
            const data = loader.parse(state.svgContent);
            const thick = state.wallThickness;
            
            let globalMinX = Infinity, globalMaxX = -Infinity, globalMinY = Infinity, globalMaxY = -Infinity;
            const allShapes = [];
            data.paths.forEach(path => {
                const pathShapes = SVGLoader.createShapes(path);
                pathShapes.forEach(shape => {
                    allShapes.push(shape);
                    const pts = shape.getPoints();
                    pts.forEach(pt => {
                        if(pt.x < globalMinX) globalMinX = pt.x;
                        if(pt.x > globalMaxX) globalMaxX = pt.x;
                        if(pt.y < globalMinY) globalMinY = pt.y;
                        if(pt.y > globalMaxY) globalMaxY = pt.y;
                    });
                });
            });
            if (allShapes.length === 0) return null;
            
            const globalW = globalMaxX - globalMinX;
            const globalH = globalMaxY - globalMinY;
            const globalArea = globalW * globalH;
            const globalCenterX = (globalMinX + globalMaxX) / 2;
            const globalCenterY = (globalMinY + globalMaxY) / 2;
            
            const shapeData = allShapes.map((shape, idx) => {
                const pts = shape.getPoints();
                let sMinX = Infinity, sMaxX = -Infinity, sMinY = Infinity, sMaxY = -Infinity;
                pts.forEach(pt => {
                    if(pt.x < sMinX) sMinX = pt.x; if(pt.x > sMaxX) sMaxX = pt.x;
                    if(pt.y < sMinY) sMinY = pt.y; if(pt.y > sMaxY) sMaxY = pt.y;
                });
                const sW = sMaxX - sMinX;
                const sH = sMaxY - sMinY;
                const sArea = sW * sH;
                const areaRatio = (globalArea > 0) ? (sArea / globalArea) : 0;
                return { shape, idx, areaRatio, numPts: pts.length };
            });
            
            const validShapes = [];
            shapeData.forEach((sd, i) => {
                const isBackground =
                    (sd.areaRatio > 0.80 && allShapes.length > 1) ||
                    (i === 0 && sd.areaRatio > 0.70 && allShapes.length > 1);
                
                if (isBackground) {
                    console.log("V63.3.1: Removed background shape #" + sd.idx + " (area:" + (sd.areaRatio*100).toFixed(1) + "%, pts:" + sd.numPts + ")");
                } else {
                    validShapes.push(sd.shape);
                }
            });
            
            if(validShapes.length === 0) return null;
            
            const maxEngraveDepth = thick - 0.5;
            let effectiveSvgThickness = state.svgThickness;
            if ((mode === 'engrave' || mode === 'doubleshot') && effectiveSvgThickness > maxEngraveDepth) {
                effectiveSvgThickness = maxEngraveDepth;
                console.log("V63.3.1: SVG depth limited to " + effectiveSvgThickness.toFixed(2) + "mm");
            }
            
            let genThick = effectiveSvgThickness;
            let yEmbedOffset = 0;
            
            const embedIntoBody = 0.3;
            
            if (mode === 'emboss') {
                genThick = effectiveSvgThickness + embedIntoBody;
                yEmbedOffset = -embedIntoBody;
            } else if (mode === 'engrave') {
                genThick = effectiveSvgThickness;
                yEmbedOffset = 0.02;
            } else if (mode === 'doubleshot') {
                genThick = effectiveSvgThickness;
                yEmbedOffset = 0.02;
            }
            yEmbedOffset += state.svgOffsetY;
            
            const extrudedGeos = [];
            for (const shape of validShapes) {
                try {
                    const simplifiedShape = simplifyShape(shape, 0.5);
                    
                    let shapeGeo = new THREE.ExtrudeGeometry([simplifiedShape], {
                        depth: genThick, 
                        bevelEnabled: false,
                        curveSegments: 4
                    });
                    
                    shapeGeo.translate(-globalCenterX, -globalCenterY, 0);
                    
                    shapeGeo.scale(0.1 * state.svgScale, -0.1 * state.svgScale, 1.0);
                    shapeGeo.rotateZ(THREE.MathUtils.degToRad(state.svgRotZ));
                    
                    shapeGeo = BufferGeometryUtils.mergeVertices(shapeGeo, 0.08);
                    shapeGeo.computeVertexNormals();
                    
                    extrudedGeos.push(shapeGeo);
                } catch (e) {
                    console.warn("SVG shape extrude failed:", e);
                }
            }
            
            if (extrudedGeos.length === 0) return null;
            
            let geo;
            if (extrudedGeos.length === 1) {
                geo = extrudedGeos[0];
            } else {
                try {
                    console.log("V63.3.1: Merging " + extrudedGeos.length + " SVG shapes with CSG Union...");
                    geo = extrudedGeos[0];
                    for (let i = 1; i < extrudedGeos.length; i++) {
                        const b1 = new Brush(geo); b1.updateMatrixWorld();
                        const b2 = new Brush(extrudedGeos[i]); b2.updateMatrixWorld();
                        const res = csgEvaluator.evaluate(b1, b2, ADDITION);
                        geo = res.geometry;
                    }
                    geo = BufferGeometryUtils.mergeVertices(geo, 0.08);
                    geo.computeVertexNormals();
                    console.log("V63.3.1: CSG Union complete");
                } catch (e) {
                    console.warn("SVG CSG Union failed, falling back to merge:", e);
                    geo = BufferGeometryUtils.mergeGeometries(extrudedGeos);
                    geo = BufferGeometryUtils.mergeVertices(geo, 0.08);
                    geo.computeVertexNormals();
                }
            }
            
            if(!state.svgConform) {
                geo.rotateX(Math.PI/2);
                geo.rotateX(THREE.MathUtils.degToRad(state.svgRotX));
                geo.rotateY(THREE.MathUtils.degToRad(state.svgRotY));
                if (mode === 'engrave' || mode === 'doubleshot') {
                    geo.scale(1, -1, 1);
                    geo.translate(0, genThick, 0);
                }
                geo.rotateX(THREE.MathUtils.degToRad(p.angle));
                const sy = getSurfaceHeight(state.svgPosX, state.svgPosZ, p);
                geo.translate(state.svgPosX, sy + yEmbedOffset, state.svgPosZ);
                geo = BufferGeometryUtils.mergeVertices(geo, 0.08);
                geo.computeVertexNormals();
                return geo;
            } else {
                const pos = geo.attributes.position;
                const v = new THREE.Vector3();
                for(let i=0; i<pos.count; i++) {
                    v.fromBufferAttribute(pos, i);
                    const tx = v.x + state.svgPosX;
                    const tz = -v.y + state.svgPosZ;
                    const sy = getSurfaceHeight(tx, tz, p);
                    const depthOffset = (mode === 'engrave' || mode === 'doubleshot') ? -v.z : v.z;
                    pos.setXYZ(i, tx, sy + depthOffset + yEmbedOffset, tz);
                }
                geo = BufferGeometryUtils.mergeVertices(geo, 0.08);
                geo.computeVertexNormals();
                return geo;
            }
        }
        
        function simplifyShape(shape, tolerance) {
            const simplifyPoints = (points, tol) => {
                if (points.length <= 2) return points;
                
                const result = [points[0]];
                let lastPoint = points[0];
                
                for (let i = 1; i < points.length - 1; i++) {
                    const dist = Math.sqrt(
                        Math.pow(points[i].x - lastPoint.x, 2) + 
                        Math.pow(points[i].y - lastPoint.y, 2)
                    );
                    if (dist >= tol) {
                        result.push(points[i]);
                        lastPoint = points[i];
                    }
                }
                
                result.push(points[points.length - 1]);
                return result;
            };
            
            const mainPoints = shape.getPoints(12);
            const simplifiedMain = simplifyPoints(mainPoints, tolerance);
            
            const newShape = new THREE.Shape(simplifiedMain);
            
            if (shape.holes && shape.holes.length > 0) {
                for (const hole of shape.holes) {
                    const holePoints = hole.getPoints(12);
                    const simplifiedHole = simplifyPoints(holePoints, tolerance);
                    if (simplifiedHole.length >= 3) {
                        newShape.holes.push(new THREE.Path(simplifiedHole));
                    }
                }
            }
            
            return newShape;
        }

        function updateModel() {
            mainGroup.rotation.x = THREE.MathUtils.degToRad(state.globalRotX);
            mainGroup.rotation.y = THREE.MathUtils.degToRad(state.globalRotY);
            const p = getParams();
            let bodyMat, textMat;
            
            if (state.renderMode === 'wireframe') {
                bodyMat = new THREE.MeshBasicMaterial({ color: state.colBody, wireframe: true });
                textMat = new THREE.MeshBasicMaterial({ color: state.colText, wireframe: true });
            } else {
                let map = null;
                if (state.imgContent && state.imgTextureVisible) {
                    map = textureLoader.load(state.imgContent);
                    map.wrapS = THREE.ClampToEdgeWrapping;
                    map.wrapT = THREE.ClampToEdgeWrapping;
                    map.minFilter = THREE.LinearFilter;
                }
                bodyMat = new THREE.MeshStandardMaterial({ color: state.colBody, roughness: 0.6, metalness: 0.1, side: THREE.DoubleSide, map: map });
                textMat = new THREE.MeshStandardMaterial({ color: state.colText, side: THREE.DoubleSide });
            }
            
            // „Éú„Éá„Ç£„Çí‰ΩúÊàê
            const bodyGeo = createBodyParts(p, false);
            const stem = createStemAndRibs(p, false);
            const bump = createHomingBump(p);
            let finalKeycapGeo = safeMerge([bodyGeo, stem, bump]);
            
            mainGroup.clear();
            const textGeos = [];
            const engraveGeos = [];
            
            const handleGeo = (geo, mode) => {
                if (!geo) return;
                if (mode === 'emboss') {
                    textGeos.push(geo);
                } else if (mode === 'engrave') {
                    engraveGeos.push(geo);
                } else if (mode === 'doubleshot') {
                    textGeos.push(geo);
                    engraveGeos.push(geo.clone());
                } else if (mode === 'lithophane') {
                    engraveGeos.push(geo);
                }
            };
            
            if (state.enableText && loadedFonts[state.font]) {
                handleGeo(createConformedText(p, state.text, state.fontSize, state.posX, state.posZ, state.textMode), state.textMode);
            }
            if (state.enableText2 && loadedFonts[state.font]) {
                handleGeo(createConformedText(p, state.text2, state.text2Size, state.text2X, state.text2Z, state.text2Mode), state.text2Mode);
            }
            if(state.enableSide) {
                handleGeo(createSidePrint(p, state.sideMode), state.sideMode);
            }
            if (state.svgContent && state.svgVisible) {
                handleGeo(createConformedSVG(p, state.svgMode), state.svgMode);
            }
            
            let finalTextGeo = safeMerge(textGeos);
            let finalEngraveGeo = safeMerge(engraveGeos);
            
            let importedGeo = null;
            if(importedModelBuffer && state.modelVisible) {
                importedGeo = new STLLoader().parse(importedModelBuffer);
                importedGeo.scale(state.modelScale, state.modelScale, state.modelScale);
                importedGeo.rotateX(THREE.MathUtils.degToRad(state.modelRX));
                importedGeo.rotateY(THREE.MathUtils.degToRad(state.modelRY));
                importedGeo.rotateZ(THREE.MathUtils.degToRad(state.modelRZ));
                importedGeo.translate(state.modelX, state.modelY, state.modelZ);
            }
            
            if (state.modelOperation === 'subtract' && importedGeo && finalKeycapGeo) {
                const b1 = new Brush(finalKeycapGeo); b1.updateMatrixWorld();
                const b2 = new Brush(importedGeo); b2.updateMatrixWorld();
                const res = csgEvaluator.evaluate(b1, b2, SUBTRACTION);
                finalKeycapGeo = res.geometry;
                importedGeo = null;
            }
            
            if (finalEngraveGeo && finalKeycapGeo) {
                const b1 = new Brush(finalKeycapGeo); b1.updateMatrixWorld();
                const b2 = new Brush(finalEngraveGeo); b2.updateMatrixWorld();
                const res = csgEvaluator.evaluate(b1, b2, SUBTRACTION);
                finalKeycapGeo = res.geometry;
            }
            
            if(finalKeycapGeo) {
                finalKeycapGeo.computeVertexNormals();
                const mesh = new THREE.Mesh(finalKeycapGeo, bodyMat);
                mesh.name = "KeycapBody";
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mainGroup.add(mesh);
            }
            if(finalTextGeo) {
                const mesh = new THREE.Mesh(finalTextGeo, textMat);
                mesh.name = "KeycapText";
                mainGroup.add(mesh);
            }
            if(importedGeo) {
                const mesh = new THREE.Mesh(importedGeo, textMat);
                mesh.name = "ImportedModel";
                mainGroup.add(mesh);
            }

            // V67: „Ç¨„É†„Éú„Éº„É´ÂÜç„Ç¢„Çø„ÉÉ„ÉÅÔºà„Éâ„É©„ÉÉ„Ç∞‰∏≠„ÅØ„Çπ„Ç≠„ÉÉ„ÉóÔºâ
            const gumballBtn = document.getElementById('hud-gumball-toggle');
            if (gumballBtn && gumballBtn.classList.contains('active') && !gumballDragging) {
                setTimeout(() => updateGumballAttachment(), 50);
            }
            
            calculateStats();
        }

        let debounceTimeout = null;
        function requestUpdate() {
            if(debounceTimeout) clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(updateModel, 100);
        }

        function cleanupGeometry(geometry) {
            if (!geometry) return null;
            let geo = geometry.clone();
            if (geo.index) geo = geo.toNonIndexed();
            geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
            geo.computeVertexNormals();
            return geo;
        }

        function repairMesh(geometry) {
            if (!geometry) return null;
            
            let geo = geometry;
            if (geo.index) {
                geo = geo.toNonIndexed();
            }
            
            const position = geo.attributes.position;
            const epsilon = 0.0001;
            const triangles = [];
            
            for (let i = 0; i < position.count; i += 3) {
                const v0 = new THREE.Vector3(position.getX(i), position.getY(i), position.getZ(i));
                const v1 = new THREE.Vector3(position.getX(i+1), position.getY(i+1), position.getZ(i+1));
                const v2 = new THREE.Vector3(position.getX(i+2), position.getY(i+2), position.getZ(i+2));
                
                const edge1 = new THREE.Vector3().subVectors(v1, v0);
                const edge2 = new THREE.Vector3().subVectors(v2, v0);
                const cross = new THREE.Vector3().crossVectors(edge1, edge2);
                const area = cross.length() / 2;
                
                if (area < epsilon) continue;
                
                if (v0.distanceTo(v1) < epsilon || v1.distanceTo(v2) < epsilon || v2.distanceTo(v0) < epsilon) continue;
                
                triangles.push({ v0, v1, v2, area });
            }
            
            const uniqueTriangles = [];
            const seen = new Set();
            
            for (const tri of triangles) {
                const cx = ((tri.v0.x + tri.v1.x + tri.v2.x) / 3).toFixed(3);
                const cy = ((tri.v0.y + tri.v1.y + tri.v2.y) / 3).toFixed(3);
                const cz = ((tri.v0.z + tri.v1.z + tri.v2.z) / 3).toFixed(3);
                const areaKey = tri.area.toFixed(4);
                const key = `${cx},${cy},${cz},${areaKey}`;
                
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueTriangles.push(tri);
                }
            }
            
            const newPositions = [];
            for (const tri of uniqueTriangles) {
                newPositions.push(tri.v0.x, tri.v0.y, tri.v0.z);
                newPositions.push(tri.v1.x, tri.v1.y, tri.v1.z);
                newPositions.push(tri.v2.x, tri.v2.y, tri.v2.z);
            }
            
            const newGeo = new THREE.BufferGeometry();
            newGeo.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
            
            const mergedGeo = BufferGeometryUtils.mergeVertices(newGeo, 0.0001);
            mergedGeo.computeVertexNormals();
            
            console.log(`Repair: ${position.count/3} -> ${uniqueTriangles.length} triangles`);
            
            return mergedGeo;
        }

        function buildExportGeometry() {
            try {
                const p = getParams();
                
                console.log("Building export geometry V67.2 (watertight body)...");
                
                // V67.2: Èï∑ÊñπÂΩ¢„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅØÊ∞¥ÂØÜ„Ç∑„Çß„É´„Çí‰ΩøÁî®
                let body;
                const isNonRectangular = state.keyShapeType === 'circle' || 
                                         state.keyShapeType === 'polygon' || 
                                         state.keyShapeType === 'star' ||
                                         state.keyShapeType === 'iso-enter' ||
                                         (state.keyShapeType === 'rounded' && state.roundCorner > 0.1);
                
                if (!isNonRectangular) {
                    // V67.3: CSG„Ç∑„Çß„É´„ÅØÂ¢ÉÁïå„Ç®„ÉÉ„Ç∏„ÇíÂ¢ó„ÇÑ„Åô„Åü„ÇÅ„ÄÅÂÖÉ„ÅÆcreateBodyParts„Çí‰ΩøÁî®
                    console.log("V67.3: Using original createBodyParts (CSG shell disabled)");
                    body = createBodyParts(p, false);
                } else {
                    // ÈùûÈï∑ÊñπÂΩ¢„ÅØÂæìÊù•ÈÄö„Çä
                    body = createBodyParts(p, false);
                }
                
                const stem = createStemAndRibs(p, false);
                const bump = createHomingBump(p);
                
                let bodyGeos = [body, stem, bump].filter(g => g != null);
                
                bodyGeos = bodyGeos.map(g => {
                    if (g.index) {
                        g = g.toNonIndexed();
                    }
                    // UV„Ç¢„Éà„É™„Éì„É•„Éº„Éà„ÇíÂâäÈô§Ôºà‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅÔºâ
                    if (g.attributes.uv) {
                        g.deleteAttribute('uv');
                    }
                    // normalÂ±ûÊÄß„ÇíÁ¢∫‰øù
                    if (!g.attributes.normal) {
                        g.computeVertexNormals();
                    }
                    return g;
                });
                
                // „Ç∑„É≥„Éó„É´„Å™„Éû„Éº„Ç∏ÔºàCSG Union„ÅØÂ¢ÉÁïå„Ç®„ÉÉ„Ç∏„ÇíÂ¢ó„ÇÑ„Åô„Åü„ÇÅ‰ΩøÁî®„Åó„Å™„ÅÑÔºâ
                let finalKeycapGeo = BufferGeometryUtils.mergeGeometries(bodyGeos);
                
                if (finalKeycapGeo) {
                    finalKeycapGeo = BufferGeometryUtils.mergeVertices(finalKeycapGeo, 0.0001);
                    finalKeycapGeo.computeVertexNormals();
                }
                
                console.log("Body geo created:", finalKeycapGeo);
                
                const textGeos = [];
                const engraveGeos = [];
                
                const handleGeo = (geo, mode) => {
                    if (!geo) return;
                    if (mode === 'emboss') {
                        textGeos.push(geo);
                    } else if (mode === 'engrave') {
                        engraveGeos.push(geo);
                    } else if (mode === 'doubleshot') {
                        textGeos.push(geo);
                        engraveGeos.push(geo.clone());
                    }
                };
                
                if (state.enableText && loadedFonts[state.font]) {
                    handleGeo(createConformedText(p, state.text, state.fontSize, state.posX, state.posZ, state.textMode), state.textMode);
                }
                if (state.enableText2 && loadedFonts[state.font]) {
                    handleGeo(createConformedText(p, state.text2, state.text2Size, state.text2X, state.text2Z, state.text2Mode), state.text2Mode);
                }
                if (state.enableSide) {
                    handleGeo(createSidePrint(p, state.sideMode), state.sideMode);
                }
                if (state.svgContent && state.svgVisible) {
                    let svgGeo = createConformedSVGForExport(p, state.svgMode);
                    if (svgGeo) {
                        console.log("V63.3.1: Applying enhanced repair to SVG geometry...");
                        svgGeo = repairSVGMesh(svgGeo);
                        
                        if (state.svgMode === 'emboss' && finalKeycapGeo) {
                            try {
                                console.log("V63.3.1: CSG Union SVG with body...");
                                const b1 = new Brush(finalKeycapGeo); b1.updateMatrixWorld();
                                const b2 = new Brush(svgGeo); b2.updateMatrixWorld();
                                const res = csgEvaluator.evaluate(b1, b2, ADDITION);
                                finalKeycapGeo = res.geometry;
                                finalKeycapGeo = BufferGeometryUtils.mergeVertices(finalKeycapGeo, 0.0001);
                                console.log("V63.3.1: CSG Union successful");
                                svgGeo = null;
                            } catch (e) {
                                console.error("SVG CSG Union failed:", e);
                            }
                        }
                    }
                    if (svgGeo) {
                        handleGeo(svgGeo, state.svgMode);
                    }
                }
                
                if (engraveGeos.length > 0 && finalKeycapGeo) {
                    let engraveGeo = BufferGeometryUtils.mergeGeometries(engraveGeos.map(g => g.index ? g.toNonIndexed() : g));
                    if (engraveGeo) {
                        try {
                            const b1 = new Brush(finalKeycapGeo); b1.updateMatrixWorld();
                            const b2 = new Brush(engraveGeo); b2.updateMatrixWorld();
                            const res = csgEvaluator.evaluate(b1, b2, SUBTRACTION);
                            finalKeycapGeo = res.geometry;
                            finalKeycapGeo = BufferGeometryUtils.mergeVertices(finalKeycapGeo, 0.0001);
                        } catch (e) {
                            console.error("Engrave CSG failed:", e);
                        }
                    }
                }
                
                let finalTextGeo = null;
                if (textGeos.length > 0) {
                    const textGeosNonIndexed = textGeos.map(g => g.index ? g.toNonIndexed() : g);
                    finalTextGeo = BufferGeometryUtils.mergeGeometries(textGeosNonIndexed);
                    if (finalTextGeo) {
                        finalTextGeo = BufferGeometryUtils.mergeVertices(finalTextGeo, 0.0001);
                        finalTextGeo.computeVertexNormals();
                    }
                }
                
                // V67: body„Åã„Çâtext„ÇíCSG„ÅßÂºï„ÅÑ„Å¶Èáç„Å™„Çä„ÇíËß£Ê∂àÔºàÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏ÂØæÁ≠ñÔºâ
                // ÁèæÂú®ÁÑ°ÂäπÂåñ - CSGÊ∏õÁÆó„ÅåÂ¢ÉÁïå„Ç®„ÉÉ„Ç∏„ÇíÂ§ßÈáè„Å´ÁîüÊàê„Åô„ÇãÂïèÈ°å„ÅÆ„Åü„ÇÅ
                // Manifold.js„Çí‰ΩøÁî®„Åó„Å¶Ê∞¥ÂØÜ„Å™CSGÊ∏õÁÆó„ÇíË°å„ÅÜ
                /*
                if (finalTextGeo && finalKeycapGeo && manifoldModule) {
                    console.log("V67: CSG Subtraction with Manifold.js - for watertight result");
                    try {
                        // Manifold.js„ÅßCSGÊ∏õÁÆó„ÇíË©¶„Åø„Çã
                        const bodyManifold = geometryToManifold(finalKeycapGeo);
                        const textManifold = geometryToManifold(finalTextGeo);
                        
                        if (bodyManifold && textManifold) {
                            const resultManifold = Manifold.difference(bodyManifold, textManifold);
                            const resultMesh = resultManifold.getMesh();
                            
                            const resultGeo = new THREE.BufferGeometry();
                            resultGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(resultMesh.vertProperties), 3));
                            resultGeo.setIndex(new THREE.BufferAttribute(new Uint32Array(resultMesh.triVerts), 1));
                            resultGeo.computeVertexNormals();
                            
                            finalKeycapGeo = resultGeo;
                            console.log("V67: Manifold CSG Subtraction successful - watertight result");
                        } else {
                            throw new Error("Failed to create Manifold objects");
                        }
                    } catch (e) {
                        console.warn("V67: Manifold CSG failed, trying three-bvh-csg:", e.message);
                        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: three-bvh-csg„Çí‰ΩøÁî®
                        try {
                            const b1 = new Brush(finalKeycapGeo); b1.updateMatrixWorld();
                            const b2 = new Brush(finalTextGeo.clone()); b2.updateMatrixWorld();
                            const res = csgEvaluator.evaluate(b1, b2, SUBTRACTION);
                            finalKeycapGeo = res.geometry;
                            finalKeycapGeo = BufferGeometryUtils.mergeVertices(finalKeycapGeo, 0.0001);
                            console.log("V67: three-bvh-csg Subtraction successful (may have boundary edges)");
                        } catch (e2) {
                            console.warn("V67: CSG Subtraction failed, continuing with overlapping geometry:", e2);
                        }
                    }
                }
                */
                console.log("V67: CSG Subtraction DISABLED for testing");
                
                console.log("Text geo created:", finalTextGeo);
                
                console.log("Repairing meshes...");
                if (finalKeycapGeo) {
                    finalKeycapGeo = repairMesh(finalKeycapGeo);
                    console.log("Body repaired:", finalKeycapGeo);
                }
                if (finalTextGeo) {
                    finalTextGeo = repairMesh(finalTextGeo);
                    console.log("Text repaired:", finalTextGeo);
                }
                
                console.log("Export geometry built successfully");
                
                return { bodyGeo: finalKeycapGeo, textGeo: finalTextGeo, importedGeo: null };
                
            } catch (error) {
                console.error("buildExportGeometry error:", error);
                document.getElementById('error-log').textContent = "Build error: " + error.message;
                throw error;
            }
        }

        async function export3MF() {
            try {
                const t = translations[currentLang];
                showProgressToast('3MF„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÊ∫ñÂÇô‰∏≠...', 0);
                
                await new Promise(r => setTimeout(r, 100));
                
                console.log("Building export geometry...");
                let { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
                console.log("bodyGeo:", bodyGeo);
                console.log("textGeo:", textGeo);
                
                if (!bodyGeo) {
                    hideProgressToast(t.toast_no_body, true);
                    return;
                }
                
                // V67.3: MeshFixLib„Åß„Ç∏„Ç™„É°„Éà„É™„Çí‰øÆÂæ©
                async function repairGeoWithMeshFix(geo, name) {
                    if (!geo) return null;
                    
                    let g = geo.clone();
                    if (!g.index) g = BufferGeometryUtils.mergeVertices(g, 0.0001);
                    
                    const position = g.attributes.position;
                    const index = g.index;
                    if (!position) return geo;
                    
                    // È†ÇÁÇπÈÖçÂàó„Çí‰ΩúÊàê
                    const vertices = [];
                    for (let i = 0; i < position.count; i++) {
                        vertices.push([position.getX(i), position.getY(i), position.getZ(i)]);
                    }
                    
                    // ‰∏âËßíÂΩ¢ÈÖçÂàó„Çí‰ΩúÊàê
                    const triangles = [];
                    if (index && index.array) {
                        const arr = index.array;
                        for (let i = 0; i < arr.length; i += 3) {
                            triangles.push([arr[i], arr[i+1], arr[i+2]]);
                        }
                    } else {
                        for (let i = 0; i < position.count; i += 3) {
                            triangles.push([i, i+1, i+2]);
                        }
                    }
                    
                    console.log(`[MeshFixLib] ${name}: ‰øÆÂæ©Ââç - ${vertices.length}È†ÇÁÇπ, ${triangles.length}‰∏âËßíÂΩ¢`);
                    
                    // MeshFixLib„Åß‰øÆÂæ©
                    const result = await meshFixLib.repairMesh(vertices, triangles, (status) => {
                        console.log(`[MeshFixLib] ${name}: ${status}`);
                    });
                    
                    console.log(`[MeshFixLib] ${name}: ‰øÆÂæ©Âæå - ${result.vertices.length}È†ÇÁÇπ, ${result.triangles.length}‰∏âËßíÂΩ¢`);
                    console.log(`[MeshFixLib] ${name}: Ë®∫Êñ≠ - Â¢ÉÁïå${result.diagnosis.boundary}, ÈùûÂ§öÊßò‰Ωì${result.diagnosis.nonManifold}`);
                    
                    // ‰øÆÂæ©„Åó„Åü„Éá„Éº„Çø„ÇíÊ†ºÁ¥ç
                    geo._meshFixData = { vertices: result.vertices, triangles: result.triangles };
                    return geo;
                }
                
                updateProgressToast('Êú¨‰Ωì„É°„ÉÉ„Ç∑„É•„Çí‰øÆÂæ©‰∏≠...', 20);
                bodyGeo = await repairGeoWithMeshFix(bodyGeo, 'Êú¨‰Ωì');
                if (!bodyGeo) { hideProgressToast('Êú¨‰Ωì„ÅÆ‰øÆÂæ©„Å´Â§±Êïó', true); return; }
                
                if (textGeo) {
                    updateProgressToast('ÊñáÂ≠ó„É°„ÉÉ„Ç∑„É•„Çí‰øÆÂæ©‰∏≠...', 50);
                    textGeo = await repairGeoWithMeshFix(textGeo, 'ÊñáÂ≠ó');
                    if (!textGeo) { hideProgressToast('ÊñáÂ≠ó„ÅÆ‰øÆÂæ©„Å´Â§±Êïó', true); return; }
                }
                
                updateProgressToast('3MF„Éï„Ç°„Ç§„É´„ÇíÁîüÊàê‰∏≠...', 80);
                
                // ExtruderÁï™Âè∑„ÇíÂèñÂæó
                const bodyExtruder = (state.bodyExtruder || 1);
                const textExtruder = (state.textExtruder || 2);
                
                const zip = new JSZip();
                
                // V67.3: MeshFixLib‰øÆÂæ©Ê∏à„Åø„Éá„Éº„Çø„Çí‰ΩøÁî®
                function geoTo3MFMesh(geometry) {
                    if (!geometry) return null;
                    
                    // MeshFixLib‰øÆÂæ©Ê∏à„Åø„Éá„Éº„Çø„Åå„ÅÇ„Çå„Å∞„Åù„Çå„Çí‰ΩøÁî®
                    if (geometry._meshFixData) {
                        const { vertices, triangles } = geometry._meshFixData;
                        return {
                            vertices: vertices.map(v => `        <vertex x="${v[0].toFixed(6)}" y="${v[1].toFixed(6)}" z="${v[2].toFixed(6)}" />`),
                            triangles: triangles.map(t => `        <triangle v1="${t[0]}" v2="${t[1]}" v3="${t[2]}" />`)
                        };
                    }
                    
                    // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÂæìÊù•„ÅÆÂá¶ÁêÜ
                    let geo = geometry.clone();
                    if (!geo.index) geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
                    
                    const position = geo.attributes.position;
                    if (!position) return null;
                    
                    const vertices = [];
                    const triangles = [];
                    const index = geo.index;
                    
                    if (index && index.array) {
                        for (let i = 0; i < position.count; i++) {
                            vertices.push(`        <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                        }
                        const indexArray = index.array;
                        for (let i = 0; i < indexArray.length; i += 3) {
                            triangles.push(`        <triangle v1="${indexArray[i]}" v2="${indexArray[i+1]}" v3="${indexArray[i+2]}" />`);
                        }
                    } else {
                        for (let i = 0; i < position.count; i++) {
                            vertices.push(`        <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                        }
                        for (let i = 0; i < position.count; i += 3) {
                            triangles.push(`        <triangle v1="${i}" v2="${i+1}" v3="${i+2}" />`);
                        }
                    }
                    
                    return { vertices, triangles };
                }
                
                // Bambu Studio ‰∫íÊèõ„ÅÆXML
                let modelXml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" 
  xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02"
  xmlns:p="http://schemas.microsoft.com/3dmanufacturing/production/2015/06">
  <metadata name="Application">Keycap Engine</metadata>
  <resources>
`;
                
                let objectId = 1;
                let componentRefs = [];
                let volumeConfigs = [];
            
            // Êú¨‰Ωì„É°„ÉÉ„Ç∑„É•ÔºàBambu Studio„Åß„ÅØÈÄÜÈ†Ü„ÅßËß£Èáà„Åï„Çå„Çã„Åü„ÇÅ„ÄÅText„Å®„ÅÑ„ÅÜÂêçÂâç„Çí‰ΩøÁî®Ôºâ
            if (bodyGeo) {
                const mesh = geoTo3MFMesh(bodyGeo);
                if (mesh) {
                    modelXml += `    <object id="${objectId}" type="model">
      <mesh>
        <vertices>
${mesh.vertices.join('\n')}
        </vertices>
        <triangles>
${mesh.triangles.join('\n')}
        </triangles>
      </mesh>
    </object>
`;
                    componentRefs.push({ id: objectId, name: 'Text' });
                    volumeConfigs.push({ id: volumeConfigs.length, extruder: bodyExtruder, name: 'Text', objectId: objectId });
                    objectId++;
                }
            }
            
            // „ÉÜ„Ç≠„Çπ„Éà„É°„ÉÉ„Ç∑„É•ÔºàBambu Studio„Åß„ÅØÈÄÜÈ†Ü„ÅßËß£Èáà„Åï„Çå„Çã„Åü„ÇÅ„ÄÅBody„Å®„ÅÑ„ÅÜÂêçÂâç„Çí‰ΩøÁî®Ôºâ
            let combinedTextGeo = textGeo;
            if (importedGeo) {
                if (combinedTextGeo) {
                    combinedTextGeo = BufferGeometryUtils.mergeGeometries([combinedTextGeo, importedGeo]);
                    combinedTextGeo = BufferGeometryUtils.mergeVertices(combinedTextGeo, 0.0001);
                } else {
                    combinedTextGeo = importedGeo;
                }
            }
            
            if (combinedTextGeo) {
                const mesh = geoTo3MFMesh(combinedTextGeo);
                if (mesh) {
                    modelXml += `    <object id="${objectId}" type="model">
      <mesh>
        <vertices>
${mesh.vertices.join('\n')}
        </vertices>
        <triangles>
${mesh.triangles.join('\n')}
        </triangles>
      </mesh>
    </object>
`;
                    componentRefs.push({ id: objectId, name: 'Body' });
                    volumeConfigs.push({ id: volumeConfigs.length, extruder: textExtruder, name: 'Body', objectId: objectId });
                    objectId++;
                }
            }
            
            // „Ç¢„Çª„É≥„Éñ„É™„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÔºàÂÖ®„Å¶„ÅÆ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Çí„Åæ„Å®„ÇÅ„ÇãÔºâ
            const assemblyId = objectId;
            modelXml += `    <object id="${assemblyId}" type="model">
      <components>
`;
            componentRefs.forEach(comp => {
                modelXml += `        <component objectid="${comp.id}" transform="1 0 0 0 1 0 0 0 1 0 0 0" />
`;
            });
            modelXml += `      </components>
    </object>
`;
            
            modelXml += `  </resources>
  <build>
    <item objectid="${assemblyId}" />
  </build>
</model>`;

            const contentTypes = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />
</Types>`;

            const rels = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>`;

            // Slic3r PE Ë®≠ÂÆö„Éï„Ç°„Ç§„É´ (volumeÂΩ¢Âºè) - component„Å®Âêå„ÅòÈ†ÜÂ∫è„Åß
            let slic3rConfig = `<?xml version="1.0" encoding="UTF-8"?>
<config>
  <object id="${assemblyId}">
    <metadata type="object" key="name" value="Keycap"/>
`;
            // componentRefs„ÅÆÈ†ÜÂ∫è„ÅßÂá∫ÂäõÔºàBody=0, Text=1Ôºâ
            componentRefs.forEach((comp, idx) => {
                const vol = volumeConfigs.find(v => v.objectId === comp.id);
                if (vol) {
                    slic3rConfig += `    <volume id="${idx}" firstid="${comp.id}">
      <metadata type="volume" key="name" value="${vol.name}"/>
      <metadata type="volume" key="extruder" value="${vol.extruder}"/>
    </volume>
`;
                }
            });
            slic3rConfig += `  </object>
</config>`;

            // Bambu Studio model_settings.config - Âêå„ÅòÈ†ÜÂ∫è„Åß
            let modelSettings = `<?xml version="1.0" encoding="UTF-8"?>
<config>
  <plate>
    <metadata key="plater_id" value="1"/>
    <metadata key="locked" value="false"/>
  </plate>
  <object id="${assemblyId}">
    <metadata key="name" value="Keycap"/>
`;
            componentRefs.forEach((comp, idx) => {
                const vol = volumeConfigs.find(v => v.objectId === comp.id);
                if (vol) {
                    modelSettings += `    <part id="${idx + 1}" subtype="normal_part">
      <metadata key="name" value="${vol.name}"/>
      <metadata key="extruder" value="${vol.extruder}"/>
    </part>
`;
                }
            });
            modelSettings += `  </object>
</config>`;

                zip.file("[Content_Types].xml", contentTypes);
                zip.folder("_rels").file(".rels", rels);
                zip.folder("3D").file("3dmodel.model", modelXml);
                zip.folder("Metadata").file("Slic3r_PE_model.config", slic3rConfig);
                zip.folder("Metadata").file("model_settings.config", modelSettings);
                
                // V67.3: 3MF„ÇíÁîüÊàêÂæå„ÄÅMeshFixLib„Åß‰øÆÂæ©
                updateProgressToast('3MF„Éï„Ç°„Ç§„É´„ÇíÁîüÊàê‰∏≠...', 85);
                const tempBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE" });
                
                // 3MF„ÇíArrayBuffer„Å´Â§âÊèõ
                updateProgressToast('„É°„ÉÉ„Ç∑„É•„Çí‰øÆÂæ©‰∏≠...', 90);
                const arrayBuffer = await tempBlob.arrayBuffer();
                
                // MeshFixLib„Åß‰øÆÂæ©
                try {
                    const parsed = await meshFixLib.parse3MF(arrayBuffer);
                    console.log(`[MeshFixLib] 3MF: ${parsed.objects.length}ÂÄã„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÊ§úÂá∫`);
                    
                    const repaired = await meshFixLib.repairAll(parsed.objects, (progress) => {
                        if (progress.type === 'progress') {
                            updateProgressToast(`„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà ${progress.objectIndex + 1}/${progress.total} „Çí‰øÆÂæ©‰∏≠...`, 90 + (progress.objectIndex / progress.total) * 8);
                        }
                        console.log(`[MeshFixLib] ${progress.status}`);
                    });
                    
                    console.log(`[MeshFixLib] ‰øÆÂæ©ÂÆå‰∫Ü: „Éû„Éº„Ç∏${repaired.totalReport.merged}, NM‰øÆÊ≠£${repaired.totalReport.nmFixed}, Á©¥Âüã„ÇÅ${repaired.totalReport.holesFilled}`);
                    
                    updateProgressToast('‰øÆÂæ©Ê∏à„Åø3MF„Çí‰øùÂ≠ò‰∏≠...', 98);
                    const repairedBlob = await meshFixLib.write3MF(repaired.objects, parsed.originalXml, parsed.zip, parsed.modelPath);
                    saveBlob(repairedBlob, getFileName() + '.3mf');
                } catch (repairError) {
                    console.warn('[MeshFixLib] ‰øÆÂæ©„Å´Â§±Êïó„ÄÅÂÖÉ„ÅÆ„Éï„Ç°„Ç§„É´„Çí‰øùÂ≠ò:', repairError);
                    saveBlob(tempBlob, getFileName() + '.3mf');
                }
                
                hideProgressToast(t.toast_3mf_exported + ` (Êú¨‰Ωì: Ext${bodyExtruder}, ÊñáÂ≠ó: Ext${textExtruder})`, false, 2000);
            } catch (error) {
                console.error("3MF Export Error:", error);
                const t = translations[currentLang];
                hideProgressToast(t.toast_export_failed + error.message, true, 3000);
                document.getElementById('error-log').textContent = "3MF Export Error: " + error.message;
            }
        }

        // ==========================================
        // V67: üßä „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ„Éª„Éì„É•„Éº„Ç≠„É•„Éº„Éñ
        // ==========================================
        function initViewCube() {
            // Èù¢„ÅÆ„ÇØ„É™„ÉÉ„ÇØÂá¶ÁêÜ
            const cubeFaces = document.querySelectorAll('.cube-face');
            cubeFaces.forEach(face => {
                face.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const faceView = face.dataset.view;
                    console.log('[ViewCube] Face click:', faceView);
                    moveCameraToView(faceView);
                });
            });
            
            // „Ç≥„Éº„Éä„ÉºÔºàËßíÔºâ„ÅÆ„ÇØ„É™„ÉÉ„ÇØÂá¶ÁêÜ
            const corners = document.querySelectorAll('.cube-corner');
            console.log('[ViewCube] Found', corners.length, 'corners');
            corners.forEach(corner => {
                corner.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const view = corner.dataset.view;
                    console.log('[ViewCube] Corner click:', view);
                    moveCameraToView(view);
                });
            });
        }
        
        // Èù¢„Å®Ëßí„ÅÆ‰ΩçÁΩÆ„Åã„Çâ„Ç¢„Ç§„ÇΩ„É°„Éà„É™„ÉÉ„ÇØË¶ñÁÇπ„ÇíÊ±∫ÂÆö
        function getCornerView(face, isLeft, isRight, isTop, isBottom) {
            // Èù¢„Åî„Å®„Å´Ëßí„ÅÆ‰ΩçÁΩÆ„Åã„Çâ„Éì„É•„Éº„ÇíÊ±∫ÂÆö
            const cornerMap = {
                'front': {
                    'lt': 'iso-flt', 'rt': 'iso-frt',
                    'lb': 'iso-flb', 'rb': 'iso-frb'
                },
                'back': {
                    'lt': 'iso-brt', 'rt': 'iso-blt',
                    'lb': 'iso-brb', 'rb': 'iso-blb'
                },
                'right': {
                    'lt': 'iso-frt', 'rt': 'iso-brt',
                    'lb': 'iso-frb', 'rb': 'iso-brb'
                },
                'left': {
                    'lt': 'iso-blt', 'rt': 'iso-flt',
                    'lb': 'iso-blb', 'rb': 'iso-flb'
                },
                'top': {
                    'lt': 'iso-blt', 'rt': 'iso-brt',
                    'lb': 'iso-flt', 'rb': 'iso-frt'
                },
                'bottom': {
                    'lt': 'iso-flb', 'rt': 'iso-frb',
                    'lb': 'iso-blb', 'rb': 'iso-brb'
                }
            };
            
            let corner = '';
            if (isLeft && isTop) corner = 'lt';
            else if (isRight && isTop) corner = 'rt';
            else if (isLeft && isBottom) corner = 'lb';
            else if (isRight && isBottom) corner = 'rb';
            
            return cornerMap[face]?.[corner] || null;
        }

        function updateViewCubeRotation() {
            const cube = document.getElementById('view-cube');
            if (!cube || !camera) return;
            
            // „Ç´„É°„É©„ÅÆÂõûËª¢Ë°åÂàó„ÇíÂèñÂæó„Åó„Å¶„Ç≠„É•„Éº„Éñ„Å´ÈÅ©Áî®
            const mat = new THREE.Matrix4();
            mat.extractRotation(camera.matrixWorldInverse);
            
            // Three.js (Y-Up) „Åã„Çâ CSS (Y-Down) „Å∏„ÅÆÂ∫ßÊ®ôÂ§âÊèõ
            const e = mat.elements;
            // YËª∏„ÇíÂèçËª¢
            const cssMatrix = `matrix3d(
                ${e[0]}, ${-e[1]}, ${e[2]}, ${e[3]},
                ${-e[4]}, ${e[5]}, ${-e[6]}, ${e[7]},
                ${e[8]}, ${-e[9]}, ${e[10]}, ${e[11]},
                ${e[12]}, ${e[13]}, ${e[14]}, ${e[15]}
            )`;
            
            cube.style.transform = cssMatrix;
            
            // Ëª∏„É©„Éô„É´„ÅÆ2D‰ΩçÁΩÆ„ÇíË®àÁÆó
            updateAxisLabels(mat);
        }
        
        function updateAxisLabels(rotMatrix) {
            const labelsContainer = document.getElementById('axis-labels-container');
            if (!labelsContainer) return;
            
            const labelX = labelsContainer.querySelector('.label-x');
            const labelY = labelsContainer.querySelector('.label-y');
            const labelZ = labelsContainer.querySelector('.label-z');
            
            // Ëª∏„ÅÆÊñπÂêë„Éô„ÇØ„Éà„É´ÔºàÂçò‰Ωç„Éô„ÇØ„Éà„É´Ôºâ
            const directions = {
                x: new THREE.Vector3(1, 0, 0),
                y: new THREE.Vector3(0, 1, 0),
                z: new THREE.Vector3(0, 0, 1)
            };
            
            const center = 65;
            const minDist = 50;
            
            Object.keys(directions).forEach(axis => {
                const dir = directions[axis].clone();
                dir.applyMatrix4(rotMatrix);
                
                // 2DÂ∫ßÊ®ô„Å´Â§âÊèõ
                let x2d = dir.x;
                let y2d = -dir.y;
                
                // 2D‰∏ä„Åß„ÅÆË∑ùÈõ¢„ÇíË®àÁÆó
                const dist2d = Math.sqrt(x2d * x2d + y2d * y2d);
                
                let finalX, finalY;
                if (dist2d < 0.3) {
                    // Ëª∏„Åå„Ç´„É°„É©ÊñπÂêë„ÇíÂêë„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅÂõ∫ÂÆö‰ΩçÁΩÆ„Å´ÈÖçÁΩÆ
                    if (dir.z > 0) {
                        finalX = center + 50;
                        finalY = center + 40;
                    } else {
                        finalX = center - 50;
                        finalY = center - 40;
                    }
                } else {
                    // ÈÄöÂ∏∏Ôºö2DÊñπÂêë„ÇíÊ≠£Ë¶èÂåñ„Åó„Å¶Ë∑ùÈõ¢„ÇíË®≠ÂÆö
                    const scale = minDist / dist2d;
                    finalX = center + x2d * scale;
                    finalY = center + y2d * scale;
                }
                
                const label = axis === 'x' ? labelX : (axis === 'y' ? labelY : labelZ);
                if (label) {
                    label.style.left = `${finalX - 5}px`;
                    label.style.top = `${finalY - 7}px`;
                }
            });
        }

        function moveCameraToView(view) {
            const dist = 45; // „Ç´„É°„É©Ë∑ùÈõ¢
            const isoDist = 30; // Êñú„ÇÅË¶ñÁÇπ„ÅÆË∑ùÈõ¢
            let targetPos = new THREE.Vector3();

            switch(view) {
                // Ê≠£ÊäïÂΩ±
                case 'front':  targetPos.set(0, 0, dist); break;
                case 'back':   targetPos.set(0, 0, -dist); break;
                case 'right':  targetPos.set(dist, 0, 0); break;
                case 'left':   targetPos.set(-dist, 0, 0); break;
                case 'top':    targetPos.set(0, dist, 0.01); break;
                case 'bottom': targetPos.set(0, -dist, 0.01); break;
                case 'iso':    targetPos.set(25, 35, 35); break;
                
                // „Ç¢„Ç§„ÇΩ„É°„Éà„É™„ÉÉ„ÇØÔºà„Ç≥„Éº„Éä„ÉºÔºâË¶ñÁÇπ
                case 'iso-frt': targetPos.set( isoDist,  isoDist,  isoDist); break;
                case 'iso-flt': targetPos.set(-isoDist,  isoDist,  isoDist); break;
                case 'iso-brt': targetPos.set( isoDist,  isoDist, -isoDist); break;
                case 'iso-blt': targetPos.set(-isoDist,  isoDist, -isoDist); break;
                case 'iso-frb': targetPos.set( isoDist, -isoDist,  isoDist); break;
                case 'iso-flb': targetPos.set(-isoDist, -isoDist,  isoDist); break;
                case 'iso-brb': targetPos.set( isoDist, -isoDist, -isoDist); break;
                case 'iso-blb': targetPos.set(-isoDist, -isoDist, -isoDist); break;
            }

            // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
            const startPos = camera.position.clone();
            const duration = 400;
            const startTime = performance.now();

            function animateCam(time) {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                const ease = 1 - Math.pow(1 - t, 3);

                camera.position.lerpVectors(startPos, targetPos, ease);
                camera.lookAt(0, 0, 0);
                controls.update();

                if (t < 1) requestAnimationFrame(animateCam);
            }
            requestAnimationFrame(animateCam);
        }

        // ==========================================
        // V67: üé® „Éï„Ç£„É©„É°„É≥„Éà„Éª„Ç´„É©„Éº„É©„Ç§„Éñ„É©„É™ÔºàÊîπËâØÁâàÔºâ
        // ==========================================
        const FILAMENT_LIB = {
            'Bambu Lab': {
                'PLA Basic': [
                    { name: 'Black', hex: '#1A1A1A' },
                    { name: 'Jade White', hex: '#F5F5F5' },
                    { name: 'Light Gray', hex: '#C0C0C0' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Dark Gray', hex: '#505050' },
                    { name: 'Brown', hex: '#5D432C' },
                    { name: 'Burgundy', hex: '#800020' },
                    { name: 'Red', hex: '#DC143C' },
                    { name: 'Magenta', hex: '#FF00FF' },
                    { name: 'Pink', hex: '#FF69B4' },
                    { name: 'Lime Green', hex: '#9ACD32' },
                    { name: 'Lemon Yellow', hex: '#FFF44F' },
                    { name: 'Orange', hex: '#FF7F00' },
                    { name: 'Savana Yellow', hex: '#DAA520' },
                    { name: 'Bambu Green', hex: '#00AE42' },
                    { name: 'Dark Green', hex: '#006400' },
                    { name: 'Cyan', hex: '#00CED1' },
                    { name: 'Sky Blue', hex: '#87CEEB' },
                    { name: 'Blue', hex: '#1E90FF' },
                    { name: 'Navy Blue', hex: '#000080' },
                    { name: 'Purple', hex: '#800080' },
                    { name: 'Violet', hex: '#8A2BE2' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'Army Green', hex: '#4B5320' },
                    { name: 'Olive', hex: '#808000' },
                    { name: 'Tan', hex: '#D2B48C' },
                    { name: 'Beige', hex: '#F5DEB3' }
                ],
                'PLA Matte': [
                    { name: 'Matte Black', hex: '#1C1C1C' },
                    { name: 'Matte Ivory White', hex: '#FFFFF0' },
                    { name: 'Matte Light Gray', hex: '#B0B0B0' },
                    { name: 'Matte Gray', hex: '#6B6B6B' },
                    { name: 'Matte Charcoal', hex: '#36454F' },
                    { name: 'Matte Brown', hex: '#5D432C' },
                    { name: 'Matte Dark Red', hex: '#8B0000' },
                    { name: 'Matte Orange', hex: '#CC5500' },
                    { name: 'Matte Yellow', hex: '#DAA520' },
                    { name: 'Matte Cyan', hex: '#40E0D0' },
                    { name: 'Matte Teal', hex: '#008080' },
                    { name: 'Matte Dark Green', hex: '#355E3B' },
                    { name: 'Matte Light Blue', hex: '#ADD8E6' },
                    { name: 'Matte Blue', hex: '#1560BD' },
                    { name: 'Matte Purple', hex: '#5D3FD3' },
                    { name: 'Matte Navy', hex: '#000080' },
                    { name: 'Matte Dark Navy', hex: '#191970' },
                    { name: 'Matte Olive', hex: '#556B2F' },
                    { name: 'Matte Army Green', hex: '#3B3C36' },
                    { name: 'Matte Turquoise', hex: '#30D5C8' },
                    { name: 'Matte Dark Brown', hex: '#3D2B1F' },
                    { name: 'Matte Light Brown', hex: '#8B7355' },
                    { name: 'Matte Aqua', hex: '#7FFFD4' }
                ],
                'PLA Wood': [
                    { name: 'Dark Ebony', hex: '#2F1E0E' },
                    { name: 'Walnut', hex: '#5D432C' },
                    { name: 'Brown', hex: '#8B4513' },
                    { name: 'Light Oak', hex: '#C4A35A' },
                    { name: 'Bamboo', hex: '#D4C4A8' },
                    { name: 'Amber', hex: '#FFBF00' }
                ],
                'PLA Silk+': [
                    { name: 'Silk Gold', hex: '#D4AF37' },
                    { name: 'Black', hex: '#1C1C1C' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Blue', hex: '#4169E1' },
                    { name: 'Purple', hex: '#8B008B' },
                    { name: 'Red', hex: '#DC143C' },
                    { name: 'Green', hex: '#228B22' },
                    { name: 'Cyan', hex: '#00CED1' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'White', hex: '#F5F5F5' },
                    { name: 'Pearl White', hex: '#FDFDF5' }
                ],
                'PLA-CF': [
                    { name: 'Black', hex: '#1C1C1C' },
                    { name: 'Gray', hex: '#4F4F4F' },
                    { name: 'Navy Blue', hex: '#000080' },
                    { name: 'Blue', hex: '#1E3A8A' },
                    { name: 'Dark Green', hex: '#006400' },
                    { name: 'Purple', hex: '#4B0082' }
                ],
                'PLA Metal': [
                    { name: 'Titanium', hex: '#878681' },
                    { name: 'Copper', hex: '#B87333' },
                    { name: 'Gold', hex: '#CFB53B' },
                    { name: 'Dark Green', hex: '#006400' },
                    { name: 'Teal', hex: '#008080' }
                ],
                'PLA Glow': [
                    { name: 'Glow Green', hex: '#ADFF2F' },
                    { name: 'Glow Blue', hex: '#00BFFF' },
                    { name: 'Glow Cyan', hex: '#00FFFF' },
                    { name: 'Glow Yellow', hex: '#FFFF00' },
                    { name: 'Glow Pink', hex: '#FF91A4' }
                ],
                'TPU for AMS': [
                    { name: 'Blue', hex: '#4169E1' },
                    { name: 'Red', hex: '#DC143C' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'Black', hex: '#1A1A1A' },
                    { name: 'White', hex: '#F5F5F5' },
                    { name: 'Light Gray', hex: '#D3D3D3' },
                    { name: 'Light Yellow', hex: '#FFFFE0' },
                    { name: 'Light Green', hex: '#90EE90' },
                    { name: 'Dark Black', hex: '#0A0A0A' }
                ],
                'TPU 95A HF': [
                    { name: 'White', hex: '#F5F5F5' },
                    { name: 'Black', hex: '#1A1A1A' },
                    { name: 'Dark Black', hex: '#0A0A0A' },
                    { name: 'Gray', hex: '#696969' },
                    { name: 'Red', hex: '#DC143C' },
                    { name: 'Yellow', hex: '#FFD700' },
                    { name: 'Blue', hex: '#1E90FF' }
                ],
                'PETG HF': [
                    { name: 'Black', hex: '#1A1A1A' },
                    { name: 'White', hex: '#F5F5F5' },
                    { name: 'Gray', hex: '#696969' },
                    { name: 'Red', hex: '#DC143C' },
                    { name: 'Orange', hex: '#FF7F00' },
                    { name: 'Yellow', hex: '#FFD700' },
                    { name: 'Bambu Green', hex: '#00AE42' },
                    { name: 'Dark Green', hex: '#006400' },
                    { name: 'Sky Blue', hex: '#87CEEB' },
                    { name: 'Blue', hex: '#1E90FF' },
                    { name: 'Navy Blue', hex: '#000080' }
                ],
                'PETG Translucent': [
                    { name: 'Cyan', hex: '#40E0D0' },
                    { name: 'Purple', hex: '#8A2BE2' },
                    { name: 'Blue', hex: '#4169E1' },
                    { name: 'Light Blue', hex: '#87CEFA' },
                    { name: 'Dark Gray', hex: '#4A4A4A' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Light Gray', hex: '#C0C0C0' }
                ],
                'PLA Support': [
                    { name: 'White', hex: '#F8F8FF' }
                ],
                'PLA Silk Multi-Color': [
                    { name: 'Cosmic', hex: '#8A2BE2' },
                    { name: 'Purple', hex: '#800080' },
                    { name: 'Red', hex: '#DC143C' },
                    { name: 'Orange', hex: '#FF7F00' },
                    { name: 'Cyan', hex: '#00FFFF' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'Lavender', hex: '#E6E6FA' },
                    { name: 'Violet', hex: '#8B008B' },
                    { name: 'Blue', hex: '#4169E1' },
                    { name: 'Green', hex: '#228B22' },
                    { name: 'Yellow', hex: '#FFD700' }
                ],
                'PETG-CF': [
                    { name: 'Black', hex: '#1C1C1C' },
                    { name: 'Gray', hex: '#4F4F4F' },
                    { name: 'Purple', hex: '#4B0082' },
                    { name: 'Dark Green', hex: '#006400' },
                    { name: 'Red', hex: '#8B0000' },
                    { name: 'Blue', hex: '#00008B' }
                ],
                'PLA/PETG Support': [
                    { name: 'White', hex: '#F8F8FF' }
                ],
                'ASA': [
                    { name: 'Teal', hex: '#008080' },
                    { name: 'White', hex: '#F5F5F5' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Black', hex: '#1A1A1A' },
                    { name: 'Blue', hex: '#0000CD' },
                    { name: 'Red', hex: '#DC143C' }
                ],
                'PLA Translucent': [
                    { name: 'Cyan', hex: '#00CED1' },
                    { name: 'Navy Blue', hex: '#000080' },
                    { name: 'Purple', hex: '#8B008B' },
                    { name: 'Orange', hex: '#FF7F00' },
                    { name: 'Dark Red', hex: '#8B0000' },
                    { name: 'Beige', hex: '#F5DEB3' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'Teal', hex: '#008080' }
                ],
                'ABS-GF': [
                    { name: 'Orange', hex: '#FF7F00' },
                    { name: 'Green', hex: '#228B22' },
                    { name: 'Red', hex: '#DC143C' },
                    { name: 'Yellow', hex: '#FFD700' },
                    { name: 'Blue', hex: '#1E90FF' },
                    { name: 'Translucent White', hex: '#FAFAFA' },
                    { name: 'White', hex: '#F5F5F5' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Black', hex: '#1A1A1A' }
                ],
                'PVA': [
                    { name: 'Natural', hex: '#FFFACD' }
                ],
                'PLA Gradient': [
                    { name: 'Salmon Pink', hex: '#FA8072' },
                    { name: 'Light Cyan', hex: '#E0FFFF' },
                    { name: 'Blue', hex: '#4169E1' },
                    { name: 'Lavender', hex: '#E6E6FA' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'Lime Green', hex: '#32CD32' },
                    { name: 'Orange', hex: '#FF7F00' },
                    { name: 'Brown', hex: '#8B4513' }
                ],
                'ABS Support': [
                    { name: 'White', hex: '#F8F8FF' }
                ],
                'PC': [
                    { name: 'Translucent', hex: '#F8F8FF' },
                    { name: 'White', hex: '#F5F5F5' },
                    { name: 'Black', hex: '#1A1A1A' },
                    { name: 'Gray', hex: '#696969' }
                ],
                'PLA Marble': [
                    { name: 'Red Marble', hex: '#8B4513' },
                    { name: 'White Marble', hex: '#F5F5F5' }
                ],
                'PLA Sparkle': [
                    { name: 'Navy Sparkle', hex: '#2E3A59' },
                    { name: 'Gray Sparkle', hex: '#4A5568' },
                    { name: 'Brown Sparkle', hex: '#5D432C' },
                    { name: 'Green Sparkle', hex: '#2E8B57' },
                    { name: 'Purple Sparkle', hex: '#4B0082' },
                    { name: 'Gold Sparkle', hex: '#B8860B' }
                ],
                'PLA Galaxy': [
                    { name: 'Galaxy Black', hex: '#1C1C2E' },
                    { name: 'Galaxy Blue', hex: '#1E3A8A' },
                    { name: 'Galaxy Green', hex: '#1E4D2B' },
                    { name: 'Galaxy Brown', hex: '#3D2B1F' }
                ],
                'PAHT-CF': [
                    { name: 'Carbon Black', hex: '#1C1C1C' }
                ],
                'TPU 85A': [
                    { name: 'Light Blue', hex: '#87CEEB' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'Black', hex: '#1A1A1A' },
                    { name: 'White', hex: '#F5F5F5' },
                    { name: 'Pearl White', hex: '#FDFDF5' },
                    { name: 'Tan', hex: '#D2B48C' },
                    { name: 'Lavender', hex: '#E6E6FA' },
                    { name: 'Cyan', hex: '#00CED1' },
                    { name: 'Orange', hex: '#FF7F00' },
                    { name: 'Yellow', hex: '#FFD700' },
                    { name: 'Dark Black', hex: '#0A0A0A' }
                ],
                'TPU 90A': [
                    { name: 'Light Blue', hex: '#87CEEB' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'Black', hex: '#1A1A1A' },
                    { name: 'White', hex: '#F5F5F5' },
                    { name: 'Pearl White', hex: '#FDFDF5' },
                    { name: 'Tan', hex: '#D2B48C' },
                    { name: 'Lavender', hex: '#E6E6FA' },
                    { name: 'Cyan', hex: '#00CED1' },
                    { name: 'Orange', hex: '#FF7F00' },
                    { name: 'Yellow', hex: '#FFD700' },
                    { name: 'Dark Black', hex: '#0A0A0A' }
                ],
                'ABS': [
                    { name: 'Yellow', hex: '#FFD700' },
                    { name: 'Red', hex: '#DC143C' },
                    { name: 'Black', hex: '#1A1A1A' },
                    { name: 'Light Gray', hex: '#C0C0C0' },
                    { name: 'Sky Blue', hex: '#87CEEB' },
                    { name: 'Navy Blue', hex: '#000080' },
                    { name: 'Purple', hex: '#8B008B' },
                    { name: 'Dark Green', hex: '#006400' },
                    { name: 'Orange', hex: '#FF7F00' },
                    { name: 'Green', hex: '#228B22' }
                ],
                'PA6-CF': [
                    { name: 'Carbon Black', hex: '#1C1C1C' }
                ],
                'PA6-GF': [
                    { name: 'Light Blue', hex: '#87CEEB' },
                    { name: 'Orange', hex: '#FF7F00' },
                    { name: 'Yellow', hex: '#FFD700' },
                    { name: 'Lime Green', hex: '#32CD32' },
                    { name: 'Brown', hex: '#8B4513' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Dark Gray', hex: '#4A4A4A' },
                    { name: 'Black', hex: '#1C1C1C' }
                ],
                'PET-CF': [
                    { name: 'Carbon Black', hex: '#1C1C1C' }
                ],
                'PPA-CF': [
                    { name: 'Carbon Black', hex: '#1C1C1C' }
                ],
                'PPS-CF': [
                    { name: 'Carbon Black', hex: '#1C1C1C' }
                ],
                'PC-FR': [
                    { name: 'Black', hex: '#1C1C1C' }
                ],
                'ASA-CF': [
                    { name: 'Carbon Black', hex: '#1C1C1C' }
                ],
                'PLA Tough+': [
                    { name: 'Orange', hex: '#FF5722' },
                    { name: 'Light Blue', hex: '#87CEEB' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Dark Gray', hex: '#4A4A4A' },
                    { name: 'Black', hex: '#1C1C1C' },
                    { name: 'White', hex: '#F5F5F5' },
                    { name: 'Yellow', hex: '#FFD700' }
                ],
                'PLA Aero': [
                    { name: 'White', hex: '#F5F5F5' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Black', hex: '#1C1C1C' }
                ],
                'ASA Aero': [
                    { name: 'White', hex: '#FFFAF0' }
                ]
            },
            'Generic': {
                'PLA': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Ivory', hex: '#FFFFF0' },
                    { name: 'Light Yellow', hex: '#FFFFE0' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Lemon', hex: '#FFF44F' },
                    { name: 'Gold', hex: '#FFD700' },
                    { name: 'Light Orange', hex: '#FFD580' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Dark Orange', hex: '#FF8C00' },
                    { name: 'Salmon', hex: '#FA8072' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'Pink', hex: '#FFC0CB' },
                    { name: 'Hot Pink', hex: '#FF69B4' },
                    { name: 'Magenta', hex: '#FF00FF' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Dark Red', hex: '#8B0000' },
                    { name: 'Maroon', hex: '#800000' },
                    { name: 'Brown', hex: '#8B4513' },
                    { name: 'Tan', hex: '#D2B48C' },
                    { name: 'Beige', hex: '#F5DEB3' },
                    { name: 'Olive', hex: '#808000' },
                    { name: 'Lime', hex: '#00FF00' },
                    { name: 'Light Green', hex: '#90EE90' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Dark Green', hex: '#006400' },
                    { name: 'Teal', hex: '#008080' },
                    { name: 'Cyan', hex: '#00FFFF' },
                    { name: 'Light Blue', hex: '#ADD8E6' },
                    { name: 'Sky Blue', hex: '#87CEEB' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Royal Blue', hex: '#4169E1' },
                    { name: 'Navy', hex: '#000080' },
                    { name: 'Purple', hex: '#800080' },
                    { name: 'Violet', hex: '#EE82EE' },
                    { name: 'Lavender', hex: '#E6E6FA' },
                    { name: 'Light Gray', hex: '#D3D3D3' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Dark Gray', hex: '#404040' },
                    { name: 'Black', hex: '#000000' }
                ],
                'ABS': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Ivory', hex: '#FFFFF0' },
                    { name: 'Light Yellow', hex: '#FFFFE0' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Lemon', hex: '#FFF44F' },
                    { name: 'Gold', hex: '#FFD700' },
                    { name: 'Light Orange', hex: '#FFD580' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Dark Orange', hex: '#FF8C00' },
                    { name: 'Salmon', hex: '#FA8072' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'Pink', hex: '#FFC0CB' },
                    { name: 'Hot Pink', hex: '#FF69B4' },
                    { name: 'Magenta', hex: '#FF00FF' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Dark Red', hex: '#8B0000' },
                    { name: 'Maroon', hex: '#800000' },
                    { name: 'Brown', hex: '#8B4513' },
                    { name: 'Tan', hex: '#D2B48C' },
                    { name: 'Beige', hex: '#F5DEB3' },
                    { name: 'Olive', hex: '#808000' },
                    { name: 'Lime', hex: '#00FF00' },
                    { name: 'Light Green', hex: '#90EE90' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Dark Green', hex: '#006400' },
                    { name: 'Teal', hex: '#008080' },
                    { name: 'Cyan', hex: '#00FFFF' },
                    { name: 'Light Blue', hex: '#ADD8E6' },
                    { name: 'Sky Blue', hex: '#87CEEB' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Royal Blue', hex: '#4169E1' },
                    { name: 'Navy', hex: '#000080' },
                    { name: 'Purple', hex: '#800080' },
                    { name: 'Violet', hex: '#EE82EE' },
                    { name: 'Lavender', hex: '#E6E6FA' },
                    { name: 'Light Gray', hex: '#D3D3D3' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Dark Gray', hex: '#404040' },
                    { name: 'Black', hex: '#000000' }
                ],
                'PETG': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Ivory', hex: '#FFFFF0' },
                    { name: 'Light Yellow', hex: '#FFFFE0' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Lemon', hex: '#FFF44F' },
                    { name: 'Gold', hex: '#FFD700' },
                    { name: 'Light Orange', hex: '#FFD580' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Dark Orange', hex: '#FF8C00' },
                    { name: 'Salmon', hex: '#FA8072' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'Pink', hex: '#FFC0CB' },
                    { name: 'Hot Pink', hex: '#FF69B4' },
                    { name: 'Magenta', hex: '#FF00FF' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Dark Red', hex: '#8B0000' },
                    { name: 'Maroon', hex: '#800000' },
                    { name: 'Brown', hex: '#8B4513' },
                    { name: 'Tan', hex: '#D2B48C' },
                    { name: 'Beige', hex: '#F5DEB3' },
                    { name: 'Olive', hex: '#808000' },
                    { name: 'Lime', hex: '#00FF00' },
                    { name: 'Light Green', hex: '#90EE90' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Dark Green', hex: '#006400' },
                    { name: 'Teal', hex: '#008080' },
                    { name: 'Cyan', hex: '#00FFFF' },
                    { name: 'Light Blue', hex: '#ADD8E6' },
                    { name: 'Sky Blue', hex: '#87CEEB' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Royal Blue', hex: '#4169E1' },
                    { name: 'Navy', hex: '#000080' },
                    { name: 'Purple', hex: '#800080' },
                    { name: 'Violet', hex: '#EE82EE' },
                    { name: 'Lavender', hex: '#E6E6FA' },
                    { name: 'Light Gray', hex: '#D3D3D3' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Dark Gray', hex: '#404040' },
                    { name: 'Black', hex: '#000000' }
                ],
                'TPU': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Pink', hex: '#FF69B4' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Cyan', hex: '#00FFFF' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Purple', hex: '#800080' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Black', hex: '#000000' }
                ]
            },
            'Polymaker': {
                'PLA': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Ivory', hex: '#FFFFF0' },
                    { name: 'Light Yellow', hex: '#FFFFE0' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Lemon', hex: '#FFF44F' },
                    { name: 'Gold', hex: '#FFD700' },
                    { name: 'Light Orange', hex: '#FFD580' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Dark Orange', hex: '#FF8C00' },
                    { name: 'Salmon', hex: '#FA8072' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'Pink', hex: '#FFC0CB' },
                    { name: 'Hot Pink', hex: '#FF69B4' },
                    { name: 'Magenta', hex: '#FF00FF' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Dark Red', hex: '#8B0000' },
                    { name: 'Maroon', hex: '#800000' },
                    { name: 'Brown', hex: '#8B4513' },
                    { name: 'Tan', hex: '#D2B48C' },
                    { name: 'Beige', hex: '#F5DEB3' },
                    { name: 'Olive', hex: '#808000' },
                    { name: 'Lime', hex: '#00FF00' },
                    { name: 'Light Green', hex: '#90EE90' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Dark Green', hex: '#006400' },
                    { name: 'Teal', hex: '#008080' },
                    { name: 'Cyan', hex: '#00FFFF' },
                    { name: 'Light Blue', hex: '#ADD8E6' },
                    { name: 'Sky Blue', hex: '#87CEEB' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Royal Blue', hex: '#4169E1' },
                    { name: 'Navy', hex: '#000080' },
                    { name: 'Purple', hex: '#800080' },
                    { name: 'Violet', hex: '#EE82EE' },
                    { name: 'Lavender', hex: '#E6E6FA' },
                    { name: 'Light Gray', hex: '#D3D3D3' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Dark Gray', hex: '#404040' },
                    { name: 'Black', hex: '#000000' }
                ],
                'ABS': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Black', hex: '#000000' }
                ],
                'PETG': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Black', hex: '#000000' },
                    { name: 'Clear', hex: '#F8F8FF' }
                ]
            },
            'Sunlu': {
                'PLA': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Ivory', hex: '#FFFFF0' },
                    { name: 'Light Yellow', hex: '#FFFFE0' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Lemon', hex: '#FFF44F' },
                    { name: 'Gold', hex: '#FFD700' },
                    { name: 'Light Orange', hex: '#FFD580' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Dark Orange', hex: '#FF8C00' },
                    { name: 'Salmon', hex: '#FA8072' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'Pink', hex: '#FFC0CB' },
                    { name: 'Hot Pink', hex: '#FF69B4' },
                    { name: 'Magenta', hex: '#FF00FF' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Dark Red', hex: '#8B0000' },
                    { name: 'Maroon', hex: '#800000' },
                    { name: 'Brown', hex: '#8B4513' },
                    { name: 'Tan', hex: '#D2B48C' },
                    { name: 'Beige', hex: '#F5DEB3' },
                    { name: 'Olive', hex: '#808000' },
                    { name: 'Lime', hex: '#00FF00' },
                    { name: 'Light Green', hex: '#90EE90' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Dark Green', hex: '#006400' },
                    { name: 'Teal', hex: '#008080' },
                    { name: 'Cyan', hex: '#00FFFF' },
                    { name: 'Light Blue', hex: '#ADD8E6' },
                    { name: 'Sky Blue', hex: '#87CEEB' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Royal Blue', hex: '#4169E1' },
                    { name: 'Navy', hex: '#000080' },
                    { name: 'Purple', hex: '#800080' },
                    { name: 'Violet', hex: '#EE82EE' },
                    { name: 'Lavender', hex: '#E6E6FA' },
                    { name: 'Light Gray', hex: '#D3D3D3' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Dark Gray', hex: '#404040' },
                    { name: 'Black', hex: '#000000' }
                ],
                'ABS': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Black', hex: '#000000' }
                ],
                'PETG': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Black', hex: '#000000' },
                    { name: 'Clear', hex: '#F8F8FF' }
                ]
            },
            'Overture': {
                'PLA': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Ivory', hex: '#FFFFF0' },
                    { name: 'Light Yellow', hex: '#FFFFE0' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Lemon', hex: '#FFF44F' },
                    { name: 'Gold', hex: '#FFD700' },
                    { name: 'Light Orange', hex: '#FFD580' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Dark Orange', hex: '#FF8C00' },
                    { name: 'Salmon', hex: '#FA8072' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'Pink', hex: '#FFC0CB' },
                    { name: 'Hot Pink', hex: '#FF69B4' },
                    { name: 'Magenta', hex: '#FF00FF' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Dark Red', hex: '#8B0000' },
                    { name: 'Maroon', hex: '#800000' },
                    { name: 'Brown', hex: '#8B4513' },
                    { name: 'Tan', hex: '#D2B48C' },
                    { name: 'Beige', hex: '#F5DEB3' },
                    { name: 'Olive', hex: '#808000' },
                    { name: 'Lime', hex: '#00FF00' },
                    { name: 'Light Green', hex: '#90EE90' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Dark Green', hex: '#006400' },
                    { name: 'Teal', hex: '#008080' },
                    { name: 'Cyan', hex: '#00FFFF' },
                    { name: 'Light Blue', hex: '#ADD8E6' },
                    { name: 'Sky Blue', hex: '#87CEEB' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Royal Blue', hex: '#4169E1' },
                    { name: 'Navy', hex: '#000080' },
                    { name: 'Purple', hex: '#800080' },
                    { name: 'Violet', hex: '#EE82EE' },
                    { name: 'Lavender', hex: '#E6E6FA' },
                    { name: 'Light Gray', hex: '#D3D3D3' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Dark Gray', hex: '#404040' },
                    { name: 'Black', hex: '#000000' }
                ],
                'ABS': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Black', hex: '#000000' }
                ],
                'PETG': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Black', hex: '#000000' },
                    { name: 'Clear', hex: '#F8F8FF' }
                ]
            },
            'Elegoo': {
                'PLA': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Ivory', hex: '#FFFFF0' },
                    { name: 'Light Yellow', hex: '#FFFFE0' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Lemon', hex: '#FFF44F' },
                    { name: 'Gold', hex: '#FFD700' },
                    { name: 'Light Orange', hex: '#FFD580' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Dark Orange', hex: '#FF8C00' },
                    { name: 'Salmon', hex: '#FA8072' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'Pink', hex: '#FFC0CB' },
                    { name: 'Hot Pink', hex: '#FF69B4' },
                    { name: 'Magenta', hex: '#FF00FF' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Dark Red', hex: '#8B0000' },
                    { name: 'Maroon', hex: '#800000' },
                    { name: 'Brown', hex: '#8B4513' },
                    { name: 'Tan', hex: '#D2B48C' },
                    { name: 'Beige', hex: '#F5DEB3' },
                    { name: 'Olive', hex: '#808000' },
                    { name: 'Lime', hex: '#00FF00' },
                    { name: 'Light Green', hex: '#90EE90' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Dark Green', hex: '#006400' },
                    { name: 'Teal', hex: '#008080' },
                    { name: 'Cyan', hex: '#00FFFF' },
                    { name: 'Light Blue', hex: '#ADD8E6' },
                    { name: 'Sky Blue', hex: '#87CEEB' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Royal Blue', hex: '#4169E1' },
                    { name: 'Navy', hex: '#000080' },
                    { name: 'Purple', hex: '#800080' },
                    { name: 'Violet', hex: '#EE82EE' },
                    { name: 'Lavender', hex: '#E6E6FA' },
                    { name: 'Light Gray', hex: '#D3D3D3' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Dark Gray', hex: '#404040' },
                    { name: 'Black', hex: '#000000' }
                ],
                'ABS': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Black', hex: '#000000' }
                ],
                'PETG': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Black', hex: '#000000' },
                    { name: 'Clear', hex: '#F8F8FF' }
                ]
            },
            'eSun': {
                'PLA+': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Ivory', hex: '#FFFFF0' },
                    { name: 'Light Yellow', hex: '#FFFFE0' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Lemon', hex: '#FFF44F' },
                    { name: 'Gold', hex: '#FFD700' },
                    { name: 'Light Orange', hex: '#FFD580' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Dark Orange', hex: '#FF8C00' },
                    { name: 'Salmon', hex: '#FA8072' },
                    { name: 'Light Pink', hex: '#FFB6C1' },
                    { name: 'Pink', hex: '#FFC0CB' },
                    { name: 'Hot Pink', hex: '#FF69B4' },
                    { name: 'Magenta', hex: '#FF00FF' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Dark Red', hex: '#8B0000' },
                    { name: 'Maroon', hex: '#800000' },
                    { name: 'Brown', hex: '#8B4513' },
                    { name: 'Tan', hex: '#D2B48C' },
                    { name: 'Beige', hex: '#F5DEB3' },
                    { name: 'Olive', hex: '#808000' },
                    { name: 'Lime', hex: '#00FF00' },
                    { name: 'Light Green', hex: '#90EE90' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Dark Green', hex: '#006400' },
                    { name: 'Teal', hex: '#008080' },
                    { name: 'Cyan', hex: '#00FFFF' },
                    { name: 'Light Blue', hex: '#ADD8E6' },
                    { name: 'Sky Blue', hex: '#87CEEB' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Royal Blue', hex: '#4169E1' },
                    { name: 'Navy', hex: '#000080' },
                    { name: 'Purple', hex: '#800080' },
                    { name: 'Violet', hex: '#EE82EE' },
                    { name: 'Lavender', hex: '#E6E6FA' },
                    { name: 'Light Gray', hex: '#D3D3D3' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Dark Gray', hex: '#404040' },
                    { name: 'Black', hex: '#000000' }
                ],
                'Silk PLA': [
                    { name: 'Silk Gold', hex: '#D4AF37' },
                    { name: 'Silk Silver', hex: '#C0C0C0' },
                    { name: 'Silk Copper', hex: '#B87333' },
                    { name: 'Silk Bronze', hex: '#CD7F32' },
                    { name: 'Silk Red', hex: '#DC143C' },
                    { name: 'Silk Blue', hex: '#4169E1' },
                    { name: 'Silk Green', hex: '#50C878' },
                    { name: 'Silk Purple', hex: '#8B008B' }
                ],
                'ABS': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Black', hex: '#000000' }
                ],
                'PETG': [
                    { name: 'White', hex: '#FFFFFF' },
                    { name: 'Yellow', hex: '#FFFF00' },
                    { name: 'Orange', hex: '#FFA500' },
                    { name: 'Red', hex: '#FF0000' },
                    { name: 'Green', hex: '#008000' },
                    { name: 'Blue', hex: '#0000FF' },
                    { name: 'Gray', hex: '#808080' },
                    { name: 'Black', hex: '#000000' },
                    { name: 'Clear', hex: '#F8F8FF' }
                ]
            }
        };
        
        // HTML16Ê®ôÊ∫ñ„Ç´„É©„Éº
        const HTML16_COLORS = [
            { name: 'Black', hex: '#000000' },
            { name: 'Maroon', hex: '#800000' },
            { name: 'Green', hex: '#008000' },
            { name: 'Olive', hex: '#808000' },
            { name: 'Navy', hex: '#000080' },
            { name: 'Purple', hex: '#800080' },
            { name: 'Teal', hex: '#008080' },
            { name: 'Silver', hex: '#C0C0C0' },
            { name: 'Gray', hex: '#808080' },
            { name: 'Red', hex: '#FF0000' },
            { name: 'Lime', hex: '#00FF00' },
            { name: 'Yellow', hex: '#FFFF00' },
            { name: 'Blue', hex: '#0000FF' },
            { name: 'Fuchsia', hex: '#FF00FF' },
            { name: 'Aqua', hex: '#00FFFF' },
            { name: 'White', hex: '#FFFFFF' }
        ];

        function initFilamentUI() {
            // Êú¨‰ΩìËâ≤Áî®
            initFilamentSelector('body', 'filament-vendor', 'filament-material', 'filament-palette', 
                'custom-color-section', 'custom-color-picker', 'html16-palette', 
                () => state.colBody, (hex) => { state.colBody = hex; });
            
            // ÊñáÂ≠óËâ≤Áî®
            initFilamentSelector('text', 'text-color-vendor', 'text-color-material', 'text-color-palette',
                'text-custom-color-section', 'text-custom-color-picker', 'text-html16-palette',
                () => state.colText, (hex) => { state.colText = hex; });
            
            // ExtruderÁï™Âè∑„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            const bodyExtruderSelect = document.getElementById('body-extruder');
            const textExtruderSelect = document.getElementById('text-extruder');
            
            if (bodyExtruderSelect) {
                bodyExtruderSelect.value = state.bodyExtruder || 1;
                bodyExtruderSelect.onchange = () => {
                    state.bodyExtruder = parseInt(bodyExtruderSelect.value);
                    amsConfig.bodyExtruder = state.bodyExtruder;
                    amsConfig.bodyExtruderSet = true;
                    showToast(`Êú¨‰Ωì Extruder: ${state.bodyExtruder}`);
                };
            }
            
            if (textExtruderSelect) {
                textExtruderSelect.value = state.textExtruder || 2;
                textExtruderSelect.onchange = () => {
                    state.textExtruder = parseInt(textExtruderSelect.value);
                    amsConfig.textExtruder = state.textExtruder;
                    amsConfig.textExtruderSet = true;
                    showToast(`ÊñáÂ≠ó Extruder: ${state.textExtruder}`);
                };
            }
        }
        
        function initFilamentSelector(type, vendorId, materialId, paletteId, customSectionId, pickerIdCustom, html16Id, getColor, setColor) {
            const vendorSelect = document.getElementById(vendorId);
            const materialSelect = document.getElementById(materialId);
            const palette = document.getElementById(paletteId);
            const customSection = document.getElementById(customSectionId);
            const colorPicker = document.getElementById(pickerIdCustom);
            const html16Palette = document.getElementById(html16Id);
            
            if (!vendorSelect || !materialSelect || !palette) return;
            
            // „Éô„É≥„ÉÄ„ÉºÈÅ∏ÊäûËÇ¢„ÇíÁîüÊàê
            Object.keys(FILAMENT_LIB).forEach(vendor => {
                const opt = document.createElement('option');
                opt.value = vendor;
                opt.textContent = vendor;
                vendorSelect.appendChild(opt);
            });
            
            // ÊùêÊñôÈÅ∏ÊäûËÇ¢„ÇíÊõ¥Êñ∞
            function updateMaterials() {
                const vendor = vendorSelect.value;
                materialSelect.innerHTML = '';
                Object.keys(FILAMENT_LIB[vendor]).forEach(mat => {
                    const opt = document.createElement('option');
                    opt.value = mat;
                    opt.textContent = mat;
                    materialSelect.appendChild(opt);
                });
                updatePalette();
            }
            
            // „Éë„É¨„ÉÉ„Éà„ÇíÊõ¥Êñ∞
            function updatePalette() {
                const vendor = vendorSelect.value;
                const material = materialSelect.value;
                const isCustom = vendor === 'Custom';
                
                palette.innerHTML = '';
                
                // „Ç´„Çπ„Çø„É†Áî®„Çª„ÇØ„Ç∑„Éß„É≥„ÅÆË°®Á§∫Âàá„ÇäÊõø„Åà
                if (customSection) {
                    customSection.style.display = isCustom ? 'block' : 'none';
                }
                
                if (isCustom) {
                    // „Ç´„Çπ„Çø„É†„ÅÆÂ†¥Âêà„ÅØHTML16„Éë„É¨„ÉÉ„Éà„ÇíÂàùÊúüÂåñ
                    initHTML16Palette();
                } else {
                    // „Éï„Ç£„É©„É°„É≥„Éà„Éë„É¨„ÉÉ„Éà
                    const colors = FILAMENT_LIB[vendor][material] || [];
                    colors.forEach(fil => {
                        const swatch = document.createElement('div');
                        swatch.className = 'color-swatch';
                        swatch.style.backgroundColor = fil.hex;
                        swatch.title = `${fil.name} (${fil.hex})`;
                        
                        if (fil.hex.toLowerCase() === getColor().toLowerCase()) {
                            swatch.classList.add('active');
                        }
                        
                        swatch.onclick = () => {
                            setColor(fil.hex);
                            requestUpdate();
                            updatePalette();
                            showToast(`${type === 'body' ? 'Êú¨‰ΩìËâ≤' : 'ÊñáÂ≠óËâ≤'}: ${fil.name}`);
                        };
                        palette.appendChild(swatch);
                    });
                }
            }
            
            // HTML16„Éë„É¨„ÉÉ„ÉàÂàùÊúüÂåñ
            function initHTML16Palette() {
                if (!html16Palette) return;
                html16Palette.innerHTML = '';
                
                HTML16_COLORS.forEach(c => {
                    const swatch = document.createElement('div');
                    swatch.style.cssText = `width:20px; height:20px; background:${c.hex}; border:1px solid #555; border-radius:2px; cursor:pointer;`;
                    swatch.title = c.name;
                    
                    if (c.hex.toLowerCase() === getColor().toLowerCase()) {
                        swatch.style.border = '2px solid #00e5ff';
                    }
                    
                    swatch.onclick = () => {
                        setColor(c.hex);
                        if (colorPicker) colorPicker.value = c.hex;
                        requestUpdate();
                        initHTML16Palette();
                        showToast(`${type === 'body' ? 'Êú¨‰ΩìËâ≤' : 'ÊñáÂ≠óËâ≤'}: ${c.name}`);
                    };
                    html16Palette.appendChild(swatch);
                });
                
                // „Ç´„É©„Éº„Éî„ÉÉ„Ç´„Éº„ÅÆÂÄ§„ÇíÂêåÊúü
                if (colorPicker) {
                    colorPicker.value = getColor();
                }
            }
            
            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            vendorSelect.onchange = updateMaterials;
            materialSelect.onchange = updatePalette;
            
            // „Ç´„É©„Éº„Éî„ÉÉ„Ç´„Éº„ÅÆ„Ç§„Éô„É≥„Éà
            if (colorPicker) {
                colorPicker.oninput = () => {
                    setColor(colorPicker.value);
                    requestUpdate();
                    initHTML16Palette();
                };
            }
            
            // ÂàùÊúüÂåñ
            updateMaterials();
            
            // „Ç∞„É≠„Éº„Éê„É´„ÅßÂÜçÊèèÁîª„Åß„Åç„Çã„Çà„ÅÜ„Å´
            if (type === 'body') {
                window.refreshFilamentPalette = updatePalette;
            }
        }

        // ==========================================
        // V67: üé® AMSËâ≤Ë®≠ÂÆö„Ç∑„Çπ„ÉÜ„É†
        // ==========================================
        const amsConfig = {
            units: [{ slots: [null, null, null, null] }], // AMS: 4„Çπ„É≠„ÉÉ„Éà {color, material}
            htUnits: [], // AMS HT: 1„Çπ„É≠„ÉÉ„Éà
            palette: [],
            currentVendor: 'Bambu Lab',
            currentMaterial: 'PLA Basic',
            bodyExtruder: null,
            textExtruder: null,
            bodyExtruderSet: false,  // „É¶„Éº„Ç∂„Éº„ÅåÊòéÁ§∫ÁöÑ„Å´Êú¨‰Ωì„Éï„Ç£„É©„É°„É≥„Éà„ÇíÈÅ∏Êäû„Åó„Åü„Åã
            textExtruderSet: false   // „É¶„Éº„Ç∂„Éº„ÅåÊòéÁ§∫ÁöÑ„Å´ÊñáÂ≠ó„Éï„Ç£„É©„É°„É≥„Éà„ÇíÈÅ∏Êäû„Åó„Åü„Åã
        };
        
        function initAMSConfig() {
            const btn = document.getElementById('btn-ams-config');
            const btnSimple = document.getElementById('btn-simple-ams-config');
            const overlay = document.getElementById('ams-popup-overlay');
            const popup = document.getElementById('ams-popup');
            const cancelBtn = document.getElementById('ams-popup-cancel');
            const confirmBtn = document.getElementById('ams-popup-confirm');
            
            if (!overlay) return;
            
            // localStorage„Åã„ÇâÂæ©ÂÖÉ
            const hasExistingConfig = loadAMSConfigFromStorage();
            
            // AMS„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆ„Éô„É≥„ÉÄ„Éº/ÊùêÊñôÈÅ∏Êäû„ÇíÂàùÊúüÂåñ
            initAMSFilamentSelectors();
            
            const openPopup = () => {
                overlay.style.display = 'flex';
                setTimeout(() => popup.classList.add('show'), 10);
                renderAMSPalette();
                renderAMSUnits();
            };
            
            // ÈÄöÂ∏∏„É¢„Éº„Éâ„ÅÆ„Éú„Çø„É≥
            if (btn) btn.onclick = openPopup;
            // Á∞°Âçò„É¢„Éº„Éâ„ÅÆ„Éú„Çø„É≥
            if (btnSimple) btnSimple.onclick = openPopup;
            
            const closePopup = () => {
                popup.classList.remove('show');
                setTimeout(() => overlay.style.display = 'none', 200);
            };
            
            cancelBtn.onclick = closePopup;
            overlay.onclick = (e) => { if (e.target === overlay) closePopup(); };
            
            confirmBtn.onclick = () => {
                saveAMSConfigToStorage(); // ‰øùÂ≠ò
                updateSettingsTabPalette();
                closePopup();
                showToast('AMSËâ≤Ë®≠ÂÆö„ÇíÈÅ©Áî®„Éª‰øùÂ≠ò„Åó„Åæ„Åó„Åü');
            };
            
            // AMSÁ¢∫Ë™ç„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆÂá¶ÁêÜ
            const confirmOverlay = document.getElementById('ams-confirm-overlay');
            const confirmNowBtn = document.getElementById('ams-confirm-now');
            const confirmLaterBtn = document.getElementById('ams-confirm-later');
            
            if (confirmOverlay && confirmNowBtn && confirmLaterBtn) {
                const closeConfirmPopup = () => {
                    confirmOverlay.style.background = 'rgba(0,0,0,0)';
                    confirmOverlay.querySelector('.export-popup').classList.remove('show');
                    setTimeout(() => {
                        confirmOverlay.style.display = 'none';
                    }, 300);
                };
                
                confirmNowBtn.onclick = () => {
                    closeConfirmPopup();
                    // Â∞ë„ÅóÈÅÖÂª∂„Åï„Åõ„Å¶AMSË®≠ÂÆö„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÈñã„Åè
                    setTimeout(openPopup, 350);
                };
                
                confirmLaterBtn.onclick = () => {
                    closeConfirmPopup();
                    // „ÄåÂæå„ÅßË®≠ÂÆö„Äç„ÇíÈÅ∏„Çì„Å†„Åì„Å®„ÇíË®òÈå≤
                    localStorage.setItem('keycapAMSConfirmDismissed', 'true');
                };
                
                // „Ç™„Éº„Éê„Éº„É¨„Ç§„ÇØ„É™„ÉÉ„ÇØ„ÅßÈñâ„Åò„ÇãÔºà„ÄåÂæå„ÅßË®≠ÂÆö„Äç„Å®Âêå„ÅòÊâ±„ÅÑÔºâ
                confirmOverlay.onclick = (e) => {
                    if (e.target === confirmOverlay) {
                        closeConfirmPopup();
                        localStorage.setItem('keycapAMSConfirmDismissed', 'true');
                    }
                };
                
                // ÂàùÂõûËµ∑ÂãïÊôÇÔºàAMSË®≠ÂÆö„Åå„Å™„Åè„ÄÅÁ¢∫Ë™ç„ÇíÈñâ„Åò„Å¶„ÅÑ„Å™„ÅÑÂ†¥ÂêàÔºâ„Å´Á¢∫Ë™ç„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíË°®Á§∫
                if (!hasExistingConfig && !localStorage.getItem('keycapAMSConfirmDismissed')) {
                    // ÁøªË®≥„ÇíÈÅ©Áî®
                    const t = translations[currentLang];
                    const titleEl = document.getElementById('ams-confirm-title');
                    const msgEl = document.getElementById('ams-confirm-message');
                    const hintEl = confirmOverlay.querySelector('[data-i18n="ams_confirm_hint"]');
                    if (titleEl && t.ams_confirm_title) titleEl.textContent = t.ams_confirm_title;
                    if (msgEl && t.ams_confirm_message) msgEl.innerHTML = t.ams_confirm_message;
                    if (hintEl && t.ams_confirm_hint) hintEl.textContent = t.ams_confirm_hint;
                    if (confirmLaterBtn && t.ams_confirm_later) confirmLaterBtn.textContent = t.ams_confirm_later;
                    if (confirmNowBtn && t.ams_confirm_now) confirmNowBtn.textContent = t.ams_confirm_now;
                    
                    // Â∞ë„ÅóÈÅÖÂª∂„Åï„Åõ„Å¶Ë°®Á§∫
                    setTimeout(() => {
                        confirmOverlay.style.display = 'flex';
                        requestAnimationFrame(() => {
                            confirmOverlay.style.background = 'rgba(0,0,0,0.7)';
                            confirmOverlay.querySelector('.export-popup').classList.add('show');
                        });
                    }, 1500);
                }
            }
            
            // AMSËøΩÂä†„Éú„Çø„É≥
            document.getElementById('ams-add-unit').onclick = () => {
                if (amsConfig.units.length < 4) {
                    amsConfig.units.push({ slots: [null, null, null, null] });
                    renderAMSUnits();
                }
            };
            
            // AMS HTËøΩÂä†„Éú„Çø„É≥
            document.getElementById('ams-ht-add-unit').onclick = () => {
                if (amsConfig.htUnits.length < 8) {
                    amsConfig.htUnits.push({ slots: [null] });
                    renderAMSUnits();
                }
            };
            
            // „Ç´„Çπ„Çø„É†Ëâ≤ËøΩÂä†
            document.getElementById('ams-add-custom-color').onclick = () => {
                const color = document.getElementById('ams-custom-color').value;
                const material = amsConfig.currentMaterial || 'Custom';
                const existing = amsConfig.palette.find(p => p.color === color);
                if (!existing) {
                    amsConfig.palette.push({ color, material });
                    renderAMSPalette();
                }
            };
            
            // JSONÊõ∏„ÅçÂá∫„Åó„Éú„Çø„É≥
            const exportBtn = document.getElementById('ams-export-json');
            if (exportBtn) {
                exportBtn.onclick = () => {
                    exportAMSConfigAsJSON();
                };
            }
            
            // JSONË™≠„ÅøËæº„Åø„Éú„Çø„É≥
            const importBtn = document.getElementById('btn-ams-import-json');
            const importInput = document.getElementById('ams-import-json-input');
            if (importBtn && importInput) {
                importBtn.onclick = () => importInput.click();
                importInput.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        importAMSConfigFromJSON(file);
                        importInput.value = '';
                    }
                };
            }
            
            // HUD„ÅÆAMS„Éú„Çø„É≥
            const hudAmsBtn = document.getElementById('hud-ams');
            if (hudAmsBtn) hudAmsBtn.onclick = openPopup;
            
            // „Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„ÉàÂèñ„ÇäËæº„ÅøÊ©üËÉΩ
            initScreenshotImport(openPopup);
            
            // ÂàùÂõû„Éë„É¨„ÉÉ„ÉàÊõ¥Êñ∞
            updateSettingsTabPalette();
        }
        
        // „Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„Éà„Åã„ÇâAMSËâ≤„ÇíÂèñ„ÇäËæº„ÇÄÊ©üËÉΩ
        function initScreenshotImport(openAmsPopup) {
            const screenshotBtn = document.getElementById('ams-screenshot-import');
            const screenshotOverlay = document.getElementById('screenshot-overlay');
            const screenshotPopup = screenshotOverlay?.querySelector('.export-popup');
            
            if (!screenshotBtn || !screenshotOverlay) return;
            
            // Ë¶ÅÁ¥†ÂèñÂæó
            const step1 = document.getElementById('screenshot-step1');
            const step2 = document.getElementById('screenshot-step2');
            const step3 = document.getElementById('screenshot-step3');
            const captureBtn = document.getElementById('screenshot-capture-btn');
            const retryBtn = document.getElementById('screenshot-retry-btn');
            const backBtn = document.getElementById('screenshot-back-btn');
            const applyBtn = document.getElementById('screenshot-apply-btn');
            const cancelBtn = document.getElementById('screenshot-cancel-btn');
            const canvas = document.getElementById('screenshot-canvas');
            const resultsDiv = document.getElementById('screenshot-results');
            
            let capturedImage = null;
            let detectedColors = [];
            let pickedColors = [];
            
            // „Çπ„ÉÜ„ÉÉ„ÉóÂàá„ÇäÊõø„Åà
            const showStep = (step) => {
                step1.style.display = step === 1 ? 'block' : 'none';
                step2.style.display = step === 2 ? 'block' : 'none';
                step3.style.display = step === 3 ? 'block' : 'none';
            };
            
            // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÈñã„Åè
            const openScreenshotPopup = () => {
                screenshotOverlay.style.display = 'flex';
                requestAnimationFrame(() => {
                    screenshotOverlay.style.background = 'rgba(0,0,0,0.85)';
                    screenshotPopup.classList.add('show');
                });
                showStep(1);
                detectedColors = [];
                pickedColors = [];
            };
            
            // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÈñâ„Åò„Çã
            const closeScreenshotPopup = () => {
                screenshotOverlay.style.background = 'rgba(0,0,0,0)';
                screenshotPopup.classList.remove('show');
                setTimeout(() => {
                    screenshotOverlay.style.display = 'none';
                }, 300);
            };
            
            // „Éú„Çø„É≥„ÇØ„É™„ÉÉ„ÇØ
            screenshotBtn.onclick = openScreenshotPopup;
            cancelBtn.onclick = closeScreenshotPopup;
            screenshotOverlay.onclick = (e) => {
                if (e.target === screenshotOverlay) closeScreenshotPopup();
            };
            
            // ÁîªÈù¢„Ç≠„É£„Éó„ÉÅ„É£
            captureBtn.onclick = async () => {
                try {
                    // „Ç¶„Ç£„É≥„Éâ„Ç¶ÈÅ∏Êäû„ÇíÂÑ™ÂÖà„Åô„Çã„Ç™„Éó„Ç∑„Éß„É≥
                    const stream = await navigator.mediaDevices.getDisplayMedia({
                        video: { 
                            cursor: 'never',
                            displaySurface: 'window' // „Ç¶„Ç£„É≥„Éâ„Ç¶ÈÅ∏Êäû„ÇíÂÑ™ÂÖà
                        },
                        audio: false,
                        preferCurrentTab: false
                    });
                    
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    await video.play();
                    
                    // Â∞ë„ÅóÂæÖ„Å£„Å¶„Åã„Çâ„Ç≠„É£„Éó„ÉÅ„É£
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Êã°Â§ßÂÄçÁéá„ÇíÂèñÂæó
                    const scaleSelect = document.getElementById('screenshot-scale');
                    const upscale = scaleSelect ? parseFloat(scaleSelect.value) : 2;
                    
                    // Canvas„Å´„Ç≠„É£„Éó„ÉÅ„É£ÔºàÊã°Â§ßÔºÅÔºâ
                    const ctx = canvas.getContext('2d');
                    canvas.width = video.videoWidth * upscale;
                    canvas.height = video.videoHeight * upscale;
                    
                    // ÁîªÂÉèË£úÈñì„ÇíÊúâÂäπ„Å´„Åó„Å¶Êã°Â§ßÊèèÁîª
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    capturedImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    // „Çπ„Éà„É™„Éº„É†„ÇíÂÅúÊ≠¢
                    stream.getTracks().forEach(track => track.stop());
                    
                    // „Ç≠„É£„É≥„Éê„Çπ„Ç≥„É≥„ÉÜ„Éä„ÅÆ„Çπ„ÇØ„É≠„Éº„É´Ë®≠ÂÆö
                    const container = document.getElementById('screenshot-canvas-container');
                    if (container) {
                        container.style.overflow = 'auto';
                        container.style.maxHeight = '450px';
                        // Ë°®Á§∫„ÇÇÊã°Â§ßÔºÅÔºà„Çπ„ÇØ„É≠„Éº„É´„ÅßË¶ã„Çâ„Çå„Çã„Çà„ÅÜ„Å´„Åô„ÇãÔºâ
                        // ÂÖÉ„ÅÆ„Çµ„Ç§„Ç∫„ÅßË°®Á§∫ÔºàÂÜÖÈÉ®„Éá„Éº„Çø„Å®Âêå„Åò„Çµ„Ç§„Ç∫Ôºâ
                        canvas.style.width = canvas.width + 'px';
                        canvas.style.height = canvas.height + 'px';
                        canvas.style.imageRendering = 'auto';
                        
                        // „Ç∫„Éº„É†„É¨„Éô„É´„ÇíÂàùÊúüÂåñ
                        currentZoom = 1.0;
                        updateZoomDisplay();
                    }
                    
                    console.log(`„Ç≠„É£„Éó„ÉÅ„É£ÂÆå‰∫Ü: ÂÖÉ=${video.videoWidth}x${video.videoHeight}px ‚Üí Êã°Â§ßÂæå=${canvas.width}x${canvas.height}px (${upscale}ÂÄç)`);
                    console.log(`Ë°®Á§∫„Çµ„Ç§„Ç∫: ${canvas.width}x${canvas.height}pxÔºà„Çπ„ÇØ„É≠„Éº„É´„ÅßÂÖ®‰Ωì„ÇíË¶ã„Çâ„Çå„Åæ„ÅôÔºâ`);
                    
                    // „Éî„ÉÉ„ÇØ„Åó„ÅüËâ≤„Çí„É™„Çª„ÉÉ„Éà
                    pickedColors = [];
                    updatePickedColorsUI();
                    
                    // „Çπ„ÉÜ„ÉÉ„Éó2„Å∏
                    showStep(2);
                    
                } catch (err) {
                    console.error('ÁîªÈù¢„Ç≠„É£„Éó„ÉÅ„É£„Ç®„É©„Éº:', err);
                    if (err.name !== 'AbortError') {
                        showToast('ÁîªÈù¢„Ç≠„É£„Éó„ÉÅ„É£„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü', true);
                    }
                }
            };
            
            // „Ç∫„Éº„É†Ê©üËÉΩ
            let currentZoom = 1.0;
            const zoomInBtn = document.getElementById('screenshot-zoom-in');
            const zoomOutBtn = document.getElementById('screenshot-zoom-out');
            const zoomFitBtn = document.getElementById('screenshot-zoom-fit');
            const zoomLevelEl = document.getElementById('screenshot-zoom-level');
            
            function updateZoomDisplay() {
                if (zoomLevelEl) zoomLevelEl.textContent = Math.round(currentZoom * 100) + '%';
                canvas.style.width = (canvas.width * currentZoom) + 'px';
                canvas.style.height = (canvas.height * currentZoom) + 'px';
            }
            
            if (zoomInBtn) zoomInBtn.onclick = () => {
                currentZoom = Math.min(3.0, currentZoom + 0.25);
                updateZoomDisplay();
            };
            
            if (zoomOutBtn) zoomOutBtn.onclick = () => {
                currentZoom = Math.max(0.25, currentZoom - 0.25);
                updateZoomDisplay();
            };
            
            if (zoomFitBtn) zoomFitBtn.onclick = () => {
                const container = document.getElementById('screenshot-canvas-container');
                if (container && canvas.width > 0) {
                    currentZoom = Math.min(
                        (container.clientWidth - 20) / canvas.width,
                        (container.clientHeight - 20) / canvas.height,
                        1.0
                    );
                    updateZoomDisplay();
                }
            };
            
            // „ÇØ„É™„ÉÉ„ÇØ„ÅßËâ≤„ÇíÂèñÂæó
            const clickStatusEl = document.getElementById('screenshot-click-status');
            const pickedColorsEl = document.getElementById('screenshot-picked-colors');
            const colorCountEl = document.getElementById('screenshot-color-count');
            const undoBtn = document.getElementById('screenshot-undo-btn');
            const doneBtn = document.getElementById('screenshot-done-btn');
            
            function updatePickedColorsUI() {
                if (!pickedColorsEl) return;
                pickedColorsEl.innerHTML = '';
                
                if (pickedColors.length === 0) {
                    // Á©∫„ÅÆ„Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„Éº„ÅØ‰∏çË¶Å
                } else {
                    pickedColors.forEach((color, idx) => {
                        const colorBox = document.createElement('div');
                        colorBox.style.cssText = `width:18px; height:18px; border-radius:2px; border:1px solid #00e5ff; background:${color};`;
                        colorBox.title = `${idx + 1}: ${color}`;
                        pickedColorsEl.appendChild(colorBox);
                    });
                }
                
                // „Çπ„ÉÜ„Éº„Çø„ÇπÊõ¥Êñ∞
                const nextNum = pickedColors.length + 1;
                
                if (clickStatusEl) {
                    clickStatusEl.textContent = `${nextNum}Áï™„ÅÆ„Éë„É¨„ÉÉ„Éà„Çí„ÇØ„É™„ÉÉ„ÇØ`;
                }
                if (colorCountEl) {
                    colorCountEl.textContent = `${pickedColors.length}`;
                }
                if (doneBtn) {
                    doneBtn.textContent = `‚úìÂÆå‰∫Ü(${pickedColors.length})`;
                }
            }
            
            // „Ç≠„É£„É≥„Éê„Çπ„ÇØ„É™„ÉÉ„ÇØ„ÅßËâ≤„ÇíÂèñÂæó
            canvas.onclick = (e) => {
                if (!capturedImage) return;
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = Math.floor((e.clientX - rect.left) * scaleX);
                const y = Math.floor((e.clientY - rect.top) * scaleY);
                
                // „ÇØ„É™„ÉÉ„ÇØ‰ΩçÁΩÆ„ÅÆÂë®Âõ≤5x5„Éî„ÇØ„Çª„É´„ÅÆÂπ≥ÂùáËâ≤„ÇíÂèñÂæó
                const ctx = canvas.getContext('2d');
                const sampleSize = 5;
                let rSum = 0, gSum = 0, bSum = 0, count = 0;
                
                for (let dy = -sampleSize; dy <= sampleSize; dy++) {
                    for (let dx = -sampleSize; dx <= sampleSize; dx++) {
                        const px = x + dx;
                        const py = y + dy;
                        if (px >= 0 && px < canvas.width && py >= 0 && py < canvas.height) {
                            const imgData = ctx.getImageData(px, py, 1, 1).data;
                            rSum += imgData[0];
                            gSum += imgData[1];
                            bSum += imgData[2];
                            count++;
                        }
                    }
                }
                
                if (count > 0) {
                    const r = Math.round(rSum / count);
                    const g = Math.round(gSum / count);
                    const b = Math.round(bSum / count);
                    const hex = '#' + [r, g, b].map(c => c.toString(16).padStart(2, '0')).join('');
                    
                    pickedColors.push(hex);
                    console.log(`„Çπ„É≠„ÉÉ„Éà${pickedColors.length}: „ÇØ„É™„ÉÉ„ÇØ‰ΩçÁΩÆ(${x}, ${y}) ‚Üí ${hex}`);
                    
                    // „ÇØ„É™„ÉÉ„ÇØ‰ΩçÁΩÆ„Å´„Éû„Éº„Ç´„Éº„ÇíÊèèÁîª
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = hex;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Áï™Âè∑„ÇíÊèèÁîª
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(pickedColors.length.toString(), x, y);
                    
                    updatePickedColorsUI();
                }
            };
            
            // Âèñ„ÇäÊ∂à„Åó„Éú„Çø„É≥
            if (undoBtn) undoBtn.onclick = () => {
                if (pickedColors.length > 0) {
                    pickedColors.pop();
                    // „Ç≠„É£„É≥„Éê„Çπ„ÇíÂÜçÊèèÁîªÔºà„Éû„Éº„Ç´„Éº„ÇíÊ∂à„ÅôÔºâ
                    const ctx = canvas.getContext('2d');
                    ctx.putImageData(capturedImage, 0, 0);
                    // ÊÆã„Çä„ÅÆ„Éû„Éº„Ç´„Éº„ÇíÂÜçÊèèÁîª
                    pickedColors.forEach((color, idx) => {
                        // „Éû„Éº„Ç´„Éº‰ΩçÁΩÆ„ÅØË®òÈå≤„Åó„Å¶„ÅÑ„Å™„ÅÑ„ÅÆ„Åß„ÄÅËâ≤„Å†„ÅëË°®Á§∫
                    });
                    updatePickedColorsUI();
                }
            };
            
            // ÂÆå‰∫Ü„Éú„Çø„É≥
            if (doneBtn) doneBtn.onclick = () => {
                if (pickedColors.length > 0) {
                    detectedColors = [...pickedColors];
                    displayDetectedColors();
                    showStep(3);
                } else {
                    showToast('Ëâ≤„Çí1„Å§‰ª•‰∏ä„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ', true);
                }
            };
            
            // ÂÜç„Ç≠„É£„Éó„ÉÅ„É£ÔºàÊúÄÂàù„Åã„ÇâÔºâ
            retryBtn.onclick = () => {
                pickedColors = [];
                updatePickedColorsUI();
                showStep(1);
            };
            
            // ËøΩÂä†„Ç≠„É£„Éó„ÉÅ„É£ÔºàËâ≤„Çí‰øùÊåÅ„Åó„Åü„Åæ„ÅæÔºâ
            const addCaptureBtn = document.getElementById('screenshot-add-capture-btn');
            if (addCaptureBtn) {
                addCaptureBtn.onclick = async () => {
                    try {
                        const stream = await navigator.mediaDevices.getDisplayMedia({
                            video: { 
                                cursor: 'never',
                                displaySurface: 'window'
                            },
                            audio: false,
                            preferCurrentTab: false
                        });
                        
                        const video = document.createElement('video');
                        video.srcObject = stream;
                        await video.play();
                        
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        const scaleSelect = document.getElementById('screenshot-scale');
                        const upscale = scaleSelect ? parseFloat(scaleSelect.value) : 2;
                        
                        const ctx = canvas.getContext('2d');
                        canvas.width = video.videoWidth * upscale;
                        canvas.height = video.videoHeight * upscale;
                        
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        
                        capturedImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        
                        stream.getTracks().forEach(track => track.stop());
                        
                        const container = document.getElementById('screenshot-canvas-container');
                        if (container) {
                            container.style.overflow = 'auto';
                            container.style.maxHeight = '450px';
                            canvas.style.width = canvas.width + 'px';
                            canvas.style.height = canvas.height + 'px';
                            canvas.style.imageRendering = 'auto';
                            
                            currentZoom = 1.0;
                            updateZoomDisplay();
                        }
                        
                        console.log(`ËøΩÂä†„Ç≠„É£„Éó„ÉÅ„É£ÂÆå‰∫Ü: ${canvas.width}x${canvas.height}px (‰øùÊåÅ‰∏≠„ÅÆËâ≤: ${pickedColors.length}Ëâ≤)`);
                        showToast(`ËøΩÂä†„Ç≠„É£„Éó„ÉÅ„É£ÂÆå‰∫ÜÔºà${pickedColors.length}Ëâ≤‰øùÊåÅ‰∏≠Ôºâ`);
                        
                    } catch (err) {
                        console.error('ËøΩÂä†„Ç≠„É£„Éó„ÉÅ„É£„Ç®„É©„Éº:', err);
                        if (err.name !== 'AbortError') {
                            showToast('„Ç≠„É£„Éó„ÉÅ„É£„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü', true);
                        }
                    }
                };
            }
            
            // Êàª„Çã
            backBtn.onclick = () => {
                showStep(2);
                // ÂèñÂæó„Åó„ÅüËâ≤„Çí‰øùÊåÅ„Åó„Åü„Åæ„ÅæÊàª„Çã
            };
            
            // AMS„Å´ÈÅ©Áî®
            applyBtn.onclick = () => {
                applyColorsToAMS(detectedColors);
                closeScreenshotPopup();
                showToast(`${detectedColors.filter(c => c).length}Ëâ≤„ÇíAMS„Çπ„É≠„ÉÉ„Éà„Å´ÈÅ©Áî®„Åó„Åæ„Åó„Åü`);
                renderAMSUnits();
            };
            
            // ÁîªÂÉè„Åã„ÇâËâ≤„ÇíÊ§úÂá∫„Åô„ÇãÈñ¢Êï∞Ôºàv5 - ‰ΩçÁΩÆ„Éô„Éº„ÇπÊ§úÂá∫Ôºâ
            // Bambu Studio„ÅÆËâ≤„Éú„ÉÉ„ÇØ„Çπ„ÅØÂêÑË°å„ÅÆÂ∑¶ÂÅ¥„ÄÅÂõ∫ÂÆö‰ΩçÁΩÆ„Å´„ÅÇ„Çã
            function detectColorsFromImage(imageData, numSlots, boxStartRatio = 0.05, boxEndRatio = 0.30) {
                const { data, width, height } = imageData;
                const colors = [];
                
                // ÂêÑ„Çπ„É≠„ÉÉ„Éà„ÅÆÈ´ò„Åï„ÇíË®àÁÆó
                const slotHeight = height / numSlots;
                
                console.log(`=== Ëâ≤Ê§úÂá∫ÈñãÂßã ===`);
                console.log(`ÁîªÂÉè: ${width}x${height}px, ${numSlots}„Çπ„É≠„ÉÉ„Éà, Ë°åÈ´ò„Åï=${slotHeight.toFixed(1)}px`);
                
                // Ëâ≤„Éú„ÉÉ„ÇØ„Çπ„ÅÆ‰ΩçÁΩÆÔºà„Çπ„É©„Ç§„ÉÄ„Éº„ÅßË™øÊï¥ÂèØËÉΩÔºâ
                const colorBoxStartX = Math.floor(width * boxStartRatio);
                const colorBoxEndX = Math.floor(width * boxEndRatio);
                const colorBoxWidth = colorBoxEndX - colorBoxStartX;
                
                console.log(`Ëâ≤„Éú„ÉÉ„ÇØ„ÇπÊ§úÁ¥¢ÁØÑÂõ≤: x=${colorBoxStartX}„Äú${colorBoxEndX} (ÂπÖ${colorBoxWidth}px, ${Math.round(boxStartRatio*100)}%„Äú${Math.round(boxEndRatio*100)}%)`);
                
                
                for (let i = 0; i < numSlots; i++) {
                    // ÂêÑ„Çπ„É≠„ÉÉ„Éà„ÅÆYÁØÑÂõ≤
                    const rowStartY = Math.floor(slotHeight * i);
                    const rowEndY = Math.floor(slotHeight * (i + 1));
                    const centerY = Math.floor((rowStartY + rowEndY) / 2);
                    
                    // „Çµ„É≥„Éó„É™„É≥„Ç∞ÁØÑÂõ≤ÔºàË°å„ÅÆ‰∏≠Â§Æ50%Ôºâ
                    const sampleStartY = Math.floor(centerY - slotHeight * 0.25);
                    const sampleEndY = Math.floor(centerY + slotHeight * 0.25);
                    
                    // Ëâ≤„Éú„ÉÉ„ÇØ„ÇπÈ†òÂüü„ÅÆÂÖ®„Éî„ÇØ„Çª„É´„ÇíÂèéÈõÜ
                    const pixels = [];
                    for (let sy = sampleStartY; sy <= sampleEndY; sy++) {
                        for (let sx = colorBoxStartX; sx <= colorBoxEndX; sx++) {
                            if (sy >= 0 && sy < height && sx >= 0 && sx < width) {
                                const idx = (sy * width + sx) * 4;
                                pixels.push({
                                    r: data[idx],
                                    g: data[idx + 1],
                                    b: data[idx + 2],
                                    x: sx,
                                    y: sy
                                });
                            }
                        }
                    }
                    
                    // ÊúÄ„ÇÇÂ§ö„ÅÑËâ≤„ÇíË¶ã„Å§„Åë„ÇãÔºàk-means„ÅÆÁ∞°ÊòìÁâàÔºâ
                    const colorGroups = [];
                    const threshold = 30; // Ëâ≤„ÅÆÈ°û‰ººÂ∫¶ÈñæÂÄ§
                    
                    for (const p of pixels) {
                        let foundGroup = false;
                        for (const group of colorGroups) {
                            const diff = Math.abs(group.r - p.r) + Math.abs(group.g - p.g) + Math.abs(group.b - p.b);
                            if (diff < threshold) {
                                // „Ç∞„É´„Éº„Éó„Å´ËøΩÂä†
                                const n = group.count;
                                group.r = (group.r * n + p.r) / (n + 1);
                                group.g = (group.g * n + p.g) / (n + 1);
                                group.b = (group.b * n + p.b) / (n + 1);
                                group.count++;
                                foundGroup = true;
                                break;
                            }
                        }
                        if (!foundGroup) {
                            colorGroups.push({ r: p.r, g: p.g, b: p.b, count: 1 });
                        }
                    }
                    
                    // „Ç∞„É´„Éº„Éó„Çí„Ç´„Ç¶„É≥„ÉàÈ†Ü„Å´„ÇΩ„Éº„Éà
                    colorGroups.sort((a, b) => b.count - a.count);
                    
                    console.log(`„Çπ„É≠„ÉÉ„Éà${i + 1}: ${colorGroups.length}„Ç∞„É´„Éº„ÉóÊ§úÂá∫`);
                    colorGroups.slice(0, 3).forEach((g, idx) => {
                        const hex = '#' + [Math.round(g.r), Math.round(g.g), Math.round(g.b)]
                            .map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
                        console.log(`  ${idx + 1}‰Ωç: ${hex} (${g.count}px)`);
                    });
                    
                    // ËÉåÊôØËâ≤ÔºàÊöó„ÅÑ„Ç∞„É¨„Éº„ÄÅRGBÂêÑÊàêÂàÜ„ÅåËøë„ÅÑ‰Ωé„ÅÑÂÄ§Ôºâ„ÇíÈô§Â§ñ„Åó„Å¶ÊúÄÂ§ß„Ç∞„É´„Éº„Éó„ÇíÈÅ∏Êäû
                    let selectedGroup = null;
                    for (const group of colorGroups) {
                        const brightness = (group.r + group.g + group.b) / 3;
                        const isGray = Math.abs(group.r - group.g) < 15 && 
                                       Math.abs(group.g - group.b) < 15 && 
                                       Math.abs(group.r - group.b) < 15;
                        const isDarkGray = isGray && brightness < 60;
                        
                        // ËÉåÊôØËâ≤ÔºàÊöó„ÅÑ„Ç∞„É¨„ÉºÔºâ‰ª•Â§ñ„ÅßÊúÄÂ§ß„ÅÆ„Ç∞„É´„Éº„Éó„ÇíÈÅ∏Êäû
                        // „Åü„Å†„Åó„ÄÅÈªíÔºàbrightness < 30Ôºâ„ÅØËâ≤„Å®„Åó„Å¶Ë™çË≠ò
                        if (!isDarkGray || brightness < 30) {
                            selectedGroup = group;
                            break;
                        }
                    }
                    
                    if (selectedGroup) {
                        const r = Math.round(selectedGroup.r);
                        const g = Math.round(selectedGroup.g);
                        const b = Math.round(selectedGroup.b);
                        const hex = '#' + [r, g, b]
                            .map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
                        
                        const brightness = (r + g + b) / 3;
                        const max = Math.max(r, g, b);
                        const min = Math.min(r, g, b);
                        const saturation = max - min;
                        
                        console.log(`  ‚Üí Êé°Áî®: ${hex} (ÊòéÂ∫¶=${brightness.toFixed(0)}, ÂΩ©Â∫¶=${saturation})`);
                        colors.push(hex);
                    } else {
                        console.log(`  ‚Üí Ëâ≤„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü`);
                        colors.push(null);
                    }
                }
                
                console.log(`=== Ê§úÂá∫ÂÆå‰∫Ü: ${colors.filter(c => c).length}/${numSlots}Ëâ≤ ===`);
                return colors;
            }
            
            // Ê§úÂá∫ÁµêÊûú„ÇíË°®Á§∫
            function displayDetectedColors() {
                resultsDiv.innerHTML = '';
                
                // „Ç∞„É™„ÉÉ„ÉâÂàóÊï∞„ÇíË™øÊï¥
                const cols = detectedColors.length <= 8 ? 4 : (detectedColors.length <= 12 ? 6 : 8);
                resultsDiv.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
                
                detectedColors.forEach((color, idx) => {
                    const div = document.createElement('div');
                    div.style.cssText = 'display:flex; flex-direction:column; align-items:center; padding:3px; background:#252535; border-radius:3px;';
                    
                    const colorBox = document.createElement('div');
                    colorBox.style.cssText = `width:24px; height:24px; border-radius:3px; border:1px solid ${color ? '#00e5ff' : '#555'}; background:${color || '#333'};`;
                    
                    const amsUnit = Math.floor(idx / 4) + 1;
                    const slotNum = (idx % 4) + 1;
                    
                    const label = document.createElement('div');
                    label.style.cssText = 'font-size:0.5rem; color:#888; margin-top:2px;';
                    label.textContent = `${amsUnit}-${slotNum}`;
                    
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.value = color || '#333333';
                    colorInput.style.cssText = 'width:20px; height:12px; border:none; cursor:pointer; margin-top:2px;';
                    colorInput.onchange = (e) => {
                        detectedColors[idx] = e.target.value;
                        colorBox.style.background = e.target.value;
                        colorBox.style.borderColor = '#00e5ff';
                    };
                    
                    div.appendChild(colorBox);
                    div.appendChild(label);
                    div.appendChild(colorInput);
                    resultsDiv.appendChild(div);
                });
            }
            
            // AMS„Çπ„É≠„ÉÉ„Éà„Å´Ëâ≤„ÇíÈÅ©Áî®
            function applyColorsToAMS(colors) {
                // ÊúÄÂàù„ÅÆAMS„É¶„Éã„ÉÉ„Éà„Å´ÈÅ©Áî®Ôºà4„Çπ„É≠„ÉÉ„ÉàÔºâ
                if (amsConfig.units.length === 0) {
                    amsConfig.units.push({ slots: [null, null, null, null] });
                }
                
                let colorIndex = 0;
                
                // AMS„É¶„Éã„ÉÉ„Éà„Å´ÈÅ©Áî®
                for (let unitIdx = 0; unitIdx < amsConfig.units.length && colorIndex < colors.length; unitIdx++) {
                    for (let slotIdx = 0; slotIdx < 4 && colorIndex < colors.length; slotIdx++) {
                        const color = colors[colorIndex];
                        if (color) {
                            amsConfig.units[unitIdx].slots[slotIdx] = {
                                color: color,
                                material: amsConfig.currentMaterial || 'Imported'
                            };
                        } else {
                            amsConfig.units[unitIdx].slots[slotIdx] = null;
                        }
                        colorIndex++;
                    }
                }
                
                // ÊÆã„Çä„ÅÆËâ≤„Åå„ÅÇ„Çå„Å∞AMS„É¶„Éã„ÉÉ„Éà„ÇíËøΩÂä†
                while (colorIndex < colors.length && amsConfig.units.length < 4) {
                    const newUnit = { slots: [null, null, null, null] };
                    for (let slotIdx = 0; slotIdx < 4 && colorIndex < colors.length; slotIdx++) {
                        const color = colors[colorIndex];
                        if (color) {
                            newUnit.slots[slotIdx] = {
                                color: color,
                                material: amsConfig.currentMaterial || 'Imported'
                            };
                        }
                        colorIndex++;
                    }
                    amsConfig.units.push(newUnit);
                }
            }
        }
        
        function initAMSFilamentSelectors() {
            const vendorSelect = document.getElementById('ams-filament-vendor');
            const materialSelect = document.getElementById('ams-filament-material');
            
            if (!vendorSelect || !materialSelect) return;
            
            // „Éô„É≥„ÉÄ„ÉºÈÅ∏ÊäûËÇ¢„ÇíÁîüÊàê
            Object.keys(FILAMENT_LIB).forEach(vendor => {
                const opt = document.createElement('option');
                opt.value = vendor;
                opt.textContent = vendor;
                vendorSelect.appendChild(opt);
            });
            
            const updateMaterials = () => {
                const vendor = vendorSelect.value;
                amsConfig.currentVendor = vendor;
                materialSelect.innerHTML = '';
                
                if (FILAMENT_LIB[vendor]) {
                    Object.keys(FILAMENT_LIB[vendor]).forEach(mat => {
                        const opt = document.createElement('option');
                        opt.value = mat;
                        opt.textContent = mat;
                        materialSelect.appendChild(opt);
                    });
                }
                updatePalette();
            };
            
            const updatePalette = () => {
                const vendor = vendorSelect.value;
                const material = materialSelect.value;
                amsConfig.currentMaterial = material;
                
                // „Éë„É¨„ÉÉ„Éà„ÇíÊõ¥Êñ∞
                amsConfig.palette = [];
                if (FILAMENT_LIB[vendor] && FILAMENT_LIB[vendor][material]) {
                    FILAMENT_LIB[vendor][material].forEach(c => {
                        amsConfig.palette.push({ color: c.hex, material: material, name: c.name });
                    });
                }
                renderAMSPalette();
            };
            
            vendorSelect.onchange = updateMaterials;
            materialSelect.onchange = updatePalette;
            
            // ÂàùÊúüÂåñ
            updateMaterials();
        }
        
        function renderAMSPalette() {
            const grid = document.getElementById('ams-palette-grid');
            if (!grid) return;
            
            grid.innerHTML = '';
            amsConfig.palette.forEach((item, idx) => {
                const color = typeof item === 'string' ? item : item.color;
                const material = typeof item === 'string' ? '' : (item.material || '');
                
                const swatch = document.createElement('div');
                swatch.className = 'ams-palette-color';
                swatch.style.background = color;
                swatch.draggable = true;
                swatch.dataset.color = color;
                swatch.dataset.material = material;
                swatch.innerHTML = `<span class="ams-palette-color-num">${idx + 1}</span>`;
                swatch.title = material;
                
                swatch.ondragstart = (e) => {
                    e.dataTransfer.setData('application/json', JSON.stringify({ color, material }));
                    e.dataTransfer.setData('text/plain', color);
                    swatch.classList.add('dragging');
                };
                swatch.ondragend = () => swatch.classList.remove('dragging');
                
                grid.appendChild(swatch);
            });
        }
        
        function renderAMSUnits() {
            // AMS
            const amsContainer = document.getElementById('ams-units-container');
            amsContainer.innerHTML = '';
            
            let slotNum = 1;
            amsConfig.units.forEach((unit, unitIdx) => {
                const unitEl = document.createElement('div');
                unitEl.className = 'ams-unit';
                
                let slotsHtml = '';
                unit.slots.forEach((slotData, slotIdx) => {
                    const hasData = slotData && slotData.color;
                    const color = hasData ? slotData.color : null;
                    const material = hasData ? (slotData.material || '') : '';
                    const colorStyle = color ? `background:${color}` : '';
                    const clearBtn = hasData 
                        ? `<button class="ams-slot-clear" data-unit="${unitIdx}" data-slot="${slotIdx}" data-type="ams">√ó</button>`
                        : '';
                    const materialLabel = material ? `<div class="ams-slot-material">${material}</div>` : '';
                    const content = hasData 
                        ? `<div class="ams-slot-color" style="${colorStyle}"></div>${materialLabel}${clearBtn}`
                        : '<span class="ams-slot-empty">+</span>';
                    slotsHtml += `<div class="ams-slot" data-unit="${unitIdx}" data-slot="${slotIdx}" data-type="ams"><span class="ams-slot-num">${slotNum}</span>${content}</div>`;
                    slotNum++;
                });
                
                // AMS„ÅÆÂâäÈô§„Éú„Çø„É≥ÔºàÂ∏∏„Å´Ë°®Á§∫Ôºâ
                const removeBtn = `<button class="ams-unit-remove" data-type="ams" data-unit="${unitIdx}">√ó</button>`;
                
                unitEl.innerHTML = `
                    <div class="ams-unit-header">
                        <span class="ams-unit-label">AMS ${unitIdx + 1}</span>
                        ${removeBtn}
                    </div>
                    <div class="ams-slots">${slotsHtml}</div>
                `;
                amsContainer.appendChild(unitEl);
            });
            
            // AMS HT
            const htContainer = document.getElementById('ams-ht-units-container');
            htContainer.innerHTML = '';
            
            amsConfig.htUnits.forEach((unit, unitIdx) => {
                const unitEl = document.createElement('div');
                unitEl.className = 'ams-unit ht-unit';
                unitEl.style.borderColor = '#e91e63';
                
                const slotData = unit.slots[0];
                const hasData = slotData && slotData.color;
                const color = hasData ? slotData.color : null;
                const material = hasData ? (slotData.material || '') : '';
                const colorStyle = color ? `background:${color}` : '';
                const clearBtn = hasData 
                    ? `<button class="ams-slot-clear" data-unit="${unitIdx}" data-slot="0" data-type="ht">√ó</button>`
                    : '';
                const materialLabel = material ? `<div class="ams-slot-material">${material}</div>` : '';
                const content = hasData 
                    ? `<div class="ams-slot-color" style="${colorStyle}"></div>${materialLabel}${clearBtn}`
                    : '<span class="ams-slot-empty">+</span>';
                
                unitEl.innerHTML = `
                    <div class="ams-unit-header">
                        <span class="ams-unit-label" style="color:#e91e63;">HT ${unitIdx + 1}</span>
                        <button class="ams-unit-remove" data-type="ht" data-unit="${unitIdx}">√ó</button>
                    </div>
                    <div class="ams-slots">
                        <div class="ams-slot" data-unit="${unitIdx}" data-slot="0" data-type="ht">
                            <span class="ams-slot-num">${slotNum}</span>
                            ${content}
                        </div>
                    </div>
                `;
                htContainer.appendChild(unitEl);
                slotNum++;
            });
            
            // „Éú„Çø„É≥„ÅÆÊúâÂäπ/ÁÑ°Âäπ
            document.getElementById('ams-add-unit').disabled = amsConfig.units.length >= 4;
            document.getElementById('ams-ht-add-unit').disabled = amsConfig.htUnits.length >= 8;
            
            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºÂÜçË®≠ÂÆö
            setupAMSSlotEvents();
        }
        
        function setupAMSSlotEvents() {
            // „Çπ„É≠„ÉÉ„Éà„Å∏„ÅÆ„Éâ„É≠„ÉÉ„Éó
            document.querySelectorAll('.ams-slot').forEach(slot => {
                slot.ondragover = (e) => {
                    e.preventDefault();
                    slot.classList.add('drag-over');
                };
                slot.ondragleave = () => slot.classList.remove('drag-over');
                slot.ondrop = (e) => {
                    e.preventDefault();
                    slot.classList.remove('drag-over');
                    
                    // JSON„Éá„Éº„Çø„ÇíÂÑ™ÂÖàÁöÑ„Å´ÂèñÂæó
                    let slotData = null;
                    try {
                        const jsonData = e.dataTransfer.getData('application/json');
                        if (jsonData) {
                            slotData = JSON.parse(jsonData);
                        }
                    } catch (err) {}
                    
                    // JSON„Åå„Å™„ÅÑÂ†¥Âêà„ÅØËâ≤„ÅÆ„Åø
                    if (!slotData) {
                        const color = e.dataTransfer.getData('text/plain');
                        slotData = { color, material: amsConfig.currentMaterial || '' };
                    }
                    
                    const unitIdx = parseInt(slot.dataset.unit);
                    const slotIdx = parseInt(slot.dataset.slot);
                    const type = slot.dataset.type;
                    
                    if (type === 'ams') {
                        amsConfig.units[unitIdx].slots[slotIdx] = slotData;
                    } else {
                        amsConfig.htUnits[unitIdx].slots[slotIdx] = slotData;
                    }
                    renderAMSUnits();
                };
            });
            
            // „ÇØ„É™„Ç¢„Éú„Çø„É≥
            document.querySelectorAll('.ams-slot-clear').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const unitIdx = parseInt(btn.dataset.unit);
                    const slotIdx = parseInt(btn.dataset.slot);
                    const type = btn.dataset.type;
                    
                    if (type === 'ams') {
                        amsConfig.units[unitIdx].slots[slotIdx] = null;
                    } else if (type === 'ht') {
                        amsConfig.htUnits[unitIdx].slots[slotIdx] = null;
                    }
                    renderAMSUnits();
                };
            });
            
            // „É¶„Éã„ÉÉ„ÉàÂâäÈô§„Éú„Çø„É≥
            document.querySelectorAll('.ams-unit-remove').forEach(btn => {
                btn.onclick = () => {
                    const unitIdx = parseInt(btn.dataset.unit);
                    const type = btn.dataset.type;
                    
                    if (type === 'ams') {
                        amsConfig.units.splice(unitIdx, 1);
                    } else if (type === 'ht') {
                        amsConfig.htUnits.splice(unitIdx, 1);
                    }
                    renderAMSUnits();
                };
            });
        }
        
        // Ë®≠ÂÆö„Çø„Éñ„ÅÆ„Éë„É¨„ÉÉ„Éà„ÇíÊõ¥Êñ∞ÔºàÈÄöÂ∏∏„É¢„Éº„ÉâÔºãÁ∞°Âçò„É¢„Éº„ÉâÔºâ
        function updateSettingsTabPalette() {
            const bodyPalette = document.getElementById('body-ams-palette');
            const textPalette = document.getElementById('text-ams-palette');
            const simpleBodyPalette = document.getElementById('simple-body-ams-palette');
            const simpleTextPalette = document.getElementById('simple-text-ams-palette');
            
            // ÂÖ®„Çπ„É≠„ÉÉ„Éà„ÅÆ„Éá„Éº„Çø„ÇíÂèéÈõÜ
            const allSlots = [];
            amsConfig.units.forEach(unit => {
                unit.slots.forEach(slotData => allSlots.push(slotData));
            });
            amsConfig.htUnits.forEach(unit => {
                unit.slots.forEach(slotData => allSlots.push(slotData));
            });
            
            // „Éë„É¨„ÉÉ„ÉàÊèèÁîªÈñ¢Êï∞
            const renderPalette = (container, type) => {
                if (!container) return;
                container.innerHTML = '';
                
                // ÁôªÈå≤Ê∏à„Åø„Çπ„É≠„ÉÉ„Éà„ÅÆ„ÅøË°®Á§∫
                let hasSlots = false;
                allSlots.forEach((slotData, idx) => {
                    if (!slotData || !slotData.color) return;
                    hasSlots = true;
                    
                    const item = document.createElement('div');
                    item.className = 'ams-select-item';
                    item.dataset.slot = idx + 1;
                    item.dataset.color = slotData.color;
                    
                    // ÈÅ∏ÊäûÁä∂ÊÖãÔºà„É¶„Éº„Ç∂„Éº„ÅåÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆö„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅøÔºâ
                    const isBodySet = amsConfig.bodyExtruderSet;
                    const isTextSet = amsConfig.textExtruderSet;
                    const selectedSlot = type === 'body' ? (isBodySet ? amsConfig.bodyExtruder : null) : (isTextSet ? amsConfig.textExtruder : null);
                    if (selectedSlot === idx + 1) {
                        item.classList.add(type === 'body' ? 'body-selected' : 'text-selected');
                    }
                    
                    const material = slotData.material || '';
                    item.innerHTML = `
                        <span class="ams-select-item-num">${idx + 1}</span>
                        <div class="ams-select-item-color" style="background:${slotData.color}"></div>
                        <div class="ams-select-item-material">${material}</div>
                    `;
                    
                    item.onclick = () => {
                        if (type === 'body') {
                            amsConfig.bodyExtruder = idx + 1;
                            amsConfig.bodyExtruderSet = true;
                            state.colBody = slotData.color;
                            state.bodyExtruder = idx + 1;
                            // Á∞°Âçò„É¢„Éº„Éâ„ÅÆhidden input„ÇÇÊõ¥Êñ∞
                            const simpleColBody = document.getElementById('simple-col-body');
                            if (simpleColBody) simpleColBody.value = slotData.color;
                        } else {
                            amsConfig.textExtruder = idx + 1;
                            amsConfig.textExtruderSet = true;
                            state.colText = slotData.color;
                            state.textExtruder = idx + 1;
                            // Á∞°Âçò„É¢„Éº„Éâ„ÅÆhidden input„ÇÇÊõ¥Êñ∞
                            const simpleColText = document.getElementById('simple-col-text');
                            if (simpleColText) simpleColText.value = slotData.color;
                        }
                        updateSettingsTabPalette();
                        updateModel();
                        showToast(`${type === 'body' ? 'Êú¨‰Ωì' : 'ÊñáÂ≠ó'}Ëâ≤„ÇíÈÅ©Áî®: „Çπ„É≠„ÉÉ„Éà${idx + 1}`);
                    };
                    
                    container.appendChild(item);
                });
                
                // „Çπ„É≠„ÉÉ„Éà„Åå„Å™„ÅÑÂ†¥Âêà
                if (!hasSlots) {
                    container.innerHTML = '<div class="ams-select-empty">AMSË®≠ÂÆö„ÅßËâ≤„ÇíÁôªÈå≤„Åó„Å¶„Åè„Å†„Åï„ÅÑ</div>';
                }
            };
            
            // ÈÄöÂ∏∏„É¢„Éº„Éâ„ÅÆ„Éë„É¨„ÉÉ„Éà
            renderPalette(bodyPalette, 'body');
            renderPalette(textPalette, 'text');
            
            // Á∞°Âçò„É¢„Éº„Éâ„ÅÆ„Éë„É¨„ÉÉ„Éà
            renderPalette(simpleBodyPalette, 'body');
            renderPalette(simpleTextPalette, 'text');
        }
        
        function isLightColor(hex) {
            if (!hex || hex.length < 7) return true;
            const r = parseInt(hex.slice(1,3), 16);
            const g = parseInt(hex.slice(3,5), 16);
            const b = parseInt(hex.slice(5,7), 16);
            return (r * 0.299 + g * 0.587 + b * 0.114) > 186;
        }
        
        // AMSË®≠ÂÆö„ÇílocalStorage„Å´‰øùÂ≠ò
        function saveAMSConfigToStorage() {
            try {
                const data = {
                    units: amsConfig.units,
                    htUnits: amsConfig.htUnits,
                    bodyExtruder: amsConfig.bodyExtruder,
                    textExtruder: amsConfig.textExtruder,
                    bodyExtruderSet: amsConfig.bodyExtruderSet,
                    textExtruderSet: amsConfig.textExtruderSet,
                    savedAt: new Date().toISOString()
                };
                localStorage.setItem('keycapAMSConfig', JSON.stringify(data));
                console.log('AMSË®≠ÂÆö„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü');
            } catch (e) {
                console.error('AMSË®≠ÂÆö„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó:', e);
            }
        }
        
        // AMSË®≠ÂÆö„ÇílocalStorage„Åã„ÇâÂæ©ÂÖÉÔºàË®≠ÂÆö„ÅåÂ≠òÂú®„Åó„Åü„Åã„Å©„ÅÜ„Åã„ÇíËøî„ÅôÔºâ
        function loadAMSConfigFromStorage() {
            try {
                const saved = localStorage.getItem('keycapAMSConfig');
                if (saved) {
                    const data = JSON.parse(saved);
                    if (data.units) amsConfig.units = data.units;
                    if (data.htUnits) amsConfig.htUnits = data.htUnits;
                    // null„ÇÇÂê´„ÇÅ„Å¶Ê≠£„Åó„ÅèÂæ©ÂÖÉÔºàÊòéÁ§∫ÁöÑ„Å´„Ç≠„Éº„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅÆ„ÅøÔºâ
                    if ('bodyExtruder' in data) amsConfig.bodyExtruder = data.bodyExtruder;
                    if ('textExtruder' in data) amsConfig.textExtruder = data.textExtruder;
                    if (data.bodyExtruderSet) amsConfig.bodyExtruderSet = true;
                    if (data.textExtruderSet) amsConfig.textExtruderSet = true;
                    console.log('AMSË®≠ÂÆö„ÇíÂæ©ÂÖÉ„Åó„Åæ„Åó„Åü:', data.savedAt);
                    
                    // ÂÆüÈöõ„Å´„Çπ„É≠„ÉÉ„Éà„Å´Ëâ≤„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                    const hasColorInSlots = data.units && data.units.some(unit => 
                        unit.slots && unit.slots.some(slot => slot && slot.color)
                    );
                    return hasColorInSlots;
                }
                return false;
            } catch (e) {
                console.error('AMSË®≠ÂÆö„ÅÆÂæ©ÂÖÉ„Å´Â§±Êïó:', e);
                return false;
            }
        }
        
        // AMSË®≠ÂÆö„ÇíJSON„Éï„Ç°„Ç§„É´„Å®„Åó„Å¶„Ç®„ÇØ„Çπ„Éù„Éº„Éà
        function exportAMSConfigAsJSON() {
            const data = {
                version: 'KeycapAMS_v1',
                units: amsConfig.units,
                htUnits: amsConfig.htUnits,
                bodyExtruder: amsConfig.bodyExtruder,
                textExtruder: amsConfig.textExtruder,
                exportedAt: new Date().toISOString()
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `ams_config_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('AMSË®≠ÂÆö„ÇíJSON„Éï„Ç°„Ç§„É´„Å´Êõ∏„ÅçÂá∫„Åó„Åæ„Åó„Åü');
        }
        
        // JSON„Éï„Ç°„Ç§„É´„Åã„ÇâAMSË®≠ÂÆö„Çí„Ç§„É≥„Éù„Éº„Éà
        function importAMSConfigFromJSON(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // „Éê„É™„Éá„Éº„Ç∑„Éß„É≥
                    if (!data.units && !data.htUnits) {
                        throw new Error('ÁÑ°Âäπ„Å™AMSË®≠ÂÆö„Éï„Ç°„Ç§„É´„Åß„Åô');
                    }
                    
                    // Ë®≠ÂÆö„ÇíÈÅ©Áî®
                    if (data.units) amsConfig.units = data.units;
                    if (data.htUnits) amsConfig.htUnits = data.htUnits;
                    if (data.bodyExtruder) amsConfig.bodyExtruder = data.bodyExtruder;
                    if (data.textExtruder) amsConfig.textExtruder = data.textExtruder;
                    
                    // localStorage„Å´„ÇÇ‰øùÂ≠ò
                    saveAMSConfigToStorage();
                    
                    // UI„ÇíÊõ¥Êñ∞
                    updateSettingsTabPalette();
                    
                    showToast('AMSË®≠ÂÆö„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü');
                } catch (err) {
                    console.error('JSON„Ç§„É≥„Éù„Éº„Éà„Ç®„É©„Éº:', err);
                    showToast('JSON„Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', 'error');
                }
            };
            reader.readAsText(file);
        }

        // ==========================================
        // V67: üì• „Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„Éó
        // ==========================================
        function initDragAndDrop() {
            const overlay = document.getElementById('dnd-overlay');
            if (!overlay) return;
            
            let dragCounter = 0;
            
            window.addEventListener('dragenter', (e) => {
                e.preventDefault();
                dragCounter++;
                overlay.classList.add('active');
            });

            window.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dragCounter--;
                if (dragCounter <= 0) {
                    dragCounter = 0;
                    overlay.classList.remove('active');
                }
            });

            window.addEventListener('dragover', (e) => {
                e.preventDefault();
            });

            window.addEventListener('drop', (e) => {
                e.preventDefault();
                dragCounter = 0;
                overlay.classList.remove('active');

                if (e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];
                    handleDroppedFile(file);
                }
            });
        }

        function handleDroppedFile(file) {
            const reader = new FileReader();
            const fileName = file.name.toLowerCase();
            
            if (fileName.endsWith('.svg') || file.type === 'image/svg+xml') {
                reader.onload = (e) => {
                    state.svgContent = e.target.result;
                    state.svgName = file.name.replace(/\.svg$/i, '');
                    state.svgVisible = true;
                    state.enableText = false;
                    
                    // UIÂêåÊúü
                    const enableTextCheckbox = document.getElementById('enable-text');
                    if (enableTextCheckbox) enableTextCheckbox.checked = false;
                    const simpleEnableTextCb = document.getElementById('simple-enable-text');
                    if (simpleEnableTextCb) simpleEnableTextCb.checked = false;
                    const hudTextBtn = document.getElementById('hud-toggle-text');
                    if (hudTextBtn) hudTextBtn.classList.remove('active');
                    const hudSvgBtn = document.getElementById('hud-toggle-svg');
                    if (hudSvgBtn) hudSvgBtn.classList.add('active');
                    
                    syncUI();
                    requestUpdate();
                    showToast(`SVGË™≠Ëæº: ${file.name}`);
                };
                reader.readAsText(file);
            } 
            else if (fileName.endsWith('.json')) {
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.version && data.state) {
                            // V67ÂΩ¢Âºè„ÅÆJSON„Éó„É™„Çª„ÉÉ„Éà
                            Object.assign(state, data.state);
                            syncUI();
                            requestUpdate();
                            showToast(`„Éó„É™„Çª„ÉÉ„ÉàË™≠Ëæº: ${file.name}`);
                        }
                    } catch (err) {
                        showToast('JSON„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', true);
                    }
                };
                reader.readAsText(file);
            }
            else if (file.type.startsWith('image/')) {
                // „ÉÜ„ÇØ„Çπ„ÉÅ„É£„Å®„Åó„Å¶Ë™≠„ÅøËæº„ÇÄ
                reader.onload = (e) => {
                    state.textureType = 'custom';
                    state.customTextureData = e.target.result;
                    syncUI();
                    requestUpdate();
                    showToast(`„ÉÜ„ÇØ„Çπ„ÉÅ„É£Ë™≠Ëæº: ${file.name}`);
                };
                reader.readAsDataURL(file);
            }
            else {
                showToast('ÂØæÂøú„Åó„Å¶„ÅÑ„Å™„ÅÑ„Éï„Ç°„Ç§„É´ÂΩ¢Âºè„Åß„Åô', true);
            }
        }

        // ==========================================
        // V67: ‚å®Ô∏è „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Ç≠„Éº
        // ==========================================
        function initShortcuts() {
            const helpBtn = document.getElementById('btn-help');
            const shortcutOverlay = document.getElementById('shortcut-overlay');
            
            if (helpBtn && shortcutOverlay) {
                helpBtn.addEventListener('click', () => {
                    shortcutOverlay.style.display = 'flex';
                });
                
                shortcutOverlay.addEventListener('click', (e) => {
                    if (e.target === shortcutOverlay) {
                        shortcutOverlay.style.display = 'none';
                    }
                });
            }

            window.addEventListener('keydown', (e) => {
                // ÂÖ•Âäõ„Éï„Ç©„Éº„É†ÂÜÖ„Åß„ÅØÁÑ°ÂäπÂåñ
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z') { // Undo
                        e.preventDefault();
                        if (typeof performUndo === 'function') performUndo();
                    }
                    if (e.key === 'y') { // Redo
                        e.preventDefault();
                        if (typeof performRedo === 'function') performRedo();
                    }
                    if (e.key === 's') { // Save
                        e.preventDefault();
                        const exportBtn = document.getElementById('btn-export-single');
                        if (exportBtn) exportBtn.click();
                    }
                } else {
                    switch(e.key) {
                        case '1': moveCameraToView('front'); break;
                        case '2': moveCameraToView('right'); break;
                        case '3': moveCameraToView('top'); break;
                        case '0': moveCameraToView('iso'); break;
                        case 'w':
                        case 'W':
                            // „ÉØ„Ç§„É§„Éº„Éï„É¨„Éº„É†ÂàáÊõø
                            document.getElementById('hud-view-mode')?.click();
                            break;
                        case 'd':
                        case 'D':
                            // ÂØ∏Ê≥ïÁ∑öÂàáÊõø
                            document.getElementById('hud-dimension')?.click();
                            break;
                        case 'g':
                        case 'G':
                            // „Ç¨„É†„Éú„Éº„É´ÂàáÊõø
                            document.getElementById('hud-gumball-toggle')?.click();
                            break;
                        case '?':
                            // „Éò„É´„ÉóË°®Á§∫
                            if (shortcutOverlay) {
                                shortcutOverlay.style.display = shortcutOverlay.style.display === 'flex' ? 'none' : 'flex';
                            }
                            break;
                        case 'Escape': {
                            if (shortcutOverlay && shortcutOverlay.style.display === 'flex') {
                                shortcutOverlay.style.display = 'none';
                            }
                            // „Éá„Éê„ÉÉ„Ç∞„Éë„Éç„É´„ÇÇÈñâ„Åò„Çã
                            const dbgPanel = document.getElementById('debug-panel-overlay');
                            if (dbgPanel && dbgPanel.style.display === 'flex') {
                                dbgPanel.style.display = 'none';
                            }
                            break;
                        }
                        case 'F5':
                            // „Éá„Éê„ÉÉ„Ç∞„É¢„Éº„ÉâÔºà„Éñ„É©„Ç¶„Ç∂„É™„É≠„Éº„Éâ„ÇíÈò≤Ê≠¢Ôºâ
                            e.preventDefault();
                            toggleDebugPanel();
                            break;
                        case 'F1':
                            // Wiki „Éò„É´„ÉóÔºà„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÅåÈñã„ÅÑ„Å¶„ÅÑ„Çã„Å®„Åç„ÅÆ„ÅøÔºâ
                            e.preventDefault();
                            openWikiHelp();
                            break;
                    }
                }
            });
        }

        // ===== F1 Wiki „Éò„É´„Éó =====
        function openWikiHelp() {
            // ÂêÑ„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÅÆË°®Á§∫Áä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            const isVisible = (id) => {
                const el = document.getElementById(id);
                return el && el.style.display !== 'none' && el.style.display !== '';
            };
            
            // a„Çø„Ç∞„ÇØ„É™„ÉÉ„ÇØ„ÅßURL„ÇíÈñã„ÅèÔºàText FragmentÂØæÂøúÔºâ
            const openUrl = (url) => {
                const a = document.createElement('a');
                a.href = url;
                a.target = '_blank';
                a.rel = 'noopener';
                a.click();
            };
            
            // Ë°®Á§∫‰∏≠„ÅÆ„ÉÄ„Ç§„Ç¢„É≠„Ç∞„Åã„Çâdata-help-urlÂ±ûÊÄß„ÇíÊé¢„Åô
            const dialogIds = ['export-popup-overlay', 'csk-overlay', 'batch-color-overlay', 'batch-export-overlay', 'ams-popup-overlay', 'debug-panel-overlay'];
            for (const id of dialogIds) {
                if (isVisible(id)) {
                    const dialog = document.getElementById(id);
                    const wikiHint = dialog.querySelector('.wiki-hint[data-help-url-ja]');
                    if (wikiHint) {
                        const url = currentLang === 'en' 
                            ? wikiHint.getAttribute('data-help-url-en') 
                            : wikiHint.getAttribute('data-help-url-ja');
                        if (url) {
                            openUrl(url);
                            return;
                        }
                    }
                }
            }
            
            // „ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÅåÈñã„ÅÑ„Å¶„ÅÑ„Å™„ÅÑ„ÄÅ„Åæ„Åü„ÅØURL„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„É°„Ç§„É≥Wiki„ÇíÈñã„Åè
            const wikiBaseUrl = currentLang === 'en' 
                ? 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9'
                : 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9';
            openUrl(wikiBaseUrl);
        }

        // ===== F5 „Éá„Éê„ÉÉ„Ç∞ / „É°„É≥„ÉÜ„Éä„É≥„Çπ„Éë„Éç„É´ =====
        function toggleDebugPanel() {
            const overlay = document.getElementById('debug-panel-overlay');
            if (!overlay) return;
            if (overlay.style.display === 'flex') {
                overlay.style.display = 'none';
            } else {
                overlay.style.display = 'flex';
                updateDebugInfo();
                initDebugHandlers();
            }
        }

        let debugHandlersInit = false;
        function initDebugHandlers() {
            if (debugHandlersInit) return;
            debugHandlersInit = true;

            // ÂÖ®„Ç≠„É£„ÉÉ„Ç∑„É•„ÇØ„É™„Ç¢
            document.getElementById('debug-clear-all-cache')?.addEventListener('click', () => {
                if (confirm('ÂÖ®„Ç≠„É£„ÉÉ„Ç∑„É•„ÇíÂâäÈô§„Åó„Å¶„Éö„Éº„Ç∏„Çí„É™„É≠„Éº„Éâ„Åó„Åæ„Åô„ÄÇ\n„ÇÆ„É£„É©„É™„Éº„ÄÅ„Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆö„ÄÅ„Éó„É™„Çª„ÉÉ„ÉàÁ≠â„Åô„Åπ„Å¶Ê∂à„Åà„Åæ„Åô„ÄÇ\nÂÆüË°å„Åó„Åæ„Åô„ÅãÔºü')) {
                    localStorage.removeItem('keycapAMSConfig');
                    localStorage.removeItem('keycapAMSConfirmDismissed');
                    localStorage.removeItem('keycap_gen_v63_preset');
                    // „Åù„ÅÆ‰ªñ keycap Èñ¢ÈÄ£„ÅÆ„Ç≠„Éº„ÇÇÂâäÈô§
                    Object.keys(localStorage).forEach(key => {
                        if (key.startsWith('keycap')) localStorage.removeItem(key);
                    });
                    location.reload();
                }
            });

            // „Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆö„ÇØ„É™„Ç¢
            document.getElementById('debug-clear-filament')?.addEventListener('click', () => {
                if (confirm('AMS / „Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆö„ÇíÂàùÊúüÂåñ„Åó„Åæ„Åô„ÄÇ\nÂÆüË°å„Åó„Åæ„Åô„ÅãÔºü')) {
                    amsConfig.units = [{ slots: [null, null, null, null] }];
                    amsConfig.htUnits = [];
                    amsConfig.palette = [];
                    amsConfig.bodyExtruder = null;
                    amsConfig.textExtruder = null;
                    amsConfig.bodyExtruderSet = false;
                    amsConfig.textExtruderSet = false;
                    localStorage.removeItem('keycapAMSConfig');
                    localStorage.removeItem('keycapAMSConfirmDismissed');
                    if (typeof renderAMSPalette === 'function') renderAMSPalette();
                    if (typeof renderAMSUnits === 'function') renderAMSUnits();
                    if (typeof updateSettingsTabPalette === 'function') updateSettingsTabPalette();
                    showToast('„Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆö„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åó„Åü');
                    updateDebugInfo();
                }
            });

            // „ÇÆ„É£„É©„É™„ÉºÂÖ®ÂâäÈô§
            document.getElementById('debug-clear-gallery')?.addEventListener('click', () => {
                const container = document.getElementById('gallery-content');
                const items = container?.querySelectorAll('.gallery-item');
                const count = items ? items.length : 0;
                if (count === 0) {
                    showToast('„ÇÆ„É£„É©„É™„Éº„Å´„Ç¢„Ç§„ÉÜ„É†„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', true);
                    return;
                }
                if (confirm(`„ÇÆ„É£„É©„É™„Éº„ÅÆÂÖ®${count}„Ç¢„Ç§„ÉÜ„É†„ÇíÂâäÈô§„Åó„Åæ„Åô„ÄÇ\nÂÆüË°å„Åó„Åæ„Åô„ÅãÔºü`)) {
                    items.forEach(item => {
                        const delBtn = item.querySelector('.gallery-delete');
                        if (delBtn) delBtn.click();
                    });
                    // ÊÆã„Å£„Åü„ÇÇ„ÅÆ„ÇÇÁõ¥Êé•ÂâäÈô§
                    if (container) container.innerHTML = '';
                    const strip = document.getElementById('gallery-strip');
                    if (strip) strip.classList.remove('show');
                    showToast(`„ÇÆ„É£„É©„É™„Éº ${count}„Ç¢„Ç§„ÉÜ„É†„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü`);
                    updateDebugInfo();
                }
            });

            // CSKÈÖçÁΩÆ„É™„Çª„ÉÉ„Éà
            document.getElementById('debug-clear-csk')?.addEventListener('click', () => {
                if (confirm('„Ç´„Çπ„Çø„É†„Çπ„Éó„É´„Ç≠„ÉÉ„Éà„ÅÆÈÖçÁΩÆ„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÄÇ\nÂÆüË°å„Åó„Åæ„Åô„ÅãÔºü')) {
                    // CSK„ÅØ IIFE ÂÜÖ„ÅÆ„Åü„ÇÅ„ÄÅ„Ç∞„É≠„Éº„Éê„É´„Å´„Ç¢„ÇØ„Çª„Çπ„Åß„Åç„Çã„Éò„É´„Éë„Éº„Çí‰Ωø„ÅÜ
                    if (typeof window._cskReset === 'function') {
                        window._cskReset();
                    }
                    showToast('„Ç´„Çπ„Çø„É†„Çπ„Éó„É´„Ç≠„ÉÉ„ÉàÈÖçÁΩÆ„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü');
                    updateDebugInfo();
                }
            });

            // „Éë„É©„É°„Éº„ÇøÂàùÊúüÂåñ
            document.getElementById('debug-reset-state')?.addEventListener('click', () => {
                if (confirm('ÂÖ®„Éë„É©„É°„Éº„Çø„Çí„Éá„Éï„Ç©„É´„ÉàÂÄ§„Å´Êàª„Åó„Åæ„Åô„ÄÇ\n„ÇÆ„É£„É©„É™„Éº„Å®„Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆö„ÅØÊÆã„Çä„Åæ„Åô„ÄÇ\nÂÆüË°å„Åó„Åæ„Åô„ÅãÔºü')) {
                    localStorage.removeItem('keycap_gen_v63_preset');
                    // state„ÇíÂàùÊúüÂÄ§„Å´Êàª„Åô
                    const defaults = {
                        profileType: 'cherry', row: 'R4', uSize: 1, w: 18, d: 18, h: 8.5,
                        wallThickness: 1.5, topThickness: 1.2,
                        dishType: 'cylindrical', dishDepth: 1.0, dishRadius: 30,
                        taper: 0.85, cornerR: 0.5, topCornerR: 1.0,
                        stemType: 'cross', textContent: 'A', fontName: 'helvetiker',
                        textMode: 'emboss', textHeight: 0.6, textSize: 6,
                        textOffX: 0, textOffY: 0, textOffZ: 0,
                        textRotX: 0, textRotY: 0, textRotZ: 0,
                        textBold: false, enableText: true,
                        colBody: '#cccccc', colText: '#333333',
                        unitSize: 19.05
                    };
                    Object.assign(state, defaults);
                    if (typeof syncUI === 'function') syncUI();
                    if (typeof updateModel === 'function') updateModel();
                    showToast('„Éë„É©„É°„Éº„Çø„ÇíÂàùÊúüÂåñ„Åó„Åæ„Åó„Åü');
                    updateDebugInfo();
                }
            });

            // JSON„Ç®„ÇØ„Çπ„Éù„Éº„Éà
            document.getElementById('debug-export-state')?.addEventListener('click', () => {
                const exportData = {
                    state: JSON.parse(JSON.stringify(state)),
                    amsConfig: {
                        units: amsConfig.units,
                        htUnits: amsConfig.htUnits,
                        bodyExtruder: amsConfig.bodyExtruder,
                        textExtruder: amsConfig.textExtruder,
                        bodyExtruderSet: amsConfig.bodyExtruderSet,
                        textExtruderSet: amsConfig.textExtruderSet,
                        currentVendor: amsConfig.currentVendor,
                        currentMaterial: amsConfig.currentMaterial
                    },
                    galleryCount: document.querySelectorAll('#gallery-content .gallery-item').length,
                    timestamp: new Date().toISOString()
                };
                const json = JSON.stringify(exportData, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = `keycap_debug_${Date.now()}.json`;
                a.click(); URL.revokeObjectURL(url);
                showToast('Áä∂ÊÖã„ÇíJSON„Åß„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„Åü');
            });

            // JSON„Ç§„É≥„Éù„Éº„Éà
            document.getElementById('debug-import-state')?.addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file'; input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        try {
                            const data = JSON.parse(ev.target.result);
                            if (data.state) {
                                Object.assign(state, data.state);
                                if (typeof syncUI === 'function') syncUI();
                                if (typeof updateModel === 'function') updateModel();
                            }
                            if (data.amsConfig) {
                                Object.assign(amsConfig, data.amsConfig);
                                if (typeof saveAMSConfigToStorage === 'function') saveAMSConfigToStorage();
                                if (typeof renderAMSPalette === 'function') renderAMSPalette();
                                if (typeof renderAMSUnits === 'function') renderAMSUnits();
                                if (typeof updateSettingsTabPalette === 'function') updateSettingsTabPalette();
                            }
                            showToast('Áä∂ÊÖã„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„Åæ„Åó„Åü');
                            updateDebugInfo();
                        } catch (err) {
                            showToast('JSON„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó: ' + err.message, true);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            });

            // Âº∑Âà∂ÂÜçÊßãÁØâ
            document.getElementById('debug-force-rebuild')?.addEventListener('click', () => {
                if (typeof updateModel === 'function') {
                    updateModel();
                    showToast('3D„É¢„Éá„É´„ÇíÂÜçÊßãÁØâ„Åó„Åæ„Åó„Åü');
                }
            });

            // „Ç≥„É≥„ÇΩ„Éº„É´Âá∫Âäõ
            document.getElementById('debug-log-state')?.addEventListener('click', () => {
                console.group('üîç Keycap Generator Debug State');
                console.log('state:', JSON.parse(JSON.stringify(state)));
                console.log('amsConfig:', JSON.parse(JSON.stringify(amsConfig)));
                console.log('localStorage keys:', Object.keys(localStorage).filter(k => k.startsWith('keycap')));
                console.log('gallery items:', document.querySelectorAll('#gallery-content .gallery-item').length);
                console.groupEnd();
                showToast('„Ç≥„É≥„ÇΩ„Éº„É´„Å´Âá∫Âäõ„Åó„Åæ„Åó„Åü (F12„ÅßÁ¢∫Ë™ç)');
            });
        }

        function updateDebugInfo() {
            const infoEl = document.getElementById('debug-state-info');
            if (!infoEl) return;
            const galleryCount = document.querySelectorAll('#gallery-content .gallery-item').length;
            const allSlots = [];
            amsConfig.units.forEach(u => u.slots.forEach(s => allSlots.push(s)));
            amsConfig.htUnits.forEach(u => u.slots.forEach(s => allSlots.push(s)));
            const filledSlots = allSlots.filter(s => s && s.color).length;

            const lines = [
                `Profile: ${state.profileType || '-'} / Row: ${state.row || '-'}`,
                `Unit: ${state.uSize || 1}U (${(state.w || 18).toFixed(1)} √ó ${(state.d || 18).toFixed(1)} √ó ${(state.h || 8.5).toFixed(1)}mm)`,
                `Text: "${state.textContent || ''}" [${state.textMode || 'emboss'}]`,
                `Font: ${state.fontName || '-'}`,
                `Body: ${state.colBody || '#ccc'}  Text: ${state.colText || '#333'}`,
                `Body Ext: ${amsConfig.bodyExtruderSet ? amsConfig.bodyExtruder : 'unset'}  Text Ext: ${amsConfig.textExtruderSet ? amsConfig.textExtruder : 'unset'}`,
                `AMS Slots: ${filledSlots} configured`,
                `Gallery: ${galleryCount} items`,
                `localStorage: ${Object.keys(localStorage).filter(k => k.startsWith('keycap')).join(', ') || 'none'}`
            ];
            infoEl.textContent = lines.join('\n');
        }

        async function init() {
            document.getElementById('loading').style.display = 'flex';
            
            await initManifold();
            
            // MeshFix WASM - ÁèæÂú®„ÅØÁÑ°ÂäπÔºà„Çπ„ÉÜ„É†Á©¥„ÇíÊåÅ„Å§„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Å´„ÅØ‰∏çÂêë„ÅçÔºâ
            // MeshFix„ÅØ„ÄåÊ∞¥ÂØÜ„Å™„ÇΩ„É™„ÉÉ„Éâ„Äç„ÇíÁîüÊàê„Åô„Çã„Åü„ÇÅ„ÄÅÊÑèÂõ≥ÁöÑ„Å™Á©¥„ÇíÂüã„ÇÅ„Å¶„Åó„Åæ„ÅÜ
            // initMeshFix().catch(e => console.warn('MeshFix init failed:', e));
            
            // Pyodide + trimesh „Çí„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÂàùÊúüÂåñÔºà„É°„Ç§„É≥‰øÆÂæ©ÊñπÊ≥ïÔºâ
            initPyodide().catch(e => console.warn('Pyodide init failed:', e));
            
            const fontConfigs = [
                ['helvetiker', 'helvetiker_regular', 'Helvetiker'],
                ['helvetiker_bold', 'helvetiker_bold', 'Helvetiker Bold'],
                ['optimer', 'optimer_regular', 'Optimer'],
                ['optimer_bold', 'optimer_bold', 'Optimer Bold'],
                ['gentilis', 'gentilis_regular', 'Gentilis'],
                ['gentilis_bold', 'gentilis_bold', 'Gentilis Bold'],
                ['droid_sans', 'droid/droid_sans_regular', 'Droid Sans'],
                ['droid_sans_bold', 'droid/droid_sans_bold', 'Droid Sans Bold'],
                ['droid_serif', 'droid/droid_serif_regular', 'Droid Serif'],
                ['droid_serif_bold', 'droid/droid_serif_bold', 'Droid Serif Bold']
            ];
            
            let fontsLoaded = 0;
            for(const [name, fileName, displayName] of fontConfigs) {
                try {
                    const path = `https://cdn.jsdelivr.net/npm/three@0.160.0/examples/fonts/${fileName}.typeface.json`;
                    loadedFonts[name] = await new Promise((resolve, reject) => fontLoader.load(path, resolve, undefined, reject));
                    fontsLoaded++;
                    console.log(`Font loaded: ${displayName}`);
                } catch(e) {
                    console.warn(`Font load failed: ${name} (${fileName})`);
                }
            }
            if(fontsLoaded === 0) document.getElementById('error-log').textContent = "Warning: No fonts loaded.";
            
            initFilamentManager();
            initNavigation();
            setupCustomDropdown();
            syncUI();
            
            // V67: Êóß„Éë„É¨„ÉÉ„Éà„ÅØ„Éï„Ç£„É©„É°„É≥„Éà„É©„Ç§„Éñ„É©„É™„Å´ÁΩÆ„ÅçÊèõ„Åà
            
            document.getElementById('unit-size-select').addEventListener('change', (e) => { state.unitSize = parseFloat(e.target.value); requestUpdate(); });
            document.getElementById('profile-select').addEventListener('change', (e) => { 
                state.profile = e.target.value; 
                const customPanel = document.getElementById('custom-profile-panel');
                if(customPanel) customPanel.style.display = e.target.value === 'custom' ? 'block' : 'none';
                requestUpdate(); 
            });
            
            document.getElementById('key-shape-type').addEventListener('change', (e) => {
                state.keyShapeType = e.target.value;
                document.getElementById('shape-polygon-options').style.display = e.target.value === 'polygon' ? 'block' : 'none';
                document.getElementById('shape-star-options').style.display = e.target.value === 'star' ? 'block' : 'none';
                document.getElementById('shape-iso-options').style.display = e.target.value === 'iso-enter' ? 'block' : 'none';
                requestUpdate();
            });
            
            document.getElementById('row-select').addEventListener('change', (e) => { state.row = e.target.value; requestUpdate(); });
            document.getElementById('texture-type').addEventListener('change', (e) => { state.textureType = e.target.value; requestUpdate(); });
            document.getElementById('text-mode').addEventListener('change', (e) => { 
                state.textMode = e.target.value; 
                // SVG„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÁ∞°Âçò„É¢„Éº„Éâ„ÅÆ„Éó„É´„ÉÄ„Ç¶„É≥„ÇíÊõ¥Êñ∞
                const simpleTextMode = document.getElementById('simple-text-mode');
                if(simpleTextMode && !state.svgContent) simpleTextMode.value = e.target.value;
                requestUpdate(); 
            });
            document.getElementById('text2-mode').addEventListener('change', (e) => { state.text2Mode = e.target.value; requestUpdate(); });
            document.getElementById('side-mode').addEventListener('change', (e) => { state.sideMode = e.target.value; requestUpdate(); });
            document.getElementById('svg-mode').addEventListener('change', (e) => { 
                state.svgMode = e.target.value; 
                // SVG„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„ÅøÁ∞°Âçò„É¢„Éº„Éâ„ÅÆ„Éó„É´„ÉÄ„Ç¶„É≥„ÇíÊõ¥Êñ∞
                const simpleTextMode = document.getElementById('simple-text-mode');
                if(simpleTextMode && state.svgContent) simpleTextMode.value = e.target.value;
                requestUpdate(); 
            });
            document.getElementById('render-mode').addEventListener('change', (e) => { state.renderMode = e.target.value; requestUpdate(); });
            document.getElementById('stabilizer-type').addEventListener('change', (e) => {
                state.stabilizerType = e.target.value;
                document.getElementById('stabilizer-custom-ui').style.display = e.target.value === 'custom' ? 'block' : 'none';
                requestUpdate();
            });
            document.getElementById('lego-stud').addEventListener('change', (e) => {
                state.legoStud = e.target.checked;
                document.getElementById('lego-adj-panel').style.display = e.target.checked ? 'block' : 'none';
                requestUpdate();
            });
            document.getElementById('enable-stem-extension').addEventListener('change', (e) => {
                state.enableStemExtension = e.target.checked;
                document.getElementById('stem-ext-control').style.display = e.target.checked ? 'block' : 'none';
                requestUpdate();
            });
            
            const mInput = document.getElementById('model-file-input');
            if(mInput) mInput.addEventListener('change', function(e) {
                const file = e.target.files[0]; if(!file) return;
                const reader = new FileReader();
                reader.onload = function(ev) { importedModelBuffer = ev.target.result; updateModel(); };
                reader.readAsArrayBuffer(file);
            });
            const bClearModel = document.getElementById('btn-clear-model');
            if(bClearModel) bClearModel.addEventListener('click', () => {
                importedModelBuffer = null;
                if(mInput) mInput.value = '';
                updateModel();
            });
            
            const imgInput = document.getElementById('img-texture-input');
            if(imgInput) imgInput.addEventListener('change', function(e) {
                const file = e.target.files[0]; if(!file) return;
                const reader = new FileReader();
                reader.onload = function(ev) {
                    state.imgContent = ev.target.result;
                    state.imgTextureVisible = true;
                    document.getElementById('img-texture-visible').checked = true;
                    updateModel();
                };
                reader.readAsDataURL(file);
            });
            const bClearImgTex = document.getElementById('btn-clear-img-texture');
            if(bClearImgTex) bClearImgTex.addEventListener('click', () => {
                state.imgContent = null;
                state.imgTextureVisible = false;
                document.getElementById('img-texture-visible').checked = false;
                if(imgInput) imgInput.value = '';
                updateModel();
            });
            
            document.getElementById('btn-random').addEventListener('click', randomizeParams);
            document.getElementById('btn-reset-params').addEventListener('click', resetParams);
            document.getElementById('btn-align-center').addEventListener('click', () => { state.posX = 0; state.posZ = 0; syncUI(); requestUpdate(); });
            document.getElementById('btn-align-tl').addEventListener('click', () => { state.posX = -3.5; state.posZ = -3.5; syncUI(); requestUpdate(); });
            document.getElementById('btn-align-tr').addEventListener('click', () => { state.posX = 3.5; state.posZ = -3.5; syncUI(); requestUpdate(); });
            document.getElementById('btn-align-bl').addEventListener('click', () => { state.posX = -3.5; state.posZ = 3.5; syncUI(); requestUpdate(); });
            document.getElementById('btn-align-br').addEventListener('click', () => { state.posX = 3.5; state.posZ = 3.5; syncUI(); requestUpdate(); });
            
            const statsPanel = document.getElementById('top-right-panel');
            const toggleStatsBtn = document.getElementById('btn-toggle-stats');
            if(toggleStatsBtn) {
                toggleStatsBtn.addEventListener('click', () => {
                    statsPanel.classList.toggle('stats-collapsed');
                    toggleStatsBtn.textContent = statsPanel.classList.contains('stats-collapsed') ? "+" : "Ôºç";
                });
            }
            
            const toggleUiBtn = document.getElementById('btn-toggle-ui');
            if(toggleUiBtn) {
                toggleUiBtn.addEventListener('click', () => {
                    document.body.classList.toggle('ui-closed');
                    const isClosed = document.body.classList.contains('ui-closed');
                    toggleUiBtn.textContent = isClosed ? "‚ñ∂" : "‚óÄ";
                    setTimeout(() => {
                        const w = container.clientWidth;
                        const h = container.clientHeight;
                        renderer.setSize(w, h);
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                    }, 350);
                });
            }
            
            document.getElementById('loading').style.display = 'none';
            requestUpdate();
            animate();
            
            // V67: Êñ∞Ê©üËÉΩ„ÅÆÂàùÊúüÂåñ
            initFilamentUI();
            initAMSConfig();
            initDragAndDrop();
            initShortcuts();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.clear();
            controls.update();
            renderer.render(scene, camera);
            
            // V67: „Éì„É•„Éº„Ç≠„É•„Éº„Éñ„ÅÆÂõûËª¢„ÇíÂêåÊúü
            updateViewCubeRotation();
        }

        const bind = (id, key) => {
            const el = document.getElementById(id);
            if(!el) return;
            const up = () => {
                const v = (el.type==='checkbox') ? el.checked : (el.type==='range'||el.type==='number' ? parseFloat(el.value) : el.value);
                state[key]=v;
                if(el.type==='range') {
                    const sp = document.getElementById('v-'+id);
                    if(sp) sp.textContent = (id === 'tex-scale') ? parseInt(v) : v.toFixed(2);
                }
                if(id === 'lock-thickness') {
                    const slider = document.getElementById('text-height');
                    if(slider) {
                        slider.disabled = v;
                        if(v) { slider.value=0.5; state.textHeight=0.5; document.getElementById('v-text-height').textContent="0.50"; }
                    }
                }
                requestUpdate();
            };
            el.addEventListener('input', up);
            el.addEventListener('change', ()=>{up(); commitHistory();});
            const vS = document.getElementById('v-'+id);
            if(vS && id !== 'text-height') vS.addEventListener('dblclick', ()=>{
                const i=document.createElement('input');
                i.type='number';
                i.value=state[key];
                i.className='direct-input';
                vS.style.display='none';
                vS.parentNode.insertBefore(i, vS.nextSibling);
                i.style.display='inline-block';
                i.focus();
                const end = ()=>{
                    const n=parseFloat(i.value);
                    if(!isNaN(n)){state[key]=n; el.value=n; vS.textContent=n.toFixed(2); requestUpdate(); commitHistory();}
                    i.remove();
                    vS.style.display='inline-block';
                };
                i.addEventListener('blur', end);
                i.addEventListener('keydown', e=>{if(e.key==='Enter')end();});
            });
        };
        
        Object.keys(paramMap).forEach(id => bind(id, paramMap[id]));
        Object.keys(boolMap).forEach(id => bind(id, boolMap[id]));
        
        // Sync main mode sliders to simple mode
        const topScaleEl = document.getElementById('top-scale');
        if(topScaleEl) topScaleEl.addEventListener('input', e => {
            const simpleTaper = document.getElementById('simple-taper');
            const simpleVal = document.getElementById('v-simple-taper');
            if(simpleTaper) simpleTaper.value = e.target.value;
            if(simpleVal) simpleVal.textContent = parseFloat(e.target.value).toFixed(2);
        });
        const dishTypeEl = document.getElementById('dish-type');
        if(dishTypeEl) dishTypeEl.addEventListener('change', e => {
            const simpleDish = document.getElementById('simple-dish-type');
            if(simpleDish) simpleDish.value = e.target.value;
        });
        const roundCornerEl = document.getElementById('round-corner');
        if(roundCornerEl) roundCornerEl.addEventListener('input', e => {
            const simpleFillet = document.getElementById('simple-fillet');
            const simpleVal = document.getElementById('v-simple-fillet');
            if(simpleFillet) simpleFillet.value = e.target.value;
            if(simpleVal) simpleVal.textContent = parseFloat(e.target.value).toFixed(1);
        });
        
        const txtC = document.getElementById('text-content');
        if(txtC) txtC.addEventListener('input', e=>{state.text=e.target.value; requestUpdate();});
        const txt2C = document.getElementById('text2-content');
        if(txt2C) txt2C.addEventListener('input', e=>{state.text2=e.target.value; requestUpdate();});
        const sideT = document.getElementById('side-text');
        if(sideT) sideT.addEventListener('input', e=>{state.sideText=e.target.value; requestUpdate();});
        const colB = document.getElementById('col-body');
        if(colB) colB.addEventListener('input', e=>{
            state.colBody=e.target.value;
            const simpleColB = document.getElementById('simple-col-body');
            if(simpleColB) simpleColB.value = e.target.value;
            // „Éï„Ç£„É©„É°„É≥„Éà„É©„Ç§„Éñ„É©„É™„ÅÆÈÅ∏ÊäûÁä∂ÊÖã„ÇíÊõ¥Êñ∞
            if(typeof window.refreshFilamentPalette === 'function') window.refreshFilamentPalette();
            updateModel();
        });
        const colT = document.getElementById('col-text');
        if(colT) colT.addEventListener('input', e=>{
            state.colText=e.target.value;
            const simpleColT = document.getElementById('simple-col-text');
            if(simpleColT) simpleColT.value = e.target.value;
            updateModel();
        });
        
        const bUndo = document.getElementById('btn-undo'); if(bUndo) bUndo.addEventListener('click', undo);
        const bRedo = document.getElementById('btn-redo'); if(bRedo) bRedo.addEventListener('click', redo);
        
        window.addEventListener('resize', () => {
            camera.aspect=container.clientWidth/container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth,container.clientHeight);
        });
        
        const fInput = document.getElementById('font-file-input');
        if(fInput) fInput.addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const json = JSON.parse(e.target.result);
                    const font = fontLoader.parse(json);
                    const fontName = "custom_" + Date.now();
                    loadedFonts[fontName] = font;
                    const select = document.getElementById('font-family');
                    if(select) {
                        const option = document.createElement('option');
                        option.value = fontName;
                        option.text = file.name.replace('.json','');
                        select.add(option);
                        select.value = fontName;
                        state.font = fontName;
                        committedFont = fontName;
                        updateCustomDropdown();
                        setupCustomDropdown();
                        
                        // Á∞°Âçò„É¢„Éº„Éâ„ÅÆ„Çª„É¨„ÇØ„Çø„Éº„Å´„ÇÇËøΩÂä†
                        const simpleSelect = document.getElementById('simple-font-select');
                        if (simpleSelect) {
                            const simpleOption = document.createElement('option');
                            simpleOption.value = fontName;
                            simpleOption.text = file.name.replace('.json','');
                            simpleSelect.add(simpleOption);
                            simpleSelect.value = fontName;
                        }
                        if (typeof window.updateSimpleCustomDropdownHead === 'function') window.updateSimpleCustomDropdownHead();
                        
                        requestUpdate();
                    }
                } catch(err) {
                    showToast(translations[currentLang].msg_import_err, true);
                }
            };
            reader.readAsText(file);
        });
        
        const sInput = document.getElementById('svg-file-input');
        if(sInput) sInput.addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                state.svgContent = e.target.result;
                state.svgName = file.name.replace(/\.svg$/i, '');
                state.svgVisible = true;
                // HUD„ÅÆSVG„Éà„Ç∞„É´„Éú„Çø„É≥„Çí„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´„Åô„Çã
                const hudSvgBtn = document.getElementById('hud-toggle-svg');
                if (hudSvgBtn) hudSvgBtn.classList.add('active');
                updateModel();
            };
            reader.readAsText(file);
        });
        const bClearSvg = document.getElementById('btn-clear-svg');
        if(bClearSvg) bClearSvg.addEventListener('click', () => {
            state.svgContent = null;
            state.svgName = null;
            state.svgVisible = false;
            if(sInput) sInput.value = '';
            
            // Re-enable text when SVG is cleared
            state.enableText = true;
            const enableTextCheckbox = document.getElementById('enable-text');
            if (enableTextCheckbox) enableTextCheckbox.checked = true;
            const simpleEnableTextCheckbox = document.getElementById('simple-enable-text');
            if (simpleEnableTextCheckbox) simpleEnableTextCheckbox.checked = true;
            // HUD„ÅÆ„Éà„Ç∞„É´„Éú„Çø„É≥„ÇÇÂêåÊúü
            const hudTextBtn = document.getElementById('hud-toggle-text');
            if (hudTextBtn) hudTextBtn.classList.add('active');
            const hudSvgBtn = document.getElementById('hud-toggle-svg');
            if (hudSvgBtn) hudSvgBtn.classList.remove('active');
            
            updateModel();
        });
        
        const getFileName = () => {
            const el = document.getElementById('export-name');
            const base = el ? (el.value || 'keycap') : 'keycap';
            const suffix = state.text ? `_[${state.text.replace(/\n/g,'_')}]` : '';
            return base + suffix;
        };
        const saveBlob = (blob, name) => {
            if (typeof saveAs !== 'undefined') {
                saveAs(blob, name);
            } else {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = name;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
            }
        };
        
        const exportSTL = async (suff) => {
            const t = translations[currentLang];
            showToast(t.toast_generating);
            await new Promise(r => setTimeout(r, 100));
            
            let { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
            
            // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„Çí‰øÆÊ≠£
            showToast('„É°„ÉÉ„Ç∑„É•„ÇíÊ§úË®º‰∏≠...');
            if (bodyGeo) {
                bodyGeo = await validateAndFixGeometry(bodyGeo, 'Êú¨‰Ωì');
                if (!bodyGeo) return;
            }
            if (textGeo) {
                textGeo = await validateAndFixGeometry(textGeo, 'ÊñáÂ≠ó');
                if (!textGeo) return;
            }
            if (importedGeo) {
                importedGeo = await validateAndFixGeometry(importedGeo, '„Ç§„É≥„Éù„Éº„Éà„É¢„Éá„É´');
                if (!importedGeo) return;
            }
            
            const clone = new THREE.Group();
            if (bodyGeo) clone.add(new THREE.Mesh(bodyGeo, new THREE.MeshBasicMaterial()));
            if (textGeo) clone.add(new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial()));
            if (importedGeo) clone.add(new THREE.Mesh(importedGeo, new THREE.MeshBasicMaterial()));
            
            const res = new STLExporter().parse(clone, {binary:true});
            saveBlob(new Blob([res], {type:'application/octet-stream'}), getFileName()+suff);
            showToast(t.toast_stl_exported);
        };
        
        const exportOBJ = async () => {
            const t = translations[currentLang];
            showToast(t.toast_generating);
            await new Promise(r => setTimeout(r, 100));
            
            let { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
            
            // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„Çí‰øÆÊ≠£
            showToast('„É°„ÉÉ„Ç∑„É•„ÇíÊ§úË®º‰∏≠...');
            if (bodyGeo) {
                bodyGeo = await validateAndFixGeometry(bodyGeo, 'Êú¨‰Ωì');
                if (!bodyGeo) return;
            }
            if (textGeo) {
                textGeo = await validateAndFixGeometry(textGeo, 'ÊñáÂ≠ó');
                if (!textGeo) return;
            }
            if (importedGeo) {
                importedGeo = await validateAndFixGeometry(importedGeo, '„Ç§„É≥„Éù„Éº„Éà„É¢„Éá„É´');
                if (!importedGeo) return;
            }
            
            const clone = new THREE.Group();
            if (bodyGeo) {
                const mesh = new THREE.Mesh(bodyGeo, new THREE.MeshBasicMaterial({ color: state.colBody }));
                mesh.name = "KeycapBody";
                clone.add(mesh);
            }
            if (textGeo) {
                const mesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial({ color: state.colText }));
                mesh.name = "KeycapText";
                clone.add(mesh);
            }
            if (importedGeo) {
                const mesh = new THREE.Mesh(importedGeo, new THREE.MeshBasicMaterial({ color: state.colText }));
                mesh.name = "ImportedModel";
                clone.add(mesh);
            }
                
            const res = new OBJExporter().parse(clone);
            saveBlob(new Blob([res], {type:'text/plain'}), getFileName() + '.obj');
            showToast(t.toast_obj_exported);
        };
        
        // Export Confirmation Popup
        function showExportPopup(options) {
            return new Promise((resolve) => {
                const overlay = document.getElementById('export-popup-overlay');
                const popup = document.getElementById('export-popup');
                const formatEl = document.getElementById('export-popup-format');
                const previewEl = document.getElementById('export-popup-preview');
                const infoEl = document.getElementById('export-popup-info');
                const confirmBtn = document.getElementById('export-popup-confirm');
                const cancelBtn = document.getElementById('export-popup-cancel');
                const formatSelector = document.getElementById('export-format-selector');
                const amsColorsDiv = document.getElementById('export-ams-colors');
                
                // „Éó„É¨„Éì„É•„ÉºÁî®„ÅÆÂ§âÊï∞
                let thumbRenderer, thumbScene, thumbCam, previewGroup;
                
                // „Åì„ÅÆÁîªÈù¢ÂÜÖ„ÅßÈÅ∏Êäû„Åï„Çå„Åü„Åã„Å©„ÅÜ„Åã„ÇíËøΩË∑°
                let bodyColorSelectedInPopup = false;
                let textColorSelectedInPopup = false;
                
                // AMS„Çπ„É≠„ÉÉ„Éà„Å´„Éï„Ç£„É©„É°„É≥„Éà„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ„Åô„ÇãÈñ¢Êï∞
                function checkFilamentConfigured() {
                    let hasBodySlot = false;
                    let hasTextSlot = false;
                    
                    // „É¶„Éº„Ç∂„Éº„ÅåÊòéÁ§∫ÁöÑ„Å´ÈÅ∏Êäû„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØÊú™Ë®≠ÂÆö
                    if (!amsConfig.bodyExtruderSet && !amsConfig.textExtruderSet) {
                        return { hasBodySlot: false, hasTextSlot: false };
                    }
                    
                    const bodyExtruder = amsConfig.bodyExtruder;
                    const textExtruder = amsConfig.textExtruder;
                    
                    // ÂÖ®„Çπ„É≠„ÉÉ„Éà„ÇíÂèéÈõÜ
                    const allSlots = [];
                    amsConfig.units.forEach(unit => {
                        unit.slots.forEach(slot => allSlots.push(slot));
                    });
                    amsConfig.htUnits.forEach(unit => {
                        unit.slots.forEach(slot => allSlots.push(slot));
                    });
                    
                    // Êú¨‰Ωì: „É¶„Éº„Ç∂„Éº„ÅåÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆö„Åó„ÄÅÂØæÂøú„Çπ„É≠„ÉÉ„Éà„Å´Ëâ≤„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„Åø
                    if (amsConfig.bodyExtruderSet && bodyExtruder && bodyExtruder >= 1 && bodyExtruder <= allSlots.length) {
                        hasBodySlot = !!(allSlots[bodyExtruder - 1] && allSlots[bodyExtruder - 1].color);
                    }
                    
                    // ÊñáÂ≠ó: „É¶„Éº„Ç∂„Éº„ÅåÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆö„Åó„ÄÅÂØæÂøú„Çπ„É≠„ÉÉ„Éà„Å´Ëâ≤„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„Åø
                    if (amsConfig.textExtruderSet && textExtruder && textExtruder >= 1 && textExtruder <= allSlots.length) {
                        hasTextSlot = !!(allSlots[textExtruder - 1] && allSlots[textExtruder - 1].color);
                    }
                    
                    return { hasBodySlot, hasTextSlot };
                }
                
                // ÈÄöÂ∏∏„É¢„Éº„Éâ„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØ„Å®Ë≠¶Âëä„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
                function updateSingleExportStatus() {
                    const previewEl = document.getElementById('export-popup-preview');
                    const warningEl = document.getElementById('export-single-warning');
                    
                    if (!previewEl || !warningEl) return;
                    
                    // CSK„Åã„ÇâÂëº„Å≥Âá∫„Åï„Çå„ÅüÂ†¥Âêà
                    if (options.fromCSK) {
                        // Êó¢Â≠ò„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÇíÂâäÈô§
                        previewEl.querySelectorAll('.color-changed-mark, .color-overlay').forEach(m => m.remove());
                        
                        // ExtruderÊú™Ë®≠ÂÆö„ÅÆ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                        const unconfigured = options.cskUnconfigured || [];
                        
                        if (unconfigured.length > 0) {
                            // Êú™Ë®≠ÂÆö„Åå„ÅÇ„Çå„Å∞Ë≠¶Âëä„Éû„Éº„ÇØ„ÇíË°®Á§∫
                            const warnMark = document.createElement('div');
                            warnMark.className = 'color-changed-mark';
                            warnMark.style.cssText = 'position:absolute; top:8px; right:8px; width:24px; height:24px; background:#ff9800; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:14px; color:#fff; font-weight:bold; box-shadow:0 2px 4px rgba(0,0,0,0.5); z-index:10;';
                            warnMark.textContent = '!';
                            warnMark.title = `${unconfigured.length}‰ª∂„ÅÆ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Åß„Éï„Ç£„É©„É°„É≥„ÉàÊú™Ë®≠ÂÆö`;
                            previewEl.appendChild(warnMark);
                            // Ë≠¶Âëä„É°„ÉÉ„Çª„Éº„Ç∏„ÅØrenderExportAMSPalette„ÅßË®≠ÂÆö„Åï„Çå„Çã
                        } else {
                            // ÂÖ®„Å¶Ë®≠ÂÆöÊ∏à„Åø„ÅÆÂ†¥Âêà„ÅØ„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØ
                            const cskMark = document.createElement('div');
                            cskMark.className = 'color-changed-mark';
                            cskMark.style.cssText = 'position:absolute; top:8px; right:8px; width:24px; height:24px; background:#4caf50; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:14px; color:#fff; font-weight:bold; box-shadow:0 2px 4px rgba(0,0,0,0.5); z-index:10;';
                            cskMark.textContent = '‚úì';
                            cskMark.title = 'CSK„ÅßËâ≤Ë®≠ÂÆöÊ∏à„Åø';
                            previewEl.appendChild(cskMark);
                            warningEl.style.display = 'none';
                        }
                        return;
                    }
                    
                    // „Çπ„ÉÜ„É†„Ç≠„ÉÉ„ÉàÔºàtoleranceÔºâ„ÅÆÂ†¥Âêà„ÅØÂçòËâ≤Âç∞Âà∑„ÅÆ„Åü„ÇÅ„ÄÅ„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØ„Å®Ë≠¶Âëä„ÅØ‰∏çË¶Å
                    if (options.type === 'tolerance') {
                        warningEl.style.display = 'none';
                        return;
                    }
                    
                    // Êó¢Â≠ò„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØ„Å®„Ç´„É©„Éº„Ç™„Éº„Éê„Éº„É¨„Ç§„ÇíÂâäÈô§
                    previewEl.querySelectorAll('.color-changed-mark, .color-overlay').forEach(m => m.remove());
                    
                    // AMS„Çπ„É≠„ÉÉ„Éà„ÅÆË®≠ÂÆöÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºà„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖÈÅ∏Êäû OR Êó¢Â≠ò„ÅÆAMSË®≠ÂÆöÔºâ
                    const { hasBodySlot, hasTextSlot } = checkFilamentConfigured();
                    const hasBodyColor = bodyColorSelectedInPopup || hasBodySlot;
                    const hasTextColor = textColorSelectedInPopup || hasTextSlot;
                    
                    // „Ç´„É©„Éº„Ç™„Éº„Éê„Éº„É¨„Ç§„ÇíËøΩÂä†ÔºàÊú¨‰ΩìËâ≤„Å®ÊñáÂ≠óËâ≤„ÇíË°®Á§∫Ôºâ
                    if (hasBodyColor || hasTextColor) {
                        const overlay = document.createElement('div');
                        overlay.className = 'color-overlay';
                        overlay.style.cssText = 'position:absolute; bottom:10px; left:50%; transform:translateX(-50%); display:flex; gap:4px; background:rgba(0,0,0,0.7); padding:4px 8px; border-radius:6px; z-index:10;';
                        
                        if (hasBodyColor) {
                            const bodyBox = document.createElement('div');
                            bodyBox.style.cssText = `width:24px; height:24px; background:${state.colBody}; border-radius:4px; border:2px solid #00e5ff;`;
                            bodyBox.title = 'Êú¨‰ΩìËâ≤';
                            overlay.appendChild(bodyBox);
                        }
                        
                        if (hasTextColor) {
                            const textBox = document.createElement('div');
                            textBox.style.cssText = `width:24px; height:24px; background:${state.colText}; border-radius:4px; border:2px solid #ff9800;`;
                            textBox.title = 'ÊñáÂ≠óËâ≤';
                            overlay.appendChild(textBox);
                        }
                        
                        previewEl.appendChild(overlay);
                    }
                    
                    // Êú¨‰Ωì„Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆöÊôÇ: „Ç∑„Ç¢„É≥Ëâ≤„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØÔºàÂè≥‰∏ä„Éª‰∏äÊÆµÔºâ
                    if (hasBodyColor) {
                        const bodyMark = document.createElement('div');
                        bodyMark.className = 'color-changed-mark';
                        bodyMark.style.cssText = 'position:absolute; top:8px; right:8px; width:20px; height:20px; background:#00e5ff; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:12px; color:#000; font-weight:bold; box-shadow:0 2px 4px rgba(0,0,0,0.5); z-index:10;';
                        bodyMark.textContent = '‚úì';
                        bodyMark.title = 'Êú¨‰ΩìËâ≤Ë®≠ÂÆöÊ∏à„Åø';
                        previewEl.appendChild(bodyMark);
                    }
                    
                    // ÊñáÂ≠ó„Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆöÊôÇ: „Ç™„É¨„É≥„Ç∏Ëâ≤„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØÔºàÂè≥‰∏ä„Éª‰∏ãÊÆµÔºâ
                    if (hasTextColor) {
                        const textMark = document.createElement('div');
                        textMark.className = 'color-changed-mark';
                        textMark.style.cssText = 'position:absolute; top:32px; right:8px; width:20px; height:20px; background:#ff9800; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:12px; color:#000; font-weight:bold; box-shadow:0 2px 4px rgba(0,0,0,0.5); z-index:10;';
                        textMark.textContent = '‚úì';
                        textMark.title = 'ÊñáÂ≠óËâ≤Ë®≠ÂÆöÊ∏à„Åø';
                        previewEl.appendChild(textMark);
                    }
                    
                    // Ë≠¶Âëä„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊõ¥Êñ∞Ôºà„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„Éà„ÇÇÂê´„ÇÄÔºâ
                    const warnings = [];
                    if (!hasBodyColor && !hasTextColor) {
                        warnings.push('Êú¨‰Ωì„Éï„Ç£„É©„É°„É≥„Éà„ÄÅÊñáÂ≠ó„Éï„Ç£„É©„É°„É≥„Éà‰∏°Êñπ„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
                    } else if (!hasBodyColor) {
                        warnings.push('Êú¨‰Ωì„Éï„Ç£„É©„É°„É≥„Éà„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
                    } else if (!hasTextColor) {
                        warnings.push('ÊñáÂ≠ó„Éï„Ç£„É©„É°„É≥„Éà„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
                    }
                    
                    if (warnings.length > 0) {
                        warningEl.style.display = 'block';
                        warningEl.innerHTML = `<span style="color:#ff5252;">‚ö†Ô∏è ${warnings.join('<br>')}</span>`;
                    } else {
                        warningEl.style.display = 'none';
                    }
                }
                
                // AMS„Éë„É¨„ÉÉ„Éà„ÇíÊèèÁîª„Åô„ÇãÈñ¢Êï∞
                function renderExportAMSPalette() {
                    const bodyPalette = document.getElementById('export-body-palette');
                    const textPalette = document.getElementById('export-text-palette');
                    const amsColorsDiv = document.getElementById('export-ams-colors');
                    const warningEl = document.getElementById('export-single-warning');
                    
                    if (!bodyPalette || !textPalette) return;
                    
                    // CSK„Åã„ÇâÂëº„Å≥Âá∫„Åï„Çå„ÅüÂ†¥Âêà„ÅØ„É≠„ÉÉ„ÇØË°®Á§∫
                    if (options.fromCSK) {
                        // AMS„Ç´„É©„Éº„Çª„ÇØ„Ç∑„Éß„É≥ÂÖ®‰Ωì„Çí„É≠„ÉÉ„ÇØÁä∂ÊÖã„Å´„Åô„Çã
                        if (amsColorsDiv) {
                            amsColorsDiv.style.opacity = '0.85';
                            amsColorsDiv.style.pointerEvents = 'none';
                        }
                        
                        // ExtruderÊú™Ë®≠ÂÆö„ÅÆ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                        const unconfigured = options.cskUnconfigured || [];
                        
                        if (unconfigured.length > 0) {
                            // Êú™Ë®≠ÂÆö„Åå„ÅÇ„Çå„Å∞Ë≠¶Âëä„ÇíË°®Á§∫
                            if (amsColorsDiv) {
                                amsColorsDiv.style.border = '1px solid #ff9800';
                                amsColorsDiv.style.background = 'rgba(255,152,0,0.08)';
                            }
                            
                            bodyPalette.innerHTML = `<div style="color:#ff9800; font-size:0.75rem; padding:8px 12px; background:rgba(255,152,0,0.15); border-radius:6px; border:1px solid rgba(255,152,0,0.3);">
                                <span style="font-weight:bold;">‚ö†Ô∏è ‰∏ÄÈÉ®Êú™Ë®≠ÂÆö</span><br>
                                <span style="font-size:0.65rem; color:#aaa;">CSK„Å´Êàª„Å£„Å¶Ëâ≤„ÇíÂâ≤„ÇäÂΩì„Å¶„Å¶„Åè„Å†„Åï„ÅÑ</span>
                            </div>`;
                            textPalette.innerHTML = `<div style="color:#ff9800; font-size:0.75rem; padding:8px 12px; background:rgba(255,152,0,0.15); border-radius:6px; border:1px solid rgba(255,152,0,0.3);">
                                <span style="font-weight:bold;">‚ö†Ô∏è ‰∏ÄÈÉ®Êú™Ë®≠ÂÆö</span><br>
                                <span style="font-size:0.65rem; color:#aaa;">CSK„Å´Êàª„Å£„Å¶Ëâ≤„ÇíÂâ≤„ÇäÂΩì„Å¶„Å¶„Åè„Å†„Åï„ÅÑ</span>
                            </div>`;
                            
                            // Ë≠¶Âëä„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫
                            if (warningEl) {
                                warningEl.style.display = 'block';
                                const warningItems = unconfigured.slice(0, 5).map(item => {
                                    const missing = [];
                                    if (item.missingBody) missing.push('Êú¨‰Ωì');
                                    if (item.missingText) missing.push('ÊñáÂ≠ó');
                                    return `„Éª${item.name}: ${missing.join('/')}„Éï„Ç£„É©„É°„É≥„ÉàÊú™Ë®≠ÂÆö`;
                                });
                                const moreCount = unconfigured.length - 5;
                                let warningText = warningItems.join('<br>');
                                if (moreCount > 0) {
                                    warningText += `<br>„Éª‰ªñ ${moreCount}‰ª∂`;
                                }
                                warningEl.innerHTML = `<span style="color:#ff9800;">‚ö†Ô∏è „Éï„Ç£„É©„É°„É≥„ÉàÊú™Ë®≠ÂÆö„ÅÆ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Åå„ÅÇ„Çä„Åæ„ÅôÔºö<br><span style="font-size:0.7rem;">${warningText}</span></span>`;
                            }
                        } else {
                            // ÂÖ®„Å¶Ë®≠ÂÆöÊ∏à„Åø„ÅÆÂ†¥Âêà
                            if (amsColorsDiv) {
                                amsColorsDiv.style.border = '1px solid #4caf50';
                                amsColorsDiv.style.background = 'rgba(76,175,80,0.08)';
                            }
                            
                            bodyPalette.innerHTML = `<div style="color:#4caf50; font-size:0.75rem; padding:8px 12px; background:rgba(76,175,80,0.15); border-radius:6px; border:1px solid rgba(76,175,80,0.3);">
                                <span style="font-weight:bold;">üîí CSK„ÅßË®≠ÂÆöÊ∏à„Åø</span><br>
                                <span style="font-size:0.65rem; color:#aaa;">ÂêÑ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Å´ÂÄãÂà•„ÅÆËâ≤„ÅåÂâ≤„ÇäÂΩì„Å¶„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô</span>
                            </div>`;
                            textPalette.innerHTML = `<div style="color:#4caf50; font-size:0.75rem; padding:8px 12px; background:rgba(76,175,80,0.15); border-radius:6px; border:1px solid rgba(76,175,80,0.3);">
                                <span style="font-weight:bold;">üîí CSK„ÅßË®≠ÂÆöÊ∏à„Åø</span><br>
                                <span style="font-size:0.65rem; color:#aaa;">ÂêÑ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Å´ÂÄãÂà•„ÅÆËâ≤„ÅåÂâ≤„ÇäÂΩì„Å¶„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô</span>
                            </div>`;
                            // Ë≠¶ÂëäÈùûË°®Á§∫
                            if (warningEl) warningEl.style.display = 'none';
                        }
                        return;
                    }
                    
                    // ÈÄöÂ∏∏„ÅÆÂ†¥Âêà„ÅØ„Çπ„Çø„Ç§„É´„Çí„É™„Çª„ÉÉ„Éà
                    if (amsColorsDiv) {
                        amsColorsDiv.style.opacity = '';
                        amsColorsDiv.style.pointerEvents = '';
                        amsColorsDiv.style.border = '';
                        amsColorsDiv.style.background = '';
                    }
                    
                    // AMS„Çπ„É≠„ÉÉ„Éà„ÇíÂèéÈõÜ
                    const allSlots = [];
                    amsConfig.units.forEach(unit => {
                        unit.slots.forEach(slotData => allSlots.push(slotData));
                    });
                    amsConfig.htUnits.forEach(unit => {
                        unit.slots.forEach(slotData => allSlots.push(slotData));
                    });
                    
                    const renderPalette = (container, type) => {
                        container.innerHTML = '';
                        let hasSlots = false;
                        
                        allSlots.forEach((slotData, idx) => {
                            if (!slotData || !slotData.color) return;
                            hasSlots = true;
                            
                            const item = document.createElement('div');
                            item.className = 'ams-select-item';
                            item.style.cssText = 'width:48px; height:52px; padding:3px;';
                            item.dataset.slot = idx + 1;
                            item.dataset.color = slotData.color;
                            
                            // „É¶„Éº„Ç∂„Éº„ÅåÊòéÁ§∫ÁöÑ„Å´ÈÅ∏Êäû„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅøÈÅ∏ÊäûÁä∂ÊÖã„ÇíË°®Á§∫
                            const isBodySelected = (bodyColorSelectedInPopup || amsConfig.bodyExtruderSet) && amsConfig.bodyExtruder === idx + 1;
                            const isTextSelected = (textColorSelectedInPopup || amsConfig.textExtruderSet) && amsConfig.textExtruder === idx + 1;
                            if (type === 'body' && isBodySelected) {
                                item.classList.add('body-selected');
                            } else if (type === 'text' && isTextSelected) {
                                item.classList.add('text-selected');
                            }
                            
                            const material = slotData.material || '';
                            item.innerHTML = `
                                <span class="ams-select-item-num" style="font-size:0.6rem;">${idx + 1}</span>
                                <div class="ams-select-item-color" style="width:24px; height:24px; background:${slotData.color}"></div>
                                <div class="ams-select-item-material" style="font-size:0.5rem; max-width:44px;">${material}</div>
                            `;
                            
                            item.onclick = () => {
                                if (type === 'body') {
                                    amsConfig.bodyExtruder = idx + 1;
                                    amsConfig.bodyExtruderSet = true;
                                    state.colBody = slotData.color;
                                    state.bodyExtruder = idx + 1;
                                    bodyColorSelectedInPopup = true;
                                } else {
                                    amsConfig.textExtruder = idx + 1;
                                    amsConfig.textExtruderSet = true;
                                    state.colText = slotData.color;
                                    state.textExtruder = idx + 1;
                                    textColorSelectedInPopup = true;
                                }
                                renderExportAMSPalette();
                                updateExportPreview();
                                updateModel(); // „É°„Ç§„É≥„Éì„É•„Éº„ÇÇÊõ¥Êñ∞
                                updateExportInfo(); // ÊÉÖÂ†±„ÇÇÊõ¥Êñ∞
                                updateSingleExportStatus(); // „ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØ„Å®Ë≠¶Âëä„ÇíÊõ¥Êñ∞
                                if (typeof updateSettingsTabPalette === 'function') updateSettingsTabPalette(); // Ë®≠ÂÆö„Çø„Éñ„ÅÆ„Éë„É¨„ÉÉ„Éà„ÇÇÊõ¥Êñ∞
                            };
                            
                            container.appendChild(item);
                        });
                        
                        if (!hasSlots) {
                            container.innerHTML = '<div style="color:#666; font-size:0.7rem; padding:5px;">AMSË®≠ÂÆö„ÅßËâ≤„ÇíÁôªÈå≤</div>';
                        }
                    };
                    
                    renderPalette(bodyPalette, 'body');
                    renderPalette(textPalette, 'text');
                    
                    // „ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØ„Å®Ë≠¶Âëä„ÇíÊõ¥Êñ∞
                    updateSingleExportStatus();
                }
                
                // „Ç®„ÇØ„Çπ„Éù„Éº„Éà„Éó„É¨„Éì„É•„Éº„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
                function updateExportPreview() {
                    if (!previewGroup || !thumbRenderer || !thumbScene || !thumbCam) return;
                    
                    // „Éó„É¨„Éì„É•„Éº„Ç∞„É´„Éº„ÉóÂÜÖ„ÅÆ„Éû„ÉÜ„É™„Ç¢„É´„ÇíÊõ¥Êñ∞
                    previewGroup.children.forEach(child => {
                        if (child.material) {
                            if (options.type === 'sprue') {
                                // „Çπ„Éó„É´„Éº„Ç≠„ÉÉ„Éà„ÅØÂÖ®‰Ωì„ÇíÊú¨‰ΩìËâ≤„ÅßÊõ¥Êñ∞
                                child.material.color.set(state.colBody);
                            } else if (child.name === 'KeycapBody') {
                                child.material.color.set(state.colBody);
                            } else if (child.name === 'KeycapText' || child.name === 'ImportedModel') {
                                child.material.color.set(state.colText);
                            }
                        }
                    });
                    
                    thumbRenderer.render(thumbScene, thumbCam);
                }
                
                // ÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
                function updateExportInfo() {
                    // Âçò‰Ωì„Ç®„ÇØ„Çπ„Éù„Éº„Éà„ÄÅ„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„Éà„ÄÅ„Éê„ÉÉ„ÉÅ„Åß„ÅÆ„ÅøËâ≤ÊÉÖÂ†±„ÇíÊõ¥Êñ∞
                    if (options.type !== 'single' && options.type !== 'sprue' && options.type !== 'batch' && options.type !== undefined) return;
                    
                    // „Éï„Ç£„É©„É°„É≥„ÉàÊÉÖÂ†±„ÇíÂèñÂæóÔºà„Åì„ÅÆÁîªÈù¢ÂÜÖ„ÅßÈÅ∏Êäû„Åï„Çå„ÅüÂ†¥Âêà„ÅÆ„ÅøË°®Á§∫Ôºâ
                    const bodySlot = bodyColorSelectedInPopup ? (amsConfig.bodyExtruder || '-') : '-';
                    const textSlot = textColorSelectedInPopup ? (amsConfig.textExtruder || '-') : '-';
                    
                    // ÊÉÖÂ†±Ë°®Á§∫„ÅÆÊõ¥Êñ∞
                    const colorInfoBody = document.getElementById('export-info-body-color');
                    const colorInfoText = document.getElementById('export-info-text-color');
                    if (colorInfoBody) {
                        if (bodyColorSelectedInPopup) {
                            colorInfoBody.innerHTML = `<span style="display:inline-block; width:12px; height:12px; background:${state.colBody}; border-radius:2px; vertical-align:middle; margin-right:4px; border:1px solid #555;"></span>${state.colBody} („Çπ„É≠„ÉÉ„Éà${bodySlot})`;
                        } else {
                            colorInfoBody.innerHTML = `<span style="display:inline-block; width:12px; height:12px; background:${state.colBody}; border-radius:2px; vertical-align:middle; margin-right:4px; border:1px solid #555;"></span>${state.colBody}`;
                        }
                    }
                    if (colorInfoText) {
                        if (textColorSelectedInPopup) {
                            colorInfoText.innerHTML = `<span style="display:inline-block; width:12px; height:12px; background:${state.colText}; border-radius:2px; vertical-align:middle; margin-right:4px; border:1px solid #555;"></span>${state.colText} („Çπ„É≠„ÉÉ„Éà${textSlot})`;
                        } else {
                            colorInfoText.innerHTML = `<span style="display:inline-block; width:12px; height:12px; background:${state.colText}; border-radius:2px; vertical-align:middle; margin-right:4px; border:1px solid #555;"></span>${state.colText}`;
                        }
                    }
                }
                
                // „Éï„Ç©„Éº„Éû„ÉÉ„ÉàÈÅ∏Êäû„ÇíË°®Á§∫„Åô„Çã„Åã„Å©„ÅÜ„Åã
                const showFormatSelector = options.showFormatSelector === true;
                if (formatSelector) {
                    formatSelector.style.display = showFormatSelector ? 'block' : 'none';
                }
                
                // „Éï„Ç©„Éº„Éû„ÉÉ„ÉàÈÅ∏ÊäûÊôÇ„ÅÆ„Éê„ÉÉ„Ç∏Êõ¥Êñ∞
                const updateFormatBadge = () => {
                    if (showFormatSelector) {
                        const selected = document.querySelector('input[name="export-format-select"]:checked');
                        if (selected) {
                            const fmt = selected.value.toUpperCase();
                            formatEl.textContent = fmt;
                            if (fmt === '3MF') {
                                formatEl.style.background = '#4caf50';
                            } else if (fmt === 'OBJ') {
                                formatEl.style.background = '#ff9800';
                            } else {
                                formatEl.style.background = '#4fc3f7';
                            }
                        }
                    } else {
                        // Set format badge - match button colors
                        formatEl.textContent = options.format || 'STL';
                        if (options.format === '3MF') {
                            formatEl.style.background = '#4caf50';
                        } else if (options.format === 'OBJ') {
                            formatEl.style.background = '#ff9800';
                        } else {
                            formatEl.style.background = '#4fc3f7';
                        }
                    }
                };
                
                // „Éï„Ç©„Éº„Éû„ÉÉ„ÉàÈÅ∏Êäû„É™„Çπ„Éä„Éº
                const formatInputs = document.querySelectorAll('input[name="export-format-select"]');
                formatInputs.forEach(input => {
                    input.addEventListener('change', updateFormatBadge);
                });
                
                // ÂàùÊúü„Éï„Ç©„Éº„Éû„ÉÉ„Éà„ÇíË®≠ÂÆö
                if (showFormatSelector && options.format) {
                    const initialFormat = options.format.toLowerCase();
                    const initialInput = document.querySelector(`input[name="export-format-select"][value="${initialFormat}"]`);
                    if (initialInput) initialInput.checked = true;
                }
                
                updateFormatBadge();
                
                // AMS„Éë„É¨„ÉÉ„Éà„ÇíË°®Á§∫ÔºàÂçò‰Ωì„Ç®„ÇØ„Çπ„Éù„Éº„Éà„ÄÅ„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„Éà„ÄÅ„Éê„ÉÉ„ÉÅ„ÅÆÂ†¥Âêà„ÅÆ„ÅøÔºâ
                if (amsColorsDiv) {
                    amsColorsDiv.style.display = (options.type === 'single' || options.type === 'sprue' || options.type === 'batch' || options.type === undefined) ? 'block' : 'none';
                }
                
                // Generate preview thumbnail with auto-fit camera
                previewEl.innerHTML = '';
                try {
                    thumbRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                    // Larger canvas for sprue kit and tolerance test
                    const canvasW = (options.type === 'sprue' || options.type === 'tolerance') ? 380 : 300;
                    const canvasH = (options.type === 'sprue' || options.type === 'tolerance') ? 200 : 170;
                    thumbRenderer.setSize(canvasW, canvasH);
                    thumbRenderer.setClearColor(0x0a0a15, 1);
                    
                    thumbScene = new THREE.Scene();
                    thumbCam = new THREE.PerspectiveCamera(35, canvasW/canvasH, 0.1, 5000);
                    
                    thumbScene.add(new THREE.AmbientLight(0xffffff, 0.6));
                    const dLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    dLight.position.set(10, 20, 10);
                    thumbScene.add(dLight);
                    
                    // Create a group to hold preview meshes
                    previewGroup = new THREE.Group();
                    
                    // Check if sprue preview geometry is provided
                    if (options.spruePreviewGeos && options.spruePreviewGeos.length > 0) {
                        options.spruePreviewGeos.forEach(geo => {
                            const mesh = new THREE.Mesh(
                                geo,
                                new THREE.MeshStandardMaterial({ color: new THREE.Color(state.colBody) })
                            );
                            previewGroup.add(mesh);
                        });
                    } else if (options.type === 'tolerance') {
                        // Generate simple preview for tolerance test kit
                        const spacing = 12;
                        const stemHeight = 4.0;
                        const stemRadius = 5.50 / 2;
                        const baseHeight = 1.5;
                        const baseSize = 9.0;
                        const previewMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
                        
                        for (let i = 0; i < 5; i++) {
                            const xPos = (i - 2) * spacing;
                            // Stem cylinder
                            const stemGeo = new THREE.CylinderGeometry(stemRadius, stemRadius, stemHeight, 16);
                            stemGeo.translate(xPos, stemHeight / 2 + baseHeight, 0);
                            previewGroup.add(new THREE.Mesh(stemGeo, previewMaterial));
                            // Base
                            const baseGeo = new THREE.BoxGeometry(baseSize, baseHeight, baseSize);
                            baseGeo.translate(xPos, baseHeight / 2, 0);
                            previewGroup.add(new THREE.Mesh(baseGeo, previewMaterial));
                        }
                    } else {
                        // Use mainGroup for single keycap
                        mainGroup.children.forEach((child, idx) => {
                            if (child.geometry) {
                                const cloneMesh = new THREE.Mesh(
                                    child.geometry.clone(),
                                    child.material.clone()
                                );
                                cloneMesh.name = child.name; // ÂêçÂâç„Çí‰øùÊåÅ
                                previewGroup.add(cloneMesh);
                            }
                        });
                    }
                    
                    thumbScene.add(previewGroup);
                    
                    // Calculate bounding box and auto-fit camera
                    const box = new THREE.Box3().setFromObject(previewGroup);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = thumbCam.fov * (Math.PI / 180);
                    let cameraDistance = maxDim / (2 * Math.tan(fov / 2));
                    
                    // Adjust camera based on model type
                    if (options.type === 'sprue') {
                        // For sprue kit: top-down angled view to see grid layout
                        cameraDistance *= 1.3; // Tighter fit for sprue
                        thumbCam.position.set(
                            center.x + cameraDistance * 0.4,
                            center.y + cameraDistance * 0.9, // Higher angle
                            center.z + cameraDistance * 0.5
                        );
                    } else if (options.type === 'tolerance') {
                        // For tolerance test: front-angled view to see all stems
                        cameraDistance *= 1.4;
                        thumbCam.position.set(
                            center.x + cameraDistance * 0.3,
                            center.y + cameraDistance * 0.6,
                            center.z + cameraDistance * 0.8
                        );
                    } else {
                        // For single keycap: standard 3/4 view
                        cameraDistance *= 1.6;
                        thumbCam.position.set(
                            center.x + cameraDistance * 0.7,
                            center.y + cameraDistance * 0.5,
                            center.z + cameraDistance * 0.7
                        );
                    }
                    thumbCam.lookAt(center);
                    
                    thumbRenderer.render(thumbScene, thumbCam);
                    previewEl.appendChild(thumbRenderer.domElement);
                    // dispose„ÅØcleanupÈñ¢Êï∞„ÅßË°å„ÅÜÔºà„Éó„É¨„Éì„É•„ÉºÊõ¥Êñ∞„ÅÆ„Åü„ÇÅ„Å´‰øùÊåÅÔºâ
                } catch(e) {
                    console.error('Preview error:', e);
                    previewEl.innerHTML = '<div style="color:#666;">Preview unavailable</div>';
                }
                
                // AMS„Éë„É¨„ÉÉ„Éà„ÇíÊèèÁîª
                renderExportAMSPalette();
                
                // Build info items
                let infoHTML = '';
                const t = translations[currentLang];
                
                if (options.type === 'sprue') {
                    // Sprue kit info
                    const printerNames = {
                        'x1p1a1': 'X1/P1/A1', 'a1mini': 'A1 mini', 'h2d': 'H2D',
                        'h2s': 'H2S', 'h2c': 'H2C', 'unlimited': t.sprue_unlimited || 'Âà∂Èôê„Å™„Åó'
                    };
                    
                    // CSK„Åã„ÇâÂëº„Å≥Âá∫„Åï„Çå„ÅüÂ†¥Âêà„ÅØ„ÄåCSK„ÅßË®≠ÂÆöÊ∏à„Åø„Äç„Å®Ë°®Á§∫
                    let bodyColorInfo, textColorInfo;
                    if (options.fromCSK) {
                        const unconfigured = options.cskUnconfigured || [];
                        if (unconfigured.length > 0) {
                            // Êú™Ë®≠ÂÆö„Åå„ÅÇ„Çå„Å∞Ë≠¶ÂëäË°®Á§∫
                            bodyColorInfo = `<span style="color:#ff9800; font-weight:bold;">‚ö†Ô∏è ${unconfigured.length}‰ª∂„ÅåÊú™Ë®≠ÂÆö</span>`;
                            textColorInfo = `<span style="color:#ff9800; font-weight:bold;">‚ö†Ô∏è ${unconfigured.length}‰ª∂„ÅåÊú™Ë®≠ÂÆö</span>`;
                        } else {
                            // ÂÖ®„Å¶Ë®≠ÂÆöÊ∏à„Åø
                            bodyColorInfo = `<span style="color:#4caf50; font-weight:bold;">‚úì CSK„ÅßÂÄãÂà•Ë®≠ÂÆöÊ∏à„Åø</span>`;
                            textColorInfo = `<span style="color:#4caf50; font-weight:bold;">‚úì CSK„ÅßÂÄãÂà•Ë®≠ÂÆöÊ∏à„Åø</span>`;
                        }
                    } else {
                        bodyColorInfo = `<span style="display:inline-block; width:12px; height:12px; background:${state.colBody}; border-radius:2px; vertical-align:middle; margin-right:4px; border:1px solid #555;"></span>${state.colBody}`;
                        textColorInfo = `<span style="display:inline-block; width:12px; height:12px; background:${state.colText}; border-radius:2px; vertical-align:middle; margin-right:4px; border:1px solid #555;"></span>${state.colText}`;
                    }
                    
                    infoHTML += `
                        <div class="export-info-item"><span class="export-info-label">${t.popup_printer || '„Éó„É™„É≥„Çø„Éº'}</span><span class="export-info-value highlight">${printerNames[options.printer] || options.printer}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_build_size || 'ÈÄ†ÂΩ¢„Çµ„Ç§„Ç∫'}</span><span class="export-info-value">${options.buildSize || '-'}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_key_count || '„Ç≠„ÉºÊï∞'}</span><span class="export-info-value highlight">${options.keyCount}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_layout || 'ÈÖçÁΩÆ'}</span><span class="export-info-value">${options.layout || '-'}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_body_color || 'Êú¨‰ΩìËâ≤'}</span><span class="export-info-value" id="export-info-body-color">${bodyColorInfo}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_text_color || 'ÊñáÂ≠óËâ≤'}</span><span class="export-info-value" id="export-info-text-color">${textColorInfo}</span></div>
                        <div class="export-info-item export-info-full"><span class="export-info-label">${t.popup_char_list || 'ÊñáÂ≠ó„É™„Çπ„Éà'}</span><span class="export-info-value">${options.charList || '-'}</span></div>
                    `;
                } else if (options.type === 'batch') {
                    // Batch export info
                    // ÂàùÊúüËâ≤ÊÉÖÂ†±Ôºà„Çπ„É≠„ÉÉ„ÉàÊÉÖÂ†±„Å™„ÅóÔºâ
                    const bodyColorInfo = `<span style="display:inline-block; width:12px; height:12px; background:${state.colBody}; border-radius:2px; vertical-align:middle; margin-right:4px; border:1px solid #555;"></span>${state.colBody}`;
                    const textColorInfo = `<span style="display:inline-block; width:12px; height:12px; background:${state.colText}; border-radius:2px; vertical-align:middle; margin-right:4px; border:1px solid #555;"></span>${state.colText}`;
                    
                    infoHTML += `
                        <div class="export-info-item"><span class="export-info-label">${t.popup_format || 'Âá∫ÂäõÂΩ¢Âºè'}</span><span class="export-info-value highlight">${options.format}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_file_count || '„Éï„Ç°„Ç§„É´Êï∞'}</span><span class="export-info-value highlight">${options.fileCount}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_body_color || 'Êú¨‰ΩìËâ≤'}</span><span class="export-info-value" id="export-info-body-color">${bodyColorInfo}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_text_color || 'ÊñáÂ≠óËâ≤'}</span><span class="export-info-value" id="export-info-text-color">${textColorInfo}</span></div>
                        <div class="export-info-item export-info-full"><span class="export-info-label">${t.popup_char_list || 'ÊñáÂ≠ó„É™„Çπ„Éà'}</span><span class="export-info-value">${options.charList || '-'}</span></div>
                    `;
                } else if (options.type === 'tolerance') {
                    // Tolerance test kit info
                    const labels = [];
                    for (let i = 0; i < options.count; i++) {
                        labels.push((options.startVal + (options.stepVal * i)).toFixed(2));
                    }
                    infoHTML += `
                        <div class="export-info-item"><span class="export-info-label">${t.popup_format || 'Âá∫ÂäõÂΩ¢Âºè'}</span><span class="export-info-value highlight">${options.format}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_tol_start || 'ÈñãÂßãÂÄ§'}</span><span class="export-info-value highlight">${options.startVal.toFixed(2)} mm</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_tol_step || 'Âàª„Åø'}</span><span class="export-info-value highlight">${options.stepVal.toFixed(2)} mm</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_tol_count || 'ÁîüÊàêÊï∞'}</span><span class="export-info-value">${options.count} ${currentLang === 'en' ? 'stems' : 'ÂÄã'}</span></div>
                        <div class="export-info-item export-info-full"><span class="export-info-label">${t.popup_tol_values || '„ÇØ„É™„Ç¢„É©„É≥„ÇπÂÄ§'}</span><span class="export-info-value">${labels.join(', ')} mm</span></div>
                    `;
                } else {
                    // Single keycap export
                    const weight = document.getElementById('info-weight')?.textContent || '0.00';
                    const cost = document.getElementById('info-cost')?.textContent || '0';
                    const currency = document.getElementById('info-currency')?.textContent || '¬•';
                    const vendor = document.getElementById('fil-vendor')?.options[document.getElementById('fil-vendor')?.selectedIndex]?.text || '-';
                    const material = document.getElementById('fil-material')?.options[document.getElementById('fil-material')?.selectedIndex]?.text || '-';
                    
                    // Get keycap info
                    const profileNames = { cherry: 'Cherry', dsa: 'DSA', sa: 'SA', oem: 'OEM', xda: 'XDA', kat: 'KAT', custom: 'Custom' };
                    const profile = profileNames[state.profile] || state.profile;
                    const size = `${state.uSize}U (${(state.unitSize * state.uSize).toFixed(1)}mm)`;
                    const row = state.row; // Already 'R3' format
                    
                    // Get text from input fields (check both simple and detailed mode)
                    // Only show text if enableText is true
                    let textDisplay = '-';
                    if (state.enableText) {
                        const simpleTextEl = document.getElementById('simple-text-content');
                        const detailedTextEl = document.getElementById('text-content');
                        let currentText = '';
                        if (simpleTextEl && simpleTextEl.value) {
                            currentText = simpleTextEl.value;
                        } else if (detailedTextEl && detailedTextEl.value) {
                            currentText = detailedTextEl.value;
                        } else {
                            currentText = state.text || '';
                        }
                        textDisplay = currentText || '-';
                    }
                    
                    // SVG info
                    let svgInfo = '-';
                    if (state.svgVisible && state.svgContent) {
                        svgInfo = state.svgName || (currentLang === 'en' ? 'Custom SVG' : '„Ç´„Çπ„Çø„É†SVG');
                    }
                    
                    // „Éï„Ç£„É©„É°„É≥„ÉàËâ≤ÊÉÖÂ†±
                    const bodySlot = amsConfig.bodyExtruder;
                    const textSlot = amsConfig.textExtruder;
                    const bodyColorInfo = bodySlot 
                        ? `<span style="display:inline-block; width:12px; height:12px; background:${state.colBody}; border-radius:2px; vertical-align:middle; margin-right:4px; border:1px solid #555;"></span>${state.colBody} („Çπ„É≠„ÉÉ„Éà${bodySlot})`
                        : `<span style="display:inline-block; width:12px; height:12px; background:${state.colBody}; border-radius:2px; vertical-align:middle; margin-right:4px; border:1px solid #555;"></span>${state.colBody}`;
                    const textColorInfo = textSlot
                        ? `<span style="display:inline-block; width:12px; height:12px; background:${state.colText}; border-radius:2px; vertical-align:middle; margin-right:4px; border:1px solid #555;"></span>${state.colText} („Çπ„É≠„ÉÉ„Éà${textSlot})`
                        : `<span style="display:inline-block; width:12px; height:12px; background:${state.colText}; border-radius:2px; vertical-align:middle; margin-right:4px; border:1px solid #555;"></span>${state.colText}`;
                    
                    infoHTML += `
                        <div class="export-info-item"><span class="export-info-label">${t.popup_est_weight || '‰∫àÊÉ≥ÈáçÈáè'}</span><span class="export-info-value highlight">${weight} g</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_est_cost || '‰∫àÊÉ≥„Ç≥„Çπ„Éà'}</span><span class="export-info-value highlight">${currency} ${cost}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_body_color || 'Êú¨‰ΩìËâ≤'}</span><span class="export-info-value" id="export-info-body-color">${bodyColorInfo}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_text_color || 'ÊñáÂ≠óËâ≤'}</span><span class="export-info-value" id="export-info-text-color">${textColorInfo}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_profile || '„Éó„É≠„Éï„Ç°„Ç§„É´'}</span><span class="export-info-value">${profile}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_size || '„Çµ„Ç§„Ç∫'}</span><span class="export-info-value">${size}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_row || 'Ë°å'}</span><span class="export-info-value">${row}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_text || 'ÊñáÂ≠ó'}</span><span class="export-info-value">${textDisplay}</span></div>
                        <div class="export-info-item export-info-full"><span class="export-info-label">${t.popup_svg_icon || 'SVG„Ç¢„Ç§„Ç≥„É≥'}</span><span class="export-info-value">${svgInfo}</span></div>
                    `;
                }
                
                infoEl.innerHTML = infoHTML;
                
                // „Ç®„ÇØ„Çπ„Éù„Éº„Éà„Çø„Ç§„Éó„Å´Âøú„Åò„Å¶F1„Ç∏„É£„É≥„ÉóURL„ÇíÂãïÁöÑ„Å´Ë®≠ÂÆö
                const wikiHint = overlay.querySelector('.wiki-hint');
                if (wikiHint) {
                    const exportHelpUrls = {
                        'single': {
                            ja: 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=1.%20%E9%80%9A%E5%B8%B8%E3%82%A8%E3%82%AF%E3%82%B9%E3%83%9D%E3%83%BC%E3%83%88%20(Standard%20Export)',
                            en: 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%C2%B6-,1.%20Standard%20Export,-Preview%3A%203D'
                        },
                        'tolerance': {
                            ja: 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=2.%20%E3%82%B9%E3%83%86%E3%83%A0%E3%83%86%E3%82%B9%E3%83%88%E3%82%AD%E3%83%83%E3%83%88%E7%94%9F%E6%88%90%20(Stem%20Tolerance%20Kit)',
                            en: 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=2.%20Stem%20Tolerance%20Kit'
                        },
                        'batch': {
                            ja: 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=3.%20%E3%83%90%E3%83%83%E3%83%81%E5%87%BA%E5%8A%9B%20(Batch%20Export)',
                            en: 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%C2%B6-,3.%20Batch%20Export,-Filament%20Select%3A'
                        },
                        'sprue': {
                            ja: 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=4.%20%E9%80%9A%E5%B8%B8%E3%82%B9%E3%83%97%E3%83%AB%E3%83%BC%E3%82%AD%E3%83%83%E3%83%88%E7%94%9F%E6%88%90%20(Standard%20Sprue%20Kit)',
                            en: 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=4.%20Standard%20Sprue%20Kit'
                        },
                        'csk': {
                            ja: 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=5.%20CSK%20%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E3%82%B9%E3%83%97%E3%83%AB%E3%82%AD%E3%83%83%E3%83%88%E7%94%9F%E6%88%90%20(Custom%20Sprue%20Kit)',
                            en: 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=5.%20CSK%20(Custom%20Sprue%20Kit)'
                        }
                    };
                    // CSK„Åã„ÇâÂëº„Å≥Âá∫„Åï„Çå„ÅüÂ†¥Âêà„ÅØcsk„ÄÅ„Åù„Çå‰ª•Â§ñ„ÅØoptions.type„Çí‰ΩøÁî®
                    const exportType = options.fromCSK ? 'csk' : (options.type || 'single');
                    const urls = exportHelpUrls[exportType] || exportHelpUrls['single'];
                    wikiHint.setAttribute('data-help-url-ja', urls.ja);
                    wikiHint.setAttribute('data-help-url-en', urls.en);
                }
                
                // Show popup with animation
                overlay.style.display = 'flex';
                requestAnimationFrame(() => {
                    overlay.style.background = 'rgba(0,0,0,0.7)';
                    popup.classList.add('show');
                });
                
                // Cleanup function
                const cleanup = () => {
                    overlay.style.background = 'rgba(0,0,0,0)';
                    popup.classList.remove('show');
                    setTimeout(() => {
                        overlay.style.display = 'none';
                    }, 300);
                    confirmBtn.onclick = null;
                    cancelBtn.onclick = null;
                    formatInputs.forEach(input => {
                        input.removeEventListener('change', updateFormatBadge);
                    });
                    // „Éó„É¨„Éì„É•„Éº„É¨„É≥„ÉÄ„É©„Éº„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
                    if (thumbRenderer) {
                        thumbRenderer.dispose();
                        thumbRenderer = null;
                    }
                };
                
                confirmBtn.onclick = () => {
                    let selectedFormat = options.format || 'STL';
                    if (showFormatSelector) {
                        const selected = document.querySelector('input[name="export-format-select"]:checked');
                        if (selected) {
                            selectedFormat = selected.value.toUpperCase();
                        }
                    }
                    cleanup();
                    resolve({ confirmed: true, format: selectedFormat });
                };
                
                cancelBtn.onclick = () => {
                    cleanup();
                    resolve({ confirmed: false });
                };
                
                // Close on overlay click
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        cleanup();
                        resolve({ confirmed: false });
                    }
                };
            });
        }
        
        // Áµ±Âêà„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Éú„Çø„É≥Ôºà„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÈÅ∏Êäû‰ªò„ÅçÔºâ
        const bExpSingle = document.getElementById('btn-export-single');
        if(bExpSingle) bExpSingle.addEventListener('click', async () => {
            const result = await showExportPopup({ type: 'single', format: '3MF', showFormatSelector: true });
            if (result.confirmed) {
                const format = result.format.toUpperCase();
                if (format === 'STL') {
                    exportSTL('.stl');
                } else if (format === '3MF') {
                    export3MF();
                } else if (format === 'OBJ') {
                    exportOBJ();
                }
            }
        });
        const bExpBody = document.getElementById('btn-export-body');
        if(bExpBody) bExpBody.addEventListener('click', ()=>exportSTL('_body.stl'));
        const bExpText = document.getElementById('btn-export-text');
        if(bExpText) bExpText.addEventListener('click', ()=>exportSTL('_text_svg.stl'));
        
        const STORAGE_KEY = 'keycap_gen_v63_preset';
        document.getElementById('btn-quick-save').addEventListener('click', () => {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            showToast(translations[currentLang].msg_save_ok);
        });
        document.getElementById('btn-quick-load').addEventListener('click', () => {
            const data = localStorage.getItem(STORAGE_KEY);
            if(data) {
                state = JSON.parse(data);
                syncUI();
                updateCustomDropdown();
                requestUpdate();
                commitHistory();
                showToast(translations[currentLang].msg_load_ok);
            } else {
                showToast(translations[currentLang].msg_load_err, true);
            }
        });
        document.getElementById('btn-export-preset').addEventListener('click', () => {
            const blob = new Blob([JSON.stringify(state, null, 2)], {type: "application/json"});
            saveBlob(blob, "keycap_preset.json");
        });
        
        document.getElementById('btn-save-named-preset').addEventListener('click', () => {
            const name = document.getElementById('preset-save-name').value || 'Preset_' + Date.now();
            const presetData = { name: name, data: {...state, svgName: state.svgName || null}, version: 'V64' };
            const blob = new Blob([JSON.stringify(presetData, null, 2)], {type: "application/json"});
            saveBlob(blob, `${name}.json`);
            showToast(translations[currentLang].msg_save_ok);
        });
        
        document.getElementById('btn-share-url').addEventListener('click', () => {
            try {
                const diffState = {};
                for(const key in state) {
                    if(JSON.stringify(state[key]) !== JSON.stringify(initialState[key])) {
                        diffState[key] = state[key];
                    }
                }
                const json = JSON.stringify(diffState);
                const compressed = LZString.compressToEncodedURIComponent(json);
                const url = window.location.origin + window.location.pathname + '?s=' + compressed;
                
                if(url.length > 8000) {
                    showToast('URL„ÅåÈï∑„Åô„Åé„Åæ„Åô„ÄÇË®≠ÂÆö„ÇíÊ∏õ„Çâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', true);
                    return;
                }
                
                navigator.clipboard.writeText(url).then(() => {
                    showToast(translations[currentLang].msg_url_copied || 'URL„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ');
                });
            } catch(e) {
                console.error('URL share error:', e);
                showToast('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü', true);
            }
        });
        
        document.getElementById('btn-share-x').addEventListener('click', () => {
            try {
                const diffState = {};
                for(const key in state) {
                    if(JSON.stringify(state[key]) !== JSON.stringify(initialState[key])) {
                        diffState[key] = state[key];
                    }
                }
                const json = JSON.stringify(diffState);
                const compressed = LZString.compressToEncodedURIComponent(json);
                const shareUrl = window.location.origin + window.location.pathname + '?s=' + compressed;
                
                if(shareUrl.length > 8000) {
                    showToast('URL„ÅåÈï∑„Åô„Åé„Åæ„Åô„ÄÇË®≠ÂÆö„ÇíÊ∏õ„Çâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', true);
                    return;
                }
                
                const profileNames = { cherry: 'CHERRY', oem: 'OEM', sa: 'SA', xda: 'XDA', dsa: 'DSA', custom: 'CUSTOM' };
                const shapeNames = { rectangle: 'rectangle', rounded: 'rounded', circle: 'circle', polygon: 'polygon', star: 'star', 'iso-enter': 'iso-enter' };
                
                const profileDisplay = profileNames[state.profile] || state.profile.toUpperCase();
                const shapeDisplay = shapeNames[state.keyShapeType] || state.keyShapeType;
                const rowDisplay = state.row;
                
                let tweetText;
                if(currentLang === 'en') {
                    tweetText = `I generated my own keycap in 3D! ‚å®Ô∏è‚ú®
üîπProfile: ${profileDisplay} üîπShape: ${shapeDisplay} üîπRow: ${rowDisplay}
3D modeling tool that runs in your browser üëá
${shareUrl}
#KCGN #CustomKeyboard #3DPrinting`;
                } else {
                    tweetText = `Ëá™ÂàÜ„Å†„Åë„ÅÆ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Çí3DÁîüÊàê„Åó„Åæ„Åó„Åü!‚å®Ô∏è‚ú®
üîπProfile: ${profileDisplay} üîπShape: ${shapeDisplay} üîπRow: ${rowDisplay}
„Éñ„É©„Ç¶„Ç∂„ÅßÂãï„Åè3D„É¢„Éá„É™„É≥„Ç∞„ÉÑ„Éº„É´ üëá
${shareUrl}
#KCGN #Ëá™‰Ωú„Ç≠„Éº„Éú„Éº„Éâ #3D„Éó„É™„É≥„Çø„Éº`;
                }
                
                const xUrl = 'https://twitter.com/intent/tweet?text=' + encodeURIComponent(tweetText);
                window.open(xUrl, '_blank', 'width=550,height=420');
                showToast(translations[currentLang].msg_x_shared || 'X(Twitter)„ÅÆÊäïÁ®øÁîªÈù¢„ÇíÈñã„Åç„Åæ„Åó„Åü');
            } catch(e) {
                console.error('X share error:', e);
                showToast('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü', true);
            }
        });
        
        document.getElementById('btn-import-url').addEventListener('click', () => {
            const input = document.getElementById('url-import-input');
            const urlStr = input.value.trim();
            if(!urlStr) return;
            
            try {
                const urls = urlStr.split(/[\n\r]+/).filter(u => u.trim());
                let loaded = 0;
                
                urls.forEach((u, idx) => {
                    const url = new URL(u.trim());
                    const encoded = url.searchParams.get('s');
                    if(encoded) {
                        const json = LZString.decompressFromEncodedURIComponent(encoded);
                        const data = JSON.parse(json);
                        
                        const presetName = 'URL_' + (Date.now() + idx);
                        loadedPresets.push({ name: presetName, data: {...initialState, ...data}, version: 'V64' });
                        loaded++;
                    }
                });
                
                if(loaded > 0) {
                    currentPresetIndex = loadedPresets.length - 1;
                    updatePresetFloatPanel();
                    updatePresetSwitcher();
                    applyPresetByIndex(currentPresetIndex);
                    showToast((translations[currentLang].msg_url_loaded || 'URL„Åã„ÇâË™≠„ÅøËæº„Åø„Åæ„Åó„Åü') + ` (${loaded}‰ª∂)`);
                    input.value = '';
                } else {
                    showToast(translations[currentLang].msg_url_invalid || 'ÁÑ°Âäπ„Å™URL„Åß„Åô', true);
                }
            } catch(e) {
                console.error('URL import error:', e);
                showToast(translations[currentLang].msg_url_invalid || 'ÁÑ°Âäπ„Å™URL„Åß„Åô', true);
            }
        });
        
        function loadFromURLParams() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const encoded = urlParams.get('s');
                if(encoded) {
                    const json = LZString.decompressFromEncodedURIComponent(encoded);
                    const data = JSON.parse(json);
                    Object.assign(state, data);
                    syncUI();
                    updateCustomDropdown();
                    requestUpdate();
                    commitHistory();
                    showToast('URL„Åã„Çâ„Éó„É™„Çª„ÉÉ„Éà„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü');
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            } catch(e) {
                console.error('Auto URL load error:', e);
            }
        }
        setTimeout(loadFromURLParams, 500);
        
        document.getElementById('btn-show-presets').addEventListener('click', () => {
            const dropdown = document.getElementById('preset-dropdown');
            dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
        });
        
        document.getElementById('btn-remove-preset').addEventListener('click', removeCurrentPreset);
        document.getElementById('btn-remove-preset-ui').addEventListener('click', removeCurrentPreset);
        
        function removeCurrentPreset() {
            if(loadedPresets.length === 0 || currentPresetIndex < 0) return;
            loadedPresets.splice(currentPresetIndex, 1);
            if(loadedPresets.length === 0) {
                currentPresetIndex = -1;
            } else if(currentPresetIndex >= loadedPresets.length) {
                currentPresetIndex = loadedPresets.length - 1;
            }
            updatePresetFloatPanel();
            updatePresetSwitcher();
            if(currentPresetIndex >= 0) {
                applyPresetByIndex(currentPresetIndex);
            }
            showToast('„Éó„É™„Çª„ÉÉ„Éà„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü');
        }
        
        document.getElementById('btn-clear-all-presets').addEventListener('click', () => {
            if(loadedPresets.length === 0) return;
            if(confirm('„Åô„Åπ„Å¶„ÅÆ„Éó„É™„Çª„ÉÉ„Éà„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åô„ÅãÔºü')) {
                loadedPresets = [];
                currentPresetIndex = -1;
                updatePresetFloatPanel();
                updatePresetSwitcher();
                showToast('„Åô„Åπ„Å¶„ÅÆ„Éó„É™„Çª„ÉÉ„Éà„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åó„Åü');
            }
        });
        
        document.getElementById('btn-prev-preset').addEventListener('click', () => {
            if(loadedPresets.length > 0 && currentPresetIndex > 0) {
                currentPresetIndex--;
                applyPresetByIndex(currentPresetIndex);
            }
        });
        
        document.getElementById('btn-next-preset').addEventListener('click', () => {
            if(loadedPresets.length > 0 && currentPresetIndex < loadedPresets.length - 1) {
                currentPresetIndex++;
                applyPresetByIndex(currentPresetIndex);
            }
        });
        
        function applyPresetByIndex(idx) {
            if(idx < 0 || idx >= loadedPresets.length) return;
            Object.assign(state, loadedPresets[idx].data);
            syncUI();
            updateCustomDropdown();
            requestUpdate();
            commitHistory();
            document.getElementById('preset-switcher-float').value = idx;
            updatePresetFloatPreview(idx);
            const uiSwitcher = document.getElementById('preset-switcher');
            if(uiSwitcher) uiSwitcher.value = idx;
            updatePresetPreview(idx);
        }
        
        document.getElementById('preset-file-input').addEventListener('change', async (e) => {
            const files = e.target.files;
            if(!files || files.length === 0) return;
            
            let addedCount = 0;
            
            for(const file of files) {
                try {
                    const text = await file.text();
                    const json = JSON.parse(text);
                    
                    if(json.data && json.name) {
                        loadedPresets.push({ name: json.name, data: json.data });
                    } else {
                        loadedPresets.push({ name: file.name.replace('.json',''), data: json });
                    }
                    addedCount++;
                } catch(err) {
                    console.warn('Failed to load preset:', file.name, err);
                }
            }
            
            if(addedCount > 0) {
                if(currentPresetIndex < 0) {
                    currentPresetIndex = 0;
                    Object.assign(state, loadedPresets[0].data);
                    syncUI();
                    updateCustomDropdown();
                    requestUpdate();
                    commitHistory();
                }
                updatePresetFloatPanel();
                updatePresetSwitcher();
                showToast(addedCount + 'ÂÄã„ÅÆ„Éó„É™„Çª„ÉÉ„Éà„ÇíËøΩÂä†„Åó„Åæ„Åó„ÅüÔºàÂêàË®à: ' + loadedPresets.length + 'Ôºâ');
            } else {
                showToast(translations[currentLang].msg_import_err, true);
            }
            
            e.target.value = '';
        });
        
        document.getElementById('preset-switcher-float').addEventListener('change', (e) => {
            const idx = parseInt(e.target.value);
            if(idx >= 0 && idx < loadedPresets.length) {
                currentPresetIndex = idx;
                applyPresetByIndex(idx);
            }
        });
        
        function updatePresetFloatPanel() {
            const switcher = document.getElementById('preset-switcher-float');
            const btn = document.getElementById('btn-show-presets');
            const countSpan = document.getElementById('preset-count');
            switcher.innerHTML = '';
            
            if(loadedPresets.length === 0) {
                btn.style.display = 'none';
                document.getElementById('preset-dropdown').style.display = 'none';
                return;
            }
            
            btn.style.display = 'block';
            countSpan.textContent = loadedPresets.length;
            
            loadedPresets.forEach((preset, idx) => {
                const opt = document.createElement('option');
                opt.value = idx;
                opt.textContent = (idx + 1) + '. ' + (preset.name || `Preset ${idx + 1}`);
                switcher.appendChild(opt);
            });
            
            if(currentPresetIndex >= 0 && currentPresetIndex < loadedPresets.length) {
                switcher.value = currentPresetIndex;
                updatePresetFloatPreview(currentPresetIndex);
            }
        }
        
        function updatePresetFloatPreview(idx) {
            if(idx < 0 || idx >= loadedPresets.length) return;
            const preset = loadedPresets[idx].data;
            const shapeNames = {
                'rectangle': 'ÂõõËßíÂΩ¢', 'rounded': 'Ëßí‰∏∏', 'circle': 'ÂÜÜÂΩ¢',
                'polygon': 'Â§öËßíÂΩ¢', 'star': 'ÊòüÂΩ¢', 'iso-enter': 'ISO Enter'
            };
            document.getElementById('pf-profile').textContent = preset.profile || 'cherry';
            document.getElementById('pf-size').textContent = (preset.uSize || 1) + 'U';
            document.getElementById('pf-shape').textContent = shapeNames[preset.keyShapeType] || 'ÂõõËßíÂΩ¢';
            document.getElementById('pf-text').textContent = preset.text || '-';
        }
        
        document.getElementById('preset-switcher').addEventListener('change', (e) => {
            const idx = parseInt(e.target.value);
            if(idx >= 0 && idx < loadedPresets.length) {
                currentPresetIndex = idx;
                applyPresetByIndex(idx);
            }
        });
        
        function updatePresetSwitcher() {
            const switcher = document.getElementById('preset-switcher');
            const panel = document.getElementById('preset-switch-panel');
            switcher.innerHTML = '';
            
            if(loadedPresets.length === 0) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            loadedPresets.forEach((preset, idx) => {
                const opt = document.createElement('option');
                opt.value = idx;
                opt.textContent = (idx + 1) + '. ' + (preset.name || `Preset ${idx + 1}`);
                switcher.appendChild(opt);
            });
            
            if(currentPresetIndex >= 0 && currentPresetIndex < loadedPresets.length) {
                switcher.value = currentPresetIndex;
                updatePresetPreview(currentPresetIndex);
            }
        }
        
        function updatePresetPreview(idx) {
            const preview = document.getElementById('preset-preview-mini');
            if(idx < 0 || idx >= loadedPresets.length) {
                const els = ['pm-profile', 'pm-size', 'pm-shape', 'pm-text', 'pm-text2', 'pm-side', 'pm-svg'];
                els.forEach(id => { const el = document.getElementById(id); if(el) el.textContent = '-'; });
                return;
            }
            const preset = loadedPresets[idx].data;
            
            const pmProfile = document.getElementById('pm-profile');
            if(pmProfile) pmProfile.textContent = preset.profile || 'cherry';
            
            const pmSize = document.getElementById('pm-size');
            if(pmSize) pmSize.textContent = (preset.uSize || 1) + 'U';
            
            const pmShape = document.getElementById('pm-shape');
            if(pmShape) pmShape.textContent = preset.keyShapeType || 'rectangle';
            
            const pmText = document.getElementById('pm-text');
            if(pmText) {
                if(preset.enableText === false) {
                    pmText.textContent = 'N/A';
                } else {
                    pmText.textContent = preset.text || '-';
                }
            }
            
            const pmText2 = document.getElementById('pm-text2');
            if(pmText2) {
                if(preset.enableText2 === false) {
                    pmText2.textContent = 'N/A';
                } else {
                    pmText2.textContent = preset.text2 || '-';
                }
            }
            
            const pmSide = document.getElementById('pm-side');
            if(pmSide) {
                if(preset.enableSide === false) {
                    pmSide.textContent = 'N/A';
                } else {
                    pmSide.textContent = preset.sideText || '-';
                }
            }
            
            const pmSvg = document.getElementById('pm-svg');
            if(pmSvg) {
                if(preset.svgVisible === false || !preset.svgContent) {
                    pmSvg.textContent = 'N/A';
                } else {
                    pmSvg.textContent = preset.svgName || 'Loaded';
                }
            }
            
            updateFloatPreview(preset);
        }
        
        function updateFloatPreview(preset) {
            const pfProfile = document.getElementById('pf-profile');
            const pfSize = document.getElementById('pf-size');
            const pfShape = document.getElementById('pf-shape');
            const pfText = document.getElementById('pf-text');
            const pfText2 = document.getElementById('pf-text2');
            const pfSide = document.getElementById('pf-side');
            const pfSvg = document.getElementById('pf-svg');
            
            if(pfProfile) pfProfile.textContent = preset.profile || 'cherry';
            if(pfSize) pfSize.textContent = (preset.uSize || 1) + 'U';
            if(pfShape) pfShape.textContent = preset.keyShapeType || 'rectangle';
            if(pfText) {
                if(preset.enableText === false) {
                    pfText.textContent = 'N/A';
                } else {
                    pfText.textContent = preset.text || '-';
                }
            }
            if(pfText2) {
                if(preset.enableText2 === false) {
                    pfText2.textContent = 'N/A';
                } else {
                    pfText2.textContent = preset.text2 || '-';
                }
            }
            if(pfSide) {
                if(preset.enableSide === false) {
                    pfSide.textContent = 'N/A';
                } else {
                    pfSide.textContent = preset.sideText || '-';
                }
            }
            if(pfSvg) {
                if(preset.svgVisible === false || !preset.svgContent) {
                    pfSvg.textContent = 'N/A';
                } else {
                    pfSvg.textContent = preset.svgName || 'Loaded';
                }
            }
        }
        
        async function runBatchExport() {
            const t = translations[currentLang];
            const raw = document.getElementById('batch-list').value;
            const list = raw.split(/[\n,]+/).map(s => s.trim()).filter(s => s);
            if(list.length === 0) { showToast(t.msg_batch_empty, true); return; }
            
            // Á¢∫Ë™çÁîªÈù¢„ÅßÈÅ∏Êäû„Åï„Çå„Åü„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Çí‰ΩøÁî®
            const format = window.batchExportFormat || 'stl';
            
            const originalText = state.text;
            const loading = document.getElementById('loading');
            const progress = document.getElementById('batch-progress');
            loading.style.display = 'flex';
            progress.style.display = 'block';
            
            const baseName = document.getElementById('export-name').value || 'keycap';
            
            try {
                for(let i=0; i<list.length; i++) {
                    const char = list[i];
                    progress.textContent = `${t.batch_processing} ${char} (${i+1}/${list.length})`;
                    state.text = char;
                    
                    await new Promise(r => setTimeout(r, 100));
                    
                    const { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
                    const safeChar = char.replace(/[\\/:*?"<>|]/g, '_');
                    
                    if (format === 'stl') {
                        const clone = new THREE.Group();
                        if (bodyGeo) clone.add(new THREE.Mesh(bodyGeo, new THREE.MeshBasicMaterial()));
                        if (textGeo) clone.add(new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial()));
                        if (importedGeo) clone.add(new THREE.Mesh(importedGeo, new THREE.MeshBasicMaterial()));
                        
                        const stlData = new STLExporter().parse(clone, {binary:true});
                        const fileName = `${baseName}_[${safeChar}].stl`;
                        saveBlob(new Blob([stlData], {type:'application/octet-stream'}), fileName);
                    } else if (format === '3mf') {
                        const fileData = await generate3MFData(bodyGeo, textGeo, importedGeo);
                        const fileName = `${baseName}_[${safeChar}].3mf`;
                        saveBlob(fileData, fileName);
                    } else if (format === 'obj') {
                        const clone = new THREE.Group();
                        if (bodyGeo) {
                            const mesh = new THREE.Mesh(bodyGeo, new THREE.MeshBasicMaterial({ color: state.colBody }));
                            mesh.name = "KeycapBody";
                            clone.add(mesh);
                        }
                        if (textGeo) {
                            const mesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial({ color: state.colText }));
                            mesh.name = "KeycapText";
                            clone.add(mesh);
                        }
                        if (importedGeo) {
                            const mesh = new THREE.Mesh(importedGeo, new THREE.MeshBasicMaterial({ color: state.colText }));
                            mesh.name = "ImportedModel";
                            clone.add(mesh);
                        }
                        
                        const objData = new OBJExporter().parse(clone);
                        const fileName = `${baseName}_[${safeChar}].obj`;
                        saveBlob(new Blob([objData], {type:'text/plain'}), fileName);
                    }
                    
                    await new Promise(r => setTimeout(r, 300));
                }
                
                progress.textContent = t.batch_complete;
                await new Promise(r => setTimeout(r, 1000));
            } finally {
                state.text = originalText;
                syncUI();
                requestUpdate();
                loading.style.display = 'none';
                progress.style.display = 'none';
            }
        }
        
        async function generate3MFData(bodyGeo, textGeo, importedGeo) {
            const zip = new JSZip();
            
            function geoTo3MFMesh(geometry) {
                if (!geometry) return null;
                let geo = geometry.clone();
                if (!geo.index) {
                    geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
                }
                const position = geo.attributes.position;
                if (!position) return null;
                
                const vertices = [];
                const triangles = [];
                const index = geo.index;
                
                if (index && index.array) {
                    for (let i = 0; i < position.count; i++) {
                        vertices.push(`      <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                    }
                    const indexArray = index.array;
                    for (let i = 0; i < indexArray.length; i += 3) {
                        triangles.push(`      <triangle v1="${indexArray[i]}" v2="${indexArray[i+1]}" v3="${indexArray[i+2]}" />`);
                    }
                } else {
                    for (let i = 0; i < position.count; i++) {
                        vertices.push(`      <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                    }
                    for (let i = 0; i < position.count; i += 3) {
                        triangles.push(`      <triangle v1="${i}" v2="${i+1}" v3="${i+2}" />`);
                    }
                }
                return { vertices, triangles };
            }
            
            let modelXml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02" xmlns:m="http://schemas.microsoft.com/3dmanufacturing/material/2015/02">
  <metadata name="Application">Keycap Generator V64.0</metadata>
  <resources>
    <m:basematerials id="1">
      <m:base name="Body" displaycolor="#${state.colBody.slice(1).toUpperCase()}" />
      <m:base name="Text" displaycolor="#${state.colText.slice(1).toUpperCase()}" />
    </m:basematerials>`;
            
            let objectId = 2;
            let buildItems = '';
            
            if (bodyGeo) {
                const mesh = geoTo3MFMesh(bodyGeo);
                if (mesh) {
                    modelXml += `
    <object id="${objectId}" name="KeycapBody" type="model">
      <mesh>
        <vertices>
${mesh.vertices.join('\n')}
        </vertices>
        <triangles>
${mesh.triangles.map(t => t.replace('/>', ' pid="1" p1="0" />')).join('\n')}
        </triangles>
      </mesh>
    </object>`;
                    buildItems += `    <item objectid="${objectId}" />`;
                    objectId++;
                }
            }
            
            let combinedTextGeo = textGeo;
            if (importedGeo) {
                if (combinedTextGeo) {
                    combinedTextGeo = BufferGeometryUtils.mergeGeometries([combinedTextGeo, importedGeo]);
                    combinedTextGeo = BufferGeometryUtils.mergeVertices(combinedTextGeo, 0.0001);
                } else {
                    combinedTextGeo = importedGeo;
                }
            }
            
            if (combinedTextGeo) {
                const mesh = geoTo3MFMesh(combinedTextGeo);
                if (mesh) {
                    modelXml += `
    <object id="${objectId}" name="KeycapText" type="model">
      <mesh>
        <vertices>
${mesh.vertices.join('\n')}
        </vertices>
        <triangles>
${mesh.triangles.map(t => t.replace('/>', ' pid="1" p1="1" />')).join('\n')}
        </triangles>
      </mesh>
    </object>`;
                    buildItems += `\n    <item objectid="${objectId}" />`;
                }
            }
            
            modelXml += `
  </resources>
  <build>
${buildItems}
  </build>
</model>`;

            const contentTypes = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />
</Types>`;

            const rels = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>`;

            zip.file("[Content_Types].xml", contentTypes);
            zip.folder("_rels").file(".rels", rels);
            zip.folder("3D").file("3dmodel.model", modelXml);
            
            return await zip.generateAsync({ type: "blob", compression: "DEFLATE" });
        }
        
        document.getElementById('btn-batch-export').addEventListener('click', async () => {
            const raw = document.getElementById('batch-list').value;
            const list = raw.split(/[\n,]+/).map(s => s.trim()).filter(s => s);
            if(list.length === 0) { 
                showToast(translations[currentLang].msg_batch_empty, true); 
                return; 
            }
            const charListDisplay = list.length > 10 ? list.slice(0, 10).join(', ') + '...' : list.join(', ');
            
            const result = await showExportPopup({ 
                type: 'batch', 
                format: '3MF',
                showFormatSelector: true,
                fileCount: list.length,
                charList: charListDisplay
            });
            if (result.confirmed) {
                // ÈÅ∏Êäû„Åï„Çå„Åü„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Åß„Éê„ÉÉ„ÉÅ„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÂÆüË°å
                window.batchExportFormat = result.format.toLowerCase();
                runBatchExport();
            }
        });
        
        const pSel = document.getElementById('profile-select');
        if(pSel) pSel.addEventListener('change', e => {
            const defs = {cherry:4.3, oem:5.0, sa:6.0, xda:2.5, dsa:2.5};
            if(defs[e.target.value]) {
                state.ribShorten = defs[e.target.value];
                document.getElementById('rib-shorten').value = state.ribShorten;
                document.getElementById('v-rib-shorten').textContent = state.ribShorten.toFixed(2);
                requestUpdate();
            }
        });
        
        const fStart = document.getElementById('force-start-btn');
        if(fStart) fStart.addEventListener('click', ()=>{
            document.getElementById('loading').style.display='none';
            requestUpdate();
        });
        
        (function initTooltipHints() {
            const tooltip = document.createElement('div');
            tooltip.className = 'hint-tooltip';
            tooltip.id = 'hint-tooltip';
            tooltip.innerHTML = `
                <div class="hint-video-area">
                    <div class="hint-video-placeholder">
                        <span>üìπ „ÉÜ„Çπ„ÉàÁîªÈù¢ / Test Video</span>
                    </div>
                </div>
                <span class="hint-text"></span>
                <div class="hint-f1-notice"><span class="kbd">F1</span> Wiki„ÅßË©≥„Åó„ÅèË¶ã„Çã</div>
            `;
            document.body.appendChild(tooltip);
            
            let hintEnabled = true;
            let hideTimeout = null;
            let videoDelayTimeout = null;
            let currentHintKey = null;
            const VIDEO_DELAY = 1500;
            
            const hintVideos = {
                hint_unit_size: { type: 'video', src: 'videos/Âü∫Êú¨„Éî„ÉÉ„ÉÅ.mp4' },
                hint_key_size: { type: 'video', src: 'videos/„Ç≠„Éº„Çµ„Ç§„Ç∫.mp4' },
                hint_stabilizer: { type: 'video', src: 'videos/„Çπ„Çø„Éì„É©„Ç§„Ç∂„Éº.mp4' },
                hint_profile: { type: 'video', src: 'videos/„Éó„É≠„Éï„Ç°„Ç§„É´.mp4' },
                hint_row: { type: 'video', src: 'videos/Ë°å.mp4' },
                hint_fillet: { type: 'video', src: 'videos/„Éï„Ç£„É¨„ÉÉ„Éà.mp4' },
                hint_wall_thick: { type: 'video', src: 'videos/Â£Å„ÅÆÂéö„Åø.mp4' },
                hint_rib_shorten: { type: 'video', src: 'videos/„É™„ÉñÁü≠Á∏Æ.mp4' },
                hint_enable_ribs: { type: 'video', src: 'videos/Ë£úÂº∑„É™„Éñ.mp4' },
                hint_homing_bump: { type: 'video', src: 'videos/„Éõ„Éº„É†„Éù„Ç∏„Ç∑„Éß„É≥Á™ÅËµ∑.mp4' },
                hint_bump_type: { type: 'video', src: 'videos/„Éõ„Éº„É†„Éù„Ç∏„Ç∑„Éß„É≥Á™ÅËµ∑ÈÅ∏Êäû.mp4' },
                hint_key_shape: { type: 'video', src: 'videos/„Ç≠„ÉºÂΩ¢Áä∂„Çø„Ç§„Éó.mp4' },
                hint_taper: { type: 'video', src: 'videos/‰∏äÈù¢„Çµ„Ç§„Ç∫.mp4' },
                hint_dish_type: { type: 'video', src: 'videos/‰∏äÈù¢ÂΩ¢Áä∂.mp4' },
                hint_texture: { type: 'video', src: 'videos/Ë°®Èù¢„Éó„É≠„Ç∑„Éº„Ç∏„É£„É´.mp4' },
                hint_img_upload: { type: 'video', src: 'videos/ÁîªÂÉè„ÉÜ„ÇØ„Çπ„ÉÅ„É£.mp4' },
                hint_stem_diameter: { type: 'video', src: 'videos/„Çπ„ÉÜ„É†Â§ñÂæÑ.mp4' },
                hint_clearance: { type: 'video', src: 'videos/„ÇØ„É™„Ç¢„É©„É≥„Çπ.mp4' },
                hint_stem_ext: { type: 'video', src: 'videos/Èï∑„Åï„ÇíÊã°Âºµ.mp4' },
                hint_box_stem: { type: 'video', src: 'videos/boxstem.mp4' },
                hint_lego_stud: { type: 'video', src: 'videos/„É¨„Ç¥„Çπ„Çø„ÉÉ„Éâ.mp4' },
                hint_randomizer: { type: 'video', src: 'videos/„É©„É≥„ÉÄ„Éû„Ç§„Ç∂.mp4' },
                hint_import_stl: { type: 'video', src: 'videos/stlË™≠„ÅøËæº„Åø.mp4' },
                hint_enable_text: { type: 'video', src: 'videos/ÊñáÂ≠ó„ÇíÁîüÊàê„Åô„Çã.mp4' },
                hint_text_input: { type: 'video', src: 'videos/ÊñáÂ≠ó„ÉÜ„Ç≠„Çπ„Éà„Éú„ÉÉ„ÇØ„Çπ.mp4' },
                hint_font: { type: 'video', src: 'videos/„Éï„Ç©„É≥„Éà.mp4' },
                hint_custom_font: { type: 'video', src: 'videos/„Ç´„Çπ„Çø„É†„Éï„Ç©„É≥„Éà.mp4' },
                hint_text_mode: { type: 'video', src: 'videos/ÊñáÂ≠óÁîüÊàê„É¢„Éº„Éâ.mp4' },
                hint_align_preset: { type: 'video', src: 'videos/ÊñáÂ≠óÈÖçÁΩÆ„Éó„É™„Çª„ÉÉ„Éà„Éú„Çø„É≥.mp4' },
                hint_text2: { type: 'video', src: 'videos/„Çµ„ÉñÊñáÂ≠ó„Çπ„Ç§„ÉÉ„ÉÅ.mp4' },
                hint_side_print: { type: 'video', src: 'videos/„Çµ„Ç§„ÉâÂç∞Â≠ó„Çπ„Ç§„ÉÉ„ÉÅ.mp4' },
                hint_svg_upload: { type: 'video', src: 'videos/SVGË™≠„ÅøËæº„Åø.mp4' },
                hint_svg_mode: { type: 'video', src: 'videos/ÊñáÂ≠óÁîüÊàê„É¢„Éº„Éâ.mp4' },
                hint_colors: { type: 'video', src: 'videos/Ëâ≤Ë®≠ÂÆö.mp4' },
                hint_import_json: { type: 'video', src: 'videos/„Éó„É™„Çª„ÉÉ„ÉàË™≠„ÅøËæº„Åø.mp4' },
                // V66 Video Hints
                hint_dimension_lines: { type: 'video', src: 'videos/ÂØ∏Ê≥ïÁ∑ö„ÇíË°®Á§∫.mp4' },
                hint_stock_icons: { type: 'video', src: 'videos/ÂÜÖËîµ„Ç¢„Ç§„Ç≥„É≥SVG.mp4' },
                hint_simple_icon: { type: 'video', src: 'videos/ÂÜÖËîµ„Ç¢„Ç§„Ç≥„É≥SVG.mp4' },
                hint_visual_presets: { type: 'video', src: 'videos/„Éì„Ç∏„É•„Ç¢„É´„Éó„É™„Çª„ÉÉ„Éà.mp4' },
                hint_simple_key_size: { type: 'video', src: 'videos/Á∞°Âçò„É¢„Éº„Éâ„Ç≠„ÉºÂπÖ.mp4' },
                // V67 Video Hints
                hint_gumball: { type: 'video', src: 'videos/„Ç¨„É†„Éú„Éº„É´.mp4' },
                hint_stem_type: { type: 'video', src: 'videos/Ëª∏„Çø„Ç§„Éó.mp4' },
                hint_click_place: { type: 'video', src: 'videos/Áõ¥ÊÑüÈÖçÁΩÆ.mp4' }
            };
            
            const enableHintsCheckbox = document.getElementById('enable-hints');
            if(enableHintsCheckbox) {
                enableHintsCheckbox.addEventListener('change', (e) => {
                    hintEnabled = e.target.checked;
                    if(!hintEnabled) {
                        tooltip.classList.remove('visible', 'show-video');
                        currentHintKey = null;
                    }
                });
            }
            
            function showTooltip(el, e) {
                if(!hintEnabled) return;
                
                const hintKey = el.getAttribute('data-hint');
                if(!hintKey) return;
                
                const t = translations[currentLang];
                const hintText = t[hintKey];
                if(!hintText) return;
                
                currentHintKey = hintKey;
                
                tooltip.querySelector('.hint-text').textContent = hintText;
                
                const f1Notice = tooltip.querySelector('.hint-f1-notice');
                f1Notice.innerHTML = `<span class="kbd">F1</span> ${t.hint_f1_notice || 'Wiki„ÅßË©≥„Åó„ÅèË¶ã„Çã'}`;
                
                tooltip.classList.remove('show-video');
                clearTimeout(videoDelayTimeout);
                
                const noVideoHints = ['hint_export_stl', 'hint_export_3mf', 'hint_export_parts', 'hint_batch_run', 'hint_url_share', 'hint_quick_save', 'hint_export_json', 'hint_conform', 'hint_simple_mode', 'hint_snapshot', 'hint_gallery_open', 'hint_gallery_save', 'hint_toggle_text', 'hint_toggle_svg'];
                const showVideoForHint = !noVideoHints.includes(hintKey);
                
                const videoArea = tooltip.querySelector('.hint-video-area');
                const videoPlaceholder = tooltip.querySelector('.hint-video-placeholder');
                
                if(showVideoForHint) {
                    if(hintVideos[hintKey]) {
                        const videoData = hintVideos[hintKey];
                        if(videoData.type === 'video') {
                            videoPlaceholder.innerHTML = `<video src="${videoData.src}" autoplay loop muted playsinline></video>`;
                        } else if(videoData.type === 'gif') {
                            videoPlaceholder.innerHTML = `<img src="${videoData.src}" alt="Hint animation">`;
                        }
                    } else {
                        videoPlaceholder.innerHTML = `<span>üìπ „ÉÜ„Çπ„ÉàÁîªÈù¢ / Test Video</span>`;
                    }
                    videoArea.style.display = '';
                    
                    videoDelayTimeout = setTimeout(() => {
                        if(tooltip.classList.contains('visible')) {
                            tooltip.classList.add('show-video');
                        }
                    }, VIDEO_DELAY);
                } else {
                    videoArea.style.display = 'none';
                }
                
                const tooltipWidth = 320;
                const uiPanel = document.getElementById('ui-panel');
                const uiPanelRect = uiPanel ? uiPanel.getBoundingClientRect() : { right: 0 };
                
                let left = (uiPanelRect.right || 500) + 20;
                
                // „ÇÆ„É£„É©„É™„Éº„Éë„Éç„É´„ÅåÂ±ïÈñã„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                const galleryStrip = document.getElementById('gallery-strip');
                const isGalleryOpen = galleryStrip && galleryStrip.classList.contains('show');
                const bottomOffset = isGalleryOpen ? 140 : 20; // „ÇÆ„É£„É©„É™„Éº„ÅÆÈ´ò„Åï(110px) + „Éû„Éº„Ç∏„É≥
                
                tooltip.style.left = left + 'px';
                tooltip.style.top = 'auto';
                tooltip.style.bottom = bottomOffset + 'px';
                tooltip.style.transform = 'translateY(0)';
                tooltip.style.maxWidth = tooltipWidth + 'px';
                
                clearTimeout(hideTimeout);
                tooltip.classList.add('visible');
            }
            
            function hideTooltip() {
                hideTimeout = setTimeout(() => {
                    tooltip.classList.remove('visible', 'show-video');
                    clearTimeout(videoDelayTimeout);
                    currentHintKey = null;
                }, 100);
            }
            
            // „ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó„ÅÆ‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞Ôºà„ÇÆ„É£„É©„É™„ÉºÂ±ïÈñãÊôÇ„Å™„Å©„Å´Âëº„Å≥Âá∫„ÅôÔºâ
            function updateTooltipPosition() {
                if (!tooltip.classList.contains('visible')) return;
                
                const galleryStrip = document.getElementById('gallery-strip');
                const isGalleryOpen = galleryStrip && galleryStrip.classList.contains('show');
                const bottomOffset = isGalleryOpen ? 140 : 20;
                
                tooltip.style.bottom = bottomOffset + 'px';
            }
            
            // „Ç∞„É≠„Éº„Éê„É´„Åã„Çâ„Ç¢„ÇØ„Çª„ÇπÂèØËÉΩ„Å´„Åô„Çã
            window.updateHintTooltipPosition = updateTooltipPosition;
            
            // V67: „Éì„É•„Éº„Ç≠„É•„Éº„Éñ„ÅÆ‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞Ôºà„ÇÆ„É£„É©„É™„ÉºÂ±ïÈñãÊôÇ„Å™„Å©„Å´Âëº„Å≥Âá∫„ÅôÔºâ
            function updateViewCubePosition() {
                const cubeWrapper = document.getElementById('view-cube-wrapper');
                const labelsContainer = document.getElementById('axis-labels-container');
                const galleryStrip = document.getElementById('gallery-strip');
                const isGalleryOpen = galleryStrip && galleryStrip.classList.contains('show');
                
                const bottomPos = isGalleryOpen ? '145px' : '20px';
                
                if (cubeWrapper) {
                    cubeWrapper.style.bottom = bottomPos;
                }
                if (labelsContainer) {
                    labelsContainer.style.bottom = bottomPos;
                }
                
                // „Éò„É´„Éó„Éú„Çø„É≥„ÇÇÁßªÂãï
                const helpBtn = document.getElementById('btn-help');
                if (helpBtn) {
                    helpBtn.style.bottom = isGalleryOpen ? '150px' : '25px';
                }
            }
            
            // „Ç∞„É≠„Éº„Éê„É´„Åã„Çâ„Ç¢„ÇØ„Çª„ÇπÂèØËÉΩ„Å´„Åô„ÇãÔºà‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅ‰∏°Êñπ„ÅÆÂêçÂâç„ÅßÂÖ¨ÈñãÔºâ
            window.updateViewCubePosition = updateViewCubePosition;
            window.updateViewHelperPosition = updateViewCubePosition;
            
            document.addEventListener('keydown', (e) => {
                if(e.key === 'F1' && tooltip.classList.contains('visible') && currentHintKey) {
                    e.preventDefault();
                    
                    // Direct URL mapping for specific hints (V67)
                    const hintDirectUrls = {
                        // HUD buttons
                        hint_gumball: {
                            ja: 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%E3%81%AB%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%81%BE%E3%81%99%E3%80%82-,%E3%82%AC%E3%83%A0%E3%83%9C%E3%83%BC%E3%83%AB%20(Gumball)%3A,-%E6%A9%9F%E8%83%BD%E3%82%92ON',
                            en: 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=Top%22%2C%20%22Isometric%22%2C%20etc.-,Gumball%3A,-Operation%20arrows%20displayed'
                        },
                        hint_snapshot: {
                            ja: 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%E5%90%84%E7%A8%AE%E3%82%B7%E3%83%A7%E3%83%BC%E3%83%88%E3%82%AB%E3%83%83%E3%83%88%E3%83%9C%E3%82%BF%E3%83%B3%3A-,%E3%82%B9%E3%83%8A%E3%83%83%E3%83%97%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%E3%83%9C%E3%82%BF%E3%83%B3,-%3A%20%E3%82%AD%E3%83%BC%E3%82%AD%E3%83%A3%E3%83%83%E3%83%97',
                            en: 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=Shortcut%20Buttons%3A-,Snapshot%20Button,-%3A%20Captures%20a'
                        },
                        hint_toggle_text: {
                            ja: 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%E4%BF%9D%E5%AD%98%E3%81%97%E3%81%BE%E3%81%99%E3%80%82-,%E6%96%87%E5%AD%97%E3%82%92%E8%A1%A8%E7%A4%BA/%E9%9D%9E%E8%A1%A8%E7%A4%BA,-%3A%20%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%81%AE',
                            en: 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=to%20the%20gallery.-,Show/Hide%20Text,-%3A%20Toggles%20text'
                        },
                        hint_toggle_svg: {
                            ja: 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%E3%82%92%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%81%BE%E3%81%99%E3%80%82-,SVG%E3%82%92%E8%A1%A8%E7%A4%BA/%E9%9D%9E%E8%A1%A8%E7%A4%BA,-%3A%20SVG%E3%82%A2%E3%82%A4%E3%82%B3',
                            en: 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=Toggles%20text%20visibility.-,Show/Hide%20SVG,-%3A%20Toggles%20SVG'
                        },
                        hint_gallery_open: {
                            ja: 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%F0%9F%93%82%20%E3%82%AE%E3%83%A3%E3%83%A9%E3%83%AA%E3%83%BC%E6%A9%9F%E8%83%BD%20(Gallery)%20(v67.0%20New)',
                            en: 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%F0%9F%93%82%20Gallery%20Features%20(v67.0%20New)'
                        },
                        hint_gallery_save: {
                            ja: 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%F0%9F%93%82%20%E3%82%AE%E3%83%A3%E3%83%A9%E3%83%AA%E3%83%BC%E6%A9%9F%E8%83%BD%20(Gallery)%20(v67.0%20New)',
                            en: 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%F0%9F%93%82%20Gallery%20Features%20(v67.0%20New)'
                        },
                        // Stem settings
                        hint_stem_type: {
                            ja: 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%C2%B6-,5.%20%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E5%AE%9A%20(Stem),-%E8%BB%B8%E3%82%BF%E3%82%A4%E3%83%97%3A',
                            en: 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%C2%B6-,5.%20Stem%20Settings,-Stem%20Type%3A'
                        },
                        // Interactive placement
                        hint_click_place: {
                            ja: 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%C2%B6-,7.%20%E5%A4%96%E9%83%A8%E3%83%A2%E3%83%87%E3%83%AB%20(Import%203D),-STL%E8%AA%AD%E8%BE%BC',
                            en: 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%C2%B6-,7.%20Import%203D,-Load%20STL%3A'
                        }
                    };
                    
                    // Check for direct URL first
                    if(hintDirectUrls[currentHintKey]) {
                        const url = hintDirectUrls[currentHintKey][currentLang] || hintDirectUrls[currentHintKey].ja;
                        // window.open„Å†„Å®Text Fragment„ÅåÂäπ„Åã„Å™„ÅÑ„Åü„ÇÅa„Çø„Ç∞„Çí‰ΩøÁî®
                        const a = document.createElement('a');
                        a.href = url;
                        a.target = '_blank';
                        a.rel = 'noopener';
                        a.click();
                        return;
                    }
                    
                    // Map hint keys to Wiki sections
                    const hintToSection = {
                        // Basic Size
                        hint_unit_size: 'basic', hint_key_size: 'basic', hint_profile: 'basic', hint_row: 'basic',
                        // Structure (including fillet/round corner)
                        hint_wall_thick: 'structure', hint_rib_shorten: 'structure', hint_enable_ribs: 'structure',
                        hint_homing_bump: 'structure', hint_round_corner: 'structure', hint_stabilizer: 'structure',
                        hint_fillet: 'structure',
                        // Shape
                        hint_key_shape: 'shape', hint_taper: 'shape', hint_dish_type: 'shape', hint_texture: 'shape',
                        // Texture
                        hint_img_upload: 'texture',
                        // Stem
                        hint_clearance: 'stem', hint_stem_diameter: 'stem', hint_stem_ext: 'stem',
                        hint_box_stem: 'stem', hint_lego_stud: 'stem',
                        // Engineering (Tolerance Test & Sprue Kit)
                        hint_tolerance_test: 'engineering', hint_sprue_kit: 'engineering',
                        // Utility (dimension lines, layer color, randomizer)
                        hint_dimension_lines: 'utility', hint_layer_color: 'utility', hint_randomizer: 'utility',
                        // Simple Mode
                        hint_simple_mode: 'simple', hint_simple_key_size: 'simple', hint_simple_icon: 'simple',
                        // Import
                        hint_import_stl: 'import', hint_import_op: 'import',
                        // Text
                        hint_text_input: 'text', hint_enable_text: 'text', hint_font: 'text', hint_custom_font: 'text',
                        hint_text_size: 'text', hint_text_height: 'text', hint_conform: 'text', hint_text_mode: 'text',
                        hint_text2: 'text', hint_side_print: 'text',
                        // SVG (all SVG section features including stock icons)
                        hint_svg_upload: 'svg', hint_stock_icons: 'svg',
                        // Colors
                        hint_colors: 'colors',
                        // Preset (all preset management features including visual presets)
                        hint_preset_save: 'preset', hint_preset_load: 'preset', hint_url_share: 'preset',
                        hint_quick_save: 'preset', hint_export_json: 'preset', hint_visual_presets: 'preset',
                        // Export (all export features including print orientation)
                        hint_export_stl: 'export', hint_export_obj: 'export', hint_export_3mf: 'export',
                        hint_export_parts: 'export', hint_print_orient: 'export',
                        // Batch
                        hint_batch: 'batch', hint_batch_list: 'batch', hint_batch_run: 'batch'
                    };
                    
                    const section = hintToSection[currentHintKey] || '';
                    const anchor = section ? '#' + section : '';
                    
                    const wikiBaseUrl = currentLang === 'en' 
                        ? 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9'
                        : 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9';
                    // a„Çø„Ç∞„ÇØ„É™„ÉÉ„ÇØ„ÅßURL„ÇíÈñã„ÅèÔºàText FragmentÂØæÂøúÔºâ
                    const a = document.createElement('a');
                    a.href = wikiBaseUrl + anchor;
                    a.target = '_blank';
                    a.rel = 'noopener';
                    a.click();
                }
            });
            
            document.querySelectorAll('[data-hint]').forEach(el => {
                el.addEventListener('mouseenter', (e) => showTooltip(el, e));
                el.addEventListener('mouseleave', hideTooltip);
                el.addEventListener('focus', (e) => showTooltip(el, e));
                el.addEventListener('blur', hideTooltip);
            });
        })();
        
        // V66: Simple Mode Initialization
        (function initV66Features() {
            // Helper function to create stem geometry (defined first for hoisting)
            function createStemGeometry(clearance, diameter, stemHeight) {
                const outerRadius = diameter / 2;
                const crossWidth = 4.0 + clearance;
                const crossThick = 1.17 + clearance;
                
                const outerGeo = new THREE.CylinderGeometry(outerRadius, outerRadius, stemHeight, 32);
                const cross1 = new THREE.BoxGeometry(crossWidth, stemHeight + 0.2, crossThick);
                const cross2 = new THREE.BoxGeometry(crossThick, stemHeight + 0.2, crossWidth);
                
                try {
                    const outerBrush = new Brush(outerGeo);
                    const brush1 = new Brush(cross1);
                    const brush2 = new Brush(cross2);
                    
                    let result = csgEvaluator.evaluate(outerBrush, brush1, SUBTRACTION);
                    result = csgEvaluator.evaluate(result, brush2, SUBTRACTION);
                    
                    const finalGeo = result.geometry.clone();
                    finalGeo.translate(0, stemHeight / 2, 0);
                    return finalGeo;
                } catch (e) {
                    console.warn('CSG failed, using simple cylinder:', e);
                    outerGeo.translate(0, stemHeight / 2, 0);
                    return outerGeo;
                }
            }

            // Simple Mode Toggle
            const simpleModeToggle = document.getElementById('enable-simple-mode');
            const simpleModePanel = document.getElementById('simple-mode-panel');
            const normalModeContent = document.getElementById('normal-mode-content');
            const navSelect = document.getElementById('section-select');
            const searchBox = document.getElementById('search-box');

            if (simpleModeToggle) {
                simpleModeToggle.addEventListener('change', (e) => {
                    const isSimple = e.target.checked;
                    if (isSimple) {
                        if (simpleModePanel) simpleModePanel.style.display = 'block';
                        if (normalModeContent) normalModeContent.style.display = 'none';
                        if (navSelect) navSelect.style.display = 'none';
                        if (searchBox) searchBox.style.display = 'none';
                        state.textMode = 'emboss';
                        state.textConform = true;
                        state.enableText = true;
                        state.stemClearance = 0.30;
                        state.stemDiameter = 5.50;
                        state.wallThickness = 1.5;
                        state.enableRibs = true;
                        // Á∞°Âçò„É¢„Éº„Éâ„ÅÆAMS„Éë„É¨„ÉÉ„Éà„ÇíÊõ¥Êñ∞
                        if (typeof updateSettingsTabPalette === 'function') updateSettingsTabPalette();
                        requestUpdate();
                    } else {
                        if (simpleModePanel) simpleModePanel.style.display = 'none';
                        if (normalModeContent) normalModeContent.style.display = 'block';
                        if (navSelect) navSelect.style.display = 'block';
                        if (searchBox) searchBox.style.display = 'block';
                    }
                });
            }

            // Simple Font Selector („Ç´„Çπ„Çø„É†„Éâ„É≠„ÉÉ„Éó„ÉÄ„Ç¶„É≥ with „Éó„É¨„Éì„É•„Éº)
            let simpleCommittedFont = state.font;
            let simpleCustomDropdownInitialized = false;
            
            function setupSimpleCustomDropdown() {
                const head = document.getElementById('simple-custom-font-head');
                const list = document.getElementById('simple-custom-font-list');
                const hiddenSelect = document.getElementById('simple-font-select');
                if (!head || !list || !hiddenSelect) return;
                
                function populate() {
                    list.innerHTML = '';
                    Array.from(hiddenSelect.options).forEach(opt => {
                        if (!loadedFonts[opt.value]) return;
                        const div = document.createElement('div');
                        div.className = 'custom-option';
                        div.textContent = opt.text;
                        if (opt.value === state.font) div.classList.add('selected');
                        
                        div.addEventListener('mouseenter', () => {
                            state.font = opt.value;
                            requestUpdate();
                        });
                        
                        div.addEventListener('click', () => {
                            simpleCommittedFont = opt.value;
                            state.font = simpleCommittedFont;
                            hiddenSelect.value = simpleCommittedFont;
                            list.classList.remove('open');
                            updateSimpleCustomDropdownHead();
                            // ÈÄöÂ∏∏„É¢„Éº„Éâ„ÅÆ„Éï„Ç©„É≥„ÉàÈÅ∏Êäû„ÇÇÂêåÊúü
                            const mainFont = document.getElementById('font-family');
                            if (mainFont) mainFont.value = simpleCommittedFont;
                            if (typeof updateCustomDropdown === 'function') updateCustomDropdown();
                            commitHistory();
                            requestUpdate();
                        });
                        
                        list.appendChild(div);
                    });
                }
                
                if (!simpleCustomDropdownInitialized) {
                    head.addEventListener('click', () => {
                        if (!list.classList.contains('open')) {
                            simpleCommittedFont = state.font;
                            populate();
                            list.classList.add('open');
                        } else {
                            list.classList.remove('open');
                        }
                    });
                    
                    list.addEventListener('mouseleave', () => {
                        state.font = simpleCommittedFont;
                        requestUpdate();
                    });
                    
                    document.addEventListener('click', (e) => {
                        const ui = document.getElementById('simple-custom-font-ui');
                        if (ui && !ui.contains(e.target) && list.classList.contains('open')) {
                            list.classList.remove('open');
                            state.font = simpleCommittedFont;
                            requestUpdate();
                        }
                    });
                    
                    simpleCustomDropdownInitialized = true;
                }
                
                updateSimpleCustomDropdownHead();
            }
            
            function updateSimpleCustomDropdownHead() {
                const hiddenSelect = document.getElementById('simple-font-select');
                const head = document.getElementById('simple-custom-font-head');
                if (hiddenSelect && head) {
                    const opt = hiddenSelect.querySelector(`option[value="${state.font}"]`);
                    if (opt) head.textContent = opt.text + " ‚ñº";
                }
            }
            
            // „Ç∞„É≠„Éº„Éê„É´„Åã„Çâ„Ç¢„ÇØ„Çª„ÇπÂèØËÉΩ„Å´„Åô„Çã
            window.updateSimpleCustomDropdownHead = updateSimpleCustomDropdownHead;
            
            // ÂàùÊúüÂåñ
            setupSimpleCustomDropdown();

            // Key Size Buttons
            const keySizeButtons = document.querySelectorAll('#simple-key-size-buttons .key-size-btn');
            keySizeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    keySizeButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const size = parseFloat(btn.dataset.size);
                    state.uSize = size;
                    const uSizeSlider = document.getElementById('u-size');
                    const vUSize = document.getElementById('v-u-size');
                    if (uSizeSlider) uSizeSlider.value = size;
                    if (vUSize) vUSize.textContent = size.toFixed(2);
                    requestUpdate();
                    commitHistory();
                });
            });

            // Simple Mode Inputs Sync
            const simpleText = document.getElementById('simple-text-content');
            if (simpleText) {
                simpleText.addEventListener('input', (e) => {
                    state.text = e.target.value;
                    const mainText = document.getElementById('text-content');
                    if (mainText) mainText.value = e.target.value;
                    requestUpdate();
                });
            }

            // Simple Mode Enable Text Toggle Sync
            const simpleEnableText = document.getElementById('simple-enable-text');
            const mainEnableText = document.getElementById('enable-text');
            if (simpleEnableText && mainEnableText) {
                simpleEnableText.addEventListener('change', (e) => {
                    state.enableText = e.target.checked;
                    mainEnableText.checked = e.target.checked;
                    requestUpdate();
                });
                mainEnableText.addEventListener('change', (e) => {
                    simpleEnableText.checked = e.target.checked;
                });
            }

            const simpleProfile = document.getElementById('simple-profile-select');
            if (simpleProfile) {
                simpleProfile.addEventListener('change', (e) => {
                    state.profile = e.target.value;
                    const mainProfile = document.getElementById('profile-select');
                    if (mainProfile) mainProfile.value = e.target.value;
                    requestUpdate();
                    commitHistory();
                });
            }

            const simpleRow = document.getElementById('simple-row-select');
            if (simpleRow) {
                simpleRow.addEventListener('change', (e) => {
                    state.row = e.target.value;
                    const mainRow = document.getElementById('row-select');
                    if (mainRow) mainRow.value = e.target.value;
                    requestUpdate();
                    commitHistory();
                });
            }

            // Simple Mode Text Mode Sync (SVG„ÅÆÊúâÁÑ°„Åß„É≠„Ç∏„ÉÉ„ÇØ„ÇíÂàá„ÇäÊõø„Åà)
            const simpleTextMode = document.getElementById('simple-text-mode');
            if (simpleTextMode) {
                simpleTextMode.addEventListener('change', (e) => {
                    const mode = e.target.value;
                    
                    // SVG„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØsvgMode„ÇíÊõ¥Êñ∞„ÄÅ„Å™„ÅÑÂ†¥Âêà„ÅØtextMode„ÇíÊõ¥Êñ∞
                    if (state.svgContent) {
                        state.svgMode = mode;
                        const mainSvgMode = document.getElementById('svg-mode');
                        if (mainSvgMode) mainSvgMode.value = mode;
                        console.log('[SimpleMode] Changed svgMode to:', mode);
                    } else {
                        state.textMode = mode;
                        const mainTextMode = document.getElementById('text-mode');
                        if (mainTextMode) mainTextMode.value = mode;
                        console.log('[SimpleMode] Changed textMode to:', mode);
                    }
                    
                    requestUpdate();
                    commitHistory();
                });
            }

            // Simple Mode Taper (Top Scale) Sync
            const simpleTaper = document.getElementById('simple-taper');
            const simpleTaperVal = document.getElementById('v-simple-taper');
            if (simpleTaper) {
                simpleTaper.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    state.topScale = val;
                    if (simpleTaperVal) simpleTaperVal.textContent = val.toFixed(2);
                    const mainTaper = document.getElementById('top-scale');
                    if (mainTaper) mainTaper.value = val;
                    const mainTaperVal = document.getElementById('v-top-scale');
                    if (mainTaperVal) mainTaperVal.textContent = val.toFixed(2);
                    requestUpdate();
                });
            }

            // Simple Mode Dish Type Sync
            const simpleDish = document.getElementById('simple-dish-type');
            if (simpleDish) {
                simpleDish.addEventListener('change', (e) => {
                    state.dishType = e.target.value;
                    const mainDish = document.getElementById('dish-type');
                    if (mainDish) mainDish.value = e.target.value;
                    requestUpdate();
                    commitHistory();
                });
            }

            // Simple Mode Fillet (Round Corner) Sync
            const simpleFillet = document.getElementById('simple-fillet');
            const simpleFilletVal = document.getElementById('v-simple-fillet');
            if (simpleFillet) {
                simpleFillet.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    state.roundCorner = val;
                    if (simpleFilletVal) simpleFilletVal.textContent = val.toFixed(1);
                    const mainFillet = document.getElementById('round-corner');
                    if (mainFillet) mainFillet.value = val;
                    const mainFilletVal = document.getElementById('v-round-corner');
                    if (mainFilletVal) mainFilletVal.textContent = val.toFixed(1);
                    requestUpdate();
                });
            }

            const simpleColBody = document.getElementById('simple-col-body');
            if (simpleColBody) {
                simpleColBody.addEventListener('input', (e) => {
                    state.colBody = e.target.value;
                    const mainColBody = document.getElementById('col-body');
                    if (mainColBody) mainColBody.value = e.target.value;
                    // „Éï„Ç£„É©„É°„É≥„Éà„É©„Ç§„Éñ„É©„É™„ÅÆÈÅ∏ÊäûÁä∂ÊÖã„ÇíÊõ¥Êñ∞
                    if(typeof window.refreshFilamentPalette === 'function') window.refreshFilamentPalette();
                    updateModel();
                });
            }

            const simpleColText = document.getElementById('simple-col-text');
            if (simpleColText) {
                simpleColText.addEventListener('input', (e) => {
                    state.colText = e.target.value;
                    const mainColText = document.getElementById('col-text');
                    if (mainColText) mainColText.value = e.target.value;
                    updateModel();
                });
            }

            // Simple Export Button
            document.getElementById('btn-simple-export')?.addEventListener('click', () => {
                document.getElementById('btn-export-single')?.click();
            });

            // Dimension Lines Toggle & Update
            const showDimensions = document.getElementById('show-dimensions');
            const dimensionOverlay = document.getElementById('dimension-overlay');
            let dimensionUpdateInterval = null;
            let dimensionHelpers = []; // Store 3D dimension objects
            
            function createDimensionLine(start, end, color, label) {
                const group = new THREE.Group();
                group.name = 'dimensionHelper';
                
                // Main line
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([start, end]);
                const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 2 });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                group.add(line);
                
                // Arrow heads at both ends
                const direction = new THREE.Vector3().subVectors(end, start).normalize();
                const length = start.distanceTo(end);
                const arrowSize = Math.min(1.5, length * 0.15);
                
                // End caps (perpendicular lines)
                const perpDir = new THREE.Vector3();
                if (Math.abs(direction.y) > 0.9) {
                    perpDir.set(1, 0, 0);
                } else if (Math.abs(direction.x) > 0.9) {
                    perpDir.set(0, 1, 0);
                } else {
                    perpDir.set(0, 0, 1);
                }
                
                const capSize = arrowSize * 0.5;
                const cap1Geo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3().addVectors(start, perpDir.clone().multiplyScalar(capSize)),
                    new THREE.Vector3().addVectors(start, perpDir.clone().multiplyScalar(-capSize))
                ]);
                const cap2Geo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3().addVectors(end, perpDir.clone().multiplyScalar(capSize)),
                    new THREE.Vector3().addVectors(end, perpDir.clone().multiplyScalar(-capSize))
                ]);
                group.add(new THREE.Line(cap1Geo, lineMaterial));
                group.add(new THREE.Line(cap2Geo, lineMaterial));
                
                return group;
            }
            
            function clearDimensionHelpers() {
                dimensionHelpers.forEach(helper => {
                    scene.remove(helper);
                    helper.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                });
                dimensionHelpers = [];
            }
            
            function updateDimensions() {
                const isVisible = showDimensions && showDimensions.checked;
                if (!isVisible) {
                    clearDimensionHelpers();
                    return;
                }
                
                // Find mesh in mainGroup (not scene directly)
                const bodyMesh = mainGroup.children.find(c => c.name === 'KeycapBody' && c.geometry);
                if (!bodyMesh || !bodyMesh.geometry) {
                    if (dimensionOverlay) {
                        document.getElementById('dim-width').textContent = '-- mm';
                        document.getElementById('dim-depth').textContent = '-- mm';
                        document.getElementById('dim-height').textContent = '-- mm';
                    }
                    clearDimensionHelpers();
                    return;
                }
                
                bodyMesh.geometry.computeBoundingBox();
                const box = bodyMesh.geometry.boundingBox;
                const width = box.max.x - box.min.x;
                const depth = box.max.z - box.min.z;
                const height = box.max.y - box.min.y;
                
                // Update overlay text
                if (dimensionOverlay) {
                    document.getElementById('dim-width').textContent = width.toFixed(2) + ' mm';
                    document.getElementById('dim-depth').textContent = depth.toFixed(2) + ' mm';
                    document.getElementById('dim-height').textContent = height.toFixed(2) + ' mm';
                }
                
                // Clear old helpers
                clearDimensionHelpers();
                
                // Offset for dimension lines (outside the model)
                const offset = 3;
                
                // Width line (X axis) - front bottom
                const widthLine = createDimensionLine(
                    new THREE.Vector3(box.min.x, box.min.y - offset, box.max.z + offset),
                    new THREE.Vector3(box.max.x, box.min.y - offset, box.max.z + offset),
                    0x2196f3, 'W'
                );
                scene.add(widthLine);
                dimensionHelpers.push(widthLine);
                
                // Depth line (Z axis) - right bottom
                const depthLine = createDimensionLine(
                    new THREE.Vector3(box.max.x + offset, box.min.y - offset, box.min.z),
                    new THREE.Vector3(box.max.x + offset, box.min.y - offset, box.max.z),
                    0x4caf50, 'D'
                );
                scene.add(depthLine);
                dimensionHelpers.push(depthLine);
                
                // Height line (Y axis) - right front
                const heightLine = createDimensionLine(
                    new THREE.Vector3(box.max.x + offset, box.min.y, box.max.z + offset),
                    new THREE.Vector3(box.max.x + offset, box.max.y, box.max.z + offset),
                    0xff9800, 'H'
                );
                scene.add(heightLine);
                dimensionHelpers.push(heightLine);
            }
            
            if (showDimensions && dimensionOverlay) {
                showDimensions.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        dimensionOverlay.style.display = 'block';
                        updateDimensions();
                        dimensionUpdateInterval = setInterval(updateDimensions, 500);
                    } else {
                        dimensionOverlay.style.display = 'none';
                        clearDimensionHelpers();
                        if (dimensionUpdateInterval) clearInterval(dimensionUpdateInterval);
                        dimensionUpdateInterval = null;
                    }
                });
            }

            // Tolerance Test Sliders
            document.getElementById('tol-start')?.addEventListener('input', (e) => {
                const val = document.getElementById('v-tol-start');
                if (val) val.textContent = parseFloat(e.target.value).toFixed(2);
            });

            document.getElementById('tol-step')?.addEventListener('input', (e) => {
                const val = document.getElementById('v-tol-step');
                if (val) val.textContent = parseFloat(e.target.value).toFixed(2);
            });

            // Tolerance Test Kit Generation (Fixed: Matrix update for CSG)
            document.getElementById('btn-gen-tolerance-test')?.addEventListener('click', async () => {
                try {
                    const startVal = parseFloat(document.getElementById('tol-start').value);
                    const stepVal = parseFloat(document.getElementById('tol-step').value);
                    
                    // Show confirmation popup with format selector
                    const result = await showExportPopup({
                        type: 'tolerance',
                        format: '3MF',
                        showFormatSelector: true,
                        startVal: startVal,
                        stepVal: stepVal,
                        count: 5
                    });
                    
                    if (!result.confirmed) return;
                    
                    const format = result.format.toLowerCase();
                    
                    showToast(translations[currentLang].tolerance_generating || '„Çπ„ÉÜ„É†„ÉÜ„Çπ„Éà„Ç≠„ÉÉ„Éà„ÇíÁîüÊàê‰∏≠...');
                    
                    // Use setTimeout to allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 50));
                    
                    const stems = [];
                    const spacing = 12;
                    const stemHeight = 4.0;
                    const stemDiameter = 5.50;
                    const baseHeight = 1.5;
                    const baseSize = 9.0;
                    
                    // Create local CSG evaluator to avoid cache issues
                    const localEvaluator = new Evaluator();
                    
                    for (let i = 0; i < 5; i++) {
                        const clearance = Math.round((startVal + (stepVal * i)) * 100) / 100;
                        const xPos = (i - 2) * spacing;
                        
                        console.log(`Generating Stem ${i + 1}: Clearance = ${clearance}mm`);

                        // 1. Outer cylinder for stem
                        const outerRadius = stemDiameter / 2;
                        const outerGeo = new THREE.CylinderGeometry(outerRadius, outerRadius, stemHeight, 32);
                        outerGeo.computeVertexNormals();
                        
                        // 2. Cross hole boxes with clearance
                        const crossWidth = 4.0 + clearance;
                        const crossThick = 1.17 + clearance;
                        
                        const cross1 = new THREE.BoxGeometry(crossWidth, stemHeight + 0.2, crossThick);
                        cross1.computeVertexNormals();
                        
                        const cross2 = new THREE.BoxGeometry(crossThick, stemHeight + 0.2, crossWidth);
                        cross2.computeVertexNormals();
                        
                        let stemGeo;
                        try {
                            // Create brushes and force matrix update
                            const outerBrush = new Brush(outerGeo);
                            outerBrush.updateMatrixWorld();
                            
                            const brush1 = new Brush(cross1);
                            brush1.updateMatrixWorld();
                            
                            const brush2 = new Brush(cross2);
                            brush2.updateMatrixWorld();
                            
                            // CSG: outer - cross1
                            let result = localEvaluator.evaluate(outerBrush, brush1, SUBTRACTION);
                            result.updateMatrixWorld();
                            
                            // CSG: result - cross2
                            result = localEvaluator.evaluate(result, brush2, SUBTRACTION);
                            result.updateMatrixWorld();
                            
                            stemGeo = result.geometry.clone();
                            stemGeo.translate(xPos, stemHeight / 2 + baseHeight, 0);
                            
                        } catch (e) {
                            console.warn('CSG failed for stem ' + i + ':', e);
                            stemGeo = outerGeo.clone();
                            stemGeo.translate(xPos, stemHeight / 2 + baseHeight, 0);
                        }
                        
                        stems.push(stemGeo);
                        
                        // 3. Base plate
                        const baseGeo = new THREE.BoxGeometry(baseSize, baseHeight, baseSize);
                        baseGeo.translate(xPos, baseHeight / 2, 0);
                        stems.push(baseGeo);
                    }
                    
                    console.log('Merging geometries...');
                    let mergedGeo = safeMerge(stems);
                    
                    if (!mergedGeo) {
                        throw new Error('„Ç∏„Ç™„É°„Éà„É™„ÅÆÁµêÂêà„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                    }
                    mergedGeo.computeVertexNormals();
                    
                    // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„Çí‰øÆÊ≠£
                    showToast('„É°„ÉÉ„Ç∑„É•„ÇíÊ§úË®º‰∏≠...');
                    mergedGeo = await validateAndFixGeometry(mergedGeo, '„Çπ„ÉÜ„É†„ÉÜ„Çπ„Éà„Ç≠„ÉÉ„Éà');
                    if (!mergedGeo) return;
                    
                    const exportMesh = new THREE.Mesh(mergedGeo, new THREE.MeshStandardMaterial({ color: 0x808080 }));
                    
                    const labels = [];
                    for (let i = 0; i < 5; i++) {
                        labels.push((startVal + (stepVal * i)).toFixed(2) + 'mm');
                    }
                    
                    const filename = 'stem_test_' + startVal.toFixed(2) + '-' + (startVal + stepVal * 4).toFixed(2);
                    console.log('Exporting:', filename);
                    
                    if (format === 'stl') {
                        const exporter = new STLExporter();
                        const stlString = exporter.parse(exportMesh, { binary: true });
                        const blob = new Blob([stlString], { type: 'application/octet-stream' });
                        saveAs(blob, filename + '.stl');
                    } else if (format === '3mf') {
                        const blob = await export3MFSingle(exportMesh, '#808080');
                        saveAs(blob, filename + '.3mf');
                    } else if (format === 'obj') {
                        const group = new THREE.Group();
                        exportMesh.name = "StemTestKit";
                        group.add(exportMesh);
                        const objData = new OBJExporter().parse(group);
                        const blob = new Blob([objData], { type: 'text/plain' });
                        saveAs(blob, filename + '.obj');
                    }
                    
                    showToast((translations[currentLang].tolerance_complete || '„Çπ„ÉÜ„É†„ÉÜ„Çπ„ÉàÁîüÊàêÂÆå‰∫Ü') + ': ' + labels.join(', '));
                } catch (error) {
                    console.error('Tolerance test generation failed:', error);
                    showToast('ÁîüÊàê„Ç®„É©„Éº: ' + error.message, true);
                }
            });

            // Sprue Count Slider
            document.getElementById('sprue-count')?.addEventListener('input', (e) => {
                const val = document.getElementById('v-sprue-count');
                if (val) val.textContent = e.target.value;
            });

            // ==========================================
            // Custom Sprue Kit (CSK) System
            // ==========================================
            (function initCustomSprueKit() {
                const cskBtn = document.getElementById('btn-custom-sprue-kit');
                const cskOverlay = document.getElementById('csk-overlay');
                const cskDialog = document.getElementById('csk-dialog');
                if (!cskBtn || !cskOverlay) return;

                // Printer sizes (shared with main sprue)
                const cskPrinterSizes = {
                    'x1p1a1': [{ value: '256,256', label: '256√ó256' }],
                    'a1mini': [{ value: '180,180', label: '180√ó180' }],
                    'h2d': [{ value: '325,320', label: 'Single Nozzle (325√ó320)' }, { value: '300,320', label: 'Dual Nozzle (300√ó320)' }, { value: '350,320', label: 'Total Area (350√ó320)' }],
                    'h2s': [{ value: '340,320', label: '340√ó320' }],
                    'h2c': [{ value: '325,320', label: 'Single Left (325√ó320)' }, { value: '305,320', label: 'Single Right (305√ó320)' }, { value: '300,320', label: 'Dual Nozzle (300√ó320)' }, { value: '330,320', label: 'Total Area (330√ó320)' }]
                };

                let cskGridData = []; // [{galleryItem, rotation, colBody, colText, bodyExtruder, textExtruder, orientX, orientY}]
                let cskCols = 6, cskRows = 7, cskMaxSlots = 42;
                let cskSelectedIdx = -1;
                let cskDragItem = null;
                let cskRunnerExtruder = 1; // „É©„É≥„Éä„Éº„ÅÆExtruderÁï™Âè∑
                let cskRunnerColor = '#808080'; // „É©„É≥„Éä„Éº„ÅÆËâ≤

                // „Éá„Éê„ÉÉ„Ç∞„Éë„Éç„É´„Åã„Çâ„Ç¢„ÇØ„Çª„Çπ„Åß„Åç„Çã„É™„Çª„ÉÉ„Éà„Éò„É´„Éë„Éº
                window._cskReset = () => {
                    cskGridData = [];
                    cskSelectedIdx = -1;
                    cskRunnerExtruder = 1;
                    cskRunnerColor = '#808080';
                };

                function calcGridSize(maxW, maxD) {
                    const keyW = state.unitSize * state.uSize;
                    const keyD = state.unitSize;
                    const xSp = keyW + 12;
                    const zSp = keyD + 20;
                    const margin = 10;
                    const cols = Math.max(1, Math.floor((maxW - margin * 2) / xSp));
                    const rows = Math.max(1, Math.floor((maxD - margin * 2) / zSp));
                    return { cols, rows };
                }

                function updateCSKGrid() {
                    const modelSel = document.getElementById('csk-printer-model');
                    const sizeSel = document.getElementById('csk-printer-size');
                    const model = modelSel.value;
                    const sizes = cskPrinterSizes[model] || cskPrinterSizes['x1p1a1'];

                    // Update size options
                    sizeSel.innerHTML = '';
                    sizes.forEach(s => {
                        const opt = document.createElement('option');
                        opt.value = s.value; opt.textContent = s.label;
                        sizeSel.appendChild(opt);
                    });

                    const sv = sizeSel.value.split(',');
                    const { cols, rows } = calcGridSize(parseFloat(sv[0]), parseFloat(sv[1]));
                    cskCols = cols; cskRows = rows; cskMaxSlots = cols * rows;

                    // Trim data if grid shrank
                    if (cskGridData.length > cskMaxSlots) cskGridData.length = cskMaxSlots;
                    while (cskGridData.length < cskMaxSlots) cskGridData.push(null);

                    renderCSKGrid();
                }

                // ‰∏ÄÊã¨ÈÖçÁΩÆ„É¢„Éº„ÉâÂ§âÊï∞
                let cskBatchMode = false;
                let cskBatchSelected = new Set();
                let cskBatchOrientX = 0;
                let cskBatchOrientY = 0;
                
                // ÈÖçÁΩÆÊñπÂêë„ÇíÂèñÂæó„Åô„ÇãÈñ¢Êï∞ÔºàÂÄãÂà•Ë®≠ÂÆö„ÅÆupdateOrientationDisplay„Å®Âêå„Åò„É≠„Ç∏„ÉÉ„ÇØÔºâ
                function getOrientationInfo(orientX, orientY) {
                    const baseRotX = -90; // Âü∫Ê∫ñÂõûËª¢Ôºö‰∏ãÈù¢„ÅåÊ≠£Èù¢
                    
                    // Âü∫Ê∫ñÂõûËª¢ + „É¶„Éº„Ç∂„ÉºÂõûËª¢„ÇíÈÅ©Áî®
                    const euler = new THREE.Euler(
                        THREE.MathUtils.degToRad(baseRotX + (orientX || 0)),
                        THREE.MathUtils.degToRad(orientY || 0),
                        0,
                        'XYZ'
                    );
                    const quaternion = new THREE.Quaternion().setFromEuler(euler);
                    
                    // „Ç´„É°„É©ÊñπÂêë„Éô„ÇØ„Éà„É´Ôºà„Ç´„É°„É©„ÅØ+ZÊñπÂêë„Åã„Çâ„Ç≠„É•„Éº„Éñ„ÇíË¶ã„Å¶„ÅÑ„ÇãÔºâ
                    const cameraDir = new THREE.Vector3(0, 0, 1);
                    
                    // ÂêÑÈù¢„ÅÆÊ≥ïÁ∑öÔºà„É≠„Éº„Ç´„É´Â∫ßÊ®ôÁ≥ªÔºâ„Å®ÂêçÂâç
                    const faces = [
                        { name: '‰∏ä', class: 'orient-top', normal: new THREE.Vector3(0, 1, 0) },
                        { name: '‰∏ã', class: 'orient-bottom', normal: new THREE.Vector3(0, -1, 0) },
                        { name: 'Ââç', class: 'orient-front', normal: new THREE.Vector3(0, 0, 1) },
                        { name: 'Âæå', class: 'orient-back', normal: new THREE.Vector3(0, 0, -1) },
                        { name: 'Âè≥', class: 'orient-right', normal: new THREE.Vector3(1, 0, 0) },
                        { name: 'Â∑¶', class: 'orient-left', normal: new THREE.Vector3(-1, 0, 0) }
                    ];
                    
                    let maxDot = -2;
                    let bestMatch = faces[1]; // „Éá„Éï„Ç©„É´„Éà: ‰∏ã
                    
                    faces.forEach(face => {
                        const rotatedNormal = face.normal.clone().applyQuaternion(quaternion);
                        // „Ç´„É°„É©ÊñπÂêë„Å®‰∏ÄËá¥„Åô„ÇãÈù¢ÔºàÊ≠£Èù¢„ÇíÂêë„ÅÑ„Å¶„ÅÑ„ÇãÈù¢Ôºâ„ÇíÊé¢„Åô
                        const dot = rotatedNormal.dot(cameraDir);
                        if (dot > maxDot) {
                            maxDot = dot;
                            bestMatch = face;
                        }
                    });
                    
                    return bestMatch;
                }
                
                function updateBatchCount() {
                    const countEl = document.getElementById('csk-batch-count');
                    if (countEl) countEl.textContent = `${cskBatchSelected.size}ÂÄãÈÅ∏Êäû‰∏≠`;
                }

                function renderCSKGrid() {
                    const grid = document.getElementById('csk-grid');
                    const wrap = document.querySelector('.csk-grid-wrap');
                    grid.innerHTML = '';

                    const filled = cskGridData.filter(d => d !== null).length;
                    document.getElementById('csk-slot-count').textContent = `${filled} / ${cskMaxSlots}`;
                    
                    // „Ç∞„É™„ÉÉ„ÉâÊÉÖÂ†±Ë°®Á§∫
                    const infoEl = document.getElementById('csk-grid-info');
                    if (infoEl) infoEl.textContent = `${cskCols}√ó${cskRows}`;

                    // „Ç∞„É™„ÉÉ„Éâ„Ç®„É™„Ç¢„ÅÆ„Çµ„Ç§„Ç∫„Åã„Çâ„Çø„Ç§„É´„Çµ„Ç§„Ç∫„ÇíÂãïÁöÑË®àÁÆó
                    const gap = 3;
                    const wrapRect = wrap.getBoundingClientRect();
                    const availW = wrapRect.width - 20; // padding: 10px * 2
                    const availH = wrapRect.height - 20;
                    const tileW = Math.floor((availW - gap * (cskCols - 1)) / cskCols);
                    const tileH = Math.floor((availH - gap * (cskRows - 1)) / cskRows);
                    const tileSize = Math.max(28, Math.min(tileW, tileH, 80)); // 28„Äú80px

                    grid.style.gridTemplateColumns = `repeat(${cskCols}, ${tileSize}px)`;
                    grid.style.gridTemplateRows = `repeat(${cskRows}, ${tileSize}px)`;

                    for (let i = 0; i < cskMaxSlots; i++) {
                        const slot = document.createElement('div');
                        slot.className = 'csk-slot';
                        slot.style.width = tileSize + 'px';
                        slot.style.height = tileSize + 'px';
                        slot.dataset.idx = i;
                        const data = cskGridData[i];

                        if (data) {
                            slot.classList.add('filled');
                            if (i === cskSelectedIdx) slot.classList.add('selected');

                            // Êú¨‰ΩìËâ≤„ÅÆ„Éú„Éº„ÉÄ„Éº„Åß„Éï„Ç£„É©„É°„É≥„ÉàËâ≤„ÇíË°®Áèæ
                            slot.style.borderColor = data.colBody || '#555';
                            slot.style.boxShadow = i === cskSelectedIdx 
                                ? `0 0 8px rgba(0,229,255,0.4), inset 0 0 0 1px ${data.colBody || '#555'}`
                                : `inset 0 0 0 1px ${data.colBody || '#555'}`;

                            const img = document.createElement('img');
                            img.src = data.galleryItem.thumbnail;
                            img.style.transform = `rotate(${data.rotation || 0}deg)`;
                            slot.appendChild(img);

                            // „Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆö„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØÔºàÂè≥‰∏ä„Å´Á∏¶‰∏¶„Å≥Ôºâ- Ë®≠ÂÆöÊ∏à„Åø„ÅÆ„ÅøË°®Á§∫
                            const hasBodyExtruder = data.bodyExtruder !== null && data.bodyExtruder !== undefined;
                            const hasTextExtruder = data.textExtruder !== null && data.textExtruder !== undefined;
                            
                            if (hasBodyExtruder || hasTextExtruder) {
                                const checkContainer = document.createElement('div');
                                checkContainer.style.cssText = 'position:absolute; top:2px; right:2px; display:flex; flex-direction:column; gap:1px; z-index:5;';
                                
                                // „Éú„Éá„Ç£„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØÔºà„Ç∑„Ç¢„É≥Ôºâ- Ë®≠ÂÆöÊ∏à„Åø„ÅÆ„Åø
                                if (hasBodyExtruder) {
                                    const bodyCheck = document.createElement('div');
                                    bodyCheck.style.cssText = 'width:10px; height:10px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:7px; font-weight:bold; background:#00e5ff; color:#000;';
                                    bodyCheck.textContent = '‚úì';
                                    bodyCheck.title = `Êú¨‰Ωì: „Çπ„É≠„ÉÉ„Éà${data.bodyExtruder}`;
                                    checkContainer.appendChild(bodyCheck);
                                }
                                
                                // ÊñáÂ≠ó„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØÔºà„Ç™„É¨„É≥„Ç∏Ôºâ- Ë®≠ÂÆöÊ∏à„Åø„ÅÆ„Åø
                                if (hasTextExtruder) {
                                    const textCheck = document.createElement('div');
                                    textCheck.style.cssText = 'width:10px; height:10px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:7px; font-weight:bold; background:#ff9800; color:#000;';
                                    textCheck.textContent = '‚úì';
                                    textCheck.title = `ÊñáÂ≠ó: „Çπ„É≠„ÉÉ„Éà${data.textExtruder}`;
                                    checkContainer.appendChild(textCheck);
                                }
                                
                                slot.appendChild(checkContainer);
                            }

                            // Ëâ≤„Ç§„É≥„Ç∏„Ç±„Éº„Çø„ÉºÔºàÂ∑¶‰∏ã: Êú¨‰ΩìËâ≤ + ÊñáÂ≠óËâ≤ „ÅÆ2Ëâ≤„Éâ„ÉÉ„ÉàÔºâ
                            const colorInd = document.createElement('div');
                            colorInd.style.cssText = `position:absolute; bottom:1px; left:1px; display:flex; gap:1px; z-index:5;`;
                            const bodyDot = document.createElement('div');
                            bodyDot.style.cssText = `width:8px; height:8px; border-radius:2px; border:1px solid rgba(255,255,255,0.4); background:${data.colBody || '#333'};`;
                            bodyDot.title = 'Êú¨‰ΩìËâ≤';
                            const textDot = document.createElement('div');
                            textDot.style.cssText = `width:8px; height:8px; border-radius:2px; border:1px solid rgba(255,255,255,0.4); background:${data.colText || '#0ee'};`;
                            textDot.title = 'ÊñáÂ≠óËâ≤';
                            colorInd.appendChild(bodyDot);
                            colorInd.appendChild(textDot);
                            slot.appendChild(colorInd);

                            const label = document.createElement('div');
                            label.className = 'csk-slot-label';
                            label.textContent = data.galleryItem.name;
                            slot.appendChild(label);

                            // ÈÖçÁΩÆÊñπÂêë„Ç§„É≥„Ç∏„Ç±„Éº„Çø„ÉºÔºà„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÅÆ‰∏ãÔºâ- Â∏∏„Å´Ë°®Á§∫
                            const orientInfo = getOrientationInfo(data.orientX || 0, data.orientY || 0);
                            const orientBadge = document.createElement('div');
                            orientBadge.className = `csk-orient-badge ${orientInfo.class}`;
                            orientBadge.textContent = orientInfo.name;
                            orientBadge.title = `ÈÖçÁΩÆÊñπÂêë: ${orientInfo.name}Èù¢„Åå‰∏ã`;
                            slot.appendChild(orientBadge);

                            if (data.rotation) {
                                const badge = document.createElement('div');
                                badge.className = 'csk-rot-badge';
                                badge.textContent = data.rotation + '¬∞';
                                slot.appendChild(badge);
                            }

                            // ‰∏ÄÊã¨ÈÅ∏Êäû„ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØ
                            const batchCheck = document.createElement('div');
                            batchCheck.className = 'csk-batch-check';
                            batchCheck.textContent = '‚úì';
                            slot.appendChild(batchCheck);
                            
                            // ‰∏ÄÊã¨ÈÅ∏Êäû„É¢„Éº„Éâ„ÅÆÂ†¥Âêà„ÅÆ„Çπ„Çø„Ç§„É´
                            if (cskBatchMode && cskBatchSelected.has(i)) {
                                slot.classList.add('batch-selected');
                            }

                            const rm = document.createElement('div');
                            rm.className = 'csk-remove-btn';
                            rm.textContent = '√ó';
                            rm.style.zIndex = '10';  // „ÉÅ„Çß„ÉÉ„ÇØ„Éû„Éº„ÇØ„Çà„Çä‰∏ä„Å´Ë°®Á§∫
                            rm.addEventListener('click', (e) => {
                                e.stopPropagation();
                                cskGridData[i] = null;
                                if (cskSelectedIdx === i) { cskSelectedIdx = -1; updateCSKProps(); }
                                cskBatchSelected.delete(i);
                                renderCSKGrid();
                            });
                            slot.appendChild(rm);

                            slot.addEventListener('click', () => {
                                if (cskBatchMode) {
                                    // ‰∏ÄÊã¨ÈÖçÁΩÆ„É¢„Éº„Éâ: ÈÅ∏Êäû/Ëß£Èô§„ÇíÂàá„ÇäÊõø„Åà
                                    if (cskBatchSelected.has(i)) {
                                        cskBatchSelected.delete(i);
                                    } else {
                                        cskBatchSelected.add(i);
                                    }
                                    updateBatchCount();
                                    renderCSKGrid();
                                } else {
                                    // ÈÄöÂ∏∏„É¢„Éº„Éâ
                                    cskSelectedIdx = (cskSelectedIdx === i) ? -1 : i;
                                    renderCSKGrid();
                                    updateCSKProps();
                                }
                            });
                        } else {
                            const col = i % cskCols + 1;
                            const row = Math.floor(i / cskCols) + 1;
                            slot.textContent = `${col},${row}`;
                        }

                        // Drop target
                        slot.addEventListener('dragover', (e) => { e.preventDefault(); slot.classList.add('drag-over'); });
                        slot.addEventListener('dragleave', () => { slot.classList.remove('drag-over'); });
                        slot.addEventListener('drop', (e) => {
                            e.preventDefault();
                            slot.classList.remove('drag-over');
                            if (cskDragItem) {
                                cskGridData[i] = {
                                    galleryItem: cskDragItem,
                                    rotation: 0,
                                    colBody: cskDragItem.state.colBody || '#333333',
                                    colText: cskDragItem.state.colText || '#00e5ff',
                                    bodyExtruder: cskDragItem.state.bodyExtruder || null,
                                    textExtruder: cskDragItem.state.textExtruder || null,
                                    orientX: 0,  // ÈÖçÁΩÆÊñπÂêëXÔºàÂ∫¶Ôºâ
                                    orientY: 0   // ÈÖçÁΩÆÊñπÂêëYÔºàÂ∫¶Ôºâ
                                };
                                renderCSKGrid();
                            }
                        });

                        grid.appendChild(slot);
                    }
                }

                function updateCSKProps() {
                    const panel = document.getElementById('csk-props');
                    if (cskSelectedIdx < 0 || !cskGridData[cskSelectedIdx]) {
                        panel.classList.remove('active');
                        return;
                    }
                    panel.classList.add('active');

                    const data = cskGridData[cskSelectedIdx];
                    
                    // ÈÖçÁΩÆÊñπÂêë„ÅÆViewCube„ÇíÊèèÁîª
                    renderOrientationCube(data);

                    // Render AMS color palettes
                    const renderPropPalette = (containerId, type) => {
                        const container = document.getElementById(containerId);
                        container.innerHTML = '';
                        const allSlots = [];
                        amsConfig.units.forEach(u => u.slots.forEach(s => allSlots.push(s)));
                        amsConfig.htUnits.forEach(u => u.slots.forEach(s => allSlots.push(s)));

                        allSlots.forEach((slotData, idx) => {
                            if (!slotData || !slotData.color) return;
                            const extruder = idx + 1;
                            const swatch = document.createElement('div');
                            const currentExt = type === 'body' ? data.bodyExtruder : data.textExtruder;
                            const isSelected = currentExt === extruder;
                            swatch.style.cssText = `
                                width:28px; height:28px; border-radius:4px; cursor:pointer; 
                                border:2px solid ${isSelected ? (type==='body'?'#00e5ff':'#ff9800') : '#333'}; 
                                background:${slotData.color};
                                display:flex; align-items:center; justify-content:center;
                                font-size:0.65rem; font-weight:bold; color:#fff;
                                text-shadow: 0 0 2px #000, 0 0 2px #000;
                            `;
                            swatch.textContent = extruder;
                            swatch.title = `„Çπ„É≠„ÉÉ„Éà${extruder}: ${slotData.material || ''}`;
                            swatch.addEventListener('click', () => {
                                if (type === 'body') {
                                    data.colBody = slotData.color;
                                    data.bodyExtruder = extruder;
                                } else {
                                    data.colText = slotData.color;
                                    data.textExtruder = extruder;
                                }
                                renderCSKGrid();
                                updateCSKProps();
                            });
                            container.appendChild(swatch);
                        });

                        if (container.children.length === 0) {
                            container.innerHTML = '<span style="color:#666; font-size:0.65rem;">AMSË®≠ÂÆö„ÅßËâ≤„ÇíÁôªÈå≤</span>';
                        }
                    };

                    renderPropPalette('csk-prop-body-palette', 'body');
                    renderPropPalette('csk-prop-text-palette', 'text');
                }
                
                // ÈÖçÁΩÆÊñπÂêëViewCube„ÅÆÊèèÁîª
                let cskCubeRenderer = null;
                let cskCubeScene = null;
                let cskCubeCam = null;
                let cskCubeMesh = null;
                let cskCubeIsDragging = false;
                let cskCubeLastX = 0, cskCubeLastY = 0;
                
                function renderOrientationCube(data) {
                    const canvas = document.getElementById('csk-orientation-cube');
                    if (!canvas) return;
                    
                    // ÂàùÊúüÂåñÔºà‰∏ÄÂ∫¶„Å†„ÅëÔºâ
                    if (!cskCubeRenderer) {
                        cskCubeRenderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
                        cskCubeRenderer.setSize(70, 70);
                        cskCubeRenderer.setClearColor(0x1a1a2e, 1);
                        
                        cskCubeScene = new THREE.Scene();
                        cskCubeCam = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
                        cskCubeCam.position.set(0, 0, 3.5);
                        
                        // „É©„Ç§„Éà
                        const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
                        light1.position.set(1, 1, 1);
                        cskCubeScene.add(light1);
                        const light2 = new THREE.AmbientLight(0x404040, 0.6);
                        cskCubeScene.add(light2);
                        
                        // „ÉÜ„Ç≠„Çπ„Éà‰ªò„Åç„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíÁîüÊàê„Åô„ÇãÈñ¢Êï∞
                        function createFaceTexture(text, bgColor, textColor = '#000') {
                            const faceCanvas = document.createElement('canvas');
                            faceCanvas.width = 64;
                            faceCanvas.height = 64;
                            const ctx = faceCanvas.getContext('2d');
                            
                            // ËÉåÊôØËâ≤
                            ctx.fillStyle = bgColor;
                            ctx.fillRect(0, 0, 64, 64);
                            
                            // „ÉÜ„Ç≠„Çπ„Éà
                            ctx.fillStyle = textColor;
                            ctx.font = 'bold 24px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(text, 32, 32);
                            
                            const texture = new THREE.CanvasTexture(faceCanvas);
                            texture.needsUpdate = true;
                            return texture;
                        }
                        
                        // ÂêÑÈù¢„Å´Ëâ≤„Å®„ÉÜ„Ç≠„Çπ„Éà„Çí‰ªò„Åë„Åü„Ç≠„É•„Éº„Éñ
                        const geometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
                        const materials = [
                            new THREE.MeshLambertMaterial({ map: createFaceTexture('Âè≥', '#ff6b6b', '#fff') }), // +X Âè≥
                            new THREE.MeshLambertMaterial({ map: createFaceTexture('Â∑¶', '#ffa07a', '#fff') }), // -X Â∑¶
                            new THREE.MeshLambertMaterial({ map: createFaceTexture('‰∏ä', '#00e5ff', '#000') }), // +Y ‰∏ä (TOP)
                            new THREE.MeshLambertMaterial({ map: createFaceTexture('‰∏ã', '#4ecdc4', '#fff') }), // -Y ‰∏ã
                            new THREE.MeshLambertMaterial({ map: createFaceTexture('Ââç', '#95e1d3', '#000') }), // +Z Ââç
                            new THREE.MeshLambertMaterial({ map: createFaceTexture('Âæå', '#6c5ce7', '#fff') })  // -Z Âæå
                        ];
                        cskCubeMesh = new THREE.Mesh(geometry, materials);
                        cskCubeScene.add(cskCubeMesh);
                        
                        // „Ç®„ÉÉ„Ç∏„É©„Ç§„É≥
                        const edges = new THREE.EdgesGeometry(geometry);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true }));
                        cskCubeMesh.add(line);
                        
                        // „Éâ„É©„ÉÉ„Ç∞„Ç§„Éô„É≥„Éà
                        canvas.addEventListener('mousedown', (e) => {
                            cskCubeIsDragging = true;
                            cskCubeLastX = e.clientX;
                            cskCubeLastY = e.clientY;
                            canvas.style.cursor = 'grabbing';
                        });
                        
                        document.addEventListener('mousemove', (e) => {
                            if (!cskCubeIsDragging || cskSelectedIdx < 0) return;
                            const dx = e.clientX - cskCubeLastX;
                            const dy = e.clientY - cskCubeLastY;
                            cskCubeLastX = e.clientX;
                            cskCubeLastY = e.clientY;
                            
                            const currentData = cskGridData[cskSelectedIdx];
                            if (!currentData) return;
                            
                            // ÂõûËª¢„ÇíÊõ¥Êñ∞ÔºàÂ∫¶Âçò‰Ωç„Åß‰øùÂ≠òÔºâ- 6Èù¢„Åô„Åπ„Å¶ÈÅ∏ÊäûÂèØËÉΩ„Å´„Åô„Çã„Åü„ÇÅÂà∂Èôê„ÇíÊã°Â§ß
                            currentData.orientY = ((currentData.orientY || 0) + dx * 2) % 360;
                            currentData.orientX = ((currentData.orientX || 0) + dy * 2) % 360;
                            // -180„Äú180„ÅÆÁØÑÂõ≤„Å´Ê≠£Ë¶èÂåñ
                            if (currentData.orientX > 180) currentData.orientX -= 360;
                            if (currentData.orientX < -180) currentData.orientX += 360;
                            
                            updateOrientationDisplay(currentData);
                            renderCSKGrid();
                        });
                        
                        document.addEventListener('mouseup', () => {
                            cskCubeIsDragging = false;
                            canvas.style.cursor = 'grab';
                        });
                    }
                    
                    // ÁèæÂú®„ÅÆÂêë„Åç„ÇíÈÅ©Áî®
                    updateOrientationDisplay(data);
                }
                
                function updateOrientationDisplay(data) {
                    if (!cskCubeMesh || !cskCubeRenderer) return;
                    
                    const orientX = data.orientX || 0;
                    const orientY = data.orientY || 0;
                    
                    // „Ç≠„É•„Éº„Éñ„ÅÆÂõûËª¢„ÇíË®≠ÂÆöÔºàÂü∫Ê∫ñ: ‰∏ãÈù¢„ÅåÊ≠£Èù¢„Å´„Å™„Çã„Çà„ÅÜ„Å´XËª∏-90Â∫¶Ôºâ
                    // „Åù„ÅÆ‰∏ä„Å´„É¶„Éº„Ç∂„Éº„ÅÆÂõûËª¢„ÇíÈÅ©Áî®
                    const baseRotX = -90; // Âü∫Ê∫ñÂõûËª¢Ôºö‰∏ãÈù¢„ÅåÊ≠£Èù¢
                    cskCubeMesh.rotation.set(
                        THREE.MathUtils.degToRad(baseRotX + orientX),
                        THREE.MathUtils.degToRad(orientY),
                        0,
                        'XYZ'
                    );
                    cskCubeMesh.updateMatrix();
                    
                    cskCubeRenderer.render(cskCubeScene, cskCubeCam);
                    
                    // Âêë„Åç„É©„Éô„É´„ÇíÊõ¥Êñ∞ÔºàÊ≠£Èù¢„ÇíÂêë„ÅÑ„Å¶„ÅÑ„ÇãÈù¢ = „Éó„É¨„Éº„Éà„Å´ÁΩÆ„ÅèÈù¢Ôºâ
                    const label = document.getElementById('csk-orientation-label');
                    if (label) {
                        // „Ç´„É°„É©ÊñπÂêë„Éô„ÇØ„Éà„É´Ôºà„Ç´„É°„É©„ÅØ+ZÊñπÂêë„Åã„Çâ„Ç≠„É•„Éº„Éñ„ÇíË¶ã„Å¶„ÅÑ„ÇãÔºâ
                        const cameraDir = new THREE.Vector3(0, 0, 1);
                        
                        // ÂêÑÈù¢„ÅÆÊ≥ïÁ∑öÔºà„É≠„Éº„Ç´„É´Â∫ßÊ®ôÁ≥ªÔºâ„Å®ÂêçÂâç
                        const faces = [
                            { name: '‰∏äÈù¢„Åå‰∏ã', normal: new THREE.Vector3(0, 1, 0) },
                            { name: '‰∏ãÈù¢„Åå‰∏ã', normal: new THREE.Vector3(0, -1, 0) },
                            { name: 'ÂâçÈù¢„Åå‰∏ã', normal: new THREE.Vector3(0, 0, 1) },
                            { name: 'ÂæåÈù¢„Åå‰∏ã', normal: new THREE.Vector3(0, 0, -1) },
                            { name: 'Âè≥Èù¢„Åå‰∏ã', normal: new THREE.Vector3(1, 0, 0) },
                            { name: 'Â∑¶Èù¢„Åå‰∏ã', normal: new THREE.Vector3(-1, 0, 0) }
                        ];
                        
                        let maxDot = -2;
                        let bottomFace = '‰∏ãÈù¢„Åå‰∏ã';
                        
                        // Âü∫Ê∫ñÂõûËª¢ + „É¶„Éº„Ç∂„ÉºÂõûËª¢„ÇíÈÅ©Áî®
                        const euler = new THREE.Euler(
                            THREE.MathUtils.degToRad(baseRotX + orientX),
                            THREE.MathUtils.degToRad(orientY),
                            0,
                            'XYZ'
                        );
                        const quaternion = new THREE.Quaternion().setFromEuler(euler);
                        
                        faces.forEach(face => {
                            const rotatedNormal = face.normal.clone().applyQuaternion(quaternion);
                            // „Ç´„É°„É©ÊñπÂêë„Å®‰∏ÄËá¥„Åô„ÇãÈù¢ÔºàÊ≠£Èù¢„ÇíÂêë„ÅÑ„Å¶„ÅÑ„ÇãÈù¢Ôºâ„ÇíÊé¢„Åô
                            const dot = rotatedNormal.dot(cameraDir);
                            if (dot > maxDot) {
                                maxDot = dot;
                                bottomFace = face.name;
                            }
                        });
                        
                        label.textContent = bottomFace;
                    }
                }

                function loadCSKGallery() {
                    const container = document.getElementById('csk-gallery');
                    container.innerHTML = '';

                    if (!galleryDB) {
                        container.innerHTML = '<div style="color:#666; padding:10px; font-size:0.7rem;">„ÇÆ„É£„É©„É™„Éº„ÅåÁ©∫„Åß„Åô</div>';
                        return;
                    }

                    const tx = galleryDB.transaction(['presets'], 'readonly');
                    const store = tx.objectStore('presets');
                    const req = store.getAll();

                    req.onsuccess = () => {
                        const items = req.result;
                        if (items.length === 0) {
                            container.innerHTML = '<div style="color:#666; padding:10px; font-size:0.7rem;">„ÇÆ„É£„É©„É™„Éº„Å´„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Çí‰øùÂ≠ò„Åó„Å¶„Åè„Å†„Åï„ÅÑ</div>';
                            return;
                        }

                        items.forEach(item => {
                            const tile = document.createElement('div');
                            tile.className = 'csk-gallery-tile';
                            tile.draggable = true;

                            const img = document.createElement('img');
                            img.src = item.thumbnail;
                            tile.appendChild(img);

                            const label = document.createElement('div');
                            label.className = 'csk-tile-label';
                            label.textContent = item.name;
                            tile.appendChild(label);

                            tile.addEventListener('dragstart', (e) => {
                                cskDragItem = item;
                                e.dataTransfer.effectAllowed = 'copy';
                                tile.style.opacity = '0.5';
                            });
                            tile.addEventListener('dragend', () => {
                                cskDragItem = null;
                                tile.style.opacity = '1';
                            });

                            container.appendChild(tile);
                        });
                    };
                }

                // Rotation helpers
                function rotateSlot(idx) {
                    if (cskGridData[idx]) {
                        cskGridData[idx].rotation = ((cskGridData[idx].rotation || 0) + 90) % 360;
                    }
                }

                // „É©„É≥„Éä„ÉºËâ≤„Éë„É¨„ÉÉ„ÉàÊèèÁîª
                function renderCSKRunnerPalette() {
                    const container = document.getElementById('csk-runner-palette');
                    if (!container) return;
                    container.innerHTML = '';

                    // AMS„Çπ„É≠„ÉÉ„Éà„Åã„ÇâËâ≤„ÇíÂèñÂæóÔºàupdateCSKProps„Å®Âêå„Åò„É≠„Ç∏„ÉÉ„ÇØÔºâ
                    const allSlots = [];
                    amsConfig.units.forEach(u => u.slots.forEach(s => allSlots.push(s)));
                    amsConfig.htUnits.forEach(u => u.slots.forEach(s => allSlots.push(s)));

                    allSlots.forEach((slotData, idx) => {
                        if (!slotData || !slotData.color) return;
                        const extruder = idx + 1;
                        const isSelected = cskRunnerExtruder === extruder;
                        
                        const swatch = document.createElement('div');
                        swatch.style.cssText = `
                            width: 28px; height: 28px; border-radius: 4px; cursor: pointer;
                            background: ${slotData.color}; 
                            border: 2px solid ${isSelected ? '#00e5ff' : '#444'};
                            box-shadow: ${isSelected ? '0 0 6px rgba(0,229,255,0.5)' : 'none'};
                            display: flex; align-items: center; justify-content: center;
                            font-size: 0.65rem; font-weight: bold; color: #fff;
                            text-shadow: 0 0 2px #000, 0 0 2px #000;
                            transition: all 0.15s;
                        `;
                        swatch.textContent = extruder;
                        swatch.title = `„Çπ„É≠„ÉÉ„Éà${extruder}: ${slotData.material || slotData.color}`;
                        swatch.addEventListener('click', () => {
                            cskRunnerExtruder = extruder;
                            cskRunnerColor = slotData.color;
                            renderCSKRunnerPalette();
                        });
                        container.appendChild(swatch);
                    });

                    // „Çπ„É≠„ÉÉ„Éà„Åå„Å™„ÅÑÂ†¥Âêà
                    if (container.children.length === 0) {
                        container.innerHTML = '<span style="color:#666; font-size:0.65rem;">AMSË®≠ÂÆö„ÅßËâ≤„ÇíÁôªÈå≤</span>';
                    }
                }
                
                // ‰∏ÄÊã¨ÈÖçÁΩÆ„É¢„Éº„Éâ„ÅÆÂàá„ÇäÊõø„Åà
                document.getElementById('csk-batch-orient')?.addEventListener('click', () => {
                    cskBatchMode = !cskBatchMode;
                    const btn = document.getElementById('csk-batch-orient');
                    const panel = document.getElementById('csk-batch-panel');
                    const propsPanel = document.getElementById('csk-props');
                    
                    if (cskBatchMode) {
                        btn.style.background = '#ff9800';
                        btn.style.color = '#fff';
                        panel.classList.add('active');
                        propsPanel.classList.remove('active');
                        cskBatchSelected.clear();
                        cskBatchOrientX = 0;
                        cskBatchOrientY = 0;
                        updateBatchOrientLabel();
                        initBatchCube();
                    } else {
                        btn.style.background = '';
                        btn.style.color = '#ff9800';
                        panel.classList.remove('active');
                        cskBatchSelected.clear();
                    }
                    renderCSKGrid();
                });
                
                // ‰∏ÄÊã¨ÈÅ∏Êäû„ÉªËß£Èô§
                document.getElementById('csk-batch-select-all')?.addEventListener('click', () => {
                    cskGridData.forEach((data, i) => {
                        if (data !== null) cskBatchSelected.add(i);
                    });
                    updateBatchCount();
                    renderCSKGrid();
                });
                
                document.getElementById('csk-batch-deselect-all')?.addEventListener('click', () => {
                    cskBatchSelected.clear();
                    updateBatchCount();
                    renderCSKGrid();
                });
                
                // ÁµÇ‰∫Ü„Éú„Çø„É≥
                document.getElementById('csk-batch-cancel')?.addEventListener('click', () => {
                    cskBatchMode = false;
                    const btn = document.getElementById('csk-batch-orient');
                    btn.style.background = '';
                    btn.style.color = '#ff9800';
                    document.getElementById('csk-batch-panel').classList.remove('active');
                    cskBatchSelected.clear();
                    renderCSKGrid();
                    // ÈÅ∏Êäû‰∏≠„ÅÆ„Çø„Ç§„É´„Åå„ÅÇ„Çå„Å∞ÂÄãÂà•Ë®≠ÂÆö„Éë„Éç„É´„ÇíÊõ¥Êñ∞
                    if (cskSelectedIdx >= 0 && cskGridData[cskSelectedIdx]) {
                        updateCSKProps();
                    }
                });
                
                function updateBatchOrientLabel() {
                    const info = getOrientationInfo(cskBatchOrientX, cskBatchOrientY);
                    const label = document.getElementById('csk-batch-orient-label');
                    if (label) label.textContent = `${info.name}Èù¢„Åå‰∏ã`;
                }
                
                // ‰∏ÄÊã¨ÈÖçÁΩÆÁî®„Çµ„Ç§„Ç≥„É≠„ÅÆÂàùÊúüÂåñ
                let batchCubeScene, batchCubeCamera, batchCubeRenderer, batchCubeMesh;
                let batchCubeDragging = false, batchCubeLastX = 0, batchCubeLastY = 0;
                
                function initBatchCube() {
                    const canvas = document.getElementById('csk-batch-cube');
                    if (!canvas) return;
                    
                    // „ÉÜ„Ç≠„Çπ„Éà‰ªò„Åç„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíÁîüÊàê„Åô„Çã„É≠„Éº„Ç´„É´Èñ¢Êï∞
                    function createBatchFaceTexture(text, bgColor, textColor = '#000') {
                        const faceCanvas = document.createElement('canvas');
                        faceCanvas.width = 64;
                        faceCanvas.height = 64;
                        const ctx = faceCanvas.getContext('2d');
                        ctx.fillStyle = bgColor;
                        ctx.fillRect(0, 0, 64, 64);
                        ctx.fillStyle = textColor;
                        ctx.font = 'bold 24px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(text, 32, 32);
                        return new THREE.CanvasTexture(faceCanvas);
                    }
                    
                    if (!batchCubeRenderer) {
                        batchCubeScene = new THREE.Scene();
                        batchCubeCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
                        batchCubeCamera.position.set(0, 0, 3.5);
                        batchCubeRenderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
                        batchCubeRenderer.setSize(80, 80);
                        batchCubeRenderer.setClearColor(0x1a1a2e, 1);
                        
                        // „É©„Ç§„Éà
                        const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
                        light1.position.set(1, 1, 1);
                        batchCubeScene.add(light1);
                        const light2 = new THREE.AmbientLight(0x404040, 0.6);
                        batchCubeScene.add(light2);
                        
                        // „Çµ„Ç§„Ç≥„É≠‰ΩúÊàêÔºàÂÄãÂà•Ë®≠ÂÆö„Å®Âêå„Åò„Çπ„Çø„Ç§„É´Ôºâ
                        const geo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
                        const materials = [
                            new THREE.MeshLambertMaterial({ map: createBatchFaceTexture('Âè≥', '#ff6b6b', '#fff') }),
                            new THREE.MeshLambertMaterial({ map: createBatchFaceTexture('Â∑¶', '#ffa07a', '#fff') }),
                            new THREE.MeshLambertMaterial({ map: createBatchFaceTexture('‰∏ä', '#00e5ff', '#000') }),
                            new THREE.MeshLambertMaterial({ map: createBatchFaceTexture('‰∏ã', '#4ecdc4', '#fff') }),
                            new THREE.MeshLambertMaterial({ map: createBatchFaceTexture('Ââç', '#95e1d3', '#000') }),
                            new THREE.MeshLambertMaterial({ map: createBatchFaceTexture('Âæå', '#6c5ce7', '#fff') })
                        ];
                        batchCubeMesh = new THREE.Mesh(geo, materials);
                        batchCubeScene.add(batchCubeMesh);
                        
                        // „Ç®„ÉÉ„Ç∏„É©„Ç§„É≥
                        const edges = new THREE.EdgesGeometry(geo);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true }));
                        batchCubeMesh.add(line);
                        
                        // „Éâ„É©„ÉÉ„Ç∞„Ç§„Éô„É≥„ÉàÔºàÂÄãÂà•Ë®≠ÂÆö„Å®Âêå„ÅòÊÑüÂ∫¶Ôºâ
                        canvas.addEventListener('mousedown', (e) => {
                            batchCubeDragging = true;
                            batchCubeLastX = e.clientX;
                            batchCubeLastY = e.clientY;
                            canvas.style.cursor = 'grabbing';
                        });
                        
                        document.addEventListener('mousemove', (e) => {
                            if (!batchCubeDragging) return;
                            const dx = e.clientX - batchCubeLastX;
                            const dy = e.clientY - batchCubeLastY;
                            batchCubeLastX = e.clientX;
                            batchCubeLastY = e.clientY;
                            
                            // ÂõûËª¢„ÇíÊõ¥Êñ∞ÔºàÂÄãÂà•Ë®≠ÂÆö„Å®Âêå„ÅòÊÑüÂ∫¶: * 2Ôºâ
                            cskBatchOrientY = ((cskBatchOrientY || 0) + dx * 2) % 360;
                            cskBatchOrientX = ((cskBatchOrientX || 0) + dy * 2) % 360;
                            // -180„Äú180„ÅÆÁØÑÂõ≤„Å´Ê≠£Ë¶èÂåñ
                            if (cskBatchOrientX > 180) cskBatchOrientX -= 360;
                            if (cskBatchOrientX < -180) cskBatchOrientX += 360;
                            
                            // ÈÅ∏Êäû„Åï„Çå„Åü„Çø„Ç§„É´„Å´Âç≥Â∫ß„Å´ÈÅ©Áî®
                            cskBatchSelected.forEach(idx => {
                                if (cskGridData[idx]) {
                                    cskGridData[idx].orientX = cskBatchOrientX;
                                    cskGridData[idx].orientY = cskBatchOrientY;
                                }
                            });
                            
                            updateBatchCube();
                            updateBatchOrientLabel();
                            renderCSKGrid();
                        });
                        
                        document.addEventListener('mouseup', () => {
                            if (batchCubeDragging) {
                                batchCubeDragging = false;
                                canvas.style.cursor = 'grab';
                            }
                        });
                    }
                    
                    // ÂàùÊúüÁä∂ÊÖã„Å´„É™„Çª„ÉÉ„Éà
                    cskBatchOrientX = 0;
                    cskBatchOrientY = 0;
                    updateBatchCube();
                }
                
                function updateBatchCube() {
                    if (!batchCubeMesh) return;
                    batchCubeMesh.rotation.x = THREE.MathUtils.degToRad(-90 + cskBatchOrientX);
                    batchCubeMesh.rotation.y = THREE.MathUtils.degToRad(cskBatchOrientY);
                    batchCubeRenderer.render(batchCubeScene, batchCubeCamera);
                }

                document.getElementById('csk-clear-all')?.addEventListener('click', () => {
                    cskGridData = cskGridData.map(() => null);
                    cskSelectedIdx = -1;
                    updateCSKProps();
                    renderCSKGrid();
                });

                // Printer change
                document.getElementById('csk-printer-model')?.addEventListener('change', () => {
                    updateCSKGrid();
                });
                document.getElementById('csk-printer-size')?.addEventListener('change', () => {
                    const sv = document.getElementById('csk-printer-size').value.split(',');
                    const { cols, rows } = calcGridSize(parseFloat(sv[0]), parseFloat(sv[1]));
                    cskCols = cols; cskRows = rows; cskMaxSlots = cols * rows;
                    while (cskGridData.length < cskMaxSlots) cskGridData.push(null);
                    if (cskGridData.length > cskMaxSlots) cskGridData.length = cskMaxSlots;
                    renderCSKGrid();
                });
                
                // „Ç¶„Ç£„É≥„Éâ„Ç¶„É™„Çµ„Ç§„Ç∫ÊôÇ„Å´„Ç∞„É™„ÉÉ„Éâ„ÇíÂÜçË®àÁÆó
                let cskResizeTimer;
                window.addEventListener('resize', () => {
                    if (cskOverlay.style.display === 'flex') {
                        clearTimeout(cskResizeTimer);
                        cskResizeTimer = setTimeout(renderCSKGrid, 150);
                    }
                });

                // Open dialog
                let cskInitialized = false;
                cskBtn.addEventListener('click', () => {
                    // Sync printer model from main panel (ÂàùÂõû„ÅÆ„Åø)
                    if (!cskInitialized) {
                        const mainModel = document.getElementById('sprue-printer-model')?.value || 'x1p1a1';
                        document.getElementById('csk-printer-model').value = mainModel;
                        cskInitialized = true;
                    }

                    // „Ç∞„É™„ÉÉ„Éâ„Éá„Éº„Çø„ÅØÁ∂≠ÊåÅÔºà„É™„Çª„ÉÉ„Éà„Åó„Å™„ÅÑÔºâ
                    cskSelectedIdx = -1;
                    loadCSKGallery();
                    updateCSKProps();
                    renderCSKRunnerPalette(); // „É©„É≥„Éä„ÉºËâ≤„Éë„É¨„ÉÉ„Éà„ÇíÊèèÁîª

                    cskOverlay.style.display = 'flex';
                    requestAnimationFrame(() => {
                        cskOverlay.style.background = 'rgba(0,0,0,0.7)';
                        cskDialog.classList.add('show');
                        // „ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÅÆ„Çµ„Ç§„Ç∫„ÅåÁ¢∫ÂÆö„Åó„Å¶„Åã„Çâ„Ç∞„É™„ÉÉ„Éâ„ÇíË®àÁÆó
                        setTimeout(() => {
                            updateCSKGrid();
                        }, 50);
                    });
                });

                // Close dialog
                const closeCSK = () => {
                    cskDialog.classList.remove('show');
                    cskOverlay.style.background = 'rgba(0,0,0,0)';
                    setTimeout(() => cskOverlay.style.display = 'none', 300);
                };
                document.getElementById('csk-cancel')?.addEventListener('click', closeCSK);
                cskOverlay.addEventListener('click', (e) => { if (e.target === cskOverlay) closeCSK(); });

                // Generate sprue kit
                document.getElementById('csk-generate')?.addEventListener('click', async () => {
                    const filledSlots = cskGridData.filter(d => d !== null);
                    if (filledSlots.length < 1) {
                        showToast('Â∞ë„Å™„Åè„Å®„ÇÇ1„Å§„ÅÆ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÇíÈÖçÁΩÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ', true);
                        return;
                    }

                    closeCSK();
                    
                    // V67.3: „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº‰ªò„Åç„Éà„Éº„Çπ„Éà„Çí‰ΩøÁî®
                    const totalSteps = filledSlots.length + 3; // „Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÊï∞ + „É©„É≥„Éä„ÉºÁîüÊàê + „É©„É≥„Éä„ÉºÊ§úË®º + „Ç®„ÇØ„Çπ„Éù„Éº„Éà
                    let currentStep = 0;
                    showProgressToast('„Ç´„Çπ„Çø„É†„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„ÉàÁîüÊàê„ÇíÈñãÂßã...', 0);

                    await new Promise(r => setTimeout(r, 200));

                    try {
                        const p = getParams();
                        const keyW = state.unitSize * state.uSize;
                        const keyD = state.unitSize;
                        const xSp = keyW + 12;
                        const zSp = keyD + 20;

                        // ÈÖçÁΩÆ„Åï„Çå„Å¶„ÅÑ„Çã„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÁØÑÂõ≤„ÇíË®àÁÆó
                        let minCol = cskCols, maxCol = 0, minRow = cskRows, maxRow = 0;
                        for (let i = 0; i < cskMaxSlots; i++) {
                            if (cskGridData[i] !== null) {
                                const col = i % cskCols;
                                const row = Math.floor(i / cskCols);
                                minCol = Math.min(minCol, col);
                                maxCol = Math.max(maxCol, col);
                                minRow = Math.min(minRow, row);
                                maxRow = Math.max(maxRow, row);
                            }
                        }

                        // ÂÆüÈöõ„Å´‰ΩøÁî®„Åô„ÇãÂàóÊï∞„ÉªË°åÊï∞
                        const usedCols = maxCol - minCol + 1;
                        const usedRows = maxRow - minRow + 1;

                        const keycapObjects = [];  // ÂêÑ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆ {bodyGeo, textGeo, bodyExtruder, textExtruder, index}
                        const keycapPositions = []; // ‰ΩçÁΩÆÊÉÖÂ†±Ôºà„Ç≤„Éº„ÉàÁîüÊàêÁî®Ôºâ
                        const runnerGeos = [];
                        const previewGeos = [];

                        // „Ç∞„É™„ÉÉ„Éâ„Çµ„Ç§„Ç∫„ÅØÂÆüÈöõ„Å´‰ΩøÁî®„Åô„ÇãÁØÑÂõ≤„Å´Âü∫„Å•„Åè
                        const gridWidth = (usedCols - 1) * xSp;
                        const gridDepth = (usedRows - 1) * zSp;

                        // Save current state
                        const savedState = JSON.parse(JSON.stringify(state));

                        // „Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÁîüÊàê„É´„Éº„Éó
                        let keycapIndex = 0;
                        let processedKeycaps = 0;
                        for (let i = 0; i < cskMaxSlots; i++) {
                            const data = cskGridData[i];
                            if (!data) continue;
                            
                            // „Éó„É≠„Ç∞„É¨„ÇπÊõ¥Êñ∞
                            processedKeycaps++;
                            const progress = (processedKeycaps / totalSteps) * 100;
                            updateProgressToast(`„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó ${processedKeycaps}/${filledSlots.length} „ÇíÂá¶ÁêÜ‰∏≠...`, progress);
                            await new Promise(r => setTimeout(r, 50));

                            const col = i % cskCols;
                            const row = Math.floor(i / cskCols);
                            
                            // ÂÆüÈöõ„ÅÆÁØÑÂõ≤ÂÜÖ„Åß„ÅÆÁõ∏ÂØæ‰ΩçÁΩÆ„ÇíË®àÁÆó
                            const relCol = col - minCol;
                            const relRow = row - minRow;
                            const xPos = relCol * xSp - gridWidth / 2;
                            const zPos = relRow * zSp - gridDepth / 2;

                            // Apply gallery item state temporarily
                            Object.assign(state, data.galleryItem.state);
                            state.colBody = data.colBody;
                            state.colText = data.colText;

                            // ÂÆåÂÖ®„Å´„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÇíÂÜçÁîüÊàê
                            await new Promise(resolve => {
                                requestUpdate();
                                setTimeout(resolve, 200);
                            });

                            const keycapObj = {
                                bodyGeo: null,
                                textGeo: null,
                                bodyExtruder: data.bodyExtruder || 1,
                                textExtruder: data.textExtruder || 2,
                                index: keycapIndex
                            };
                            
                            // ÈÖçÁΩÆÊñπÂêë„Çí90Â∫¶Âçò‰Ωç„Åß„Çπ„Éä„ÉÉ„Éó„Åó„Å¶Ê≠£Á¢∫„Å™ÂõûËª¢ËßíÂ∫¶„ÇíÂèñÂæó
                            // orientX/orientY„ÅÆËá™Áî±„Å™ËßíÂ∫¶„Åß„ÅØ„Å™„Åè„ÄÅÂà§ÂÆö„Åï„Çå„ÅüÈù¢„Å´Âü∫„Å•„Åè
                            function getSnappedRotation(orientX, orientY) {
                                // Âü∫Ê∫ñÂõûËª¢Ôºà-90Â∫¶Ôºâ„ÇíÈÅ©Áî®„Åó„Åü‰∏ä„Åß„ÄÅ„Å©„ÅÆÈù¢„ÅåÊ≠£Èù¢„Åã„ÇíÂà§ÂÆö
                                const baseRotX = -90;
                                const euler = new THREE.Euler(
                                    THREE.MathUtils.degToRad(baseRotX + (orientX || 0)),
                                    THREE.MathUtils.degToRad(orientY || 0),
                                    0,
                                    'XYZ'
                                );
                                const quaternion = new THREE.Quaternion().setFromEuler(euler);
                                const cameraDir = new THREE.Vector3(0, 0, 1);
                                
                                // ÂêÑÈù¢„ÅÆÂÆöÁæ©„Å®„ÄÅ„Åù„ÅÆÈù¢„Åå‰∏ã„Å´„Å™„ÇãÊôÇ„ÅÆÂõûËª¢ËßíÂ∫¶
                                // „Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆ„Éá„Éï„Ç©„É´„Éà: „Çπ„ÉÜ„É†(Â∫ïÈù¢)„Åå-YÊñπÂêë„ÄÅ„Éà„ÉÉ„Éó„Åå+YÊñπÂêë
                                const faces = [
                                    { name: 'top', normal: new THREE.Vector3(0, 1, 0), rotX: 180, rotY: 0, rotZ: 0 },     // ‰∏äÈù¢„Åå‰∏ã ‚Üí XËª∏180Â∫¶
                                    { name: 'bottom', normal: new THREE.Vector3(0, -1, 0), rotX: 0, rotY: 0, rotZ: 0 },   // ‰∏ãÈù¢„Åå‰∏ã ‚Üí „Éá„Éï„Ç©„É´„Éà
                                    { name: 'front', normal: new THREE.Vector3(0, 0, 1), rotX: -90, rotY: 0, rotZ: 0 },   // ÂâçÈù¢„Åå‰∏ã ‚Üí XËª∏-90Â∫¶
                                    { name: 'back', normal: new THREE.Vector3(0, 0, -1), rotX: 90, rotY: 0, rotZ: 0 },    // ÂæåÈù¢„Åå‰∏ã ‚Üí XËª∏90Â∫¶
                                    { name: 'right', normal: new THREE.Vector3(1, 0, 0), rotX: 0, rotY: 0, rotZ: -90 },   // Âè≥Èù¢„Åå‰∏ã ‚Üí ZËª∏-90Â∫¶
                                    { name: 'left', normal: new THREE.Vector3(-1, 0, 0), rotX: 0, rotY: 0, rotZ: 90 }     // Â∑¶Èù¢„Åå‰∏ã ‚Üí ZËª∏90Â∫¶
                                ];
                                
                                let maxDot = -2;
                                let selectedFace = faces[1]; // „Éá„Éï„Ç©„É´„Éà„ÅØ bottom
                                
                                faces.forEach(face => {
                                    const rotatedNormal = face.normal.clone().applyQuaternion(quaternion);
                                    const dot = rotatedNormal.dot(cameraDir);
                                    if (dot > maxDot) {
                                        maxDot = dot;
                                        selectedFace = face;
                                    }
                                });
                                
                                // Âà§ÂÆö„Åï„Çå„ÅüÈù¢„Å´Âü∫„Å•„ÅÑ„Å¶Ê≠£Á¢∫„Å™90Â∫¶Âçò‰Ωç„ÅÆÂõûËª¢„ÇíËøî„Åô
                                return {
                                    x: THREE.MathUtils.degToRad(selectedFace.rotX),
                                    y: THREE.MathUtils.degToRad(selectedFace.rotY),
                                    z: THREE.MathUtils.degToRad(selectedFace.rotZ)
                                };
                            }
                            
                            // „Çπ„Éä„ÉÉ„Éó„Åï„Çå„ÅüÂõûËª¢ËßíÂ∫¶„ÇíÂèñÂæó
                            const snappedRot = getSnappedRotation(data.orientX, data.orientY);
                            const rotYRad = THREE.MathUtils.degToRad(data.rotation || 0);
                            
                            // „Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂØ∏Ê≥ï
                            const kcWidth = state.unitSize * state.uSize;
                            const kcDepth = state.unitSize;
                            const kcHeight = p.h;
                            
                            // ÂõûËª¢Âæå„ÅÆ„Éê„Ç¶„É≥„Éá„Ç£„É≥„Ç∞„Éú„ÉÉ„ÇØ„Çπ„Åã„ÇâYÊñπÂêë„Ç™„Éï„Çª„ÉÉ„Éà„ÇíË®àÁÆó
                            // „Éó„É¨„Éº„Éà‰∏ä„Å´‰πó„Çã„Çà„ÅÜ„Å´ÊúÄ‰ΩéÁÇπ„ÇíY=0„Å´„Åô„Çã
                            let yOffset = 0;
                            let gateHeight = kcHeight * 0.5; // „Ç≤„Éº„ÉàÊé•Á∂ö‰ΩçÁΩÆÔºà„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó‰∏≠Â§ÆÈ´ò„ÅïÔºâ
                            
                            // ÈÖçÁΩÆÊñπÂêë„Å´Âøú„Åò„ÅüÂÇæÊñúË£úÊ≠£ËßíÂ∫¶„ÇíË®àÁÆó„Åô„ÇãÈñ¢Êï∞
                            // Êó¢Áü•„ÅÆ„Éë„É©„É°„Éº„ÇøÔºàangle, taperÔºâ„Çí‰ΩøÁî®„Åó„Å¶Á¢∫ÂÆü„Å´Ë£úÊ≠£
                            function getOrientationCorrection(snappedRotation) {
                                const rotXDeg = Math.round(THREE.MathUtils.radToDeg(snappedRotation.x));
                                const rotZDeg = Math.round(THREE.MathUtils.radToDeg(snappedRotation.z));
                                
                                // „Éó„É≠„Éï„Ç°„Ç§„É´„Åã„ÇâÂÇæÊñúËßíÂ∫¶„ÇíÂèñÂæóÔºàgetProfile()„Å®Âêå„Åò„É≠„Ç∏„ÉÉ„ÇØÔºâ
                                const profileData = PROFILES[state.profile];
                                const rowData = profileData[state.row] || profileData.all || { h: 9.5, a: 0 };
                                const typingAngle = rowData.a || 0;  // „Éó„É≠„Éï„Ç°„Ç§„É´„ÅÆÂÇæÊñúËßíÂ∫¶ÔºàÂ∫¶Ôºâ
                                const dishType = state.dishType || 'cylindrical';
                                
                                // „ÉÜ„Éº„Éë„ÉºËßíÂ∫¶„ÇíË®àÁÆó
                                // topScaleÔºà‰∏äÈù¢„Çπ„Ç±„Éº„É´Ôºâ„Å®È´ò„Åï„Åã„Çâ„ÉÜ„Éº„Éë„ÉºËßíÂ∫¶„ÇíÁÆóÂá∫
                                const topScale = state.topScale || 0.85;
                                const keycapHeight = rowData.h || 9.5;
                                const unit = parseFloat(state.unitSize) || 19.05;
                                const baseWidth = (unit * (state.uSize || 1.0)) - 0.5;
                                
                                // „ÉÜ„Éº„Éë„ÉºËßíÂ∫¶ = atan((Â∫ïÈù¢ÂπÖ/2 - ‰∏äÈù¢ÂπÖ/2) / È´ò„Åï)
                                const bottomHalfWidth = baseWidth / 2;
                                const topHalfWidth = (baseWidth * topScale) / 2;
                                const taperAngle = THREE.MathUtils.radToDeg(Math.atan((bottomHalfWidth - topHalfWidth) / keycapHeight));
                                
                                console.log('[CSK-V2] ÈÖçÁΩÆË£úÊ≠£: rotXDeg=' + rotXDeg + ', rotZDeg=' + rotZDeg + ', taperAngle=' + taperAngle.toFixed(2) + ', topScale=' + topScale + ', dishType=' + dishType);
                                
                                let correctionX = 0;  // XËª∏Ë£úÊ≠£Ôºà„É©„Ç∏„Ç¢„É≥Ôºâ
                                let correctionZ = 0;  // ZËª∏Ë£úÊ≠£Ôºà„É©„Ç∏„Ç¢„É≥Ôºâ
                                
                                // ‰∏ãÈù¢„Åå‰∏ãÔºà„Éá„Éï„Ç©„É´„ÉàÔºâ: Ë£úÊ≠£‰∏çË¶Å
                                if (snappedRotation.x === 0 && snappedRotation.y === 0 && snappedRotation.z === 0) {
                                    console.log('[CSK-V2] ‰∏ãÈù¢„Åå‰∏ã: Ë£úÊ≠£„Å™„Åó');
                                    return { x: 0, z: 0 };
                                }
                                
                                // ‰∏äÈù¢„Åå‰∏ãÔºàrotX = 180 or -180Ôºâ„Åã„Å§ dishType „Åå flat „ÅÆÂ†¥Âêà„ÅÆ„ÅøË£úÊ≠£
                                if (Math.abs(rotXDeg) === 180) {
                                    if (dishType === 'flat') {
                                        correctionX = THREE.MathUtils.degToRad(-typingAngle);
                                        console.log('[CSK-V2] ‰∏äÈù¢flatË£úÊ≠£: typingAngle=' + typingAngle + ', correctionX=' + correctionX);
                                    }
                                    return { x: correctionX, z: 0 };
                                }
                                
                                // ÂâçÈù¢„Åå‰∏ãÔºàrotX = -90Ôºâ- Ë£úÊ≠£„Å™„Åó
                                if (rotXDeg === -90) {
                                    console.log('[CSK-V2] ÂâçÈù¢„Åå‰∏ã: Ë£úÊ≠£„Å™„Åó');
                                    return { x: 0, z: 0 };
                                }
                                
                                // ÂæåÈù¢„Åå‰∏ãÔºàrotX = 90Ôºâ- Ë£úÊ≠£„Å™„Åó
                                if (rotXDeg === 90) {
                                    console.log('[CSK-V2] ÂæåÈù¢„Åå‰∏ã: Ë£úÊ≠£„Å™„Åó');
                                    return { x: 0, z: 0 };
                                }
                                
                                // Â∑¶Èù¢„Åå‰∏ãÔºàrotZ = 90Ôºâ- Ë£úÊ≠£„Å™„Åó
                                if (rotZDeg === 90) {
                                    console.log('[CSK-V2] Â∑¶Èù¢„Åå‰∏ã: Ë£úÊ≠£„Å™„Åó');
                                    return { x: 0, z: 0 };
                                }
                                
                                // Âè≥Èù¢„Åå‰∏ãÔºàrotZ = -90Ôºâ- Ë£úÊ≠£„Å™„Åó
                                if (rotZDeg === -90) {
                                    console.log('[CSK-V2] Âè≥Èù¢„Åå‰∏ã: Ë£úÊ≠£„Å™„Åó');
                                    return { x: 0, z: 0 };
                                }
                                
                                console.log('[CSK-V2] Êù°‰ª∂„Å´‰∏ÄËá¥„Åó„Å™„ÅÑ: Ë£úÊ≠£„Å™„Åó');
                                return { x: 0, z: 0 };
                            }
                            
                            // Ë£úÊ≠£ËßíÂ∫¶„ÇíÂèñÂæó
                            const tiltCorrection = getOrientationCorrection(snappedRot);
                            
                            // V67.3: buildExportGeometry„Çí‰ΩøÁî®„Åó„Å¶ÊúÄÈÅ©Âåñ„Åï„Çå„Åü„Ç∏„Ç™„É°„Éà„É™„ÇíÂèñÂæó
                            const { bodyGeo: exportBodyGeo, textGeo: exportTextGeo } = buildExportGeometry();
                            
                            if (exportBodyGeo) {
                                let bodyGeo = exportBodyGeo.clone();
                                
                                // „Çπ„Éä„ÉÉ„Éó„Åï„Çå„ÅüÈÖçÁΩÆÊñπÂêë„ÅÆÂõûËª¢„ÇíÈÅ©Áî®Ôºà90Â∫¶Âçò‰ΩçÔºâ
                                if (snappedRot.x !== 0) bodyGeo.rotateX(snappedRot.x);
                                if (snappedRot.y !== 0) bodyGeo.rotateY(snappedRot.y);
                                if (snappedRot.z !== 0) bodyGeo.rotateZ(snappedRot.z);
                                // ÂæìÊù•„ÅÆYËª∏ÂõûËª¢Ôºà„Çµ„É†„Éç„Ç§„É´ÂõûËª¢Áî®Ôºâ
                                if (rotYRad !== 0) bodyGeo.rotateY(rotYRad);
                                
                                // ÂÇæÊñúË£úÊ≠£„ÇíÈÅ©Áî®ÔºàÊó¢Áü•„ÅÆ„Éë„É©„É°„Éº„Çø„Å´Âü∫„Å•„ÅèÔºâ
                                if (tiltCorrection.x !== 0) bodyGeo.rotateX(tiltCorrection.x);
                                if (tiltCorrection.z !== 0) bodyGeo.rotateZ(tiltCorrection.z);
                                
                                // „Éê„Ç¶„É≥„Éá„Ç£„É≥„Ç∞„Éú„ÉÉ„ÇØ„Çπ„ÇíË®àÁÆóÔºàË£úÊ≠£ÂæåÔºâ
                                bodyGeo.computeBoundingBox();
                                const bbox = bodyGeo.boundingBox;
                                
                                // ÊúÄ‰ΩéÁÇπ„ÅåY=0„Å´„Å™„Çã„Çà„ÅÜ„Å´„Ç™„Éï„Çª„ÉÉ„Éà
                                yOffset = -bbox.min.y;
                                
                                // „Ç≤„Éº„ÉàÊé•Á∂ö‰ΩçÁΩÆ„ÅØÂõûËª¢Âæå„ÅÆ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆ‰∏≠ÂøÉÈ´ò„Åï
                                const keycapHeight = bbox.max.y - bbox.min.y;
                                gateHeight = keycapHeight / 2;
                                
                                // „Ç∏„Ç™„É°„Éà„É™„ÅÆ‰∏≠ÂøÉÂ∫ßÊ®ôÔºàÂõûËª¢Âæå„ÄÅtranslateÂâçÔºâ
                                const geoCenterX = (bbox.max.x + bbox.min.x) / 2;
                                const geoCenterZ = (bbox.max.z + bbox.min.z) / 2;
                                
                                // ZÊñπÂêë„ÅÆ„Çµ„Ç§„Ç∫
                                const geoDepth = bbox.max.z - bbox.min.z;
                                
                                // V67.3: „Éñ„É™„ÉÉ„Ç∏Êé•Á∂öÁÇπ„ÇíË®àÁÆóÔºàÂõûËª¢Ââç„ÅÆÂâçÈù¢„ÉªÂæåÈù¢‰∏≠ÂøÉ ‚Üí ÂõûËª¢ÈÅ©Áî® ‚Üí translateÔºâ
                                // „Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂâçÈù¢„ÉªÂæåÈù¢‰∏≠ÂøÉÁÇπÔºàÂõûËª¢Ââç„ÄÅÂéüÁÇπ‰∏≠ÂøÉÔºâ
                                const frontPoint = new THREE.Vector3(0, kcHeight / 2, -kcDepth / 2);
                                const backPoint = new THREE.Vector3(0, kcHeight / 2, kcDepth / 2);
                                
                                // ÂõûËª¢„ÇíÈÅ©Áî®ÔºàsnappedRot + rotYRadÔºâ
                                const rotEuler = new THREE.Euler(snappedRot.x, snappedRot.y, snappedRot.z, 'XYZ');
                                const rotQuat = new THREE.Quaternion().setFromEuler(rotEuler);
                                frontPoint.applyQuaternion(rotQuat);
                                backPoint.applyQuaternion(rotQuat);
                                
                                // YËª∏ÂõûËª¢
                                if (rotYRad !== 0) {
                                    const yRotQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotYRad);
                                    frontPoint.applyQuaternion(yRotQuat);
                                    backPoint.applyQuaternion(yRotQuat);
                                }
                                
                                // ÂÇæÊñúË£úÊ≠£„ÇíÈÅ©Áî®
                                if (tiltCorrection.x !== 0 || tiltCorrection.z !== 0) {
                                    const tiltEuler = new THREE.Euler(tiltCorrection.x, 0, tiltCorrection.z, 'XYZ');
                                    const tiltQuat = new THREE.Quaternion().setFromEuler(tiltEuler);
                                    frontPoint.applyQuaternion(tiltQuat);
                                    backPoint.applyQuaternion(tiltQuat);
                                }
                                
                                // translate„ÇíÈÅ©Áî®
                                frontPoint.add(new THREE.Vector3(xPos, yOffset, zPos));
                                backPoint.add(new THREE.Vector3(xPos, yOffset, zPos));
                                
                                bodyGeo.translate(xPos, yOffset, zPos);
                                keycapObj.bodyGeo = bodyGeo;
                                
                                // translateÂæå„ÅÆÂÆüÈöõ„ÅÆ‰∏≠ÂøÉÂ∫ßÊ®ô„Å®ÂâçÈù¢„ÉªÂæåÈù¢Â∫ßÊ®ô
                                const actualCenterX = xPos + geoCenterX;
                                const actualCenterZ = zPos + geoCenterZ;
                                const realMinZ = actualCenterZ - geoDepth / 2;  // „Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂâçÈù¢
                                const realMaxZ = actualCenterZ + geoDepth / 2;  // „Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂæåÈù¢
                                
                                // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
                                const alreadyExists = keycapPositions.some(p => 
                                    Math.abs(p.x - actualCenterX) < 0.1 && Math.abs(p.centerZ - actualCenterZ) < 0.1
                                );
                                if (!alreadyExists) {
                                    keycapPositions.push({ 
                                        x: actualCenterX,      // „Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂÆüÈöõ„ÅÆ‰∏≠ÂøÉXÂ∫ßÊ®ô
                                        centerZ: actualCenterZ, // „Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂÆüÈöõ„ÅÆ‰∏≠ÂøÉZÂ∫ßÊ®ô
                                        minZ: realMinZ,        // „Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂâçÈù¢ZÂ∫ßÊ®ô
                                        maxZ: realMaxZ,        // „Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂæåÈù¢ZÂ∫ßÊ®ô
                                        gateY: gateHeight,
                                        relRow: relRow,        // V67.3: Ë°åÁï™Âè∑ÔºàÊ®™Ê£íÊé•Á∂öÁî®Ôºâ
                                        // V67.3: „Éñ„É™„ÉÉ„Ç∏Êé•Á∂öÁÇπÔºà„Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóË°®Èù¢„ÅÆ‰∏≠ÂøÉÔºâ
                                        frontAttach: { x: frontPoint.x, y: frontPoint.y, z: frontPoint.z },
                                        backAttach: { x: backPoint.x, y: backPoint.y, z: backPoint.z }
                                    });
                                }
                                previewGeos.push(bodyGeo.clone());
                            }
                            
                            if (exportTextGeo) {
                                let textGeo = exportTextGeo.clone();
                                
                                // „Çπ„Éä„ÉÉ„Éó„Åï„Çå„ÅüÈÖçÁΩÆÊñπÂêë„ÅÆÂõûËª¢„ÇíÈÅ©Áî®
                                if (snappedRot.x !== 0) textGeo.rotateX(snappedRot.x);
                                if (snappedRot.y !== 0) textGeo.rotateY(snappedRot.y);
                                if (snappedRot.z !== 0) textGeo.rotateZ(snappedRot.z);
                                // ÂæìÊù•„ÅÆYËª∏ÂõûËª¢
                                if (rotYRad !== 0) textGeo.rotateY(rotYRad);
                                // body„Å®Âêå„ÅòÂÇæÊñúË£úÊ≠£„ÇíÈÅ©Áî®
                                if (tiltCorrection.x !== 0) textGeo.rotateX(tiltCorrection.x);
                                if (tiltCorrection.z !== 0) textGeo.rotateZ(tiltCorrection.z);
                                textGeo.translate(xPos, yOffset, zPos);
                                keycapObj.textGeo = textGeo;
                            }

                            keycapObjects.push(keycapObj);
                            keycapIndex++;
                        }

                        // Restore state
                        Object.assign(state, savedState);
                        requestUpdate();

                        if (keycapObjects.length === 0) {
                            hideProgressToast('„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', true);
                            return;
                        }
                        
                        // „É©„É≥„Éä„ÉºÁîüÊàê„Éï„Çß„Éº„Ç∫
                        updateProgressToast('„É©„É≥„Éä„Éº„ÇíÁîüÊàê‰∏≠...', ((filledSlots.length + 0.5) / totalSteps) * 100);

                        // „É©„É≥„Éä„ÉºÁîüÊàê
                        const runnerThick = 3.0;
                        const keyHeight = p.h;
                        
                        // ÂÖ®„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÊúÄÂ§ß„Ç≤„Éº„ÉàÈ´ò„Åï„ÇíË®àÁÆó
                        const maxGateY = Math.max(...keycapPositions.map(k => k.gateY || keyHeight * 0.5));
                        const runnerTopY = maxGateY + runnerThick / 2; // „É©„É≥„Éä„Éº‰∏äÈÉ®„ÅÆÈ´ò„ÅïÔºà„Éñ„É™„ÉÉ„Ç∏„Å´Âêà„Çè„Åõ„ÇãÔºâ
                        
                        const frameW = gridWidth + keyW + 25;
                        const frameD = gridDepth + keyD + 25;
                        
                        // V67.3: ÂÖ®„Å¶„ÅÆË°å„ÅÆÊ®™Ê£í‰ΩçÁΩÆ„ÇíË®àÁÆóÔºàÂâçÂæå + ‰∏≠ÈñìÔºâ
                        // usedRowsË°å„ÅÇ„ÇãÂ†¥Âêà„ÄÅusedRows+1Êú¨„ÅÆÊ®™Ê£í„ÅåÂøÖË¶Å
                        const allBarZPositions = [];
                        for (let row = 0; row <= usedRows; row++) {
                            const barZ = -gridDepth / 2 - zSp / 2 + row * zSp;
                            allBarZPositions.push(barZ);
                        }
                        const frontBarZ = allBarZPositions[0];  // ÊúÄÂâçÊñπ„ÅÆÊ®™Ê£í
                        const backBarZ = allBarZPositions[allBarZPositions.length - 1];  // ÊúÄÂæåÊñπ„ÅÆÊ®™Ê£í

                        // Ê®™Ê£íÔºàÂÖ®„Å¶„ÅÆË°å - 4ÊñπÂêëÂõ≤„Åø„ÅÆ„Åü„ÇÅÔºâ
                        allBarZPositions.forEach(barZ => {
                            // Â∫ïÈù¢„Éê„ÉºÔºàY=0„Åã„ÇâÔºâ
                            const hBar = new THREE.BoxGeometry(frameW, runnerThick, runnerThick);
                            hBar.translate(0, runnerThick / 2, barZ);
                            runnerGeos.push(hBar);
                            previewGeos.push(hBar.clone());

                            // „Éñ„É™„ÉÉ„Ç∏È´ò„Åï„ÅÆ„Éà„ÉÉ„Éó„Éê„Éº
                            const topBar = new THREE.BoxGeometry(frameW, runnerThick, runnerThick);
                            topBar.translate(0, runnerTopY, barZ);
                            runnerGeos.push(topBar);
                            previewGeos.push(topBar.clone());

                            // ÊîØÊü±Ôºà‰∏°Á´Ø„Å®‰∏≠Â§ÆÔºâ- Â∫ïÈù¢„Åã„Çâ„Éà„ÉÉ„Éó„Éê„Éº„Åæ„Åß
                            const supportXPositions = [-frameW / 2 + runnerThick / 2, 0, frameW / 2 - runnerThick / 2];
                            supportXPositions.forEach(sx => {
                                const vSup = new THREE.BoxGeometry(runnerThick, runnerTopY, runnerThick);
                                vSup.translate(sx, runnerTopY / 2, barZ);
                                runnerGeos.push(vSup);
                                previewGeos.push(vSup.clone());
                            });
                        });

                        // Á∏¶Ê£íÔºàÂ∑¶Âè≥Á´Ø„ÅÆ„ÅøÔºâ- Â∫ïÈù¢„ÅÆ„Åø
                        const leftBar = new THREE.BoxGeometry(runnerThick, runnerThick, frameD);
                        leftBar.translate(-frameW / 2 + runnerThick / 2, runnerThick / 2, 0);
                        runnerGeos.push(leftBar);
                        previewGeos.push(leftBar.clone());

                        const rightBar = new THREE.BoxGeometry(runnerThick, runnerThick, frameD);
                        rightBar.translate(frameW / 2 - runnerThick / 2, runnerThick / 2, 0);
                        runnerGeos.push(rightBar);
                        previewGeos.push(rightBar.clone());

                        // „Éñ„É™„ÉÉ„Ç∏ÔºàÊ®™Ê£í„Åã„Çâ„Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóË°®Èù¢„Å∏Ôºâ
                        // „Éã„ÉÉ„Éë„Éº„ÅßÂàá„Çä„ÇÑ„Åô„ÅÑ„Çà„ÅÜÁ¥∞„Åè
                        const bridgeWidth = 0.8;   // Á¥∞„ÅÑ„Éñ„É™„ÉÉ„Ç∏
                        const bridgeThick = 0.8;
                        const bridgePenetration = 1.2; // È£ü„ÅÑËæº„ÅøÈáèÔºàÂ£Å„ÅÆÂÜÖÂÅ¥ÊâãÂâç„Åæ„Åß„ÄÅÂ£ÅÂéöÁ¥Ñ1.5mm„Å™„ÅÆ„ÅßÔºâ
                        const bridgePillarWidth = 1.5; // Êü±„ÅÆÂπÖ
                        
                        keycapPositions.forEach(k => {
                            const thisGateY = k.gateY || keyHeight * 0.5;
                            
                            // V67.3: ÂêÑ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆË°å„Å´ÂØæÂøú„Åô„ÇãÂâçÂæå„ÅÆÊ®™Ê£í„Çí‰ΩøÁî®
                            const rowIndex = k.relRow !== undefined ? k.relRow : 0;
                            const thisFrontBarZ = allBarZPositions[rowIndex];      // „Åì„ÅÆË°å„ÅÆÂâçÊñπÊ®™Ê£í
                            const thisBackBarZ = allBarZPositions[rowIndex + 1];   // „Åì„ÅÆË°å„ÅÆÂæåÊñπÊ®™Ê£í
                            
                            // V67.3: „Éñ„É™„ÉÉ„Ç∏Êé•Á∂öÁÇπ„Çí‰ΩøÁî®Ôºà„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂÇæ„Åç„Éª„Å≠„Åò„Çå„Å´ÂØæÂøúÔºâ
                            const frontAttach = k.frontAttach || { x: k.x, y: thisGateY, z: k.minZ };
                            const backAttach = k.backAttach || { x: k.x, y: thisGateY, z: k.maxZ };
                            
                            // === ÂâçÊñπ„Éñ„É™„ÉÉ„Ç∏ÔºàÊ®™Ê£í„Åã„Çâ„Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÂâçÈù¢„Å∏Ôºâ===
                            // Ê®™Ê£íÂÅ¥„ÅÆÂßãÁÇπÔºà„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÊé•Á∂öÁÇπ„ÅÆXÂ∫ßÊ®ô„Çí‰ΩøÁî®Ôºâ
                            const frontStart = new THREE.Vector3(frontAttach.x, thisGateY, thisFrontBarZ);
                            // „Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÂÅ¥„ÅÆÊé•Á∂öÁÇπ
                            const frontAttachVec = new THREE.Vector3(frontAttach.x, frontAttach.y, frontAttach.z);
                            
                            // Ê®™Ê£í„Åã„Çâ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Å∏„ÅÆÊñπÂêë
                            const frontToKeycap = new THREE.Vector3().subVectors(frontAttachVec, frontStart);
                            const frontToKeycapLen = frontToKeycap.length();
                            const frontToKeycapDir = frontToKeycap.clone().normalize();
                            
                            // È£ü„ÅÑËæº„Åø„ÇíÂä†„Åà„ÅüÁµÇÁÇπ
                            const frontEnd = frontAttachVec.clone().add(frontToKeycapDir.clone().multiplyScalar(bridgePenetration));
                            
                            // „Éñ„É™„ÉÉ„Ç∏„ÅÆÈï∑„Åï
                            const frontBridgeLen = frontToKeycapLen + bridgePenetration;
                            
                            // „Éñ„É™„ÉÉ„Ç∏„Çí‰ΩúÊàêÔºàZËª∏ÊñπÂêë„Å´‰ΩúÊàê„Åó„Å¶ÂõûËª¢Ôºâ
                            const frontBridge = new THREE.BoxGeometry(bridgeWidth, bridgeThick, frontBridgeLen);
                            const zAxis = new THREE.Vector3(0, 0, 1);
                            if (frontToKeycapDir.length() > 0.01) {
                                const frontQuat = new THREE.Quaternion().setFromUnitVectors(zAxis, frontToKeycapDir);
                                frontBridge.applyQuaternion(frontQuat);
                            }
                            
                            // ‰∏≠ÂøÉ‰ΩçÁΩÆ„Å´ÈÖçÁΩÆ
                            const frontCenter = new THREE.Vector3().addVectors(frontStart, frontEnd).multiplyScalar(0.5);
                            frontBridge.translate(frontCenter.x, frontCenter.y, frontCenter.z);
                            runnerGeos.push(frontBridge);
                            previewGeos.push(frontBridge.clone());
                            
                            // ÂâçÊñπ„Éñ„É™„ÉÉ„Ç∏Áî®„ÅÆÊü±Ôºà„Éô„Éº„Çπ„Åã„Çâ„Éñ„É™„ÉÉ„Ç∏È´ò„Åï„Åæ„ÅßÔºâ
                            const frontPillarHeight = Math.max(thisGateY, frontAttach.y);
                            const frontPillar = new THREE.BoxGeometry(bridgePillarWidth, frontPillarHeight, bridgePillarWidth);
                            frontPillar.translate(frontAttach.x, frontPillarHeight / 2, thisFrontBarZ);
                            runnerGeos.push(frontPillar);
                            previewGeos.push(frontPillar.clone());

                            // === ÂæåÊñπ„Éñ„É™„ÉÉ„Ç∏ÔºàÊ®™Ê£í„Åã„Çâ„Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÂæåÈù¢„Å∏Ôºâ===
                            // Ê®™Ê£íÂÅ¥„ÅÆÂßãÁÇπ
                            const backStart = new THREE.Vector3(backAttach.x, thisGateY, thisBackBarZ);
                            // „Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÂÅ¥„ÅÆÊé•Á∂öÁÇπ
                            const backAttachVec = new THREE.Vector3(backAttach.x, backAttach.y, backAttach.z);
                            
                            // Ê®™Ê£í„Åã„Çâ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Å∏„ÅÆÊñπÂêë
                            const backToKeycap = new THREE.Vector3().subVectors(backAttachVec, backStart);
                            const backToKeycapLen = backToKeycap.length();
                            const backToKeycapDir = backToKeycap.clone().normalize();
                            
                            // È£ü„ÅÑËæº„Åø„ÇíÂä†„Åà„ÅüÁµÇÁÇπ
                            const backEnd = backAttachVec.clone().add(backToKeycapDir.clone().multiplyScalar(bridgePenetration));
                            
                            // „Éñ„É™„ÉÉ„Ç∏„ÅÆÈï∑„Åï
                            const backBridgeLen = backToKeycapLen + bridgePenetration;
                            
                            // „Éñ„É™„ÉÉ„Ç∏„Çí‰ΩúÊàêÔºàZËª∏ÊñπÂêë„Å´‰ΩúÊàê„Åó„Å¶ÂõûËª¢Ôºâ
                            const backBridge = new THREE.BoxGeometry(bridgeWidth, bridgeThick, backBridgeLen);
                            if (backToKeycapDir.length() > 0.01) {
                                const backQuat = new THREE.Quaternion().setFromUnitVectors(zAxis, backToKeycapDir);
                                backBridge.applyQuaternion(backQuat);
                            }
                            
                            // ‰∏≠ÂøÉ‰ΩçÁΩÆ„Å´ÈÖçÁΩÆ
                            const backCenter = new THREE.Vector3().addVectors(backStart, backEnd).multiplyScalar(0.5);
                            backBridge.translate(backCenter.x, backCenter.y, backCenter.z);
                            runnerGeos.push(backBridge);
                            previewGeos.push(backBridge.clone());
                            
                            // ÂæåÊñπ„Éñ„É™„ÉÉ„Ç∏Áî®„ÅÆÊü±Ôºà„Éô„Éº„Çπ„Åã„Çâ„Éñ„É™„ÉÉ„Ç∏È´ò„Åï„Åæ„ÅßÔºâ
                            const backPillarHeight = Math.max(thisGateY, backAttach.y);
                            const backPillar = new THREE.BoxGeometry(bridgePillarWidth, backPillarHeight, bridgePillarWidth);
                            backPillar.translate(backAttach.x, backPillarHeight / 2, thisBackBarZ);
                            runnerGeos.push(backPillar);
                            previewGeos.push(backPillar.clone());
                        });

                        // ÈÖçÁΩÆÊÉÖÂ†±„Çí‰ΩúÊàê
                        const filledCount = cskGridData.filter(d => d !== null).length;
                        const printerLabel = document.getElementById('csk-printer-model')?.selectedOptions[0]?.text || '';
                        const sizeLabel = document.getElementById('csk-printer-size')?.selectedOptions[0]?.text || '';

                        // ExtruderÊú™Ë®≠ÂÆö„ÅÆ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                        const unconfiguredKeycaps = [];
                        cskGridData.forEach((data, idx) => {
                            if (data) {
                                const hasBodyExtruder = data.bodyExtruder !== null && data.bodyExtruder !== undefined;
                                const hasTextExtruder = data.textExtruder !== null && data.textExtruder !== undefined;
                                if (!hasBodyExtruder || !hasTextExtruder) {
                                    const name = data.galleryItem?.name || `„Çπ„É≠„ÉÉ„Éà${idx + 1}`;
                                    unconfiguredKeycaps.push({
                                        index: idx,
                                        name: name,
                                        missingBody: !hasBodyExtruder,
                                        missingText: !hasTextExtruder
                                    });
                                }
                            }
                        });

                        // „Ç®„ÇØ„Çπ„Éù„Éº„ÉàÁ¢∫Ë™çÁîªÈù¢„ÇíË°®Á§∫Ôºà„Éó„É¨„Éì„É•„Éº„Ç∏„Ç™„É°„Éà„É™‰ªò„ÅçÔºâ
                        const result = await showExportPopup({
                            type: 'sprue',
                            format: '3MF',
                            showFormatSelector: true,
                            printer: printerLabel,
                            buildSize: sizeLabel,
                            keyCount: filledCount,
                            layout: `${usedRows}Ë°å √ó ${usedCols}Âàó („Ç´„Çπ„Çø„É†)`,
                            charList: '„Ç´„Çπ„Çø„É†ÈÖçÁΩÆ',
                            spruePreviewGeos: previewGeos,
                            fromCSK: true,  // CSK„Åã„ÇâÂëº„Å≥Âá∫„Åï„Çå„Åü„Åì„Å®„ÇíÁ§∫„Åô„Éï„É©„Ç∞
                            cskUnconfigured: unconfiguredKeycaps  // ExtruderÊú™Ë®≠ÂÆö„ÅÆ„Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÊÉÖÂ†±
                        });

                        if (!result.confirmed) {
                            // „Ç≠„É£„É≥„Çª„É´ÊôÇ„ÅØ„Éó„É≠„Ç∞„É¨„Çπ„Éà„Éº„Çπ„Éà„ÇíÈùûË°®Á§∫„Å´„Åó„Å¶CSK„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÇíÂÜçË°®Á§∫
                            hideProgressToast();
                            const cskOverlay = document.getElementById('csk-overlay');
                            const cskDialog = document.getElementById('csk-dialog');
                            cskOverlay.style.display = 'flex';
                            requestAnimationFrame(() => {
                                cskOverlay.style.background = 'rgba(0,0,0,0.7)';
                                cskDialog.classList.add('show');
                            });
                            return;
                        }

                        // V67.3: MeshFixLib„Åß„Ç∏„Ç™„É°„Éà„É™„Çí‰øÆÂæ©„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞
                        async function repairGeoWithMeshFixCSK(geo, name) {
                            if (!geo) return null;
                            
                            let g = geo.clone();
                            if (!g.index) g = BufferGeometryUtils.mergeVertices(g, 0.0001);
                            
                            const position = g.attributes.position;
                            const index = g.index;
                            if (!position) return geo;
                            
                            // È†ÇÁÇπÈÖçÂàó„Çí‰ΩúÊàê
                            const vertices = [];
                            for (let i = 0; i < position.count; i++) {
                                vertices.push([position.getX(i), position.getY(i), position.getZ(i)]);
                            }
                            
                            // ‰∏âËßíÂΩ¢ÈÖçÂàó„Çí‰ΩúÊàê
                            const triangles = [];
                            if (index && index.array) {
                                const arr = index.array;
                                for (let i = 0; i < arr.length; i += 3) {
                                    triangles.push([arr[i], arr[i+1], arr[i+2]]);
                                }
                            } else {
                                for (let i = 0; i < position.count; i += 3) {
                                    triangles.push([i, i+1, i+2]);
                                }
                            }
                            
                            // MeshFixLib„Åß‰øÆÂæ©
                            const result = await meshFixLib.repairMesh(vertices, triangles);
                            console.log(`[MeshFixLib-CSK] ${name}: Â¢ÉÁïå${result.diagnosis.boundary}, ÈùûÂ§öÊßò‰Ωì${result.diagnosis.nonManifold}`);
                            
                            // ‰øÆÂæ©„Åó„Åü„Éá„Éº„Çø„ÇíÊ†ºÁ¥ç
                            geo._meshFixData = { vertices: result.vertices, triangles: result.triangles };
                            return geo;
                        }

                        // „É©„É≥„Éä„Éº„ÇíÁµêÂêà
                        let runnerMerged = safeMerge(runnerGeos);
                        if (runnerMerged) {
                            runnerMerged.computeVertexNormals();
                            // V67.3: MeshFixLib„Åß‰øÆÂæ©
                            updateProgressToast('„É©„É≥„Éä„Éº„É°„ÉÉ„Ç∑„É•„Çí‰øÆÂæ©‰∏≠...', ((filledSlots.length + 1) / totalSteps) * 100);
                            runnerMerged = await repairGeoWithMeshFixCSK(runnerMerged, '„É©„É≥„Éä„Éº');
                            if (!runnerMerged) {
                                hideProgressToast('„É©„É≥„Éä„Éº‰øÆÂæ©„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', true);
                                Object.assign(state, savedState);
                                syncUI();
                                requestUpdate();
                                return;
                            }
                        }
                        
                        // ÂêÑ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆ„Ç∏„Ç™„É°„Éà„É™„Çí‰øÆÂæ©
                        updateProgressToast('„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„É°„ÉÉ„Ç∑„É•„Çí‰øÆÂæ©‰∏≠...', ((filledSlots.length + 1.5) / totalSteps) * 100);
                        for (let i = 0; i < keycapObjects.length; i++) {
                            const obj = keycapObjects[i];
                            updateProgressToast(`„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó ${i+1}/${keycapObjects.length} „Çí‰øÆÂæ©‰∏≠...`, ((filledSlots.length + 1.5 + (i / keycapObjects.length)) / totalSteps) * 100);
                            if (obj.bodyGeo) {
                                obj.bodyGeo = await repairGeoWithMeshFixCSK(obj.bodyGeo, `„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó${i+1}Êú¨‰Ωì`);
                                if (!obj.bodyGeo) {
                                    hideProgressToast(`„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó${i+1}„ÅÆ‰øÆÂæ©„Å´Â§±Êïó„Åó„Åæ„Åó„Åü`, true);
                                    Object.assign(state, savedState);
                                    syncUI();
                                    requestUpdate();
                                    return;
                                }
                            }
                            if (obj.textGeo) {
                                obj.textGeo = await repairGeoWithMeshFixCSK(obj.textGeo, `„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó${i+1}ÊñáÂ≠ó`);
                                if (!obj.textGeo) {
                                    hideProgressToast(`„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó${i+1}ÊñáÂ≠ó„ÅÆ‰øÆÂæ©„Å´Â§±Êïó„Åó„Åæ„Åó„Åü`, true);
                                    Object.assign(state, savedState);
                                    syncUI();
                                    requestUpdate();
                                    return;
                                }
                            }
                        }
                        
                        // „Ç®„ÇØ„Çπ„Éù„Éº„Éà„Éï„Çß„Éº„Ç∫
                        updateProgressToast('„Éï„Ç°„Ç§„É´„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà‰∏≠...', 95);

                        const fmt = result.format.toLowerCase();

                        if (fmt === 'stl') {
                            // STL„ÅØÂÖ®„Å¶ÁµêÂêà
                            const allGeos = [];
                            keycapObjects.forEach(obj => {
                                if (obj.bodyGeo) allGeos.push(obj.bodyGeo);
                                if (obj.textGeo) allGeos.push(obj.textGeo);
                            });
                            if (runnerMerged) allGeos.push(runnerMerged);
                            const finalGeo = safeMerge(allGeos);
                            finalGeo.computeVertexNormals();
                            const group = new THREE.Group();
                            group.add(new THREE.Mesh(finalGeo, new THREE.MeshStandardMaterial({ color: state.colBody })));
                            const res = new STLExporter().parse(group, { binary: true });
                            saveBlob(new Blob([res], { type: 'application/octet-stream' }), 'custom_sprue_kit.stl');
                        } else if (fmt === '3mf') {
                            // 3MF: „É©„É≥„Éä„Éº + ÂêÑ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆ„Éú„Éá„Ç£„Éª„ÉÜ„Ç≠„Çπ„Éà„ÇíÂÄãÂà•„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å´
                            // „É©„É≥„Éä„Éº„ÅØCSK„ÅßÈÅ∏Êäû„Åó„ÅüExtruder„Çí‰ΩøÁî®
                            const runnerExtruder = cskRunnerExtruder || 1;
                            
                            const zip = new JSZip();
                            
                            // V67.3: MeshFixLib‰øÆÂæ©Ê∏à„Åø„Éá„Éº„Çø„Çí‰ΩøÁî®
                            function geoTo3MFMesh(geometry) {
                                if (!geometry) return null;
                                
                                // MeshFixLib‰øÆÂæ©Ê∏à„Åø„Éá„Éº„Çø„Åå„ÅÇ„Çå„Å∞„Åù„Çå„Çí‰ΩøÁî®
                                if (geometry._meshFixData) {
                                    const { vertices, triangles } = geometry._meshFixData;
                                    return {
                                        vertices: vertices.map(v => `        <vertex x="${v[0].toFixed(6)}" y="${v[1].toFixed(6)}" z="${v[2].toFixed(6)}" />`),
                                        triangles: triangles.map(t => `        <triangle v1="${t[0]}" v2="${t[1]}" v3="${t[2]}" />`)
                                    };
                                }
                                
                                // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÂæìÊù•„ÅÆÂá¶ÁêÜ
                                let geo = geometry;
                                if (!geo.index) geo = BufferGeometryUtils.mergeVertices(geo.clone(), 0.0001);
                                
                                const position = geo.attributes.position;
                                if (!position) return null;
                                
                                const vertices = [];
                                const triangles = [];
                                
                                const index = geo.index;
                                
                                if (index && index.array) {
                                    for (let i = 0; i < position.count; i++) {
                                        vertices.push(`        <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                                    }
                                    const indexArray = index.array;
                                    for (let i = 0; i < indexArray.length; i += 3) {
                                        triangles.push(`        <triangle v1="${indexArray[i]}" v2="${indexArray[i+1]}" v3="${indexArray[i+2]}" />`);
                                    }
                                } else {
                                    for (let i = 0; i < position.count; i++) {
                                        vertices.push(`        <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                                    }
                                    for (let i = 0; i < position.count; i += 3) {
                                        triangles.push(`        <triangle v1="${i}" v2="${i+1}" v3="${i+2}" />`);
                                    }
                                }
                                
                                return { vertices, triangles };
                            }

                            let objectXml = '';
                            let componentRefs = [];
                            let volumeConfigs = [];
                            let objectId = 1;

                            // „É©„É≥„Éä„Éº
                            if (runnerMerged) {
                                const runnerData = geoTo3MFMesh(runnerMerged);
                                if (runnerData) {
                                    objectXml += `    <object id="${objectId}" type="model">
      <mesh>
        <vertices>
${runnerData.vertices.join('\n')}
        </vertices>
        <triangles>
${runnerData.triangles.join('\n')}
        </triangles>
      </mesh>
    </object>\n`;
                                    componentRefs.push({ id: objectId, name: 'Runner' });
                                    volumeConfigs.push({ id: volumeConfigs.length, extruder: runnerExtruder, name: 'Runner', objectId: objectId });
                                    objectId++;
                                }
                            }

                            // Âêå„ÅòExtruderÁï™Âè∑„ÅÆ„Ç∏„Ç™„É°„Éà„É™„Çí„Ç∞„É´„Éº„ÉóÂåñ
                            const bodyGroups = {};  // { extruder: [geo1, geo2, ...] }
                            const textGroups = {};  // { extruder: [geo1, geo2, ...] }
                            
                            keycapObjects.forEach(kcObj => {
                                if (kcObj.bodyGeo) {
                                    const ext = kcObj.bodyExtruder;
                                    if (!bodyGroups[ext]) bodyGroups[ext] = [];
                                    bodyGroups[ext].push(kcObj.bodyGeo);
                                }
                                if (kcObj.textGeo) {
                                    const ext = kcObj.textExtruder;
                                    if (!textGroups[ext]) textGroups[ext] = [];
                                    textGroups[ext].push(kcObj.textGeo);
                                }
                            });

                            // V67.3: „Éû„Éº„Ç∏Âæå„ÅÆ„Ç∏„Ç™„É°„Éà„É™„Çí‰øÆÂæ©„Åô„Çã„Éò„É´„Éë„Éº
                            async function repairMergedGeo(geo, name) {
                                if (!geo) return null;
                                
                                let g = geo;
                                if (!g.index) g = BufferGeometryUtils.mergeVertices(g, 0.0001);
                                
                                const position = g.attributes.position;
                                const index = g.index;
                                if (!position) return geo;
                                
                                const vertices = [];
                                for (let i = 0; i < position.count; i++) {
                                    vertices.push([position.getX(i), position.getY(i), position.getZ(i)]);
                                }
                                
                                const triangles = [];
                                if (index && index.array) {
                                    const arr = index.array;
                                    for (let i = 0; i < arr.length; i += 3) {
                                        triangles.push([arr[i], arr[i+1], arr[i+2]]);
                                    }
                                } else {
                                    for (let i = 0; i < position.count; i += 3) {
                                        triangles.push([i, i+1, i+2]);
                                    }
                                }
                                
                                console.log(`[MeshFixLib-CSK] ${name}: ‰øÆÂæ©Ââç - ${vertices.length}È†ÇÁÇπ, ${triangles.length}‰∏âËßíÂΩ¢`);
                                const result = await meshFixLib.repairMesh(vertices, triangles);
                                console.log(`[MeshFixLib-CSK] ${name}: ‰øÆÂæ©Âæå - ${result.vertices.length}È†ÇÁÇπ, ${result.triangles.length}‰∏âËßíÂΩ¢, Â¢ÉÁïå${result.diagnosis.boundary}, ÈùûÂ§öÊßò‰Ωì${result.diagnosis.nonManifold}`);
                                
                                geo._meshFixData = { vertices: result.vertices, triangles: result.triangles };
                                return geo;
                            }

                            // „Éú„Éá„Ç£„Ç∞„É´„Éº„Éó„ÇíÂá∫Âäõ
                            const bodyExtKeys = Object.keys(bodyGroups).sort((a,b) => a - b);
                            for (let bi = 0; bi < bodyExtKeys.length; bi++) {
                                const ext = bodyExtKeys[bi];
                                const geos = bodyGroups[ext];
                                let mergedGeo = geos.length > 1 ? safeMerge(geos) : geos[0];
                                if (mergedGeo) {
                                    mergedGeo.computeVertexNormals();
                                    
                                    // V67.3: „Éû„Éº„Ç∏Âæå„Å´‰øÆÂæ©
                                    updateProgressToast(`„Éú„Éá„Ç£„É°„ÉÉ„Ç∑„É•(Ext${ext})„Çí‰øÆÂæ©‰∏≠...`, 96);
                                    mergedGeo = await repairMergedGeo(mergedGeo, `Body_Ext${ext}`);
                                    
                                    const bodyData = geoTo3MFMesh(mergedGeo);
                                    if (bodyData) {
                                        const name = bodyExtKeys.length === 1 ? 'Body' : `Body_Ext${ext}`;
                                        objectXml += `    <object id="${objectId}" type="model">
      <mesh>
        <vertices>
${bodyData.vertices.join('\n')}
        </vertices>
        <triangles>
${bodyData.triangles.join('\n')}
        </triangles>
      </mesh>
    </object>\n`;
                                        componentRefs.push({ id: objectId, name: name });
                                        volumeConfigs.push({ id: volumeConfigs.length, extruder: parseInt(ext), name: name, objectId: objectId });
                                        objectId++;
                                    }
                                }
                            }

                            // „ÉÜ„Ç≠„Çπ„Éà„Ç∞„É´„Éº„Éó„ÇíÂá∫Âäõ
                            const textExtKeys = Object.keys(textGroups).sort((a,b) => a - b);
                            for (let ti = 0; ti < textExtKeys.length; ti++) {
                                const ext = textExtKeys[ti];
                                const geos = textGroups[ext];
                                let mergedGeo = geos.length > 1 ? safeMerge(geos) : geos[0];
                                if (mergedGeo) {
                                    mergedGeo.computeVertexNormals();
                                    
                                    // V67.3: „Éû„Éº„Ç∏Âæå„Å´‰øÆÂæ©
                                    updateProgressToast(`„ÉÜ„Ç≠„Çπ„Éà„É°„ÉÉ„Ç∑„É•(Ext${ext})„Çí‰øÆÂæ©‰∏≠...`, 97);
                                    mergedGeo = await repairMergedGeo(mergedGeo, `Text_Ext${ext}`);
                                    
                                    const textData = geoTo3MFMesh(mergedGeo);
                                    if (textData) {
                                        const name = textExtKeys.length === 1 ? 'Text' : `Text_Ext${ext}`;
                                        objectXml += `    <object id="${objectId}" type="model">
      <mesh>
        <vertices>
${textData.vertices.join('\n')}
        </vertices>
        <triangles>
${textData.triangles.join('\n')}
        </triangles>
      </mesh>
    </object>\n`;
                                        componentRefs.push({ id: objectId, name: name });
                                        volumeConfigs.push({ id: volumeConfigs.length, extruder: parseInt(ext), name: name, objectId: objectId });
                                        objectId++;
                                    }
                                }
                            }

                            // „Ç¢„Çª„É≥„Éñ„É™
                            const assemblyId = objectId;
                            let assemblyXml = `    <object id="${assemblyId}" type="model">\n      <components>\n`;
                            componentRefs.forEach(comp => {
                                assemblyXml += `        <component objectid="${comp.id}" transform="1 0 0 0 1 0 0 0 1 0 0 0" />\n`;
                            });
                            assemblyXml += `      </components>\n    </object>\n`;

                            const modelXml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" 
  xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02"
  xmlns:p="http://schemas.microsoft.com/3dmanufacturing/production/2015/06">
  <metadata name="Application">Keycap Generator V67</metadata>
  <resources>
${objectXml}${assemblyXml}  </resources>
  <build>
    <item objectid="${assemblyId}" />
  </build>
</model>`;

                            const contentTypes = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />
</Types>`;

                            const rels = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>`;

                            // Slic3r PE Ë®≠ÂÆö„Éï„Ç°„Ç§„É´
                            let slic3rConfig = `<?xml version="1.0" encoding="UTF-8"?>
<config>
  <object id="${assemblyId}">
    <metadata type="object" key="name" value="CustomSprueKit"/>
`;
                            componentRefs.forEach((comp, idx) => {
                                const vol = volumeConfigs.find(v => v.objectId === comp.id);
                                if (vol) {
                                    slic3rConfig += `    <volume id="${idx}" firstid="${comp.id}">
      <metadata type="volume" key="name" value="${vol.name}"/>
      <metadata type="volume" key="extruder" value="${vol.extruder}"/>
    </volume>
`;
                                }
                            });
                            slic3rConfig += `  </object>
</config>`;

                            // Bambu Studio model_settings.config
                            let modelSettings = `<?xml version="1.0" encoding="UTF-8"?>
<config>
  <plate>
    <metadata key="plater_id" value="1"/>
    <metadata key="locked" value="false"/>
  </plate>
  <object id="${assemblyId}">
    <metadata key="name" value="CustomSprueKit"/>
`;
                            componentRefs.forEach((comp, idx) => {
                                const vol = volumeConfigs.find(v => v.objectId === comp.id);
                                if (vol) {
                                    modelSettings += `    <part id="${idx + 1}" subtype="normal_part">
      <metadata key="name" value="${vol.name}"/>
      <metadata key="extruder" value="${vol.extruder}"/>
    </part>
`;
                                }
                            });
                            modelSettings += `  </object>
</config>`;

                            zip.file("[Content_Types].xml", contentTypes);
                            zip.folder("_rels").file(".rels", rels);
                            zip.folder("3D").file("3dmodel.model", modelXml);
                            zip.folder("Metadata").file("Slic3r_PE_model.config", slic3rConfig);
                            zip.folder("Metadata").file("model_settings.config", modelSettings);
                            
                            // V67.3: 3MF„ÇíÁîüÊàêÂæå„ÄÅMeshFixLib„Åß‰øÆÂæ©
                            updateProgressToast('3MF„Éï„Ç°„Ç§„É´„ÇíÁîüÊàê‰∏≠...', 90);
                            const tempBlob = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE' });
                            
                            // 3MF„ÇíArrayBuffer„Å´Â§âÊèõ
                            updateProgressToast('„É°„ÉÉ„Ç∑„É•„Çí‰øÆÂæ©‰∏≠...', 92);
                            const arrayBuffer = await tempBlob.arrayBuffer();
                            
                            // MeshFixLib„Åß‰øÆÂæ©
                            try {
                                const parsed = await meshFixLib.parse3MF(arrayBuffer);
                                console.log(`[MeshFixLib] CSK 3MF: ${parsed.objects.length}ÂÄã„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÊ§úÂá∫`);
                                
                                const repaired = await meshFixLib.repairAll(parsed.objects, (progress) => {
                                    if (progress.type === 'progress') {
                                        updateProgressToast(`„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà ${progress.objectIndex + 1}/${progress.total} „Çí‰øÆÂæ©‰∏≠...`, 92 + (progress.objectIndex / progress.total) * 6);
                                    }
                                    console.log(`[MeshFixLib] ${progress.status}`);
                                });
                                
                                console.log(`[MeshFixLib] ‰øÆÂæ©ÂÆå‰∫Ü: „Éû„Éº„Ç∏${repaired.totalReport.merged}, NM‰øÆÊ≠£${repaired.totalReport.nmFixed}, Á©¥Âüã„ÇÅ${repaired.totalReport.holesFilled}`);
                                
                                updateProgressToast('‰øÆÂæ©Ê∏à„Åø3MF„Çí‰øùÂ≠ò‰∏≠...', 98);
                                const repairedBlob = await meshFixLib.write3MF(repaired.objects, parsed.originalXml, parsed.zip, parsed.modelPath);
                                saveBlob(repairedBlob, 'custom_sprue_kit.3mf');
                            } catch (repairError) {
                                console.warn('[MeshFixLib] ‰øÆÂæ©„Å´Â§±Êïó„ÄÅÂÖÉ„ÅÆ„Éï„Ç°„Ç§„É´„Çí‰øùÂ≠ò:', repairError);
                                saveBlob(tempBlob, 'custom_sprue_kit.3mf');
                            }
                        } else {
                            // OBJ
                            const allGeos = [];
                            keycapObjects.forEach(obj => {
                                if (obj.bodyGeo) allGeos.push(obj.bodyGeo);
                                if (obj.textGeo) allGeos.push(obj.textGeo);
                            });
                            if (runnerMerged) allGeos.push(runnerMerged);
                            const finalGeo = safeMerge(allGeos);
                            finalGeo.computeVertexNormals();
                            const group = new THREE.Group();
                            group.add(new THREE.Mesh(finalGeo, new THREE.MeshStandardMaterial({ color: state.colBody })));
                            const res = new OBJExporter().parse(group);
                            saveBlob(new Blob([res], { type: 'text/plain' }), 'custom_sprue_kit.obj');
                        }
                        hideProgressToast('„Ç´„Çπ„Çø„É†„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„Éà„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„ÅüÔºÅ', false, 2000);

                        syncUI();
                        updateModel();
                    } catch (err) {
                        console.error('Custom sprue kit error:', err);
                        hideProgressToast('ÁîüÊàê„Ç®„É©„Éº: ' + err.message, true, 3000);
                        syncUI();
                        updateModel();
                    }
                });
            })();

            // Printer Model/Size Selection
            const printerSizes = {
                'x1p1a1': [
                    { value: '256,256', label: '256√ó256' }
                ],
                'a1mini': [
                    { value: '180,180', label: '180√ó180' }
                ],
                'h2d': [
                    { value: '325,320', label: 'Single Nozzle (325√ó320)' },
                    { value: '300,320', label: 'Dual Nozzle (300√ó320)' },
                    { value: '350,320', label: 'Total Area (350√ó320)' }
                ],
                'h2s': [
                    { value: '340,320', label: '340√ó320' }
                ],
                'h2c': [
                    { value: '325,320', label: 'Single Left (325√ó320)' },
                    { value: '305,320', label: 'Single Right (305√ó320)' },
                    { value: '300,320', label: 'Dual Nozzle (300√ó320)' },
                    { value: '330,320', label: 'Total Area (330√ó320)' }
                ],
                'unlimited': [
                    { value: '9999,9999', label: 'Âà∂Èôê„Å™„Åó (‰∏ÄÁõ¥Á∑ö)' }
                ]
            };

            const printerModelSelect = document.getElementById('sprue-printer-model');
            const printerSizeSelect = document.getElementById('sprue-printer-size');
            const maxKeysDisplay = document.getElementById('sprue-max-keys');
            const sprueCountSlider = document.getElementById('sprue-count');

            function calculateMaxKeys() {
                const sizeVal = printerSizeSelect.value.split(',');
                const maxWidth = parseFloat(sizeVal[0]);
                const maxDepth = parseFloat(sizeVal[1]);
                
                if (maxWidth > 9000) {
                    maxKeysDisplay.textContent = '‚àû';
                    sprueCountSlider.max = 100;
                    return 999;
                }
                
                // Calculate based on current keycap size
                const keyWidth = state.unitSize * state.uSize;
                const keyDepth = state.unitSize;
                const xSpacing = keyWidth + 12;
                const zSpacing = keyDepth + 20;
                const margin = 10;
                
                const keysPerRow = Math.floor((maxWidth - margin * 2) / xSpacing);
                const rowsAvailable = Math.floor((maxDepth - margin * 2) / zSpacing);
                const maxKeys = Math.max(1, keysPerRow) * Math.max(1, rowsAvailable);
                
                maxKeysDisplay.textContent = maxKeys;
                
                // Update slider max value
                sprueCountSlider.max = maxKeys;
                
                // If current value exceeds max, adjust it
                if (parseInt(sprueCountSlider.value) > maxKeys) {
                    sprueCountSlider.value = maxKeys;
                    const val = document.getElementById('v-sprue-count');
                    if (val) val.textContent = maxKeys;
                }
                
                return maxKeys;
            }

            function updatePrinterSizeOptions() {
                const model = printerModelSelect.value;
                const sizes = printerSizes[model] || [];
                
                // Clear existing options
                printerSizeSelect.innerHTML = '';
                
                // Add new options
                sizes.forEach(size => {
                    const option = document.createElement('option');
                    option.value = size.value;
                    option.textContent = size.label;
                    printerSizeSelect.appendChild(option);
                });
                
                // Disable if only one option
                printerSizeSelect.disabled = sizes.length <= 1;
                printerSizeSelect.style.opacity = sizes.length <= 1 ? '0.5' : '1';
                
                // Update max keys display
                calculateMaxKeys();
            }

            printerModelSelect?.addEventListener('change', updatePrinterSizeOptions);
            printerSizeSelect?.addEventListener('change', calculateMaxKeys);
            
            // Recalculate when keycap size changes
            document.getElementById('unit-size')?.addEventListener('input', () => setTimeout(calculateMaxKeys, 100));
            document.getElementById('u-size')?.addEventListener('input', () => setTimeout(calculateMaxKeys, 100));
            
            // Initialize on load
            updatePrinterSizeOptions();
            
            // Repeat Mode Toggle
            const repeatModeCheckbox = document.getElementById('sprue-repeat-mode');
            const charsGroup = document.getElementById('sprue-chars-group');
            const singleCharGroup = document.getElementById('sprue-single-char-group');
            const sprueCharsInput = document.getElementById('sprue-chars');
            
            repeatModeCheckbox?.addEventListener('change', (e) => {
                if (e.target.checked) {
                    charsGroup.style.display = 'none';
                    singleCharGroup.style.display = 'block';
                } else {
                    charsGroup.style.display = 'block';
                    singleCharGroup.style.display = 'none';
                }
            });
            
            // Auto-update key count based on character list
            sprueCharsInput?.addEventListener('input', (e) => {
                const chars = e.target.value.split(',').map(s => s.trim()).filter(s => s);
                if (chars.length >= 2) {
                    const maxAllowed = parseInt(sprueCountSlider.max);
                    const newCount = Math.min(chars.length, maxAllowed);
                    sprueCountSlider.value = newCount;
                    const val = document.getElementById('v-sprue-count');
                    if (val) val.textContent = newCount;
                }
            });

            // Sprue Kit Generation (Grid Layout & Printer Presets)
            document.getElementById('btn-gen-sprue-kit')?.addEventListener('click', async () => {
                try {
                    const t = translations[currentLang];
                    const count = parseInt(document.getElementById('sprue-count').value);
                    const sizeVal = document.getElementById('sprue-printer-size').value.split(',');
                    const maxBuildWidth = parseFloat(sizeVal[0]);
                    const maxBuildDepth = parseFloat(sizeVal[1]);
                    const printerModel = document.getElementById('sprue-printer-model').value;
                    const isRepeatMode = document.getElementById('sprue-repeat-mode').checked;
                    
                    // Get character list based on mode
                    let keycapsList = [];
                    if (isRepeatMode) {
                        const singleChar = document.getElementById('sprue-single-char').value.trim();
                        if (!singleChar) {
                            showToast(t.msg_enter_repeat_char || 'ÈÄ£Á∂öÂá∫Âäõ„Åô„ÇãÊñáÂ≠ó„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ', true);
                            return;
                        }
                        // Fill array with same character
                        for (let i = 0; i < count; i++) {
                            keycapsList.push(singleChar);
                        }
                    } else {
                        const chars = document.getElementById('sprue-chars').value.split(',').map(s => s.trim()).filter(s => s);
                        if (chars.length < 1) {
                            showToast(t.msg_enter_one_char || '1„Å§‰ª•‰∏ä„ÅÆÊñáÂ≠ó„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ', true);
                            return;
                        }
                        // Loop chars to fill count
                        while (keycapsList.length < count) {
                            keycapsList = keycapsList.concat(chars);
                        }
                        keycapsList = keycapsList.slice(0, count);
                    }
                    
                    // Calculate layout info
                    const keyWidth = state.unitSize * state.uSize;
                    const keyDepth = state.unitSize;
                    const xSpacing = keyWidth + 12;
                    const margin = 10.0;
                    let keysPerRow = Math.floor((maxBuildWidth - (margin * 2)) / xSpacing);
                    if (keysPerRow < 1) keysPerRow = 1;
                    if (maxBuildWidth > 9000) keysPerRow = count;
                    const numRows = Math.ceil(count / keysPerRow);
                    
                    // Generate preview geometry for sprue kit
                    const spruePreviewGeos = [];
                    const zSpacingPrev = keyDepth + 20;
                    const gridWidthPrev = (Math.min(count, keysPerRow) - 1) * xSpacing;
                    const gridDepthPrev = (numRows - 1) * zSpacingPrev;
                    
                    const bodyMeshPrev = mainGroup.children.find(ch => ch.name === 'KeycapBody' && ch.geometry);
                    if (bodyMeshPrev && bodyMeshPrev.geometry) {
                        // Create preview keycaps in grid
                        for (let rp = 0; rp < numRows; rp++) {
                            const rowCountPrev = (rp === numRows - 1) ? (count - rp * keysPerRow) : keysPerRow;
                            const currentRowWidthPrev = (rowCountPrev - 1) * xSpacing;
                            for (let cp = 0; cp < rowCountPrev; cp++) {
                                const previewGeo = bodyMeshPrev.geometry.clone();
                                const xPosPrev = (cp * xSpacing) - (currentRowWidthPrev / 2);
                                const zPosPrev = (rp * zSpacingPrev) - (gridDepthPrev / 2);
                                previewGeo.translate(xPosPrev, 0, zPosPrev);
                                spruePreviewGeos.push(previewGeo);
                            }
                        }
                        
                        // Add runner frame preview
                        const pPrev = getParams();
                        const runnerThickPrev = 3.0;
                        const frameWidthPrev = gridWidthPrev + keyWidth + 25;
                        const frameDepthPrev = gridDepthPrev + keyDepth + 25;
                        const gateYPrev = pPrev.h * 0.4;
                        
                        // Horizontal bars
                        for (let ip = 0; ip <= numRows; ip++) {
                            const row0ZPrev = -gridDepthPrev / 2;
                            const barZPrev = (row0ZPrev - zSpacingPrev/2) + (ip * zSpacingPrev);
                            const hBarPrev = new THREE.BoxGeometry(frameWidthPrev, runnerThickPrev, runnerThickPrev);
                            hBarPrev.translate(0, runnerThickPrev/2, barZPrev);
                            spruePreviewGeos.push(hBarPrev);
                            
                            // Top bar at gate height
                            const topBarPrev = new THREE.BoxGeometry(frameWidthPrev, runnerThickPrev, runnerThickPrev);
                            topBarPrev.translate(0, gateYPrev, barZPrev);
                            spruePreviewGeos.push(topBarPrev);
                        }
                        
                        // Side bars
                        const leftBarPrev = new THREE.BoxGeometry(runnerThickPrev, runnerThickPrev, frameDepthPrev);
                        leftBarPrev.translate(-frameWidthPrev/2 + runnerThickPrev/2, runnerThickPrev/2, 0);
                        spruePreviewGeos.push(leftBarPrev);
                        const rightBarPrev = new THREE.BoxGeometry(runnerThickPrev, runnerThickPrev, frameDepthPrev);
                        rightBarPrev.translate(frameWidthPrev/2 - runnerThickPrev/2, runnerThickPrev/2, 0);
                        spruePreviewGeos.push(rightBarPrev);
                    }
                    
                    // Show popup with format selector
                    const charListDisplay = keycapsList.length > 15 ? 
                        keycapsList.slice(0, 15).join(', ') + '...' : 
                        keycapsList.join(', ');
                    const buildSizeDisplay = maxBuildWidth > 9000 ? 'Âà∂Èôê„Å™„Åó' : `${maxBuildWidth}√ó${maxBuildDepth}mm`;
                    const layoutDisplay = `${numRows}Ë°å √ó ÊúÄÂ§ß${keysPerRow}Âàó`;
                    
                    const result = await showExportPopup({
                        type: 'sprue',
                        format: '3MF',
                        showFormatSelector: true,
                        printer: printerModel,
                        buildSize: buildSizeDisplay,
                        keyCount: count,
                        layout: layoutDisplay,
                        charList: charListDisplay,
                        spruePreviewGeos: spruePreviewGeos
                    });
                    
                    if (!result.confirmed) return;
                    
                    const format = result.format.toLowerCase();

                    showToast(`„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„ÉàÁîüÊàê‰∏≠... (${count}ÂÄã, ${numRows}Ë°å√ó${keysPerRow}Âàó)`);
                    
                    // „Éë„É©„É°„Éº„ÇøÂèñÂæó
                    const keyHeight = getParams().h;
                    
                    const zSpacing = keyDepth + 20;
                    const runnerThickGen = 3.0;

                    // Ë°å„Åî„Å®„ÅÆ„Ç≠„Éº„É™„Çπ„Éà
                    const rows = [];
                    for (let i = 0; i < keycapsList.length; i += keysPerRow) {
                        rows.push(keycapsList.slice(i, i + keysPerRow));
                    }
                    
                    // Use same calculations as preview
                    const gridWidth = (Math.min(count, keysPerRow) - 1) * xSpacing;
                    const gridDepth = (numRows - 1) * zSpacing;
                    
                    const bodyGeometries = [];  // „Éú„Éá„Ç£Áî®
                    const textGeometries = [];  // „ÉÜ„Ç≠„Çπ„ÉàÁî®
                    const keycapPositions = []; // ‰ΩçÁΩÆÊÉÖÂ†±Ôºà„Ç≤„Éº„ÉàÁîüÊàêÁî®Ôºâ
                    const originalText = state.text;
                    const originalSvg = state.svgContent;
                    const originalSvgVisible = state.svgVisible;
                    
                    // „Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÁîüÊàê„É´„Éº„Éó
                    for (let r = 0; r < numRows; r++) {
                        const currentRow = rows[r];
                        const currentRowWidth = (currentRow.length - 1) * xSpacing;
                        
                        for (let c = 0; c < currentRow.length; c++) {
                            state.text = currentRow[c];
                            state.svgContent = null;
                            state.svgVisible = false;
                            
                            await new Promise(resolve => {
                                requestUpdate();
                                setTimeout(resolve, 200);
                            });
                            
                            const bodyMesh = mainGroup.children.find(ch => ch.name === 'KeycapBody' && ch.geometry);
                            const textMesh = mainGroup.children.find(ch => ch.name === 'KeycapText' && ch.geometry);
                            
                            const xPos = (c * xSpacing) - (currentRowWidth / 2);
                            const zPos = (r * zSpacing) - (gridDepth / 2);
                            
                            if (bodyMesh && bodyMesh.geometry) {
                                const bodyGeo = bodyMesh.geometry.clone();
                                bodyGeo.translate(xPos, 0, zPos);
                                bodyGeometries.push(bodyGeo);
                                keycapPositions.push({ x: xPos, z: zPos });
                            }
                            
                            if (textMesh && textMesh.geometry) {
                                const textGeo = textMesh.geometry.clone();
                                textGeo.translate(xPos, 0, zPos);
                                textGeometries.push(textGeo);
                            }
                        }
                    }
                    
                    state.text = originalText;
                    state.svgContent = originalSvg;
                    state.svgVisible = originalSvgVisible;
                    requestUpdate();
                    
                    if (bodyGeometries.length === 0) {
                        showToast('ÁîüÊàêÂ§±Êïó', true);
                        return;
                    }

                    // „É©„É≥„Éä„ÉºÁîüÊàêÔºà„ÅØ„Åó„ÅîÂûãÔºâ
                    const runnerParts = [];
                    const gateY = keyHeight * 0.4;
                    
                    const maxRowLen = Math.max(...rows.map(r => r.length));
                    const maxRowWidth = (maxRowLen - 1) * xSpacing;
                    const frameWidth = maxRowWidth + keyWidth + 25; 
                    const frameDepthGen = gridDepth + keyDepth + 25;
                    
                    // Ê®™Ê£íÔºàË°å„ÅÆÈñì„Å®‰∏ä‰∏ãÔºâ
                    for (let i = 0; i <= numRows; i++) {
                        const row0Z = -gridDepth / 2;
                        const barZ = (row0Z - zSpacing/2) + (i * zSpacing);
                        
                        const hBar = new THREE.BoxGeometry(frameWidth, runnerThickGen, runnerThickGen);
                        hBar.translate(0, runnerThickGen/2, barZ);
                        runnerParts.push(hBar);

                        // ÊîØÊü±Ôºà‰∏°Á´Ø„Å®‰∏≠Â§ÆÔºâ
                        const supportX = [-frameWidth/2 + runnerThickGen/2, 0, frameWidth/2 - runnerThickGen/2];
                        supportX.forEach(sx => {
                           const vSup = new THREE.BoxGeometry(runnerThickGen, gateY, runnerThickGen);
                           vSup.translate(sx, gateY/2, barZ);
                           runnerParts.push(vSup);
                        });
                        
                        // „Ç≤„Éº„ÉàÈ´ò„Åï„ÅÆ„Éà„ÉÉ„Éó„Éê„Éº
                        const topBar = new THREE.BoxGeometry(frameWidth, runnerThickGen, runnerThickGen);
                        topBar.translate(0, gateY, barZ);
                        runnerParts.push(topBar);
                    }
                    
                    // Á∏¶Ê£íÔºàÂ∑¶Âè≥Á´ØÔºâ
                    const sideBarHeight = runnerThickGen;
                    const leftBar = new THREE.BoxGeometry(runnerThickGen, sideBarHeight, frameDepthGen);
                    leftBar.translate(-frameWidth/2 + runnerThickGen/2, runnerThickGen/2, 0);
                    runnerParts.push(leftBar);

                    const rightBar = new THREE.BoxGeometry(runnerThickGen, sideBarHeight, frameDepthGen);
                    rightBar.translate(frameWidth/2 - runnerThickGen/2, runnerThickGen/2, 0);
                    runnerParts.push(rightBar);
                    
                    // „Ç≤„Éº„ÉàÔºà„Ç≠„Éº„Å®Ê®™Ê£í„ÇíÁπã„ÅêÔºâ
                    const gateWidth = 0.8;
                    const gateThick = 0.6;
                    
                    keycapPositions.forEach(k => {
                        const gateFrontLen = (zSpacing/2) - (keyDepth/2) + 2.0;
                        const gateFront = new THREE.BoxGeometry(gateWidth, gateThick, gateFrontLen);
                        const frontZ = k.z - (keyDepth/2) - (gateFrontLen/2) + 2.0; 
                        gateFront.translate(k.x, gateY, frontZ);
                        runnerParts.push(gateFront);

                        const gateBack = new THREE.BoxGeometry(gateWidth, gateThick, gateFrontLen);
                        const backZ = k.z + (keyDepth/2) + (gateFrontLen/2) - 2.0;
                        gateBack.translate(k.x, gateY, backZ);
                        runnerParts.push(gateBack);
                    });

                    // „Éú„Éá„Ç£ + „É©„É≥„Éä„Éº „ÇíÁµêÂêà
                    const bodyRunnerGeos = [...bodyGeometries, ...runnerParts];
                    console.log(`Merging ${bodyRunnerGeos.length} body/runner geometries...`);
                    let bodyRunnerMerged = safeMerge(bodyRunnerGeos);
                    if (!bodyRunnerMerged) throw new Error('„Éú„Éá„Ç£/„É©„É≥„Éä„ÉºÁµêÂêàÂ§±Êïó');
                    bodyRunnerMerged.computeVertexNormals();
                    
                    // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„Çí‰øÆÊ≠£
                    showToast('„Éú„Éá„Ç£/„É©„É≥„Éä„Éº„É°„ÉÉ„Ç∑„É•„ÇíÊ§úË®º‰∏≠...');
                    bodyRunnerMerged = await validateAndFixGeometry(bodyRunnerMerged, '„Éú„Éá„Ç£/„É©„É≥„Éä„Éº');
                    if (!bodyRunnerMerged) {
                        state.text = originalText;
                        state.svgContent = originalSvg;
                        state.svgVisible = originalSvgVisible;
                        requestUpdate();
                        return;
                    }
                    
                    // „ÉÜ„Ç≠„Çπ„Éà„ÇíÁµêÂêàÔºà„ÅÇ„Çå„Å∞Ôºâ
                    let textMerged = null;
                    if (textGeometries.length > 0) {
                        console.log(`Merging ${textGeometries.length} text geometries...`);
                        textMerged = safeMerge(textGeometries);
                        if (textMerged) {
                            textMerged.computeVertexNormals();
                            // ÈùûÂ§öÊßò‰Ωì„Ç®„ÉÉ„Ç∏„Çí‰øÆÊ≠£
                            showToast('„ÉÜ„Ç≠„Çπ„Éà„É°„ÉÉ„Ç∑„É•„ÇíÊ§úË®º‰∏≠...');
                            textMerged = await validateAndFixGeometry(textMerged, '„ÉÜ„Ç≠„Çπ„Éà');
                            if (!textMerged) {
                                state.text = originalText;
                                state.svgContent = originalSvg;
                                state.svgVisible = originalSvgVisible;
                                requestUpdate();
                                return;
                            }
                        }
                    }
                    
                    // „Éï„Ç°„Ç§„É´ÂêçÁîüÊàê
                    const printerNames = {
                        'x1p1a1': 'X1P1A1',
                        'a1mini': 'A1mini',
                        'h2d': 'H2D',
                        'h2s': 'H2S',
                        'h2c': 'H2C',
                        'unlimited': 'Unlimited'
                    };
                    const printerName = printerNames[printerModel] || 'Custom';
                    let charsPart = '';
                    if (isRepeatMode) {
                        const singleChar = document.getElementById('sprue-single-char').value.trim();
                        charsPart = `_${singleChar}x${count}`;
                    } else {
                        charsPart = `_${count}keys`;
                    }
                    const filename = `sprue_${printerName}${charsPart}`;

                    if (format === 'stl') {
                        // STL„ÅØÂÖ®„Å¶ÁµêÂêà„Åó„Å¶1„Éï„Ç°„Ç§„É´
                        const allGeos = [bodyRunnerMerged];
                        if (textMerged) allGeos.push(textMerged);
                        const finalGeo = safeMerge(allGeos);
                        finalGeo.computeVertexNormals();
                        const exportMesh = new THREE.Mesh(finalGeo, new THREE.MeshStandardMaterial({ color: new THREE.Color(state.colBody) }));
                        const exporter = new STLExporter();
                        const stlData = exporter.parse(exportMesh, { binary: true });
                        const blob = new Blob([stlData], { type: 'application/octet-stream' });
                        saveAs(blob, filename + '.stl');
                    } else if (format === '3mf') {
                        // 3MF: „Éú„Éá„Ç£/„É©„É≥„Éä„Éº„Å®„ÉÜ„Ç≠„Çπ„Éà„ÇíÂà•„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å´
                        const bodyExtruder = amsConfig.bodyExtruderSet ? amsConfig.bodyExtruder : 1;
                        const textExtruder = amsConfig.textExtruderSet ? amsConfig.textExtruder : 2;
                        
                        const zip = new JSZip();
                        
                        function geoTo3MFMesh(geometry) {
                            if (!geometry) return null;
                            let geo = geometry.clone();
                            if (!geo.index) {
                                geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
                            }
                            const pos = geo.attributes.position;
                            if (!pos) return null;
                            
                            const vertices = [];
                            const triangles = [];
                            
                            for (let i = 0; i < pos.count; i++) {
                                vertices.push(`        <vertex x="${pos.getX(i).toFixed(6)}" y="${pos.getY(i).toFixed(6)}" z="${pos.getZ(i).toFixed(6)}" />`);
                            }
                            
                            if (geo.index) {
                                const idx = geo.index.array;
                                for (let i = 0; i < idx.length; i += 3) {
                                    triangles.push(`        <triangle v1="${idx[i]}" v2="${idx[i+1]}" v3="${idx[i+2]}" />`);
                                }
                            } else {
                                for (let i = 0; i < pos.count; i += 3) {
                                    triangles.push(`        <triangle v1="${i}" v2="${i+1}" v3="${i+2}" />`);
                                }
                            }
                            return { vertices, triangles };
                        }

                        let objectXml = '';
                        let componentRefs = [];
                        let volumeConfigs = [];
                        let objectId = 1;

                        // „Éú„Éá„Ç£ + „É©„É≥„Éä„ÉºÔºàBambu Studio„Åß„ÅØÈÄÜÈ†Ü„Å™„ÅÆ„ÅßText„Å®„ÅÑ„ÅÜÂêçÂâç„Çí‰ΩøÁî®Ôºâ
                        const bodyData = geoTo3MFMesh(bodyRunnerMerged);
                        if (bodyData) {
                            objectXml += `    <object id="${objectId}" type="model">
      <mesh>
        <vertices>
${bodyData.vertices.join('\n')}
        </vertices>
        <triangles>
${bodyData.triangles.join('\n')}
        </triangles>
      </mesh>
    </object>\n`;
                            componentRefs.push({ id: objectId, name: 'Text' });
                            volumeConfigs.push({ id: volumeConfigs.length, extruder: bodyExtruder, name: 'Text', objectId: objectId });
                            objectId++;
                        }

                        // „ÉÜ„Ç≠„Çπ„ÉàÔºàBambu Studio„Åß„ÅØÈÄÜÈ†Ü„Å™„ÅÆ„ÅßBody„Å®„ÅÑ„ÅÜÂêçÂâç„Çí‰ΩøÁî®Ôºâ
                        if (textMerged) {
                            const textData = geoTo3MFMesh(textMerged);
                            if (textData) {
                                objectXml += `    <object id="${objectId}" type="model">
      <mesh>
        <vertices>
${textData.vertices.join('\n')}
        </vertices>
        <triangles>
${textData.triangles.join('\n')}
        </triangles>
      </mesh>
    </object>\n`;
                                componentRefs.push({ id: objectId, name: 'Body' });
                                volumeConfigs.push({ id: volumeConfigs.length, extruder: textExtruder, name: 'Body', objectId: objectId });
                                objectId++;
                            }
                        }

                        // „Ç¢„Çª„É≥„Éñ„É™
                        const assemblyId = objectId;
                        let assemblyXml = `    <object id="${assemblyId}" type="model">\n      <components>\n`;
                        componentRefs.forEach(comp => {
                            assemblyXml += `        <component objectid="${comp.id}" transform="1 0 0 0 1 0 0 0 1 0 0 0" />\n`;
                        });
                        assemblyXml += `      </components>\n    </object>\n`;

                        const modelXml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" 
  xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02"
  xmlns:p="http://schemas.microsoft.com/3dmanufacturing/production/2015/06">
  <metadata name="Application">Keycap Generator V67</metadata>
  <resources>
${objectXml}${assemblyXml}  </resources>
  <build>
    <item objectid="${assemblyId}" />
  </build>
</model>`;

                        const contentTypes = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />
</Types>`;

                        const rels = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>`;

                        // Slic3r PE Ë®≠ÂÆö„Éï„Ç°„Ç§„É´
                        let slic3rConfig = `<?xml version="1.0" encoding="UTF-8"?>
<config>
  <object id="${assemblyId}">
    <metadata type="object" key="name" value="SprueKit"/>
`;
                        componentRefs.forEach((comp, idx) => {
                            const vol = volumeConfigs.find(v => v.objectId === comp.id);
                            if (vol) {
                                slic3rConfig += `    <volume id="${idx}" firstid="${comp.id}">
      <metadata type="volume" key="name" value="${vol.name}"/>
      <metadata type="volume" key="extruder" value="${vol.extruder}"/>
    </volume>
`;
                            }
                        });
                        slic3rConfig += `  </object>
</config>`;

                        // Bambu Studio model_settings.config
                        let modelSettings = `<?xml version="1.0" encoding="UTF-8"?>
<config>
  <plate>
    <metadata key="plater_id" value="1"/>
    <metadata key="locked" value="false"/>
  </plate>
  <object id="${assemblyId}">
    <metadata key="name" value="SprueKit"/>
`;
                        componentRefs.forEach((comp, idx) => {
                            const vol = volumeConfigs.find(v => v.objectId === comp.id);
                            if (vol) {
                                modelSettings += `    <part id="${idx + 1}" subtype="normal_part">
      <metadata key="name" value="${vol.name}"/>
      <metadata key="extruder" value="${vol.extruder}"/>
    </part>
`;
                            }
                        });
                        modelSettings += `  </object>
</config>`;

                        zip.file("[Content_Types].xml", contentTypes);
                        zip.folder("_rels").file(".rels", rels);
                        zip.folder("3D").file("3dmodel.model", modelXml);
                        zip.folder("Metadata").file("Slic3r_PE_model.config", slic3rConfig);
                        zip.folder("Metadata").file("model_settings.config", modelSettings);
                        
                        const blob = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE' });
                        saveAs(blob, filename + '.3mf');
                    } else if (format === 'obj') {
                        const allGeos = [bodyRunnerMerged];
                        if (textMerged) allGeos.push(textMerged);
                        const finalGeo = safeMerge(allGeos);
                        finalGeo.computeVertexNormals();
                        const exportMesh = new THREE.Mesh(finalGeo, new THREE.MeshStandardMaterial({ color: new THREE.Color(state.colBody) }));
                        const group = new THREE.Group();
                        exportMesh.name = "SprueKit";
                        group.add(exportMesh);
                        const objData = new OBJExporter().parse(group);
                        const blob = new Blob([objData], { type: 'text/plain' });
                        saveAs(blob, filename + '.obj');
                    }
                    
                    showToast(`ÁîüÊàêÂÆå‰∫Ü: ${numRows}Ë°å √ó ÊúÄÂ§ß${keysPerRow}Âàó`);

                } catch (error) {
                    console.error('Sprue kit error:', error);
                    showToast('„Ç®„É©„Éº: ' + error.message, true);
                }
            });

            // Visual Preset Library with real-time updates
            const presetFont = document.getElementById('preset-font');
            const presetSize = document.getElementById('preset-size');
            const presetMode = document.getElementById('preset-mode');
            
            presetFont?.addEventListener('change', (e) => {
                state.font = e.target.value;
                const mainFont = document.getElementById('font-family');
                if (mainFont) mainFont.value = e.target.value;
                if (typeof updateCustomDropdown === 'function') updateCustomDropdown();
                requestUpdate();
                commitHistory();
            });
            
            presetSize?.addEventListener('change', (e) => {
                state.fontSize = parseFloat(e.target.value);
                const mainSize = document.getElementById('font-size');
                const vMainSize = document.getElementById('v-font-size');
                if (mainSize) mainSize.value = e.target.value;
                if (vMainSize) vMainSize.textContent = e.target.value;
                requestUpdate();
                commitHistory();
            });
            
            presetMode?.addEventListener('change', (e) => {
                state.textMode = e.target.value;
                const mainMode = document.getElementById('text-mode');
                if (mainMode) mainMode.value = e.target.value;
                requestUpdate();
                commitHistory();
            });

            const visualPresetBtns = document.querySelectorAll('#visual-preset-grid .visual-preset-btn');
            const visualPresets = {
                'wasd': { text: 'W', profile: 'cherry', row: 'R3', size: 1.0 },
                'arrows': { text: '', profile: 'cherry', row: 'R4', size: 1.0, useIcon: 'up' },
                'fn': { text: 'Fn', profile: 'cherry', row: 'R1', size: 1.0 },
                'mac-cmd': { text: 'Cmd', profile: 'cherry', row: 'R1', size: 1.25 },
                'mac-opt': { text: 'Alt', profile: 'cherry', row: 'R1', size: 1.25 },
                'esc': { text: 'Esc', profile: 'cherry', row: 'R4', size: 1.0 }
            };
            
            // Arrow key icon selector for arrows preset
            const arrowIconOptions = [
                { id: 'up', name: '‚Üë ‰∏äÁü¢Âç∞', nameEn: '‚Üë Up' },
                { id: 'down', name: '‚Üì ‰∏ãÁü¢Âç∞', nameEn: '‚Üì Down' },
                { id: 'left', name: '‚Üê Â∑¶Áü¢Âç∞', nameEn: '‚Üê Left' },
                { id: 'right', name: '‚Üí Âè≥Áü¢Âç∞', nameEn: '‚Üí Right' }
            ];

            visualPresetBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                    const presetKey = btn.dataset.preset;
                    const preset = visualPresets[presetKey];
                    if (preset) {
                        // Handle WASD preset with key selection
                        if (presetKey === 'wasd') {
                            const key = await showWASDSelector();
                            if (!key) return;
                            
                            state.text = key;
                            state.profile = preset.profile;
                            state.row = preset.row;
                            state.uSize = preset.size;
                            if (presetFont) state.font = presetFont.value;
                            if (presetSize) state.fontSize = parseFloat(presetSize.value);
                            if (presetMode) state.textMode = presetMode.value;
                            syncUI();
                            requestUpdate();
                            commitHistory();
                            showToast('WASD„Ç≠„Éº„Äå' + key + '„Äç„ÇíÈÅ©Áî®');
                            return;
                        }
                        
                        // Handle arrow keys preset with icon selection
                        if (presetKey === 'arrows' && stockIconsData) {
                            // Show arrow direction selector
                            const direction = await showArrowSelector();
                            if (!direction) return;
                            
                            // Find the icon in stockIconsData
                            const icon = stockIconsData.icons.find(i => i.id === direction);
                            if (icon && icon.svgContent) {
                                state.text = '';
                                state.showText = false;
                                state.svgContent = icon.svgContent;
                                state.svgName = icon.nameJa || icon.name;
                                state.svgVisible = true;
                                state.profile = preset.profile;
                                state.row = preset.row;
                                state.uSize = preset.size;
                                
                                // Update UI checkboxes
                                const showTextChk = document.getElementById('show-text');
                                const svgVisibleChk = document.getElementById('svg-visible');
                                if (showTextChk) showTextChk.checked = false;
                                if (svgVisibleChk) svgVisibleChk.checked = true;
                                
                                syncUI();
                                requestUpdate();
                                commitHistory();
                                showToast('Áü¢Âç∞„Ç≠„Éº„Äå' + (icon.nameJa || icon.name) + '„Äç„ÇíÈÅ©Áî®');
                                return;
                            }
                        }
                        
                        // Standard preset handling
                        state.text = preset.text;
                        state.profile = preset.profile;
                        state.row = preset.row;
                        state.uSize = preset.size;
                        if (presetFont) state.font = presetFont.value;
                        if (presetSize) state.fontSize = parseFloat(presetSize.value);
                        if (presetMode) state.textMode = presetMode.value;
                        syncUI();
                        requestUpdate();
                        commitHistory();
                        showToast('„Éó„É™„Çª„ÉÉ„Éà„Äå' + preset.text + '„Äç„ÇíÈÅ©Áî®');
                    }
                });
            });
            
            // Clear visual preset button - reset to initial state
            document.getElementById('btn-clear-visual-preset')?.addEventListener('click', () => {
                // Reset visual preset related values to initial state
                state.text = initialState.text;
                state.font = initialState.font;
                state.fontSize = initialState.fontSize;
                state.textHeight = initialState.textHeight;
                state.textMode = initialState.textMode;
                state.enableText = initialState.enableText;
                state.posX = initialState.posX;
                state.posZ = initialState.posZ;
                state.profile = initialState.profile;
                state.row = initialState.row;
                state.uSize = initialState.uSize;
                state.topScale = initialState.topScale;
                state.dishType = initialState.dishType;
                state.roundCorner = initialState.roundCorner;
                state.colBody = initialState.colBody;
                state.colText = initialState.colText;
                state.svgContent = null;
                state.svgName = null;
                state.svgVisible = initialState.svgVisible;
                
                // Clear icon selections
                document.querySelectorAll('#stock-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                document.querySelectorAll('#simple-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                
                // Sync all UI elements
                syncUI();
                
                // Update simple mode specific elements not covered by syncUI
                const simpleTxtEl = document.getElementById('simple-text-content');
                if (simpleTxtEl) simpleTxtEl.value = state.text;
                const simpleEnableTextChk = document.getElementById('simple-enable-text');
                if (simpleEnableTextChk) simpleEnableTextChk.checked = state.enableText;
                const simpleProfile = document.getElementById('simple-profile-select');
                if (simpleProfile) simpleProfile.value = state.profile;
                const simpleRow = document.getElementById('simple-row-select');
                if (simpleRow) simpleRow.value = state.row;
                const simpleFont = document.getElementById('simple-font-select');
                if (simpleFont) simpleFont.value = state.font;
                if (typeof window.updateSimpleCustomDropdownHead === 'function') window.updateSimpleCustomDropdownHead();
                
                // Update key size buttons
                document.querySelectorAll('#simple-key-size-buttons .key-size-btn').forEach(btn => {
                    btn.classList.toggle('active', parseFloat(btn.dataset.size) === state.uSize);
                });
                
                requestUpdate();
                commitHistory();
                showToast(translations[currentLang].msg_preset_cleared || 'ÂàùÊúüÁä∂ÊÖã„Å´Êàª„Åó„Åæ„Åó„Åü');
            });
            
            // WASD key selector dialog with animation
            function showWASDSelector() {
                return new Promise(resolve => {
                    const overlay = document.createElement('div');
                    overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0);display:flex;justify-content:center;align-items:center;z-index:9999;transition:background 0.3s ease;';
                    
                    const dialog = document.createElement('div');
                    dialog.style.cssText = 'background:#1a1a2e;padding:20px;border-radius:12px;text-align:center;min-width:250px;transform:scale(0.8);opacity:0;transition:transform 0.3s ease, opacity 0.3s ease;';
                    const t = translations[currentLang];
                    dialog.innerHTML = `
                        <h3 style="color:#e040fb;margin:0 0 15px;">${t.wasd_select_title || 'WASD„Ç≠„Éº„ÇíÈÅ∏Êäû'}</h3>
                        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:15px;">
                            <div></div>
                            <button class="wasd-btn" data-key="W" style="padding:15px 20px;font-size:1.5rem;font-weight:bold;background:#16213e;border:2px solid #e040fb;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">W</button>
                            <div></div>
                            <button class="wasd-btn" data-key="A" style="padding:15px 20px;font-size:1.5rem;font-weight:bold;background:#16213e;border:2px solid #e040fb;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">A</button>
                            <button class="wasd-btn" data-key="S" style="padding:15px 20px;font-size:1.5rem;font-weight:bold;background:#16213e;border:2px solid #e040fb;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">S</button>
                            <button class="wasd-btn" data-key="D" style="padding:15px 20px;font-size:1.5rem;font-weight:bold;background:#16213e;border:2px solid #e040fb;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">D</button>
                        </div>
                        <button id="wasd-cancel" style="padding:8px 20px;background:#666;border:none;color:#fff;border-radius:6px;cursor:pointer;transition:all 0.2s;">${t.popup_cancel || '„Ç≠„É£„É≥„Çª„É´'}</button>
                    `;
                    
                    overlay.appendChild(dialog);
                    document.body.appendChild(overlay);
                    
                    // Animate in
                    requestAnimationFrame(() => {
                        overlay.style.background = 'rgba(0,0,0,0.7)';
                        dialog.style.transform = 'scale(1)';
                        dialog.style.opacity = '1';
                    });
                    
                    const closeWithAnimation = (result) => {
                        overlay.style.background = 'rgba(0,0,0,0)';
                        dialog.style.transform = 'scale(0.8)';
                        dialog.style.opacity = '0';
                        setTimeout(() => {
                            document.body.removeChild(overlay);
                            resolve(result);
                        }, 300);
                    };
                    
                    dialog.querySelectorAll('.wasd-btn').forEach(btn => {
                        btn.addEventListener('click', () => closeWithAnimation(btn.dataset.key));
                        btn.addEventListener('mouseenter', () => {
                            btn.style.background = '#2d1b4e';
                            btn.style.transform = 'scale(1.1)';
                        });
                        btn.addEventListener('mouseleave', () => {
                            btn.style.background = '#16213e';
                            btn.style.transform = 'scale(1)';
                        });
                    });
                    
                    dialog.querySelector('#wasd-cancel').addEventListener('click', () => closeWithAnimation(null));
                    
                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) closeWithAnimation(null);
                    });
                });
            }
            
            // Arrow direction selector dialog with animation
            function showArrowSelector() {
                return new Promise(resolve => {
                    const overlay = document.createElement('div');
                    overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0);display:flex;justify-content:center;align-items:center;z-index:9999;transition:background 0.3s ease;';
                    
                    const dialog = document.createElement('div');
                    dialog.style.cssText = 'background:#1a1a2e;padding:20px;border-radius:12px;text-align:center;min-width:250px;transform:scale(0.8);opacity:0;transition:transform 0.3s ease, opacity 0.3s ease;';
                    const t = translations[currentLang];
                    dialog.innerHTML = `
                        <h3 style="color:#4fc3f7;margin:0 0 15px;">${t.arrow_select_title || 'Áü¢Âç∞„ÅÆÊñπÂêë„ÇíÈÅ∏Êäû'}</h3>
                        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:15px;">
                            <div></div>
                            <button class="arrow-btn" data-dir="up" style="padding:15px;font-size:1.5rem;background:#16213e;border:2px solid #4fc3f7;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">‚Üë</button>
                            <div></div>
                            <button class="arrow-btn" data-dir="left" style="padding:15px;font-size:1.5rem;background:#16213e;border:2px solid #4fc3f7;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">‚Üê</button>
                            <button class="arrow-btn" data-dir="down" style="padding:15px;font-size:1.5rem;background:#16213e;border:2px solid #4fc3f7;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">‚Üì</button>
                            <button class="arrow-btn" data-dir="right" style="padding:15px;font-size:1.5rem;background:#16213e;border:2px solid #4fc3f7;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">‚Üí</button>
                        </div>
                        <button id="arrow-cancel" style="padding:8px 20px;background:#666;border:none;color:#fff;border-radius:6px;cursor:pointer;transition:all 0.2s;">${t.popup_cancel || '„Ç≠„É£„É≥„Çª„É´'}</button>
                    `;
                    
                    overlay.appendChild(dialog);
                    document.body.appendChild(overlay);
                    
                    // Animate in
                    requestAnimationFrame(() => {
                        overlay.style.background = 'rgba(0,0,0,0.7)';
                        dialog.style.transform = 'scale(1)';
                        dialog.style.opacity = '1';
                    });
                    
                    const closeWithAnimation = (result) => {
                        overlay.style.background = 'rgba(0,0,0,0)';
                        dialog.style.transform = 'scale(0.8)';
                        dialog.style.opacity = '0';
                        setTimeout(() => {
                            document.body.removeChild(overlay);
                            resolve(result);
                        }, 300);
                    };
                    
                    dialog.querySelectorAll('.arrow-btn').forEach(btn => {
                        btn.addEventListener('click', () => closeWithAnimation(btn.dataset.dir));
                        btn.addEventListener('mouseenter', () => {
                            btn.style.background = '#0f3460';
                            btn.style.transform = 'scale(1.1)';
                        });
                        btn.addEventListener('mouseleave', () => {
                            btn.style.background = '#16213e';
                            btn.style.transform = 'scale(1)';
                        });
                    });
                    
                    dialog.querySelector('#arrow-cancel').addEventListener('click', () => closeWithAnimation(null));
                    
                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) closeWithAnimation(null);
                    });
                });
            }

            // Stock Icon Library - All icons embedded in HTML
            let stockIconsData = null;
            const stockIconGrid = document.getElementById('stock-icon-grid');
            const stockIconCategory = document.getElementById('stock-icon-category');
            
            async function loadStockIcons() {
                console.log('[StockIcon] Loading icons...');
                try {
                    // Try to load from external folder first
                    let externalLoaded = false;
                    try {
                        const response = await fetch('stock-icons/icons.json');
                        if (response.ok) {
                            const indexData = await response.json();
                            console.log('[StockIcon] Found external icons.json');
                            
                            // Load SVG content for each icon
                            const loadedIcons = [];
                            const icons = indexData.icons || [];
                            
                            for (const icon of icons) {
                                try {
                                    const svgResponse = await fetch('stock-icons/' + icon.file);
                                    if (svgResponse.ok) {
                                        const svgContent = await svgResponse.text();
                                        
                                        loadedIcons.push({
                                            id: icon.id,
                                            name: icon.name,
                                            nameJa: icon.nameJa || icon.name,
                                            category: icon.category,
                                            svgContent: svgContent
                                        });
                                    }
                                } catch (e) {
                                    console.warn('[StockIcon] Failed to load:', icon.file);
                                }
                            }
                            
                            if (loadedIcons.length > 0) {
                                stockIconsData = {
                                    categories: indexData.categories || [
                                        { id: 'arrows', name: 'Arrows', nameJa: 'Áü¢Âç∞' },
                                        { id: 'media', name: 'Media', nameJa: '„É°„Éá„Ç£„Ç¢' },
                                        { id: 'modifiers', name: 'Modifiers', nameJa: '‰øÆÈ£æ„Ç≠„Éº' },
                                        { id: 'system', name: 'System', nameJa: '„Ç∑„Çπ„ÉÜ„É†' },
                                        { id: 'symbols', name: 'Symbols', nameJa: 'Ë®òÂè∑' }
                                    ],
                                    icons: loadedIcons
                                };
                                console.log('[StockIcon] Loaded', loadedIcons.length, 'external SVG files');
                                externalLoaded = true;
                            }
                        }
                    } catch (e) {
                        console.log('[StockIcon] External folder not available:', e.message);
                    }
                    
                    // External icons are required (no fallback)
                    if (!externalLoaded) {
                        console.log('[StockIcon] External icons not available');
                        stockIconGrid.innerHTML = '<div style="grid-column:1/-1; color:#888; padding:10px; text-align:center; font-size:0.75rem;">stock-icons/icons.json „ÇíË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì<br><small>Web„Çµ„Éº„Éê„ÉºÁµåÁî±„Åß„Ç¢„ÇØ„Çª„Çπ„Åó„Å¶„Åè„Å†„Åï„ÅÑ</small></div>';
                        return;
                    }
                    
                    // Populate category dropdown
                    if (stockIconCategory && stockIconsData.categories) {
                        stockIconsData.categories.forEach(cat => {
                            const opt = document.createElement('option');
                            opt.value = cat.id;
                            opt.textContent = cat.nameJa + ' (' + cat.name + ')';
                            stockIconCategory.appendChild(opt);
                        });
                    }
                    
                    // Render all icons
                    renderStockIcons('all');
                    
                } catch (error) {
                    console.error('[StockIcon] Failed to load:', error);
                    stockIconGrid.innerHTML = '<div style="grid-column:1/-1; color:#f44; padding:10px;">„Ç¢„Ç§„Ç≥„É≥Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº</div>';
                }
            }
            
            async function renderStockIcons(category) {
                if (!stockIconsData || !stockIconGrid) return;
                
                stockIconGrid.innerHTML = '';
                
                const icons = category === 'all' 
                    ? stockIconsData.icons 
                    : stockIconsData.icons.filter(icon => icon.category === category);
                
                for (const icon of icons) {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'stock-icon-btn';
                    btn.dataset.iconId = icon.id;
                    btn.title = icon.nameJa + ' (' + icon.name + ')';
                    
                    // Use embedded SVG content
                    if (icon.svgContent) {
                        const svgContent = normalizeSVGForPreview(icon.svgContent);
                        btn.innerHTML = svgContent;
                    } else {
                        btn.textContent = '?';
                    }
                    
                    btn.addEventListener('click', () => applyStockIcon(icon, btn));
                    stockIconGrid.appendChild(btn);
                }
            }
            
            // Normalize SVG for preview display (simpler version for button icons)
            function normalizeSVGForPreview(svgString) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svgString, 'image/svg+xml');
                    const svg = doc.documentElement;
                    
                    // Extract CSS styles from <style> tags
                    const styleTags = svg.querySelectorAll('style');
                    styleTags.forEach(styleTag => styleTag.remove());
                    
                    // Apply currentColor to all shape elements
                    svg.querySelectorAll('path, polygon, rect, circle, ellipse, line').forEach(el => {
                        el.removeAttribute('class');
                        el.removeAttribute('style');
                        // Handle fill
                        const hasFill = el.getAttribute('fill');
                        if (!hasFill || hasFill !== 'none') {
                            el.setAttribute('fill', 'currentColor');
                        }
                        // Handle stroke
                        if (el.getAttribute('stroke')) {
                            el.setAttribute('stroke', 'currentColor');
                        }
                    });
                    
                    // Clean up SVG element
                    svg.removeAttribute('style');
                    svg.removeAttribute('xml:space');
                    svg.removeAttribute('width');
                    svg.removeAttribute('height');
                    
                    const serializer = new XMLSerializer();
                    return serializer.serializeToString(svg);
                } catch (e) {
                    return svgString;
                }
            }
            
            async function applyStockIcon(icon, btn) {
                // Clear other selections
                document.querySelectorAll('#stock-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                
                console.log('[StockIcon] Applying icon:', icon.id);
                
                try {
                    const svgString = icon.svgContent;
                    
                    if (!svgString) {
                        showToast('SVG„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', true);
                        return;
                    }
                    
                    // Use the same logic as manual SVG upload
                    state.svgContent = svgString;
                    state.svgName = icon.id;
                    
                    // Auto-adjust scale based on viewBox size
                    const viewBoxMatch = svgString.match(/viewBox=["']([^"']+)["']/);
                    if (viewBoxMatch) {
                        const viewBoxParts = viewBoxMatch[1].split(/[\s,]+/).map(Number);
                        const viewBoxWidth = viewBoxParts[2] || 24;
                        const viewBoxHeight = viewBoxParts[3] || 24;
                        const maxDim = Math.max(viewBoxWidth, viewBoxHeight);
                        // viewBox 24 -> scale 1.0, viewBox 512 -> scale ~0.047
                        const autoScale = 24 / maxDim;
                        console.log('[StockIcon] ViewBox:', viewBoxWidth, 'x', viewBoxHeight, '-> scale:', autoScale.toFixed(3));
                        
                        state.svgScale = autoScale;
                        
                        // Update sliders
                        const stockIconScaleSlider = document.getElementById('stock-icon-scale');
                        const stockIconScaleDisplay = document.getElementById('v-stock-icon-scale');
                        const mainSvgScaleSlider = document.getElementById('svg-scale');
                        const mainSvgScaleDisplay = document.getElementById('v-svg-scale');
                        
                        if (stockIconScaleSlider) stockIconScaleSlider.value = autoScale;
                        if (stockIconScaleDisplay) stockIconScaleDisplay.textContent = autoScale.toFixed(2);
                        if (mainSvgScaleSlider) mainSvgScaleSlider.value = autoScale;
                        if (mainSvgScaleDisplay) mainSvgScaleDisplay.textContent = autoScale.toFixed(2);
                    }
                    
                    // Auto-disable text when icon is applied
                    state.enableText = false;
                    state.svgVisible = true;
                    const enableTextCheckbox = document.getElementById('enable-text');
                    if (enableTextCheckbox) enableTextCheckbox.checked = false;
                    const simpleEnableTextCheckbox = document.getElementById('simple-enable-text');
                    if (simpleEnableTextCheckbox) simpleEnableTextCheckbox.checked = false;
                    // HUD„ÅÆ„Éà„Ç∞„É´„Éú„Çø„É≥„ÇÇÂêåÊúü
                    const hudTextBtn = document.getElementById('hud-toggle-text');
                    if (hudTextBtn) hudTextBtn.classList.remove('active');
                    const hudSvgBtn = document.getElementById('hud-toggle-svg');
                    if (hudSvgBtn) hudSvgBtn.classList.add('active');
                    
                    updateModel();
                    showToast('SVG„Ç¢„Ç§„Ç≥„É≥„Äå' + icon.nameJa + '„Äç„ÇíÈÅ©Áî®');
                    
                } catch (error) {
                    console.error('[StockIcon] ERROR:', error);
                    showToast('SVGÈÅ©Áî®„Ç®„É©„Éº: ' + error.message, true);
                }
            }
            
            // Category filter
            stockIconCategory?.addEventListener('change', (e) => {
                renderStockIcons(e.target.value);
            });
            
            // Stock icon size slider - syncs with main SVG scale
            const stockIconScaleSlider = document.getElementById('stock-icon-scale');
            const stockIconScaleDisplay = document.getElementById('v-stock-icon-scale');
            const mainSvgScaleSlider = document.getElementById('svg-scale');
            const mainSvgScaleDisplay = document.getElementById('v-svg-scale');
            
            stockIconScaleSlider?.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                if (stockIconScaleDisplay) stockIconScaleDisplay.textContent = value.toFixed(2);
                
                // Sync with main SVG scale
                state.svgScale = value;
                if (mainSvgScaleSlider) mainSvgScaleSlider.value = value;
                if (mainSvgScaleDisplay) mainSvgScaleDisplay.textContent = value.toFixed(2);
                
                requestUpdate();
            });
            
            stockIconScaleSlider?.addEventListener('change', () => {
                commitHistory();
            });
            
            // Also sync when main SVG scale changes
            mainSvgScaleSlider?.addEventListener('input', () => {
                const value = parseFloat(mainSvgScaleSlider.value);
                if (stockIconScaleSlider) stockIconScaleSlider.value = value;
                if (stockIconScaleDisplay) stockIconScaleDisplay.textContent = value.toFixed(2);
            });
            
            // Clear selection
            document.getElementById('btn-clear-stock-icon')?.addEventListener('click', () => {
                document.querySelectorAll('#stock-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                document.querySelectorAll('#simple-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                // Clear SVG using same logic as btn-clear-svg
                state.svgContent = null;
                state.svgName = null;
                
                // Re-enable text when SVG is cleared
                state.enableText = true;
                const enableTextCheckbox = document.getElementById('enable-text');
                if (enableTextCheckbox) enableTextCheckbox.checked = true;
                const simpleEnableTextCheckbox = document.getElementById('simple-enable-text');
                if (simpleEnableTextCheckbox) simpleEnableTextCheckbox.checked = true;
                
                updateModel();
            });
            
            // Simple Mode Icon Grid
            const simpleIconGrid = document.getElementById('simple-icon-grid');
            const simpleIconCategory = document.getElementById('simple-icon-category');
            
            function renderSimpleIcons(category = 'all') {
                if (!simpleIconGrid || !stockIconsData) return;
                simpleIconGrid.innerHTML = '';
                
                const filteredIcons = category === 'all' 
                    ? stockIconsData.icons 
                    : stockIconsData.icons.filter(i => i.category === category);
                
                filteredIcons.forEach(icon => {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'stock-icon-btn';
                    btn.title = icon.nameJa;
                    btn.innerHTML = icon.svgContent || '';
                    btn.addEventListener('click', () => applySimpleIcon(icon, btn));
                    simpleIconGrid.appendChild(btn);
                });
            }
            
            function applySimpleIcon(icon, btn) {
                try {
                    // Deselect all in both grids
                    document.querySelectorAll('#simple-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                    document.querySelectorAll('#stock-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    
                    state.svgContent = icon.svgContent;
                    state.svgName = icon.nameJa;
                    state.svgVisible = true;
                    
                    // Á∞°Âçò„É¢„Éº„Éâ„ÅÆÁîüÊàê„É¢„Éº„Éâ„ÇíSVG„É¢„Éº„Éâ„Å´ÈÅ©Áî®
                    const simpleTextMode = document.getElementById('simple-text-mode');
                    if (simpleTextMode) {
                        const currentMode = simpleTextMode.value;
                        state.svgMode = currentMode;
                        const mainSvgMode = document.getElementById('svg-mode');
                        if (mainSvgMode) mainSvgMode.value = currentMode;
                        console.log('[SimpleIcon] Applied svgMode:', currentMode);
                    }
                    
                    // Auto scale based on viewBox
                    const viewBoxMatch = icon.svgContent.match(/viewBox="([^"]+)"/);
                    if (viewBoxMatch) {
                        const parts = viewBoxMatch[1].split(/[\s,]+/).map(Number);
                        const maxDim = Math.max(parts[2] || 24, parts[3] || 24);
                        const autoScale = 24 / maxDim;
                        state.svgScale = autoScale;
                    }
                    
                    // Auto-disable text
                    state.enableText = false;
                    const enableTextCheckbox = document.getElementById('enable-text');
                    if (enableTextCheckbox) enableTextCheckbox.checked = false;
                    const simpleEnableTextCb = document.getElementById('simple-enable-text');
                    if (simpleEnableTextCb) simpleEnableTextCb.checked = false;
                    // HUD„ÅÆ„Éà„Ç∞„É´„Éú„Çø„É≥„ÇÇÂêåÊúü
                    const hudTextBtn = document.getElementById('hud-toggle-text');
                    if (hudTextBtn) hudTextBtn.classList.remove('active');
                    const hudSvgBtn = document.getElementById('hud-toggle-svg');
                    if (hudSvgBtn) hudSvgBtn.classList.add('active');
                    
                    updateModel();
                    showToast('„Ç¢„Ç§„Ç≥„É≥„Äå' + icon.nameJa + '„Äç„ÇíÈÅ©Áî®');
                } catch (error) {
                    console.error('[SimpleIcon] ERROR:', error);
                }
            }
            
            function initSimpleIconGrid() {
                if (simpleIconCategory && stockIconsData && stockIconsData.categories) {
                    // Clear existing options except "all"
                    while (simpleIconCategory.options.length > 1) {
                        simpleIconCategory.remove(1);
                    }
                    stockIconsData.categories.forEach(cat => {
                        const opt = document.createElement('option');
                        opt.value = cat.id;
                        opt.textContent = cat.nameJa + ' (' + cat.name + ')';
                        simpleIconCategory.appendChild(opt);
                    });
                }
                renderSimpleIcons('all');
            }
            
            simpleIconCategory?.addEventListener('change', (e) => {
                renderSimpleIcons(e.target.value);
            });
            
            // Clear simple icon
            document.getElementById('btn-clear-simple-icon')?.addEventListener('click', () => {
                document.querySelectorAll('#simple-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                document.querySelectorAll('#stock-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                state.svgContent = null;
                state.svgName = null;
                state.svgVisible = false;
                state.enableText = true;
                const enableTextCheckbox = document.getElementById('enable-text');
                if (enableTextCheckbox) enableTextCheckbox.checked = true;
                const simpleEnableTextCb = document.getElementById('simple-enable-text');
                if (simpleEnableTextCb) simpleEnableTextCb.checked = true;
                // HUD„ÅÆ„Éà„Ç∞„É´„Éú„Çø„É≥„ÇÇÂêåÊúü
                const hudTextBtn = document.getElementById('hud-toggle-text');
                if (hudTextBtn) hudTextBtn.classList.add('active');
                const hudSvgBtn = document.getElementById('hud-toggle-svg');
                if (hudSvgBtn) hudSvgBtn.classList.remove('active');
                // „Éó„É´„ÉÄ„Ç¶„É≥„ÅÆË°®Á§∫„ÇítextMode„ÅÆÂÄ§„Å´Êàª„Åô
                const simpleTextMode = document.getElementById('simple-text-mode');
                if (simpleTextMode) simpleTextMode.value = state.textMode;
                updateModel();
                showToast('„Ç¢„Ç§„Ç≥„É≥„ÇíËß£Èô§„Åó„Åæ„Åó„Åü');
            });
            
            // Load icons and then initialize simple grid
            loadStockIcons().then(() => {
                initSimpleIconGrid();
            });

            console.log('V66 features initialized');
        })();
        
        // ==========================================
        // V67: ÂàùÊúüÂåñ„Ç≥„Éº„Éâ
        // ==========================================
        (function initV67Features() {
            // RaycasterÂàùÊúüÂåñÔºà„ÇØ„É™„ÉÉ„ÇØÈÖçÁΩÆÁî®Ôºâ
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            renderer.domElement.addEventListener('pointerdown', onCanvasPointerDown);

            // „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„ÉºÂàùÊúüÂåñ
            renderer.domElement.addEventListener('mousedown', onCanvasMouseDown);
            renderer.domElement.addEventListener('contextmenu', onCanvasContextMenu);
            initContextMenu();

            // „Ç¨„É†„Éú„Éº„É´ÂàùÊúüÂåñ
            initGumball();

            // „ÇÆ„É£„É©„É™„ÉºDBÂàùÊúüÂåñ
            initGalleryDB();

            // HUD„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            document.getElementById('hud-view-mode')?.addEventListener('click', () => {
                state.renderMode = (state.renderMode === 'wireframe') ? 'standard' : 'wireframe';
                document.getElementById('render-mode').value = state.renderMode;
                requestUpdate();
            });

            document.getElementById('hud-gumball-toggle')?.addEventListener('click', (e) => {
                const btn = e.currentTarget;
                btn.classList.toggle('active');
                const targetControls = document.getElementById('gumball-target-controls');
                
                if (btn.classList.contains('active')) {
                    if (targetControls) targetControls.style.display = 'block';
                    updateGumballAttachment();
                } else {
                    if (targetControls) targetControls.style.display = 'none';
                    if (gumballControl) gumballControl.detach();
                }
            });

            document.getElementById('hud-dimension')?.addEventListener('click', () => {
                const cb = document.getElementById('show-dimensions');
                if (cb) {
                    cb.checked = !cb.checked;
                    cb.dispatchEvent(new Event('change'));
                }
            });

            document.getElementById('hud-snapshot')?.addEventListener('click', () => {
                renderer.render(scene, camera);
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                link.download = `keycap_${timestamp}.png`;
                link.href = renderer.domElement.toDataURL('image/png');
                link.click();
                showToast("„Çπ„Éä„ÉÉ„Éó„Ç∑„Éß„ÉÉ„Éà„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü");
            });

            // ÊñáÂ≠ó„ÅÆË°®Á§∫/ÈùûË°®Á§∫„Éà„Ç∞„É´
            document.getElementById('hud-toggle-text')?.addEventListener('click', () => {
                state.enableText = !state.enableText;
                const btn = document.getElementById('hud-toggle-text');
                if (btn) btn.classList.toggle('active', state.enableText);
                // UI„Éë„Éç„É´„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÇÇÂêåÊúü
                const checkbox = document.getElementById('enable-text');
                if (checkbox) checkbox.checked = state.enableText;
                syncUI();
                requestUpdate();
                showToast(state.enableText ? "ÊñáÂ≠ó„ÇíË°®Á§∫" : "ÊñáÂ≠ó„ÇíÈùûË°®Á§∫");
            });

            // SVG„ÅÆË°®Á§∫/ÈùûË°®Á§∫„Éà„Ç∞„É´
            document.getElementById('hud-toggle-svg')?.addEventListener('click', () => {
                state.svgVisible = !state.svgVisible;
                const btn = document.getElementById('hud-toggle-svg');
                if (btn) btn.classList.toggle('active', state.svgVisible);
                // UI„Éë„Éç„É´„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÇÇÂêåÊúü
                const checkbox = document.getElementById('svg-visible');
                if (checkbox) checkbox.checked = state.svgVisible;
                syncUI();
                requestUpdate();
                showToast(state.svgVisible ? "SVG„ÇíË°®Á§∫" : "SVG„ÇíÈùûË°®Á§∫");
            });

            // ÂàùÊúüÁä∂ÊÖã„ÅÆ„Éú„Çø„É≥Ë°®Á§∫„ÇíÊõ¥Êñ∞
            const textBtn = document.getElementById('hud-toggle-text');
            if (textBtn) textBtn.classList.toggle('active', state.enableText);
            const svgBtn = document.getElementById('hud-toggle-svg');
            if (svgBtn) svgBtn.classList.toggle('active', state.svgVisible);

            // „ÇÆ„É£„É©„É™„Éº„Å´‰øùÂ≠ò„Éú„Çø„É≥
            document.getElementById('hud-gallery-save')?.addEventListener('click', () => {
                saveToGallery();
            });

            document.getElementById('hud-gallery')?.addEventListener('click', () => {
                const strip = document.getElementById('gallery-strip');
                if (strip) {
                    if (strip.classList.contains('show')) {
                        strip.classList.remove('show');
                        strip.classList.add('hide');
                        // „ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó‰ΩçÁΩÆ„ÇíÂç≥Â∫ß„Å´Êõ¥Êñ∞ÔºàÈñâ„Åò„ÇãÊôÇÔºâ
                        if (typeof window.updateHintTooltipPosition === 'function') {
                            window.updateHintTooltipPosition();
                        }
                        // ViewHelper‰ΩçÁΩÆ„ÇíÂç≥Â∫ß„Å´Êõ¥Êñ∞ÔºàÈñâ„Åò„ÇãÊôÇÔºâ
                        if (typeof window.updateViewHelperPosition === 'function') {
                            window.updateViewHelperPosition();
                        }
                        setTimeout(() => {
                            strip.style.display = 'none';
                            strip.classList.remove('hide');
                        }, 200);
                    } else {
                        strip.style.display = 'block';
                        strip.classList.add('show');
                        loadGallery();
                        // „ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó‰ΩçÁΩÆ„ÇíÂç≥Â∫ß„Å´Êõ¥Êñ∞ÔºàÈñã„ÅèÊôÇÔºâ
                        if (typeof window.updateHintTooltipPosition === 'function') {
                            window.updateHintTooltipPosition();
                        }
                        // ViewHelper‰ΩçÁΩÆ„ÇíÂç≥Â∫ß„Å´Êõ¥Êñ∞ÔºàÈñã„ÅèÊôÇÔºâ
                        if (typeof window.updateViewHelperPosition === 'function') {
                            window.updateViewHelperPosition();
                        }
                    }
                }
            });

            // „Ç®„ÇØ„Çπ„Éù„Éº„Éà„Éú„Çø„É≥ÔºàÁµ±Âêà„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Éú„Çø„É≥„Çí„ÇØ„É™„ÉÉ„ÇØÔºâ
            const exportBtn = document.getElementById('hud-export');
            
            exportBtn?.addEventListener('click', (e) => {
                e.stopPropagation();
                document.getElementById('btn-export-single')?.click();
            });

            // ÈÖçÁΩÆ„É¢„Éº„Éâ„Éú„Çø„É≥
            document.getElementById('btn-click-place-mode')?.addEventListener('click', (e) => {
                isPlaceMode = !isPlaceMode;
                const btn = e.currentTarget;
                const panel = document.getElementById('v67-placement-panel');
                
                btn.textContent = isPlaceMode ? "ÈÖçÁΩÆ„É¢„Éº„Éâ: ON („ÇØ„É™„ÉÉ„ÇØÂæÖÊ©ü‰∏≠)" : "ÈÖçÁΩÆ„É¢„Éº„Éâ: OFF";
                btn.style.background = isPlaceMode ? "#00e5ff" : "";
                btn.style.color = isPlaceMode ? "#000" : "";
                
                if (panel) {
                    panel.classList.toggle('active', isPlaceMode);
                }
                
                renderer.domElement.style.cursor = isPlaceMode ? 'crosshair' : '';
            });

            // „Çπ„ÉÜ„É†„Çø„Ç§„ÉóÈÅ∏Êäû
            document.getElementById('stem-type-select')?.addEventListener('change', (e) => {
                state.stemType = e.target.value;
                requestUpdate();
            });

            // „ÇÆ„É£„É©„É™„Éº„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„Éº„ÅÆ„Ç§„Éô„É≥„Éà
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#gallery-context-menu')) {
                    hideGalleryContextMenu();
                }
            });
            
            document.querySelectorAll('.gallery-ctx-item').forEach(item => {
                item.addEventListener('click', async () => {
                    if (!currentGalleryItem) return;
                    
                    const action = item.dataset.action;
                    
                    if (action === 'load') {
                        loadFromGallery(currentGalleryItem);
                    } else if (action === 'export') {
                        // Áµ±Âêà„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÔºàÁ¢∫Ë™çÁîªÈù¢„Åß„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÈÅ∏ÊäûÔºâ
                        const itemToExport = currentGalleryItem; // ÂÖà„Å´‰øùÂ≠ò
                        hideGalleryContextMenu();
                        
                        if (!itemToExport) return;
                        
                        // Áä∂ÊÖã„ÇíÈÅ©Áî®
                        Object.assign(state, itemToExport.state);
                        
                        // „ÇÆ„É£„É©„É™„Éº„Å´„Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆö„Åå„ÅÇ„ÇãÂ†¥Âêà„ÄÅamsConfig„Å´„ÇÇÂèçÊò†
                        if (state.bodyExtruder) {
                            amsConfig.bodyExtruder = state.bodyExtruder;
                            amsConfig.bodyExtruderSet = true;
                        }
                        if (state.textExtruder) {
                            amsConfig.textExtruder = state.textExtruder;
                            amsConfig.textExtruderSet = true;
                        }
                        
                        syncUI();
                        if (typeof updateSettingsTabPalette === 'function') updateSettingsTabPalette();
                        requestUpdate();
                        
                        // „É¢„Éá„É´Êõ¥Êñ∞„ÇíÂæÖ„Å§
                        await new Promise(resolve => setTimeout(resolve, 400));
                        
                        // Á¢∫Ë™çÁîªÈù¢„ÇíË°®Á§∫Ôºà„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÈÅ∏Êäû‰ªò„ÅçÔºâ
                        const result = await showExportPopup({ type: 'single', format: '3MF', showFormatSelector: true });
                        
                        if (result.confirmed) {
                            const format = result.format.toLowerCase();
                            if (format === 'stl') {
                                galleryExportSTL(itemToExport.name);
                            } else if (format === '3mf') {
                                await galleryExport3MF(itemToExport.name);
                            } else if (format === 'obj') {
                                galleryExportOBJ(itemToExport.name);
                            }
                            showToast(`„Äå${itemToExport.name}„Äç„Çí${result.format}„Åß„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„Åü`);
                        }
                        return; // hideGalleryContextMenu„ÅØÊó¢„Å´Âëº„Å≥Âá∫„ÅóÊ∏à„Åø
                    } else if (action === 'delete') {
                        deleteFromGallery(currentGalleryItem.id);
                    }
                    
                    hideGalleryContextMenu();
                });
            });
            
            // ‰∏ÄÊã¨Ëâ≤Ë®≠ÂÆö„Éú„Çø„É≥
            document.getElementById('batch-color-btn')?.addEventListener('click', (e) => {
                e.stopPropagation();
                showBatchColorPopup();
            });
            
            // ‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Éú„Çø„É≥Ôºà„ÉÄ„Ç§„Ç¢„É≠„Ç∞Ë°®Á§∫Ôºâ
            // ‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Éú„Çø„É≥
            document.getElementById('batch-export-btn')?.addEventListener('click', (e) => {
                e.stopPropagation();
                executeBatchExport();
            });
            
            // ‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Éó„É¨„Éì„É•„Éº„ÅÆÊ®™„Çπ„ÇØ„É≠„Éº„É´
            const batchPreview = document.getElementById('batch-export-preview');
            batchPreview?.addEventListener('wheel', (e) => {
                if (e.deltaY !== 0) {
                    e.preventDefault();
                    batchPreview.scrollLeft += e.deltaY;
                }
            }, { passive: false });
            
            // „ÇÆ„É£„É©„É™„Éº„Çπ„Éà„É™„ÉÉ„Éó„ÅÆÊ®™„Çπ„ÇØ„É≠„Éº„É´ÂØæÂøú
            const galleryContent = document.getElementById('gallery-content');
            galleryContent?.addEventListener('wheel', (e) => {
                if (e.deltaY !== 0) {
                    e.preventDefault();
                    galleryContent.scrollLeft += e.deltaY;
                }
            }, { passive: false });
            
            // „ÇÆ„É£„É©„É™„Éº„Ç≥„É≥„ÉÜ„É≥„ÉÑÂÜÖ„ÅÆ„ÇØ„É™„ÉÉ„ÇØ„Åå‰∏ÄÊã¨„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Éú„Çø„É≥„Å´‰ºùÊí≠„Åó„Å™„ÅÑ„Çà„ÅÜ„Å´„Åô„Çã
            galleryContent?.addEventListener('click', (e) => {
                e.stopPropagation();
            });
            
            // Âà•„Çø„Éñ„Åã„ÇâÊàª„Å£„Å¶„Åç„ÅüÊôÇ„Å´„ÇÆ„É£„É©„É™„Éº„ÇíÂÜçÊèèÁîª
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    const strip = document.getElementById('gallery-strip');
                    if (strip && strip.classList.contains('show')) {
                        // Â∞ë„ÅóÈÅÖÂª∂„Åï„Åõ„Å¶ÂÜçÊèèÁîª
                        setTimeout(() => {
                            loadGallery();
                        }, 100);
                    }
                }
            });

            console.log('V67 features initialized');
        })();
        
        // Helper function for single mesh 3MF export (used by Tolerance Test Kit & Sprue Kit)
        async function export3MFSingle(mesh, colorHex, extruder = 1) {
            const geometry = mesh.geometry;
            if (!geometry) return null;

            const zip = new JSZip();
            
            // Convert geometry to vertices and triangles array
            let geo = geometry.clone();
            if (!geo.index) {
                geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
            }
            
            const position = geo.attributes.position;
            const vertices = [];
            const triangles = [];
            const extIdx = (extruder || 1) - 1; // 0-indexed
            
            if (geo.index) {
                const indexArray = geo.index.array;
                for (let i = 0; i < position.count; i++) {
                    vertices.push(`      <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                }
                for (let i = 0; i < indexArray.length; i += 3) {
                    triangles.push(`      <triangle v1="${indexArray[i]}" v2="${indexArray[i+1]}" v3="${indexArray[i+2]}" pid="1" p1="${extIdx}" />`);
                }
            } else {
                for (let i = 0; i < position.count; i++) {
                    vertices.push(`      <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                }
                for (let i = 0; i < position.count; i += 3) {
                    triangles.push(`      <triangle v1="${i}" v2="${i+1}" v3="${i+2}" pid="1" p1="${extIdx}" />`);
                }
            }
            
            // Create basematerials for all 16 possible extruders
            let baseMaterials = '';
            for (let i = 0; i < 16; i++) {
                const slotColor = i === extIdx ? (colorHex || '#808080').slice(1).toUpperCase() : '808080';
                baseMaterials += `   <m:base name="Extruder${i+1}" displaycolor="#${slotColor}" />\n`;
            }
            
            // Create 3MF XML structure
            const modelXml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02" xmlns:m="http://schemas.microsoft.com/3dmanufacturing/material/2015/02">
<metadata name="Application">Keycap Generator V67</metadata>
<resources>
 <m:basematerials id="1">
${baseMaterials} </m:basematerials>
 <object id="2" name="Mesh" type="model">
   <mesh>
     <vertices>
${vertices.join('\n')}
     </vertices>
     <triangles>
${triangles.join('\n')}
     </triangles>
   </mesh>
 </object>
</resources>
<build>
 <item objectid="2" />
</build>
</model>`;

            const contentTypes = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
<Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />
</Types>`;

            const rels = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
<Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>`;

            zip.file("[Content_Types].xml", contentTypes);
            zip.folder("_rels").file(".rels", rels);
            zip.folder("3D").file("3dmodel.model", modelXml);
            
            return await zip.generateAsync({ type: "blob", compression: "DEFLATE" });
        }
        
        init();
    </script>

    <!-- V67: „Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„Éó „Ç™„Éº„Éê„Éº„É¨„Ç§ -->
    <div id="dnd-overlay">
        <h1>üìÇ „Éï„Ç°„Ç§„É´„Çí„Éâ„É≠„ÉÉ„Éó (SVG / ÁîªÂÉè / JSON)</h1>
    </div>

    <!-- V67: „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Éò„É´„Éó„Éú„Çø„É≥ -->
    <button id="btn-help" title="Shortcuts (?)">?</button>

    <!-- V67: „Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà‰∏ÄË¶ß„Ç™„Éº„Éê„Éº„É¨„Ç§ -->
    <div id="shortcut-overlay">
        <div class="shortcut-card" onclick="event.stopPropagation()">
            <h2>‚å®Ô∏è „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà</h2>
            <div class="key-row"><span>ÂÖÉ„Å´Êàª„Åô (Undo)</span> <span><span class="kbd">Ctrl</span> + <span class="kbd">Z</span></span></div>
            <div class="key-row"><span>„ÇÑ„ÇäÁõ¥„Åó (Redo)</span> <span><span class="kbd">Ctrl</span> + <span class="kbd">Y</span></span></div>
            <div class="key-row"><span>„Ç®„ÇØ„Çπ„Éù„Éº„Éà</span> <span><span class="kbd">Ctrl</span> + <span class="kbd">S</span></span></div>
            <div class="key-row"><span>Ê≠£Èù¢„Éì„É•„Éº (Front)</span> <span><span class="kbd">1</span></span></div>
            <div class="key-row"><span>ÂÅ¥Èù¢„Éì„É•„Éº (Side)</span> <span><span class="kbd">2</span></span></div>
            <div class="key-row"><span>‰∏äÈù¢„Éì„É•„Éº (Top)</span> <span><span class="kbd">3</span></span></div>
            <div class="key-row"><span>Á≠âËßí„Éì„É•„Éº (Isometric)</span> <span><span class="kbd">0</span></span></div>
            <div class="key-row"><span>„ÉØ„Ç§„É§„Éº„Éï„É¨„Éº„É†ÂàáÊõø</span> <span><span class="kbd">W</span></span></div>
            <div class="key-row"><span>ÂØ∏Ê≥ïÁ∑öÂàáÊõø</span> <span><span class="kbd">D</span></span></div>
            <div class="key-row"><span>„Ç¨„É†„Éú„Éº„É´ÂàáÊõø</span> <span><span class="kbd">G</span></span></div>
            <div class="key-row"><span>„Éò„É´„ÉóË°®Á§∫</span> <span><span class="kbd">?</span></span></div>
            <div class="key-row"><span>„Éá„Éê„ÉÉ„Ç∞ / „É°„É≥„ÉÜ„Éä„É≥„Çπ</span> <span><span class="kbd">F5</span></span></div>
            <div class="key-row"><span>Wiki „Éò„É´„Éó</span> <span><span class="kbd">F1</span></span></div>
            <div style="text-align:center; margin-top:20px;">
                <button onclick="document.getElementById('shortcut-overlay').style.display='none'" style="padding:10px 30px; cursor:pointer; background:#00e5ff; border:none; border-radius:4px; font-weight:bold;">Èñâ„Åò„Çã</button>
            </div>
        </div>
    </div>
    <!-- F5 Debug Panel -->
    <div id="debug-panel-overlay" onclick="if(event.target===this){this.style.display='none';}">
        <div class="debug-panel" onclick="event.stopPropagation()">
            <h2 data-i18n="debug_title">üõ†Ô∏è „Éá„Éê„ÉÉ„Ç∞ / „É°„É≥„ÉÜ„Éä„É≥„Çπ <span style="font-size:0.65rem; color:#888; font-weight:normal;">(F5)</span></h2>
            
            <div class="debug-section">
                <h3 data-i18n="debug_cache_section">üóëÔ∏è „Ç≠„É£„ÉÉ„Ç∑„É• / „Éá„Éº„Çø„ÇØ„É™„Ç¢</h3>
                <button class="debug-btn danger" id="debug-clear-all-cache" data-i18n="debug_clear_all">üóëÔ∏è ÂÖ®„Ç≠„É£„ÉÉ„Ç∑„É•„ÇØ„É™„Ç¢ÔºàlocalStorageÂÖ®ÂâäÈô§ + „Éö„Éº„Ç∏„É™„É≠„Éº„ÉâÔºâ</button>
                <button class="debug-btn" id="debug-clear-filament" data-i18n="debug_clear_filament">üé® „Éï„Ç£„É©„É°„É≥„ÉàË®≠ÂÆö„ÇØ„É™„Ç¢ÔºàAMSË®≠ÂÆö„ÇíÂàùÊúüÂåñÔºâ</button>
                <button class="debug-btn" id="debug-clear-gallery" data-i18n="debug_clear_gallery">üì¶ „ÇÆ„É£„É©„É™„ÉºÂÖ®ÂâäÈô§ÔºàÂÖ®„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÇíÂâäÈô§Ôºâ</button>
                <button class="debug-btn" id="debug-clear-csk" data-i18n="debug_clear_csk">üìê „Ç´„Çπ„Çø„É†„Çπ„Éó„É´„Ç≠„ÉÉ„ÉàÈÖçÁΩÆ„Çí„É™„Çª„ÉÉ„Éà</button>
                <button class="debug-btn" id="debug-reset-state" data-i18n="debug_reset_state">üîÑ „Éë„É©„É°„Éº„ÇøÂàùÊúüÂåñÔºà„Éá„Éï„Ç©„É´„ÉàÂÄ§„Å´Êàª„ÅôÔºâ</button>
            </div>
            
            <div class="debug-section">
                <h3 data-i18n="debug_state_section">üìä ÁèæÂú®„ÅÆÁä∂ÊÖãÊÉÖÂ†±</h3>
                <div class="debug-info" id="debug-state-info" data-i18n="msg_loading">Ë™≠„ÅøËæº„Åø‰∏≠...</div>
            </div>
            
            <div class="debug-section">
                <h3 data-i18n="debug_tools_section">üîß „ÉÑ„Éº„É´</h3>
                <button class="debug-btn" id="debug-export-state" data-i18n="debug_export_state">üíæ ÁèæÂú®„ÅÆÂÖ®Áä∂ÊÖã„ÇíJSON„Åß„Ç®„ÇØ„Çπ„Éù„Éº„Éà</button>
                <button class="debug-btn" id="debug-import-state" data-i18n="debug_import_state">üìÇ JSON„Åã„ÇâÁä∂ÊÖã„Çí„Ç§„É≥„Éù„Éº„Éà</button>
                <button class="debug-btn" id="debug-force-rebuild" data-i18n="debug_force_rebuild">‚ö° 3D„É¢„Éá„É´„ÇíÂº∑Âà∂ÂÜçÊßãÁØâ</button>
                <button class="debug-btn" id="debug-log-state" data-i18n="debug_log_state">üìã „Ç≥„É≥„ÇΩ„Éº„É´„Å´ÂÖ®stateÂá∫Âäõ</button>
            </div>
            
            <div style="display:flex; justify-content:space-between; align-items:center; margin-top:15px;">
                <span class="wiki-hint" data-help-url-ja="https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%F0%9F%90%9E%20%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E3%83%A2%E3%83%BC%E3%83%89%20(Debug%20Mode)%20(v67.0%20New)" data-help-url-en="https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9#:~:text=%F0%9F%90%9E%20Debug%20Mode%20(v67.0%20New)"><span class="kbd">F1</span> <span data-i18n="wiki_hint">Wiki„ÅßË©≥„Åó„ÅèË¶ã„Çã</span></span>
                <button onclick="document.getElementById('debug-panel-overlay').style.display='none'" style="padding:10px 30px; cursor:pointer; background:#ff5252; border:none; border-radius:4px; font-weight:bold; color:#fff;" data-i18n="btn_close">Èñâ„Åò„Çã</button>
            </div>
        </div>
    </div>

</body>
</html>
