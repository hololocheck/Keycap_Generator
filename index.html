<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="google-site-verification" content="E2yuICa6eKYqirbpWGXo9DtwvVG9mlCf_g56Qzpse2M" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keycap Generator V66</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 306.06 217.55'%3E%3Cstyle%3E.a%7Bstroke:%23ccc;stroke-miterlimit:10;fill:none%7D.b%7Bfill:aqua;stroke:aqua;stroke-miterlimit:10%7D.c%7Bstroke:aqua;stroke-miterlimit:10;fill:none;stroke-width:4px%7D.d%7Bfill:%23b3b3b3%7D%3C/style%3E%3Cpolygon class='d' points='273.2 41.92 305.59 144.63 149.26 216.93 148.91 216.18 151.25 80.26 273.2 41.92'/%3E%3Cpolygon class='d' points='273.2 41.92 151.25 80.26 35.16 29.06 152.73 .49 273.2 41.92'/%3E%3Cpolygon class='d' points='151.25 80.26 148.91 216.18 .25 136.62 .61 135.77 35.16 29.06 151.25 80.26'/%3E%3Cline class='a' x1='35.16' y1='29.06' x2='.61' y2='135.77'/%3E%3Cline class='a' x1='.25' y1='136.62' x2='148.91' y2='216.18'/%3E%3Cline class='a' x1='151.25' y1='80.26' x2='35.16' y2='29.06'/%3E%3Cline class='a' x1='148.91' y1='216.18' x2='151.25' y2='80.26'/%3E%3Cline class='a' x1='273.2' y1='41.92' x2='151.25' y2='80.26'/%3E%3Cline class='a' x1='305.59' y1='144.63' x2='273.2' y2='41.92'/%3E%3Cpolyline class='a' points='148.91 217.1 149.26 216.93 305.59 144.63'/%3E%3Cline class='a' x1='152.73' y1='.49' x2='273.2' y2='41.92'/%3E%3Cline class='a' x1='152.73' y1='.49' x2='35.16' y2='29.06'/%3E%3Cline class='c' x1='86.1' y1='30.23' x2='119.97' y2='22'/%3E%3Cline class='c' x1='155.68' y1='60.92' x2='86.1' y2='30.23'/%3E%3Cline class='c' x1='224.32' y1='40.72' x2='154.45' y2='60.92'/%3E%3Cline class='c' x1='224.32' y1='41.22' x2='198.07' y2='32.19'/%3E%3Cpath class='b' d='M167.62,24.24s-20.08-4.1-28.79,0c-8.7,4.1,7.85-6.02,3.19-9.13s11.8,5.35,23.8.19c12-5.15-13.25,5.77,1.79,8.94Z'/%3E%3Cpath class='b' d='M169.51,46.26s-18.64-3.8-26.72,0c-8.08,3.8,7.29-5.59,2.96-8.48-4.32-2.88,10.96,4.96,22.1.18,11.14-4.78-12.3,5.36,1.66,8.3Z'/%3E%3Cpath class='b' d='M134.59,37.59s-10.53-2.15-15.09,0,4.12-3.16,1.67-4.79c-2.44-1.63,6.19,2.8,12.48.1,6.29-2.7-6.94,3.03.94,4.69Z'/%3E%3C/svg%3E">
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: rgba(30, 30, 30, 0.98);
            --text-main: #e0f7fa;
            --text-muted: #80deea;
            --accent: #00e5ff;
            --accent-hover: #84ffff;
            --border: #444;
            --input-bg: #263238;
            --danger: #ff5252;
            --sub-bg: rgba(0, 229, 255, 0.05); 
            --import-bg: rgba(255, 152, 0, 0.05);
            --texture-bg: rgba(233, 30, 99, 0.05);
            --highlight: rgba(255, 235, 59, 0.3);
        }

        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: var(--bg-color); color: var(--text-main); }
        
        #canvas-container { 
            position: absolute; left: 400px; width: calc(100% - 400px); height: 100%; top: 0; z-index: 1; 
            transition: all 0.3s ease; 
        }
        
        #ui-panel {
            position: absolute; left: 0; top: 0; width: 400px; height: 100%;
            background: var(--panel-bg); border-right: 1px solid var(--border);
            box-sizing: border-box; 
            display: flex; flex-direction: column; 
            box-shadow: 4px 0 15px rgba(0,0,0,0.6); z-index: 2;
            padding: 0; transition: transform 0.3s ease;
        }

        body.ui-closed #ui-panel { transform: translateX(-400px); }
        body.ui-closed #canvas-container { left: 0 !important; width: 100% !important; }

        #ui-header-area { flex: 0 0 auto; padding: 15px 15px 5px 15px; background: var(--panel-bg); border-bottom: 1px solid #333; z-index: 10; }
        #ui-scroll-area { flex: 1; overflow-y: auto; padding: 10px 15px 30px 15px; scroll-behavior: smooth; }
        #ui-scroll-area::-webkit-scrollbar { width: 6px; }
        #ui-scroll-area::-webkit-scrollbar-thumb { background: #006064; border-radius: 3px; }

        #top-right-panel {
            position: absolute; top: 10px; right: 10px; width: 260px;
            background: rgba(20, 20, 20, 0.95); border: 1px solid var(--accent);
            padding: 12px 12px 12px 50px; border-radius: 6px; z-index: 10;
            box-shadow: -4px 4px 15px rgba(0,0,0,0.5); font-family: monospace; transition: all 0.3s ease;
        }
        #top-right-panel:hover { background: rgba(30, 30, 30, 0.98); box-shadow: -4px 4px 20px rgba(0,229,255,0.2); }
        #top-right-panel.stats-collapsed { height: 36px; width: 36px; min-width: 0; padding: 0; overflow: hidden; border: none; background: transparent; box-shadow: none; }
        #top-right-panel.stats-collapsed .cost-row, #top-right-panel.stats-collapsed .fil-control, #top-right-panel.stats-collapsed #btn-toggle-fil, #top-right-panel.stats-collapsed #info-fil-name, #top-right-panel.stats-collapsed #fil-details-panel { display: none; }

        .cost-row { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 1.0rem; border-bottom: 1px solid #333; padding-bottom: 4px; }
        .cost-val { color: var(--accent); font-weight: bold; }
        .cost-sub { font-size: 0.75rem; color: #aaa; text-align: right; margin-bottom: 10px; }
        .fil-control { margin-top: 8px; }
        .fil-control label { color: #b2ff59; font-size: 0.75rem; margin-bottom: 2px; display: block; }
        .fil-control select { width: 100%; padding: 5px; font-size: 0.85rem; background: #111; border: 1px solid #555; color: #fff; margin-bottom: 5px; border-radius: 4px; cursor: pointer; }
        .fil-details { display: none; margin-top: 8px; padding-top: 8px; border-top: 1px dashed #444; background: rgba(255,255,255,0.02); padding: 5px; border-radius: 4px; }
        .fil-details.open { display: block; animation: fadeIn 0.2s; }
        .fil-input-row { display: flex; gap: 5px; margin-bottom: 5px; align-items: center; }
        .fil-input-row label { width: 45px; color: #aaa; font-size: 0.7rem; margin: 0; }
        .fil-input-row input { flex: 1; min-width: 0; background: #222; border: 1px solid #444; color: #fff; padding: 4px; font-size: 0.8rem; text-align: right; border-radius: 2px; }
        #btn-toggle-fil { width: 100%; padding: 4px; font-size: 0.75rem; background: transparent; border: 1px solid #333; color: #aaa; cursor: pointer; border-radius: 4px; transition: 0.2s; margin-top: 5px; }
        #btn-toggle-fil:hover { color: #fff; border-color: #777; background: rgba(255,255,255,0.05); }

        .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .title-block { display: flex; align-items: center; gap: 10px; }
        #app-logo { height: 45px; width: auto; cursor: pointer; transition: transform 0.2s, filter 0.2s; filter: drop-shadow(0 0 2px rgba(0, 229, 255, 0.3)); }
        #app-logo:hover { transform: scale(1.1); filter: drop-shadow(0 0 5px rgba(0, 229, 255, 0.8)); }
        h2 { margin: 0; color: var(--accent); font-size: 1.3rem; line-height: 1.1; }
        .ver { font-size: 0.65rem; color: var(--text-muted); opacity: 0.8; display: block; }
        #language-select { background: var(--input-bg); border: 1px solid var(--border); color: var(--text-main); padding: 4px 8px; border-radius: 4px; font-size: 0.85rem; cursor: pointer; }

        #nav-bar { display: flex; flex-direction: column; gap: 5px; margin-bottom: 5px; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px; border: 1px solid #333; }
        .nav-row { display: flex; gap: 5px; }
        #section-select { flex: 1; background: #222; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 4px; font-size: 0.85rem; cursor: pointer; }
        #section-select:hover { border-color: var(--accent); }
        #search-box { flex: 1; background: #222; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 4px 8px; font-size: 0.85rem; }
        #search-box:focus { border-color: var(--accent); outline: none; }
        .search-highlight { background-color: var(--highlight); color: #000 !important; border-radius: 2px; padding: 0 2px; transition: 0.3s; }

        h3 { font-size: 0.85rem; border-bottom: 1px solid var(--accent); margin-top: 15px; padding-bottom: 3px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; scroll-margin-top: 10px; }
        .control-group { margin-bottom: 6px; }
        .control-row { display: flex; gap: 8px; align-items: center; margin-bottom: 4px; }
        label { font-size: 0.75rem; display: flex; justify-content: space-between; color: #b2ebf2; margin-bottom: 2px; align-items: center; white-space: nowrap; }
        span.val { color: var(--accent); font-family: monospace; font-size: 0.9rem; font-weight: bold; min-width: 35px; text-align: right; display: inline-block; }
        
        input.direct-input { width: 50px; background: #000; border: 1px solid var(--accent); color: var(--accent); font-family: monospace; font-size: 0.9rem; text-align: right; padding: 2px 4px; display: none; z-index:100; }
        input[type="range"] { width: 100%; margin: 4px 0; cursor: pointer; appearance: none; background: transparent; }
        input[type="range"]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #006064; border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; height: 14px; width: 14px; border-radius: 50%; background: var(--accent); margin-top: -5px; box-shadow: 0 0 5px var(--accent); transition: 0.2s; }
        input[type="range"]:disabled { opacity: 0.3; cursor: not-allowed; }
        select, input[type="text"], textarea { width: 100%; background: var(--input-bg); border: 1px solid #00838f; color: white; padding: 6px; border-radius: 4px; font-size: 0.85rem; font-family: sans-serif; box-sizing: border-box; }
        textarea { resize: vertical; min-height: 40px; }
        
        .toggle-switch { display: flex; align-items: center; gap: 8px; cursor: pointer; justify-content: start; width: 100%; margin-bottom: 4px; }
        .toggle-input { display: none; }
        .toggle-knob { width: 36px; height: 18px; background: #444; border-radius: 9px; position: relative; transition: 0.3s; border:1px solid #666; flex-shrink: 0; }
        .toggle-knob::after { content:''; position:absolute; left:2px; top:2px; width:12px; height:12px; background:white; border-radius:50%; transition:0.3s; }
        .toggle-input:checked + .toggle-knob { background: var(--accent); border-color:var(--accent); }
        .toggle-input:checked + .toggle-knob::after { left: 20px; background: black; }
        .toggle-label { color: #e0f7fa; font-size: 0.8rem; user-select: none; }

        .hint-tooltip { position: fixed; bottom: 20px; background: rgba(0, 40, 45, 0.95); border: 1px solid var(--accent); color: #e0f7fa; padding: 10px 14px; border-radius: 6px; font-size: 0.75rem; max-width: 320px; z-index: 9999; pointer-events: auto; box-shadow: 0 4px 20px rgba(0, 229, 255, 0.3); opacity: 0; transform: translateY(5px); transition: opacity 0.3s ease, transform 0.3s ease; line-height: 1.5; }
        .hint-tooltip.visible { opacity: 1; transform: translateY(0); }
        .hint-tooltip .hint-text::before { content: 'üí°'; margin-right: 6px; }
        .hint-tooltip .hint-text { display: block; }
        .hint-tooltip .hint-video-area { display: none; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px dashed rgba(0, 229, 255, 0.3); }
        .hint-tooltip.show-video .hint-video-area { display: block; animation: fadeIn 0.3s ease; }
        .hint-tooltip .hint-video-placeholder { width: 100%; height: 120px; background: rgba(0, 0, 0, 0.5); border: 1px dashed rgba(0, 229, 255, 0.5); border-radius: 4px; display: flex; justify-content: center; align-items: center; color: #80deea; font-size: 0.7rem; text-align: center; }
        .hint-tooltip .hint-video-placeholder video, .hint-tooltip .hint-video-placeholder img { width: 100%; height: 100%; object-fit: contain; border-radius: 4px; }
        .hint-tooltip .hint-f1-notice { margin-top: 8px; font-size: 0.65rem; color: #80deea; opacity: 0.8; text-align: right; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        [data-hint] { position: relative; }
        [data-hint].hint-highlight { background: rgba(0, 229, 255, 0.1); border-radius: 4px; transition: background 0.3s; }

        .file-upload { position: relative; display: inline-block; width: 100%; }
        .file-upload input[type="file"] { display: none; }
        .file-upload-label { display: block; width: 100%; padding: 8px; background: #004d40; border: 1px dashed #00e5ff; color: #e0f7fa; text-align: center; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: 0.3s; box-sizing: border-box; }
        .file-upload-label:hover { background: #006064; }
        .file-upload-label.preset { background: #37474f; border-color: #90a4ae; color: #eceff1; }
        .file-upload-label.preset:hover { background: #455a64; }

        button { width: 100%; background: transparent; border: 1px solid var(--accent); padding: 10px; color: var(--accent); font-weight: bold; cursor: pointer; border-radius: 4px; margin-top: 5px; transition: 0.2s; text-transform: uppercase; font-size: 0.8rem; }
        button:hover { background: var(--accent); color: #000; box-shadow: 0 0 10px var(--accent); }
        button:disabled { border-color: #555; color: #555; background: rgba(0,0,0,0.5); cursor: not-allowed; box-shadow: none; }
        button.secondary { border-color: #555; color: #aaa; }
        button.secondary:hover { background: #555; color: white; }
        button.danger { border-color: var(--danger); color: var(--danger); margin-top:0; padding: 0; }
        button.danger:hover { background: var(--danger); color: white; }
        button.accent { background: rgba(0, 229, 255, 0.1); }
        button.accent:hover { background: var(--accent); color: black; }
        button.primary-3mf { border-color: #4caf50; color: #4caf50; background: rgba(76, 175, 80, 0.1); }
        button.primary-3mf:hover { background: #4caf50; color: white; }
        .btn-square { width: 34px; height: 34px; display: flex; justify-content: center; align-items: center; font-size: 1.2rem; margin: 0; flex-shrink: 0; }
        .btn-small { padding: 6px; font-size: 0.75rem; margin-top: 0; }

        .color-input { -webkit-appearance: none; appearance: none; border: none; width: 100%; height: 30px; cursor: pointer; padding: 0; background: none; }
        .palette-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-top: 6px; }
        .palette-swatch { width: 100%; padding-bottom: 60%; border-radius: 3px; cursor: pointer; border: 1px solid #555; transition: transform 0.1s; }
        .palette-swatch:hover { transform: scale(1.1); border-color: white; z-index: 10; box-shadow: 0 0 8px rgba(255,255,255,0.5); }

        #history-controls { position: absolute; top: 10px; left: 450px; z-index: 10; display: flex; gap: 5px; transition: all 0.3s ease; }
        .hist-btn { background: rgba(0,0,0,0.8); border: 1px solid var(--accent); color: var(--accent); width: 40px; height: 40px; border-radius: 4px; font-size: 1.2rem; cursor: pointer; display: flex; justify-content: center; align-items: center; padding: 0; margin: 0; }
        .hist-btn:hover { background: var(--accent); color: #000; }
        .hist-btn:disabled { border-color: #555; color: #555; background: rgba(0,0,0,0.5); }
        #render-mode-controls { position: absolute; top: 60px; left: 450px; z-index: 10; width: 120px; transition: all 0.3s ease; }
        #render-mode-controls select { background: rgba(0,0,0,0.8); border: 1px solid var(--accent); color: var(--accent); padding: 5px; cursor: pointer; width: 100%; }
        body.ui-closed #history-controls { left: 50px; top: 10px; }
        body.ui-closed #render-mode-controls { left: 50px; top: 60px; }
        body.ui-closed #preset-float-panel { left: 50px; top: 110px; }

        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; color: var(--accent); font-size: 1.5rem; transition: opacity 0.5s; }
        #force-start-btn { margin-top: 20px; padding: 10px 20px; border: 1px solid white; color: white; background: transparent; cursor: pointer; display: none; }
        #error-log { color:#ff5252; font-size:0.9rem; margin-top:10px; max-width:80%; font-family:monospace; white-space: pre-wrap; }
        #batch-progress { margin-top: 20px; font-size: 1rem; color: var(--text-main); display: none; }

        .info-link { font-size: 0.75rem; color: #aaa; margin-bottom: 6px; line-height: 1.3; }
        .info-link a { color: var(--accent); text-decoration: none; }
        .custom-select-container { position: relative; width: 100%; }
        .custom-select-head { background: var(--input-bg); border: 1px solid #00838f; color: white; padding: 8px; border-radius: 4px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; }
        .custom-select-list { position: absolute; top: 100%; left: 0; right: 0; background: #1e272c; border: 1px solid var(--accent); border-top: none; z-index: 999; max-height: 200px; overflow-y: auto; display: none; border-radius: 0 0 4px 4px; }
        .custom-select-list.open { display: block; }
        .custom-option { padding: 8px; cursor: pointer; font-size: 0.85rem; border-bottom: 1px solid #333; }
        .custom-option:hover { background: rgba(0, 229, 255, 0.2); color: white; }
        .custom-option.selected { background: var(--accent); color: black; font-weight: bold; }

        .section-sep { border-top: 1px solid #333; margin: 15px 0 5px 0; }
        .v60-sub-panel { background: var(--sub-bg); padding: 8px; border-radius: 4px; border: 1px dashed #444; margin-top: 5px; }
        .v60-import-panel { background: var(--import-bg); padding: 8px; border-radius: 4px; border: 1px dashed #ff9800; margin-top: 5px; }
        .v60-label { color: #ffeb3b; font-weight: bold; }
        .v60-label-side { color: #b2ff59; font-weight: bold; }
        .v61-texture-panel { background: var(--texture-bg); padding: 8px; border-radius: 4px; border: 1px dashed #e91e63; margin-top: 5px; }
        .v63-texture-map-panel { background: rgba(156, 39, 176, 0.05); padding: 8px; border-radius: 4px; border: 1px dashed #ba68c8; margin-top: 5px; }

        #btn-toggle-ui { position: absolute; left: 400px; top: 10px; z-index: 20; width: 30px; height: 40px; border-radius: 0 4px 4px 0; background: var(--panel-bg); color: var(--accent); border: 1px solid var(--border); border-left: none; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: all 0.3s ease; font-weight: bold; font-size: 1.2rem; font-family: "Segoe UI Symbol", sans-serif; }
        #btn-toggle-ui:hover { background: #333; color: #fff; }
        body.ui-closed #btn-toggle-ui { left: 0; background: rgba(0,0,0,0.5); }
        #btn-toggle-stats { position: absolute; top: 5px; left: 5px; width: 36px; height: 36px; border: 1px solid var(--accent); background: rgba(0, 0, 0, 0.5); color: var(--accent); cursor: pointer; font-weight: bold; z-index: 11; font-size: 1.2rem; line-height: 1; padding: 0; border-radius: 4px; display: flex; justify-content: center; align-items: center; transition: all 0.2s ease; font-family: "Segoe UI Symbol", sans-serif; }
        #btn-toggle-stats:hover { background: var(--accent); color: #000; }
        #top-right-panel.stats-collapsed #btn-toggle-stats { top: 0; left: 0; border-color: #555; color: #aaa; background: rgba(0,0,0,0.8); }
        #top-right-panel.stats-collapsed #btn-toggle-stats:hover { border-color: var(--accent); color: var(--accent); }
        .social-links { display: flex; gap: 10px; align-items: center; margin-right: 10px; }
        .social-icon { width: 32px; height: 32px; cursor: pointer; transition: transform 0.2s, filter 0.2s; fill: var(--text-muted); }
        .social-icon:hover { transform: scale(1.2); filter: drop-shadow(0 0 5px var(--accent)); fill: var(--accent); }
        .social-icon.github-icon path { fill: var(--text-muted); transition: fill 0.2s; }
        .social-icon.github-icon:hover path { fill: var(--accent); }

        #toast-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 2000; display: flex; flex-direction: column; gap: 10px; pointer-events: none; }
        .toast { background: rgba(0, 0, 0, 0.85); color: #e0f7fa; padding: 10px 20px; border-radius: 4px; border: 1px solid var(--accent); box-shadow: 0 4px 15px rgba(0,0,0,0.5); font-size: 0.9rem; opacity: 0; transform: translateY(20px); transition: all 0.3s ease; pointer-events: auto; text-align: center; }
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.error { border-color: var(--danger); color: #ffeb3b; }

        /* V66 Simple Mode Styles */
        .simple-mode-panel { background: rgba(76, 175, 80, 0.1); border: 2px solid #4caf50; border-radius: 8px; padding: 15px; margin-bottom: 15px; }
        .simple-mode-panel h3 { color: #4caf50; border-color: #4caf50; margin-top: 0; }
        .simple-mode-hidden { display: none !important; }
        
        .key-size-buttons { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin-top: 8px; }
        .key-size-btn { padding: 8px 4px; font-size: 0.7rem; border: 1px solid #555; background: #333; color: #aaa; cursor: pointer; border-radius: 4px; transition: all 0.2s; text-align: center; }
        .key-size-btn:hover { border-color: var(--accent); color: var(--accent); }
        .key-size-btn.active { background: var(--accent); color: #000; border-color: var(--accent); font-weight: bold; }
        .key-size-btn .size-label { display: block; font-weight: bold; font-size: 0.85rem; }
        .key-size-btn .size-desc { display: block; font-size: 0.6rem; opacity: 0.8; margin-top: 2px; }

        /* V66 Visual Preset Library */
        .visual-preset-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 10px; }
        .visual-preset-btn { padding: 12px 8px; border: 1px solid #555; background: #222; color: #aaa; cursor: pointer; border-radius: 6px; transition: all 0.2s; text-align: center; font-size: 0.75rem; }
        .visual-preset-btn:hover { border-color: var(--accent); color: var(--accent); background: rgba(0, 229, 255, 0.1); }
        .visual-preset-btn .preset-icon { font-size: 1.5rem; display: block; margin-bottom: 4px; }
        .visual-preset-btn .preset-name { display: block; font-size: 0.65rem; }

        /* V66 Stock Icons */
        .stock-icon-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; margin-top: 8px; max-height: 200px; overflow-y: auto; }
        .stock-icon-btn { width: 100%; aspect-ratio: 1; border: 1px solid #555; background: #222; color: #aaa; cursor: pointer; border-radius: 4px; transition: all 0.2s; display: flex; justify-content: center; align-items: center; font-size: 1.2rem; padding: 4px; }
        .stock-icon-btn svg { width: 100%; height: 100%; fill: currentColor; stroke: currentColor; }
        .stock-icon-btn:hover { border-color: #ffeb3b; color: #ffeb3b; background: rgba(255, 235, 59, 0.1); }
        .stock-icon-btn.selected { border-color: #ffeb3b; background: #ffeb3b; color: #000; }
        .stock-icon-btn.selected svg { fill: #000; stroke: #000; }

        /* V66 Dimension Lines */
        .dimension-overlay { 
            position: absolute; 
            bottom: 10px; 
            left: 10px; 
            background: rgba(0,0,0,0.85); 
            border: 1px solid #2196f3; 
            padding: 10px; 
            border-radius: 4px; 
            font-family: monospace; 
            font-size: 0.8rem; 
            color: #aaa; 
            z-index: 4;
            min-width: 140px;
        }
        .dimension-row { display: flex; justify-content: space-between; gap: 15px; margin-bottom: 4px; }
        .dimension-row:last-child { margin-bottom: 0; }
        .dimension-label { color: #2196f3; }
        .dimension-value { color: var(--accent); font-weight: bold; }

        /* V66 Tolerance Test Kit */
        .tolerance-test-panel { background: rgba(156, 39, 176, 0.1); border: 1px dashed #9c27b0; padding: 10px; border-radius: 4px; margin-top: 10px; }
        .tolerance-test-panel label { color: #9c27b0; }

        /* V66 Sprue Kit */
        .sprue-kit-panel { background: rgba(0, 188, 212, 0.1); border: 1px dashed #00bcd4; padding: 10px; border-radius: 4px; margin-top: 10px; }
        .sprue-kit-panel label { color: #00bcd4; }
        
        /* Export Confirmation Popup */
        .export-popup-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0); display: flex; justify-content: center; align-items: center;
            z-index: 10000; transition: background 0.3s ease;
        }
        .export-popup {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #4fc3f7; border-radius: 16px;
            padding: 20px; min-width: 400px; max-width: 550px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            transform: scale(0.8); opacity: 0; transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .export-popup.show { transform: scale(1); opacity: 1; }
        .export-popup-header {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #4fc3f7; padding-bottom: 10px; margin-bottom: 15px;
        }
        .export-popup-title { color: #4fc3f7; font-size: 1.1rem; font-weight: bold; margin: 0; }
        .export-popup-format { background: #4fc3f7; color: #000; padding: 4px 12px; border-radius: 12px; font-size: 0.8rem; font-weight: bold; }
        .export-popup-preview {
            background: #0a0a15; border-radius: 8px; height: 210px;
            display: flex; justify-content: center; align-items: center;
            margin-bottom: 15px; overflow: hidden;
        }
        .export-popup-preview canvas { max-width: 100%; max-height: 100%; }
        .export-popup-info { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        .export-info-item {
            background: rgba(79, 195, 247, 0.1); padding: 8px 12px; border-radius: 6px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .export-info-label { color: #888; font-size: 0.75rem; }
        .export-info-value { color: #fff; font-size: 0.85rem; font-weight: bold; }
        .export-info-value.highlight { color: #4fc3f7; }
        .export-info-full { grid-column: 1 / -1; }
        .export-popup-buttons {
            display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px;
            padding-top: 15px; border-top: 1px solid #333;
        }
        .export-popup-btn {
            padding: 10px 24px; border-radius: 8px; font-size: 0.9rem; cursor: pointer;
            transition: all 0.2s; border: none;
        }
        .export-popup-btn.cancel { background: #444; color: #fff; }
        .export-popup-btn.cancel:hover { background: #555; }
        .export-popup-btn.confirm { background: #4fc3f7; color: #000; font-weight: bold; }
        .export-popup-btn.confirm:hover { background: #80deea; transform: scale(1.02); }
    </style>
    
    <script src="https://unpkg.com/lz-string@1.5.0/libs/lz-string.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "three-bvh-csg": "https://unpkg.com/three-bvh-csg@0.0.16/build/index.module.js",
                "three-mesh-bvh": "https://unpkg.com/three-mesh-bvh@0.7.3/build/index.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="toast-container"></div>
    
    <!-- Export Confirmation Popup -->
    <div id="export-popup-overlay" class="export-popup-overlay" style="display:none;">
        <div class="export-popup" id="export-popup">
            <div class="export-popup-header">
                <h3 class="export-popup-title" data-i18n="popup_export_confirm">„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÁ¢∫Ë™ç</h3>
                <span class="export-popup-format" id="export-popup-format">STL</span>
            </div>
            <div class="export-popup-preview" id="export-popup-preview"></div>
            <div class="export-popup-info" id="export-popup-info"></div>
            <div class="export-popup-buttons">
                <button class="export-popup-btn cancel" id="export-popup-cancel" data-i18n="popup_cancel">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="export-popup-btn confirm" id="export-popup-confirm" data-i18n="popup_export">„Ç®„ÇØ„Çπ„Éù„Éº„Éà</button>
            </div>
        </div>
    </div>
    
    <div id="loading">
        <div>Initializing V66...</div>
        <div id="error-log"></div>
        <div id="batch-progress"></div>
        <button id="force-start-btn">FORCE START</button>
    </div>

    <div id="top-right-panel">
        <button id="btn-toggle-stats" title="Toggle Stats">Ôºç</button> 
        <div class="cost-row"><span data-i18n="lbl_weight">Est. Weight:</span><span class="cost-val"><span id="info-weight">0.00</span> g</span></div>
        <div class="cost-row"><span data-i18n="lbl_cost">Est. Cost:</span><span class="cost-val"><span id="info-currency">¬•</span> <span id="info-cost">0</span></span></div>
        <div class="cost-sub" id="info-fil-name" style="margin-bottom:10px;">Select Material</div>
        <div class="fil-control"><label data-i18n="lbl_vendor">Vendor:</label><select id="fil-vendor"></select></div>
        <div class="fil-control"><label data-i18n="lbl_material">Material:</label><select id="fil-material"></select></div>
        <button id="btn-toggle-fil" data-i18n="btn_details">‚ñº Details / Edit</button>
        <div class="fil-details" id="fil-details-panel">
            <div style="font-size:0.7rem; color:#80deea; margin-bottom:5px;" data-i18n="lbl_manual_override">Manual Override</div>
            <div class="fil-input-row"><label data-i18n="lbl_price">Price</label><input type="number" id="fil-price" placeholder="Price"></div>
            <div class="fil-input-row"><label data-i18n="lbl_spool">Spool</label><input type="number" id="fil-capacity" placeholder="g"></div>
            <div class="fil-input-row"><label data-i18n="lbl_density">Dens.</label><input type="number" id="fil-density" placeholder="g/cm3" step="0.01"></div>
            <div style="text-align:right; font-size:0.65rem; color:#555; margin-top:2px;">*Updates calculations instantly</div>
        </div>
    </div>

    <div id="history-controls">
        <button class="hist-btn" id="btn-undo" title="Undo" disabled>‚Ü©</button>
        <button class="hist-btn" id="btn-redo" title="Redo" disabled>‚Ü™</button>
    </div>

    <div id="render-mode-controls">
        <select id="render-mode">
            <option value="standard">Standard</option>
            <option value="wireframe">Wireframe</option>
        </select>
    </div>

    <div id="preset-float-panel" style="position:absolute; top:110px; left:450px; z-index:10; transition:all 0.3s ease;">
        <button id="btn-show-presets" style="background:rgba(0,0,0,0.8); border:1px solid #ff9800; color:#ff9800; padding:8px 12px; border-radius:4px; cursor:pointer; font-size:0.8rem; display:none;">üìÅ <span data-i18n="btn_presets">„Éó„É™„Çª„ÉÉ„Éà</span> (<span id="preset-count">0</span>)</button>
        <div id="preset-dropdown" style="display:none; margin-top:5px; background:rgba(20,20,20,0.95); border:1px solid #ff9800; border-radius:6px; padding:10px; min-width:220px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                <div style="color:#ff9800; font-size:0.75rem; font-weight:bold;">üìÅ Ë™≠„ÅøËæº„ÅøÊ∏à„Åø</div>
                <button id="btn-clear-all-presets" style="background:#ff5252; border:none; color:white; padding:3px 8px; border-radius:3px; cursor:pointer; font-size:0.65rem;" data-i18n="btn_clear_all">ÂÖ®ÂâäÈô§</button>
            </div>
            <div style="display:flex; gap:5px; align-items:center;">
                <select id="preset-switcher-float" style="flex:1; background:#111; border:1px solid #ff9800; color:#fff; padding:6px; font-size:0.8rem; border-radius:3px; cursor:pointer;"></select>
                <button id="btn-remove-preset" style="background:#ff5252; border:none; color:white; width:28px; height:28px; border-radius:3px; cursor:pointer; font-size:1rem;" title="ÈÅ∏Êäû‰∏≠„ÇíÂâäÈô§">√ó</button>
            </div>
            <div id="preset-preview-float" style="margin-top:10px; font-size:0.7rem; color:#aaa; background:#000; padding:8px; border-radius:4px;">
                <div style="display:flex; justify-content:space-between; margin-bottom:3px;"><span data-i18n="pv_profile">Profile:</span><span id="pf-profile" style="color:#ff9800;">-</span></div>
                <div style="display:flex; justify-content:space-between; margin-bottom:3px;"><span data-i18n="pv_size">Size:</span><span id="pf-size" style="color:#ff9800;">-</span></div>
                <div style="display:flex; justify-content:space-between; margin-bottom:3px;"><span data-i18n="pv_shape">Shape:</span><span id="pf-shape" style="color:#ff9800;">-</span></div>
                <div style="display:flex; justify-content:space-between; margin-bottom:3px;"><span data-i18n="pv_text">Text:</span><span id="pf-text" style="color:#ff9800;">-</span></div>
                <div style="display:flex; justify-content:space-between; margin-bottom:3px;"><span data-i18n="pv_text2">Sub Text:</span><span id="pf-text2" style="color:#ff9800;">-</span></div>
                <div style="display:flex; justify-content:space-between; margin-bottom:3px;"><span data-i18n="pv_side">Side:</span><span id="pf-side" style="color:#ff9800;">-</span></div>
                <div style="display:flex; justify-content:space-between;"><span data-i18n="pv_svg">SVG:</span><span id="pf-svg" style="color:#ff9800;">-</span></div>
            </div>
            <div style="display:flex; gap:5px; margin-top:8px;">
                <button id="btn-prev-preset" style="flex:1; background:#222; border:1px solid #555; color:#fff; padding:5px; border-radius:3px; cursor:pointer;" data-i18n="btn_prev">‚óÄ Ââç„Å∏</button>
                <button id="btn-next-preset" style="flex:1; background:#222; border:1px solid #555; color:#fff; padding:5px; border-radius:3px; cursor:pointer;" data-i18n="btn_next">Ê¨°„Å∏ ‚ñ∂</button>
            </div>
        </div>
    </div>

    <div id="canvas-container">
        <!-- V66: Dimension Overlay (inside canvas for correct positioning) -->
        <div id="dimension-overlay" class="dimension-overlay" style="display:none;">
            <div class="dimension-row">
                <span class="dimension-label" style="color:#2196f3;">W:</span>
                <span class="dimension-value" id="dim-width">0.00 mm</span>
            </div>
            <div class="dimension-row">
                <span class="dimension-label" style="color:#4caf50;">D:</span>
                <span class="dimension-value" id="dim-depth">0.00 mm</span>
            </div>
            <div class="dimension-row">
                <span class="dimension-label" style="color:#ff9800;">H:</span>
                <span class="dimension-value" id="dim-height">0.00 mm</span>
            </div>
        </div>
    </div>
    <button id="btn-toggle-ui" title="Toggle Sidebar">‚óÄ</button>

    <div id="ui-panel">
        <div id="ui-header-area">
            <div class="header-row">
                <div class="title-block">
                    <svg id="app-logo" onclick="location.reload()" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 306.06 217.55">
                         <defs><style>.cls-1{stroke:#ccc;}.cls-1,.cls-2,.cls-3{stroke-miterlimit:10;}.cls-1,.cls-3{fill:none;}.cls-2{fill:aqua;}.cls-2,.cls-3{stroke:aqua;}.cls-3{stroke-width:4px;}.cls-4{fill:#b3b3b3;}</style></defs><g><g><polygon class="cls-4" points="273.2 41.92 305.59 144.63 149.26 216.93 148.91 216.18 151.25 80.26 273.2 41.92"/><polygon class="cls-4" points="273.2 41.92 151.25 80.26 35.16 29.06 152.73 .49 273.2 41.92"/><polygon class="cls-4" points="151.25 80.26 148.91 216.18 .25 136.62 .61 135.77 35.16 29.06 151.25 80.26"/></g><g><line class="cls-1" x1="35.16" y1="29.06" x2=".61" y2="135.77"/><line class="cls-1" x1=".25" y1="136.62" x2="148.91" y2="216.18"/><line class="cls-1" x1="151.25" y1="80.26" x2="35.16" y2="29.06"/><line class="cls-1" x1="148.91" y1="216.18" x2="151.25" y2="80.26"/><line class="cls-1" x1="273.2" y1="41.92" x2="151.25" y2="80.26"/><line class="cls-1" x1="305.59" y1="144.63" x2="273.2" y2="41.92"/><polyline class="cls-1" points="148.91 217.1 149.26 216.93 305.59 144.63"/><line class="cls-1" x1="152.73" y1=".49" x2="273.2" y2="41.92"/><line class="cls-1" x1="152.73" y1=".49" x2="35.16" y2="29.06"/></g></g><g><line class="cls-3" x1="86.1" y1="30.23" x2="119.97" y2="22"/><line class="cls-3" x1="155.68" y1="60.92" x2="86.1" y2="30.23"/><line class="cls-3" x1="224.32" y1="40.72" x2="154.45" y2="60.92"/><line class="cls-3" x1="224.32" y1="41.22" x2="198.07" y2="32.19"/><path class="cls-2" d="M167.62,24.24s-20.08-4.1-28.79,0c-8.7,4.1,7.85-6.02,3.19-9.13s11.8,5.35,23.8.19c12-5.15-13.25,5.77,1.79,8.94Z"/><path class="cls-2" d="M169.51,46.26s-18.64-3.8-26.72,0c-8.08,3.8,7.29-5.59,2.96-8.48-4.32-2.88,10.96,4.96,22.1.18,11.14-4.78-12.3,5.36,1.66,8.3Z"/></g>
                    </svg>
                    <div><h2>Keycap Gen</h2><span class="ver">V66</span></div>
                </div>
                <div style="display:flex; align-items:center;">
                    <div class="social-links">
                        <a href="https://keycapgeneratorwiki.com/" target="_blank" id="link-wiki" title="Go to Wiki"><svg class="social-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 306.06 217.55"><defs><style>.cls-1{stroke:#ccc;}.cls-1,.cls-2,.cls-3{stroke-miterlimit:10;}.cls-1,.cls-3{fill:none;}.cls-2{fill:aqua;}.cls-2,.cls-3{stroke:aqua;}.cls-3{stroke-width:4px;}.cls-4{fill:#b3b3b3;}</style></defs><g><g><polygon class="cls-4" points="273.2 41.92 305.59 144.63 149.26 216.93 148.91 216.18 151.25 80.26 273.2 41.92"/><polygon class="cls-4" points="273.2 41.92 151.25 80.26 35.16 29.06 152.73 .49 273.2 41.92"/><polygon class="cls-4" points="151.25 80.26 148.91 216.18 .25 136.62 .61 135.77 35.16 29.06 151.25 80.26"/></g><g><line class="cls-1" x1="35.16" y1="29.06" x2=".61" y2="135.77"/><line class="cls-1" x1=".25" y1="136.62" x2="148.91" y2="216.18"/><line class="cls-1" x1="151.25" y1="80.26" x2="35.16" y2="29.06"/><line class="cls-1" x1="148.91" y1="216.18" x2="151.25" y2="80.26"/><line class="cls-1" x1="273.2" y1="41.92" x2="151.25" y2="80.26"/><line class="cls-1" x1="305.59" y1="144.63" x2="273.2" y2="41.92"/><polyline class="cls-1" points="148.91 217.1 149.26 216.93 305.59 144.63"/><line class="cls-1" x1="152.73" y1=".49" x2="273.2" y2="41.92"/><line class="cls-1" x1="152.73" y1=".49" x2="35.16" y2="29.06"/></g></g><g><line class="cls-3" x1="86.1" y1="30.23" x2="119.97" y2="22"/><line class="cls-3" x1="155.68" y1="60.92" x2="86.1" y2="30.23"/><line class="cls-3" x1="224.32" y1="40.72" x2="154.45" y2="60.92"/><line class="cls-3" x1="224.32" y1="41.22" x2="198.07" y2="32.19"/><path class="cls-2" d="M167.62,24.24s-20.08-4.1-28.79,0c-8.7,4.1,7.85-6.02,3.19-9.13s11.8,5.35,23.8.19c12-5.15-13.25,5.77,1.79,8.94Z"/><path class="cls-2" d="M169.51,46.26s-18.64-3.8-26.72,0c-8.08,3.8,7.29-5.59,2.96-8.48-4.32-2.88,10.96,4.96,22.1.18,11.14-4.78-12.3,5.36,1.66,8.3Z"/><path class="cls-2" d="M134.59,37.59s-10.53-2.15-15.09,0,4.12-3.16,1.67-4.79c-2.44-1.63,6.19,2.8,12.48.1,6.29-2.7-6.94,3.03.94,4.69Z"/></g></svg></a>
                        <a href="https://github.com/hololocheck/Keycap_Generator" target="_blank" id="link-github" title="Go to GitHub"><svg class="social-icon github-icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M512 0C229.12 0 0 229.12 0 512C0 738.56 146.56 930.56 349.44 997.76C375.04 1002.24 384.64 986.88 384.64 973.44C384.64 961.28 384 920.96 384 878.08C256 901.12 222.72 846.72 212.48 817.92C206.72 803.2 181.76 757.76 159.36 745.6C140.8 735.36 114.56 710.4 158.72 709.12C199.68 707.84 228.48 748.8 238.08 764.16C284.16 840.96 357.76 819.84 387.2 806.4C391.68 773.76 405.12 751.36 419.84 737.92C300.16 724.48 174.08 678.4 174.08 472.96C174.08 414.08 195.2 366.08 229.76 328.32C224 314.88 205.44 259.84 234.88 184.96C234.88 184.96 280.32 170.88 383.36 240.64C426.24 228.48 472.32 222.72 517.76 222.72C563.2 222.72 609.28 228.48 652.8 240.64C755.2 170.24 800 184.96 800 184.96C829.44 259.84 810.88 314.88 805.76 328.32C840.32 366.08 860.8 414.08 860.8 472.96C860.8 679.04 734.08 723.84 613.76 737.92C633.6 753.92 650.88 786.56 650.88 837.12C650.88 908.8 650.24 967.04 650.24 973.44C650.24 987.52 659.84 1002.88 686.08 997.76C888.32 930.56 1033.6 738.56 1033.6 512C1033.6 229.12 804.48 0 512 0Z"/></svg></a>
                    </div>
                    <select id="language-select"><option value="ja">üáØüáµ Êó•Êú¨Ë™û</option><option value="en">üá∫üá∏ English</option></select>
                </div>
            </div>

            <div id="nav-bar">
                <div class="nav-row"><select id="section-select"><option value="" data-i18n="nav_jump">--- Jump to Section ---</option><option value="sec-basic" data-i18n="nav_basic">Basic Size</option><option value="sec-structure" data-i18n="nav_structure">Structure</option><option value="sec-shape" data-i18n="nav_shape">Shape</option><option value="sec-texture" data-i18n="nav_texture">Texture Map</option><option value="sec-utility" data-i18n="nav_utility">Utility</option><option value="sec-import" data-i18n="nav_import">Import 3D</option><option value="sec-stem" data-i18n="nav_stem">Stem</option><option value="sec-text" data-i18n="nav_text">Text / Legend</option><option value="sec-svg" data-i18n="nav_svg">SVG Icon</option><option value="sec-color" data-i18n="nav_color">Colors</option><option value="sec-preset" data-i18n="nav_preset">Presets</option><option value="sec-export" data-i18n="nav_export">Export</option></select></div>
                <div class="nav-row"><input type="text" id="search-box" placeholder="üîç Search settings..."></div>
                <div class="nav-row" style="justify-content:flex-start; padding:2px 0;"><label class="toggle-switch" style="width:auto; margin:0;"><input type="checkbox" id="enable-hints" class="toggle-input" checked><span class="toggle-knob" style="width:28px; height:14px;"></span><span class="toggle-label" style="font-size:0.7rem;" data-i18n="lbl_show_hints">üí° „Éí„É≥„ÉàË°®Á§∫</span></label></div>
                <!-- V66: Simple Mode Toggle -->
                <div class="nav-row" style="justify-content:flex-start; padding:2px 0; margin-top:5px; border-top:1px dashed #4caf50; padding-top:8px;">
                    <label class="toggle-switch" style="width:auto; margin:0;" data-hint="hint_simple_mode">
                        <input type="checkbox" id="enable-simple-mode" class="toggle-input">
                        <span class="toggle-knob" style="width:28px; height:14px;"></span>
                        <span class="toggle-label" style="font-size:0.7rem; color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_mode">üå± Á∞°Âçò„É¢„Éº„Éâ</span>
                    </label>
                </div>
            </div>
        </div>
        <div id="ui-scroll-area">
            <!-- V66: Simple Mode Panel (shown only in Simple Mode) -->
            <div id="simple-mode-panel" class="simple-mode-panel" style="display:none;">
                <h3 style="color:#4caf50; border-color:#4caf50;" data-i18n="h_simple_mode">üå± Á∞°Âçò„É¢„Éº„Éâ</h3>
                
                <!-- 1. Text Content -->
                <div class="control-group" data-hint="hint_text_input">
                    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:5px;">
                        <label style="color:#4caf50; font-weight:bold; margin:0;" data-i18n="lbl_simple_text">ÊñáÂ≠óÂÖ•Âäõ</label>
                        <label class="toggle-switch" style="margin:0; width:auto;">
                            <input type="checkbox" id="simple-enable-text" checked class="toggle-input">
                            <span class="toggle-knob" style="width:28px; height:14px;"></span>
                            <span class="toggle-label" style="font-size:0.75rem;" data-i18n="lbl_text_visible">ÊñáÂ≠óË°®Á§∫</span>
                        </label>
                    </div>
                    <textarea id="simple-text-content" rows="2" placeholder="A" style="font-size:1.2rem; text-align:center;"></textarea>
                </div>

                <!-- 1.2 Text Mode -->
                <div class="control-group" data-hint="hint_text_mode">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_text_mode">ÁîüÊàê„É¢„Éº„Éâ</label>
                    <select id="simple-text-mode">
                        <option value="emboss" data-i18n="opt_mode_emboss">Emboss (ÊµÆ„ÅçÂá∫„Åó)</option>
                        <option value="engrave" data-i18n="opt_mode_engrave">Engrave (ÂàªÂç∞)</option>
                        <option value="doubleshot" data-i18n="opt_mode_doubleshot">Double-Shot (Âüã„ÇÅËæº„Åø)</option>
                        <option value="lithophane" data-i18n="opt_mode_lithophane">Lithophane (ÈÄèÈÅé)</option>
                    </select>
                </div>

                <!-- 1.5 Font Selection -->
                <div class="control-group" data-hint="hint_font">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_font">„Éï„Ç©„É≥„Éà</label>
                    <select id="simple-font-select">
                        <option value="helvetiker">Helvetiker</option>
                        <option value="helvetiker_bold">Helvetiker Bold</option>
                        <option value="optimer">Optimer</option>
                        <option value="optimer_bold">Optimer Bold</option>
                        <option value="gentilis">Gentilis</option>
                        <option value="gentilis_bold">Gentilis Bold</option>
                        <option value="droid_sans">Droid Sans</option>
                        <option value="droid_sans_bold">Droid Sans Bold</option>
                        <option value="droid_serif">Droid Serif</option>
                        <option value="droid_serif_bold">Droid Serif Bold</option>
                    </select>
                </div>

                <!-- 1.6 Stock Icons (Simple) -->
                <div class="control-group" style="margin-top:10px;" data-hint="hint_simple_icon">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_icon">„Ç¢„Ç§„Ç≥„É≥</label>
                    <select id="simple-icon-category" style="margin-bottom:5px;">
                        <option value="all" data-i18n="cat_all">„Åô„Åπ„Å¶</option>
                    </select>
                    <div id="simple-icon-grid" style="display:grid; grid-template-columns:repeat(6,1fr); gap:4px; max-height:120px; overflow-y:auto; background:#1a1a2e; padding:5px; border-radius:4px;"></div>
                    <button type="button" class="danger" id="btn-clear-simple-icon" style="margin-top:5px; width:100%; padding:5px;" data-i18n="btn_clear_icon">„Ç¢„Ç§„Ç≥„É≥Ëß£Èô§</button>
                </div>

                <!-- 2. Profile & Row -->
                <div class="control-group" style="margin-top:15px;" data-hint="hint_profile">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_profile">ÂΩ¢Áä∂</label>
                    <select id="simple-profile-select">
                        <option value="cherry">Cherry Profile</option>
                        <option value="oem">OEM Profile</option>
                        <option value="sa">SA Profile</option>
                        <option value="xda">XDA Profile</option>
                        <option value="dsa">DSA Profile</option>
                    </select>
                </div>
                <div class="control-group" data-hint="hint_row">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_row">Ë°å</label>
                    <select id="simple-row-select">
                        <option value="R4" data-i18n="row_r4">R4ÔºàÊúÄ‰∏äÊÆµ/Êï∞Â≠ó„Ç≠„ÉºÔºâ</option>
                        <option value="R3" data-i18n="row_r3">R3ÔºàÊñáÂ≠ó„Ç≠„Éº/EnterÔºâ</option>
                        <option value="R2" data-i18n="row_r2">R2Ôºà„Éõ„Éº„É†ÊÆµ/ASDFÔºâ</option>
                        <option value="R1" data-i18n="row_r1">R1ÔºàÊúÄ‰∏ãÊÆµ/SpaceÔºâ</option>
                    </select>
                </div>

                <!-- 2.5 Taper (Top Scale) -->
                <div class="control-group" data-hint="hint_taper">
                    <label style="color:#4caf50; font-weight:bold;"><span data-i18n="lbl_simple_taper">‰∏äÈù¢„Çµ„Ç§„Ç∫</span> <span id="v-simple-taper" class="val">1.00</span></label>
                    <input type="range" id="simple-taper" min="0.5" max="1.0" step="0.01" value="1.0">
                </div>

                <!-- 2.6 Dish Type -->
                <div class="control-group" data-hint="hint_dish_type">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_dish">‰∏äÈù¢ÂΩ¢Áä∂</label>
                    <select id="simple-dish-type">
                        <option value="cylindrical" data-i18n="opt_dish_cyl">Cylindrical (ÂÜÜÁ≠í)</option>
                        <option value="spherical" data-i18n="opt_dish_sph">Spherical (ÁêÉ)</option>
                        <option value="flat" data-i18n="opt_dish_flat">Flat (Âπ≥)</option>
                    </select>
                </div>

                <!-- 2.7 Fillet (Round Corner) -->
                <div class="control-group" data-hint="hint_fillet">
                    <label style="color:#4caf50; font-weight:bold;"><span data-i18n="lbl_simple_fillet">Ëßí„ÅÆ‰∏∏„Åø</span> <span id="v-simple-fillet" class="val">0.0</span>mm</label>
                    <input type="range" id="simple-fillet" min="0.0" max="7.0" step="0.1" value="0.0">
                </div>

                <!-- 3. Key Size (Buttons) -->
                <div class="control-group" style="margin-top:15px;" data-hint="hint_simple_key_size">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_key_size">„Ç≠„Éº„ÅÆÂπÖ</label>
                    <div class="key-size-buttons" id="simple-key-size-buttons">
                        <button type="button" class="key-size-btn active" data-size="1.0">
                            <span class="size-label">1U</span>
                            <span class="size-desc">ÈÄöÂ∏∏</span>
                        </button>
                        <button type="button" class="key-size-btn" data-size="1.25">
                            <span class="size-label">1.25U</span>
                            <span class="size-desc">Ctrl/Alt</span>
                        </button>
                        <button type="button" class="key-size-btn" data-size="1.5">
                            <span class="size-label">1.5U</span>
                            <span class="size-desc">Tab</span>
                        </button>
                        <button type="button" class="key-size-btn" data-size="1.75">
                            <span class="size-label">1.75U</span>
                            <span class="size-desc">Caps</span>
                        </button>
                        <button type="button" class="key-size-btn" data-size="2.0">
                            <span class="size-label">2U</span>
                            <span class="size-desc">BS</span>
                        </button>
                        <button type="button" class="key-size-btn" data-size="2.25">
                            <span class="size-label">2.25U</span>
                            <span class="size-desc">Enter/Shift</span>
                        </button>
                        <button type="button" class="key-size-btn" data-size="2.75">
                            <span class="size-label">2.75U</span>
                            <span class="size-desc">Shift</span>
                        </button>
                        <button type="button" class="key-size-btn" data-size="6.25">
                            <span class="size-label">6.25U</span>
                            <span class="size-desc">Space</span>
                        </button>
                    </div>
                </div>

                <!-- 4. Colors -->
                <div class="control-group" style="margin-top:15px;" data-hint="hint_colors">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_body_color">Êú¨‰ΩìËâ≤</label>
                    <input type="color" id="simple-col-body" value="#333333" class="color-input">
                </div>
                <div class="control-group">
                    <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_simple_text_color">ÊñáÂ≠óËâ≤</label>
                    <input type="color" id="simple-col-text" value="#00e5ff" class="color-input">
                </div>

                <!-- 5. Export Buttons -->
                <div class="control-group" style="margin-top:20px;">
                    <button id="btn-simple-export-stl" style="background:rgba(76,175,80,0.2); border-color:#4caf50; color:#4caf50; font-size:1rem; padding:15px;" data-hint="hint_export_stl" data-i18n="btn_simple_export_stl">
                        üì• STL„Åß‰øùÂ≠ò
                    </button>
                    <button id="btn-simple-export-3mf" class="primary-3mf" style="font-size:1rem; padding:15px; margin-top:10px;" data-hint="hint_export_3mf" data-i18n="btn_simple_export_3mf">
                        üé® 3MF„Åß‰øùÂ≠ò
                    </button>
                </div>
            </div>

            <!-- Normal Mode Content (hidden in Simple Mode) -->
            <div id="normal-mode-content">
            <h3 id="sec-basic" data-i18n="h_basic" style="margin-top:0;">Âü∫Êú¨„Çµ„Ç§„Ç∫</h3>
            <div class="control-group"><label data-i18n="lbl_unit_size" data-hint="hint_unit_size">Âü∫Êú¨„Éî„ÉÉ„ÉÅ (Unit Size)</label><select id="unit-size-select"><option value="19.05">19.05mm (Standard MX)</option><option value="19.00">19.00mm (Just)</option><option value="18.00">18.00mm</option><option value="17.00">17.00mm (Choc/Narrow)</option><option value="16.00">16.00mm (Mini)</option></select></div>
            <div class="control-group"><label data-hint="hint_key_size"><span data-i18n="lbl_u_size">„Ç≠„Éº„Çµ„Ç§„Ç∫</span> <span id="v-u-size" class="val" data-target="u-size">1.0</span></label><input type="range" id="u-size" min="1.0" max="10.0" step="0.25" value="1.0"></div>
            <div class="control-group" style="margin-top:5px; padding-top:5px; border-top:1px dashed #333;"><label data-hint="hint_stabilizer" data-i18n="lbl_stabilizer">„Çπ„Çø„Éì„É©„Ç§„Ç∂„Éº</label><select id="stabilizer-type"><option value="auto" data-i18n="opt_stab_auto">Ëá™Âãï</option><option value="custom" data-i18n="opt_stab_custom">ÊâãÂãïË®≠ÂÆö</option></select><div id="stabilizer-custom-ui" style="display:none; margin-top:5px;"><label><span data-i18n="lbl_stab_pitch">„Éî„ÉÉ„ÉÅÔºà‰∏≠ÂøÉ„Ç™„Éï„Çª„ÉÉ„ÉàÔºâ</span> <span id="v-stabilizer-offset" class="val">0.0</span>mm</label><input type="range" id="stabilizer-offset" min="0" max="150" step="0.1" value="0"><div style="font-size:0.7em; color:#aaa;" data-i18n="note_stab_distance">‚Äª‰∏≠ÂøÉ„Åã„Çâ„Çπ„ÉÜ„É†‰∏≠ÂøÉ„Åæ„Åß„ÅÆË∑ùÈõ¢</div></div></div>
            <div class="control-group"><label data-i18n="lbl_profile" data-hint="hint_profile">„Éó„É≠„Éï„Ç°„Ç§„É´</label><select id="profile-select"><option value="cherry">Cherry Profile</option><option value="oem">OEM Profile</option><option value="sa">SA Profile</option><option value="xda">XDA Profile</option><option value="dsa">DSA Profile</option><option value="custom">Custom Profile (V64)</option></select></div>
            <div id="custom-profile-panel" class="v60-sub-panel" style="display:none; border-color:#4caf50;">
                <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_custom_profile">üÜï „Ç´„Çπ„Çø„É†„Éó„É≠„Éï„Ç°„Ç§„É´Ë®≠ÂÆö</label>
                <div class="control-group"><label>È´ò„Åï <span id="v-custom-height" class="val">9.5</span>mm</label><input type="range" id="custom-height" min="5.0" max="20.0" step="0.5" value="9.5"></div>
                <div class="control-group"><label>ËßíÂ∫¶ <span id="v-custom-angle" class="val">3</span>¬∞</label><input type="range" id="custom-angle" min="-15" max="15" step="1" value="3"></div>
            </div>
            <div class="control-group" id="row-group"><label data-i18n="lbl_row" data-hint="hint_row">Ë°å (Row)</label><select id="row-select"><option value="R4">R4 (ESC/Num)</option><option value="R3">R3 (QWERTY)</option><option value="R2">R2 (ASDF)</option><option value="R1">R1 (ZXCV/Space)</option></select></div>
            
            <h3 id="sec-structure" data-i18n="h_structure">ÊßãÈÄ†„Éª„Éú„ÉÉ„ÉÅ</h3>
            <div class="control-group"><label style="color:#00e5ff; font-weight:bold;" data-hint="hint_fillet"><span data-i18n="lbl_round_corner">Ëßí„ÅÆ‰∏∏„Åø (Fillet)</span> <span><span id="v-round-corner" class="val" data-target="round-corner">0.0</span>mm</span></label><input type="range" id="round-corner" min="0.0" max="7.0" step="0.1" value="0.0"><div style="font-size:0.7em; color:#aaa;" data-i18n="note_round">‚ÄªSquircle Mapping (È´òÈÄü„ÉªÂÆâÂÆö)</div></div>
            <div class="control-group"><label data-hint="hint_wall_thick"><span data-i18n="lbl_wall_thick">Â£Å„ÅÆÂéö„Åø</span> <span><span id="v-wall-thick" class="val" data-target="wall-thick">1.5</span>mm</span></label><input type="range" id="wall-thick" min="0.8" max="4.0" step="0.1" value="1.5"></div>
            <div class="control-group"><label style="color:#ff80ab;" data-hint="hint_rib_shorten"><span data-i18n="lbl_rib_shorten">„É™„ÉñÁü≠Á∏Æ (Â∫ï‰∏ä„Åí)</span> <span><span id="v-rib-shorten" class="val" data-target="rib-shorten">4.3</span>mm</span></label><input type="range" id="rib-shorten" min="0.0" max="10.0" step="0.1" value="4.3"></div>
            <label class="toggle-switch" data-hint="hint_enable_ribs"><input type="checkbox" id="enable-ribs" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_enable_ribs">Ë£úÂº∑„É™„Éñ (ÂçÅÂ≠ó)</span></label>
            <div class="control-group" style="margin-top:5px; border-top:1px solid #333; padding-top:5px;">
                <label class="toggle-switch" data-hint="hint_homing_bump"><input type="checkbox" id="homing-bump" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" style="color:#ff4081;" data-i18n="lbl_homing_bump">„Éõ„Éº„É†„Éù„Ç∏„Ç∑„Éß„É≥Á™ÅËµ∑</span></label>
                <select id="homing-type" style="margin-bottom: 5px;" data-hint="hint_bump_type"><option value="round" data-i18n="opt_bump_round">‰∏∏Âûã (Round)</option><option value="bar" data-i18n="opt_bump_bar">Èï∑ÊñπÂΩ¢ (Bar)</option></select>
                <div class="control-row"><div style="flex:1"><label><span data-i18n="lbl_pos_x">‰ΩçÁΩÆ X</span> <span id="v-bump-x" class="val" data-target="bump-x">0.0</span></label><input type="range" id="bump-x" min="-10" max="10" step="0.1" value="0.0"></div><div style="flex:1"><label><span data-i18n="lbl_pos_z">‰ΩçÁΩÆ Z</span> <span id="v-bump-z" class="val" data-target="bump-z">0.0</span></label><input type="range" id="bump-z" min="-10" max="10" step="0.1" value="0.0"></div></div>
                <div class="control-group"><label><span data-i18n="lbl_bump_offset">È´ò„ÅïÂæÆË™øÊï¥ (Offset)</span> <span><span id="v-bump-offset-y" class="val" data-target="bump-offset-y">0.0</span>mm</span></label><input type="range" id="bump-offset-y" min="-5.0" max="5.0" step="0.1" value="0.0"></div>
            </div>
            
            <h3 id="sec-shape" data-i18n="h_shape">ÂΩ¢Áä∂</h3>
            <div class="v60-sub-panel" style="border-color:#ba68c8; margin-bottom:10px;">
                <label style="color:#ba68c8; font-weight:bold;" data-i18n="lbl_key_shape_type" data-hint="hint_key_shape">üÜï „Ç≠„ÉºÂΩ¢Áä∂„Çø„Ç§„Éó (V64)</label>
                <select id="key-shape-type" style="margin-top:5px;">
                    <option value="rectangle" data-i18n="opt_shape_rect">ÂõõËßíÂΩ¢ (Rectangle)</option>
                    <option value="rounded" data-i18n="opt_shape_round">Ëßí‰∏∏ (Rounded)</option>
                    <option value="circle" data-i18n="opt_shape_circle">ÂÜÜÂΩ¢ (Circle)</option>
                    <option value="polygon" data-i18n="opt_shape_polygon">Â§öËßíÂΩ¢ (Polygon)</option>
                    <option value="star" data-i18n="opt_shape_star">ÊòüÂΩ¢ (Star)</option>
                    <option value="iso-enter" data-i18n="opt_shape_iso">ISO Enter (LÂ≠óÂΩ¢)</option>
                </select>
                <div id="shape-polygon-options" style="display:none; margin-top:8px;">
                    <label data-i18n="lbl_polygon_sides">Ëæ∫„ÅÆÊï∞</label> <span id="v-polygon-sides" class="val">6</span>
                    <input type="range" id="polygon-sides" min="3" max="12" step="1" value="6">
                </div>
                <div id="shape-star-options" style="display:none; margin-top:8px;">
                    <label data-i18n="lbl_star_points">È†ÇÁÇπÊï∞</label> <span id="v-star-points" class="val">5</span>
                    <input type="range" id="star-points" min="3" max="12" step="1" value="5">
                    <label data-i18n="lbl_star_inner">ÂÜÖÂæÑÊØî</label> <span id="v-star-inner" class="val">0.50</span>
                    <input type="range" id="star-inner" min="0.2" max="0.8" step="0.05" value="0.5">
                </div>
                <div id="shape-iso-options" style="display:none; margin-top:8px;">
                    <label style="color:#ff9800;" data-i18n="lbl_iso_settings">ISO/JIS Enter Ë®≠ÂÆö</label>
                    <div class="control-row">
                        <div style="flex:1"><label data-i18n="lbl_iso_top_w">‰∏äÈÉ®ÂπÖ</label> <span id="v-iso-top-width" class="val">1.50</span>U<input type="range" id="iso-top-width" min="1.25" max="2.0" step="0.25" value="1.5"></div>
                    </div>
                    <div class="control-row">
                        <div style="flex:1"><label data-i18n="lbl_iso_bottom_w">‰∏ãÈÉ®ÂπÖ</label> <span id="v-iso-bottom-width" class="val">1.25</span>U<input type="range" id="iso-bottom-width" min="1.0" max="1.5" step="0.25" value="1.25"></div>
                    </div>
                    <div class="control-row">
                        <div style="flex:1"><label data-i18n="lbl_iso_total_h">ÂÖ®‰Ωì„ÅÆÈ´ò„Åï</label> <span id="v-iso-height" class="val">2.00</span>U<input type="range" id="iso-height" min="1.5" max="2.5" step="0.25" value="2.0"></div>
                    </div>
                    <div style="display:flex; gap:8px; margin-top:5px;">
                        <div style="flex:1"><label data-i18n="lbl_stem_x">„Çπ„ÉÜ„É†X</label> <span id="v-iso-stem-x" class="val">2.4</span><input type="range" id="iso-stem-x" min="-15" max="15" step="0.5" value="2.4"></div>
                        <div style="flex:1"><label data-i18n="lbl_stem_z">„Çπ„ÉÜ„É†Z</label> <span id="v-iso-stem-z" class="val">0.0</span><input type="range" id="iso-stem-z" min="-20" max="25" step="0.5" value="0"></div>
                    </div>
                    <div style="display:flex; gap:8px; margin-top:5px;">
                        <div style="flex:1"><label data-i18n="lbl_stab_top_z">‰∏ä„Çπ„Çø„ÉìZ</label> <span id="v-iso-stab-top-z" class="val">-12.0</span><input type="range" id="iso-stab-top-z" min="-20" max="15" step="0.5" value="-12"></div>
                        <div style="flex:1"><label data-i18n="lbl_stab_bottom_z">‰∏ã„Çπ„Çø„ÉìZ</label> <span id="v-iso-stab-bottom-z" class="val">12.0</span><input type="range" id="iso-stab-bottom-z" min="-5" max="25" step="0.5" value="12"></div>
                    </div>
                </div>
            </div>
            <div class="control-group"><label data-hint="hint_taper"><span data-i18n="lbl_top_scale">‰∏äÈù¢„Çµ„Ç§„Ç∫</span> <span id="v-top-scale" class="val" data-target="top-scale">1.00</span></label><input type="range" id="top-scale" min="0.5" max="1.0" step="0.01" value="1.0"></div>
            <div class="control-group"><label data-i18n="lbl_dish_type" data-hint="hint_dish_type">‰∏äÈù¢ÂΩ¢Áä∂ (Dish Type)</label><select id="dish-type"><option value="cylindrical" data-i18n="opt_dish_cyl">Cylindrical (ÂÜÜÁ≠í)</option><option value="spherical" data-i18n="opt_dish_sph">Spherical (ÁêÉ)</option><option value="flat" data-i18n="opt_dish_flat">Flat (Âπ≥)</option></select></div>
            
            <div class="v61-texture-panel">
                <label style="color:#e91e63; font-weight:bold;" data-i18n="lbl_texture" data-hint="hint_texture">Ë°®Èù¢„ÉÜ„ÇØ„Çπ„ÉÅ„É£</label>
                <select id="texture-type" style="margin-bottom:5px;">
                    <option value="none" data-i18n="opt_tex_none">„Å™„Åó</option>
                    <option value="noise" data-i18n="opt_tex_noise">Ê¢®Âú∞</option>
                    <option value="grid" data-i18n="opt_tex_grid">„Ç∞„É™„ÉÉ„Éó</option>
                    <option value="knurling" data-i18n="opt_tex_knurling">„É≠„Éº„É¨„ÉÉ„Éà</option>
                    <option value="stripes" data-i18n="opt_tex_stripes">„Çπ„Éà„É©„Ç§„Éó</option>
                    <option value="ripple" data-i18n="opt_tex_ripple">Ê≥¢Á¥ã</option>
                    <option value="wood" data-i18n="opt_tex_wood">Êú®ÁõÆ</option>
                    <option value="hammered" data-i18n="opt_tex_hammered">ÊâìÁóï</option>
                    <option value="hexagon" data-i18n="opt_tex_hexagon">„Éè„Éã„Ç´„É†</option>
                    <option value="bricks" data-i18n="opt_tex_bricks">„É¨„É≥„Ç¨</option>
                </select>
                <div class="control-row">
                    <div style="flex:1"><label><span data-i18n="lbl_tex_scale">Scale</span> <span id="v-tex-scale" class="val">50</span></label><input type="range" id="tex-scale" min="1" max="100" step="1" value="50"></div>
                    <div style="flex:1"><label><span data-i18n="lbl_tex_strength">Strength</span> <span id="v-tex-strength" class="val">0.05</span></label><input type="range" id="tex-strength" min="0.01" max="0.5" step="0.01" value="0.05"></div>
                </div>
                 <label class="toggle-switch" style="margin-top:5px;">
                    <input type="checkbox" id="texture-global" class="toggle-input">
                    <span class="toggle-knob"></span>
                    <span class="toggle-label" data-i18n="lbl_global_apply">ÂÖ®‰Ωì„Å´ÈÅ©Áî® (Global Apply)</span>
                </label>
            </div>

            <h3 id="sec-texture" data-i18n="h_texture_map" style="color:#ba68c8; border-color:#ba68c8;">ÁîªÂÉè„ÉÜ„ÇØ„Çπ„ÉÅ„É£ (Image Map)</h3>
            <div class="v63-texture-map-panel">
                <div class="file-upload" data-hint="hint_img_upload"><label for="img-texture-input" class="file-upload-label" style="border-color:#ba68c8; color:#e1bee7;" data-i18n="btn_upload_img">üìÅ ÁîªÂÉèË™≠Ëæº (PNG/JPG)</label><input type="file" id="img-texture-input" accept="image/*"></div>
                <div class="control-row" style="margin-top:5px; align-items:center;">
                    <label class="toggle-switch" style="flex:1; margin:0;"><input type="checkbox" id="img-texture-visible" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_visible">Ë°®Á§∫ (Visible)</span></label>
                    <button class="danger btn-small" id="btn-clear-img-texture" style="width:30px; margin:0;">√ó</button>
                </div>
                <div class="control-group" style="margin-top:5px;"><label>Scale <span id="v-img-scale" class="val">1.0</span></label><input type="range" id="img-scale" min="0.1" max="3.0" step="0.1" value="1.0"></div>
                <div class="control-row"><div style="flex:1"><label>Pos X <span id="v-img-pos-x" class="val">0.0</span></label><input type="range" id="img-pos-x" min="-0.5" max="0.5" step="0.01" value="0.0"></div><div style="flex:1"><label>Pos Y <span id="v-img-pos-y" class="val">0.0</span></label><input type="range" id="img-pos-y" min="-0.5" max="0.5" step="0.01" value="0.0"></div></div>
                <div class="control-group"><label>Rotation <span id="v-img-rot" class="val">0</span>¬∞</label><input type="range" id="img-rot" min="-180" max="180" step="1" value="0"></div>
            </div>

            <div class="control-group" style="border-top:1px dashed #555; margin-top:5px; padding-top:5px;">
                <label style="color:#b2ff59;">Twist („Å≠„Åò„Çä)</label><input type="range" id="twist-factor" min="-90" max="90" step="1" value="0">
                <label style="color:#b2ff59; margin-top:5px;" data-i18n="lbl_tilt">Â§©Èù¢ËßíÂ∫¶Ë™øÊï¥</label><div class="control-row"><div style="flex:1"><label>X</label><input type="range" id="tilt-x" min="-20" max="20" step="0.5" value="0"></div><div style="flex:1"><label>Z</label><input type="range" id="tilt-z" min="-20" max="20" step="0.5" value="0"></div></div>
            </div>

            <h3 id="sec-stem" data-i18n="h_stem">„Çπ„ÉÜ„É†Ë®≠ÂÆö</h3>
            <div class="control-group"><label style="color:#80deea;" data-i18n="lbl_stem_type">Ëª∏„Çø„Ç§„Éó: Cherry MX (Âõ∫ÂÆö)</label></div>
            <div class="control-group"><label style="color:#ffeb3b;" data-hint="hint_stem_diameter"><span data-i18n="lbl_stem_diameter">„Çπ„ÉÜ„É†Â§ñÂæÑ (Diameter)</span> <span><span id="v-stem-diameter" class="val" data-target="stem-diameter">5.50</span>mm</span></label><input type="range" id="stem-diameter" min="5.0" max="7.0" step="0.05" value="5.50"></div>
            <div class="control-group"><label style="color:#ffeb3b;" data-hint="hint_clearance"><span data-i18n="lbl_clearance">„ÇØ„É™„Ç¢„É©„É≥„Çπ</span> <span><span id="v-stem-clearance" class="val" data-target="stem-clearance">0.30</span>mm</span></label><input type="range" id="stem-clearance" min="0.0" max="1.0" step="0.01" value="0.30"></div>
            <div class="control-group" style="border-top:1px solid #333; margin-top:5px; padding-top:5px;">
                <label class="toggle-switch" data-hint="hint_stem_ext"><input type="checkbox" id="enable-stem-extension" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" style="color:#80deea;" data-i18n="lbl_stem_extension">Èï∑„Åï„ÇíÊã°Âºµ</span></label>
                <div id="stem-ext-control" style="display:none; margin-top:5px;"><label>Extension <span id="v-stem-extension" class="val">1.0</span>mm</label><input type="range" id="stem-extension" min="0.0" max="5.0" step="0.1" value="1.0"></div>
            </div>
            <label class="toggle-switch" style="margin-top:5px;" data-hint="hint_box_stem"><input type="checkbox" id="box-stem" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" style="color:#ffeb3b;" data-i18n="lbl_box_stem">„Éú„ÉÉ„ÇØ„ÇπËª∏</span></label>
            <label class="toggle-switch" data-hint="hint_lego_stud"><input type="checkbox" id="lego-stud" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" style="color:#ff5722;" data-i18n="lbl_lego_stud">Â§©Èù¢„Éù„ÉÉ„ÉÅ</span></label>
            <div id="lego-adj-panel" style="display:none; background:rgba(255,87,34,0.1); padding:5px; border-radius:4px; margin-bottom:5px; border:1px dashed #ff5722;">
                <div class="control-row"><div style="flex:1"><label>Pos X <span id="v-lego-x" class="val">0.0</span></label><input type="range" id="lego-x" min="-10" max="10" step="0.1" value="0.0"></div><div style="flex:1"><label>Pos Z <span id="v-lego-z" class="val">0.0</span></label><input type="range" id="lego-z" min="-10" max="10" step="0.1" value="0.0"></div></div>
                <div class="control-row"><div style="flex:1"><label>Pos Y <span id="v-lego-y" class="val">0.0</span></label><input type="range" id="lego-y" min="-5" max="5" step="0.1" value="0.0"></div><div style="flex:1"><label>Clearance <span id="v-lego-clear" class="val">0.0</span></label><input type="range" id="lego-clear" min="-0.5" max="0.5" step="0.05" value="0.0"></div></div>
            </div>

            <!-- V66: Tolerance Test Kit -->
            <div class="tolerance-test-panel" data-hint="hint_tolerance_test">
                <label style="color:#9c27b0; font-weight:bold;" data-i18n="lbl_tolerance_test">üîß „Çπ„ÉÜ„É†„ÉÜ„Çπ„Éà„Ç≠„ÉÉ„Éà (V66)</label>
                <p style="font-size:0.7rem; color:#aaa; margin:5px 0;" data-i18n="tolerance_desc">„Éó„É™„É≥„Çø„Éº„ÅÆÂÖ¨Â∑Æ„Çí„ÉÜ„Çπ„Éà„Åô„Çã„Åü„ÇÅ„ÅÆ„Çπ„ÉÜ„É†„Å†„Åë„Çí‰∏¶„Åπ„Åü„Éó„É¨„Éº„Éà„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ</p>
                <div class="control-row" style="margin-top:8px;">
                    <div style="flex:1"><label><span data-i18n="tolerance_start">ÈñãÂßãÂÄ§</span> <span id="v-tol-start" class="val">0.20</span>mm</label><input type="range" id="tol-start" min="0.1" max="0.5" step="0.05" value="0.2"></div>
                    <div style="flex:1"><label><span data-i18n="tolerance_step">Âàª„Åø</span> <span id="v-tol-step" class="val">0.05</span>mm</label><input type="range" id="tol-step" min="0.02" max="0.1" step="0.01" value="0.05"></div>
                </div>
                <div class="control-group" style="margin-top:8px;">
                    <label data-i18n="tolerance_output_format">Âá∫ÂäõÂΩ¢Âºè</label>
                    <select id="tol-test-format">
                        <option value="stl">STL</option>
                        <option value="3mf">3MF (Color)</option>
                    </select>
                </div>
                <button id="btn-gen-tolerance-test" style="border-color:#9c27b0; color:#9c27b0; margin-top:8px;" data-i18n="tolerance_generate">„Çπ„ÉÜ„É†„ÉÜ„Çπ„ÉàÁîüÊàê (5ÂÄã)</button>
            </div>

            <div class="section-sep"></div>
            <h3 id="sec-utility" style="color:#00e5ff;">Utility</h3>
            <div class="control-group" style="display:flex; gap:5px; align-items:center;">
                <button id="btn-random" class="accent" style="border-color:#e040fb; color:#e040fb; flex:1;" data-hint="hint_randomizer">üé≤ Randomizer</button>
                <button id="btn-reset-params" class="danger btn-square" title="Reset Params to Default" style="width:40px; margin-top:5px;" data-hint="hint_reset">√ó</button>
            </div>

            <!-- V66: Dimension Lines Toggle -->
            <div class="control-group" style="margin-top:10px;" data-hint="hint_dimension_lines">
                <label class="toggle-switch">
                    <input type="checkbox" id="show-dimensions" class="toggle-input">
                    <span class="toggle-knob"></span>
                    <span class="toggle-label" style="color:#2196f3;" data-i18n="lbl_dimension_lines">üìê ÂØ∏Ê≥ïÁ∑ö„ÇíË°®Á§∫ (V66)</span>
                </label>
            </div>
            
            <h3 id="sec-import" style="color:#ff9800; margin-top:10px; border-bottom:1px solid #ff9800;" data-i18n="h_import">Â§ñÈÉ®„É¢„Éá„É´ (Import 3D)</h3>
            <div class="v60-import-panel">
                <div class="control-group" style="display:flex; gap:5px; align-items: flex-end;">
                    <div class="file-upload" style="flex:1;" data-hint="hint_import_stl"><label for="model-file-input" class="file-upload-label" style="border-color:#ff9800; color:#ff9800;" data-i18n="btn_load_stl">üìÅ STL„É¢„Éá„É´Ë™≠Ëæº</label><input type="file" id="model-file-input" accept=".stl"></div>
                    <button class="danger btn-square" id="btn-clear-model" title="„É¢„Éá„É´ÂâäÈô§">√ó</button>
                </div>
                <label class="toggle-switch" style="margin-top:5px;"><input type="checkbox" id="model-visible" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_visible">Ë°®Á§∫ (Visible)</span></label>
                <div class="control-group" style="margin-top:5px; background:rgba(0,0,0,0.2); padding:5px; border-radius:4px;" data-hint="hint_import_op"><label style="color:#ff9800;" data-i18n="lbl_import_op">ÂêàÊàê„É¢„Éº„Éâ</label><select id="model-operation"><option value="union" data-i18n="opt_union">ÁµêÂêàÔºàËøΩÂä†Ôºâ</option><option value="subtract" data-i18n="opt_subtract">ÂûãÊäú„ÅçÔºàÂΩ´ÂàªÔºâ</option></select><div style="font-size:0.7em; color:#aaa; margin-top:2px;" data-i18n="note_subtract">‚ÄªÂûãÊäú„Åç„ÅØÂá¶ÁêÜ„Å´ÊôÇÈñì„Åå„Åã„Åã„Çä„Åæ„Åô</div></div>
                <div class="control-group"><label>Pivot / Transform (‰ΩçÁΩÆ/ÂõûËª¢)</label><div class="control-row"><div style="flex:1"><label>Scale <span id="v-model-scale" class="val">1.0</span></label><input type="range" id="model-scale" min="0.1" max="5.0" step="0.1" value="1.0"></div></div><div class="control-row"><div style="flex:1"><label>X <span id="v-model-x" class="val">0.0</span></label><input type="range" id="model-x" min="-15" max="15" step="0.5" value="0"></div><div style="flex:1"><label>Z <span id="v-model-z" class="val">0.0</span></label><input type="range" id="model-z" min="-15" max="15" step="0.5" value="0"></div></div><div class="control-row"><div style="flex:1"><label>Y-Pos <span id="v-model-y" class="val">0.0</span></label><input type="range" id="model-y" min="-10" max="20" step="0.5" value="0"></div></div><div class="control-row"><div style="flex:1"><label>Rot X <span id="v-model-rx" class="val">0</span>¬∞</label><input type="range" id="model-rx" min="-180" max="180" step="15" value="0"></div><div style="flex:1"><label>Rot Y <span id="v-model-ry" class="val">0</span>¬∞</label><input type="range" id="model-ry" min="-180" max="180" step="15" value="0"></div><div style="flex:1"><label>Rot Z <span id="v-model-rz" class="val">0</span>¬∞</label><input type="range" id="model-rz" min="-180" max="180" step="15" value="0"></div></div></div>
            </div>

            <h3 id="sec-text" data-i18n="h_text">ÊñáÂ≠óË®≠ÂÆö</h3>
            <div class="control-group">
                <label class="toggle-switch" data-hint="hint_enable_text"><input type="checkbox" id="enable-text" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_enable_text">ÊñáÂ≠ó„ÇíÁîüÊàê„Åô„Çã</span></label>
                <textarea id="text-content" rows="2" placeholder="‰æã: A&#13;&#10;{&#13;&#10;[" data-hint="hint_text_input"></textarea><div style="font-size:0.7em; color:#aaa; text-align:right;" data-i18n="note_multiline">‚ÄªÊîπË°å„Åß2ÊÆµÂç∞Â≠ó„ÅåÂèØËÉΩ</div>
            </div>
            
            <div class="control-group" data-hint="hint_font"><label data-i18n="lbl_font">„Éï„Ç©„É≥„Éà</label><select id="font-family" style="display:none;"><option value="helvetiker">Helvetiker</option><option value="helvetiker_bold">Helvetiker Bold</option><option value="optimer">Optimer</option><option value="optimer_bold">Optimer Bold</option><option value="gentilis">Gentilis</option><option value="gentilis_bold">Gentilis Bold</option><option value="droid_sans">Droid Sans</option><option value="droid_sans_bold">Droid Sans Bold</option><option value="droid_serif">Droid Serif</option><option value="droid_serif_bold">Droid Serif Bold</option></select><div class="custom-select-container" id="custom-font-ui"><div class="custom-select-head" id="custom-font-head">Helvetiker ‚ñº</div><div class="custom-select-list" id="custom-font-list"></div></div></div>
            <div class="control-group" style="border: 1px dashed #555; padding: 8px; border-radius: 4px; background: rgba(0,0,0,0.3); margin-top: 5px;"><div class="info-link" data-i18n="note_font_upload">‚Äª.ttf „Å™„Å©„Çí„Åù„ÅÆ„Åæ„ÅæË™≠„ÅøËæº„ÇÄ„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ<br><a href="http://gero3.github.io/facetype.js/" target="_blank">Facetype.js</a> „Å™„Å©„ÅßJSON„Å´Â§âÊèõ„Åó„Åü„Éï„Ç°„Ç§„É´„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</div><div class="file-upload" data-hint="hint_custom_font"><label for="font-file-input" class="file-upload-label" data-i18n="btn_upload_font">üìÅ „Ç´„Çπ„Çø„É†„Éï„Ç©„É≥„Éà (.json)</label><input type="file" id="font-file-input" accept=".json"></div></div>

            <div class="control-group" style="background:rgba(0,229,255,0.1); padding:5px; border-radius:4px; margin-bottom:5px; margin-top:5px;" data-hint="hint_text_mode">
                <label data-i18n="lbl_text_mode" style="color:#00e5ff; font-weight:bold;">ÁîüÊàê„É¢„Éº„Éâ (Mode)</label>
                <select id="text-mode">
                    <option value="emboss" data-i18n="opt_mode_emboss">Emboss (ÊµÆ„ÅçÂá∫„Åó)</option>
                    <option value="engrave" data-i18n="opt_mode_engrave">Engrave (ÂàªÂç∞/Êéò„ÇäËæº„Åø)</option>
                    <option value="doubleshot" data-i18n="opt_mode_doubleshot">Double-Shot (Âüã„ÇÅËæº„Åø)</option>
                    <option value="lithophane" data-i18n="opt_mode_lithophane">Lithophane („Éê„ÉÉ„ÇØ„É©„Ç§„ÉàÈÄèÈÅé)</option>
                </select>
                <div style="font-size:0.7em; color:#aaa; margin-top:3px;" data-i18n="note_engrave">‚ÄªEngrave„ÅØË®àÁÆóÂá¶ÁêÜ„Å´ÊôÇÈñì„Åå„Åã„Åã„Çä„Åæ„Åô</div>
            </div>

            <div class="control-group">
                <div class="control-row">
                    <div style="flex:1"><label><span data-i18n="lbl_size">„Çµ„Ç§„Ç∫</span> <span id="v-font-size" class="val" data-target="font-size">8.0</span></label><input type="range" id="font-size" min="3" max="20" step="0.5" value="8.0"></div>
                    <div style="flex:1" data-hint="hint_text_height">
                        <label><span data-i18n="lbl_thickness">Ê∑±„Åï/È´ò„Åï</span> <span id="v-text-height" class="val" data-target="text-height">0.5</span></label>
                        <div style="display:flex; align-items:center; gap:5px;"><input type="range" id="text-height" min="0.1" max="5.0" step="0.1" value="0.5" disabled><label class="toggle-switch" style="margin:0; width:auto;" title="Âéö„Åø„ÇíÂõ∫ÂÆö"><input type="checkbox" id="lock-thickness" checked class="toggle-input"><span class="toggle-knob" style="width:28px; height:14px;"></span></label></div>
                    </div>
                </div>
            </div>
            
            <label class="toggle-switch" data-hint="hint_conform"><input type="checkbox" id="text-conform" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_conform">Êõ≤Èù¢„Å´Âêà„Çè„Åõ„Çã (Conform)</span></label>
            <div class="control-group" data-hint="hint_align_preset"><label data-i18n="lbl_align_preset">ÊñáÂ≠óÈÖçÁΩÆ („Éó„É™„Çª„ÉÉ„Éà)</label>
                <div class="control-row" style="margin-bottom:2px;">
                    <button id="btn-align-tl" class="secondary btn-small" style="margin:0;" data-i18n="btn_align_tl">‚Üñ TL</button>
                    <button id="btn-align-tr" class="secondary btn-small" style="margin:0;" data-i18n="btn_align_tr">‚Üó TR</button>
                </div>
                <div class="control-row">
                    <button id="btn-align-bl" class="secondary btn-small" style="margin:0;" data-i18n="btn_align_bl">‚Üô BL</button>
                    <button id="btn-align-br" class="secondary btn-small" style="margin:0;" data-i18n="btn_align_br">‚Üò BR</button>
                </div>
                <button id="btn-align-center" class="secondary btn-small" style="margin-top:4px;" data-i18n="btn_align_center">Center (‰∏≠Â§Æ)</button>
            </div>
            <div class="control-group"><label data-i18n="lbl_pos_xz_fine">‰ΩçÁΩÆ X / Z (ÂæÆË™øÊï¥)</label><div class="control-row"><input type="range" id="pos-x" min="-15" max="15" step="0.5" value="0" title="X Position"><input type="range" id="pos-z" min="-15" max="15" step="0.5" value="0" title="Z Position"></div><div style="display:flex; justify-content:space-between; font-size:0.7em; color:#aaa;"><span>X: <span id="v-pos-x">0.0</span></span><span>Z: <span id="v-pos-z">0.0</span></span></div></div>
            <div class="control-group"><label style="color:#aaa; font-size:0.7rem;"><span data-i18n="lbl_offset_y">È´ò„ÅïÂæÆË™øÊï¥ (Offset Y)</span> <span id="v-text-offset-y" class="val">0.0</span></label><input type="range" id="text-offset-y" min="-5.0" max="5.0" step="0.01" value="0.0"></div>
            <div class="v60-sub-panel">
                <label class="toggle-switch" data-hint="hint_text2"><input type="checkbox" id="enable-text2" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label v60-label" data-i18n="lbl_sub_text">„Çµ„ÉñÊñáÂ≠ó (Legend 2)</span></label>
                <div class="control-group"><select id="text2-mode" style="margin-bottom:5px; font-size:0.75rem; padding:3px;"><option value="emboss">Emboss</option><option value="engrave">Engrave</option><option value="doubleshot">Double-Shot</option><option value="lithophane">Lithophane</option></select></div>
                <textarea id="text2-content" rows="1" placeholder="‰æã: „ÅÇ / @" style="margin-bottom:5px;"></textarea>
                <div class="control-row"><div style="flex:1"><label>Size <span id="v-text2-size" class="val">4.0</span></label><input type="range" id="text2-size" min="2" max="15" step="0.1" value="4.0"></div></div>
                <div class="control-row"><div style="flex:1"><label>X <span id="v-text2-x" class="val">3.5</span></label><input type="range" id="text2-x" min="-10" max="10" step="0.1" value="3.5"></div><div style="flex:1"><label>Z <span id="v-text2-z" class="val">3.5</span></label><input type="range" id="text2-z" min="-10" max="10" step="0.1" value="3.5"></div></div>
            </div>

            <div class="v60-sub-panel">
                <label class="toggle-switch" data-hint="hint_side_print"><input type="checkbox" id="enable-side" class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label v60-label-side" data-i18n="lbl_side_print">„Çµ„Ç§„ÉâÂç∞Â≠ó (Side Print)</span></label>
                <div class="control-group"><select id="side-mode" style="margin-bottom:5px; font-size:0.75rem; padding:3px;"><option value="emboss">Emboss</option><option value="engrave">Engrave</option><option value="doubleshot">Double-Shot</option><option value="lithophane">Lithophane</option></select></div>
                <input type="text" id="side-text" placeholder="FRONT TEXT" style="margin-bottom:5px;">
                <div class="control-row"><div style="flex:1"><label>Size <span id="v-side-size" class="val">3.0</span></label><input type="range" id="side-size" min="1" max="10" step="0.1" value="3.0"></div><div style="flex:1"><label>Y-Ofs <span id="v-side-y" class="val">-2.0</span></label><input type="range" id="side-y" min="-10" max="5" step="0.1" value="-2.0"></div></div>
                <div class="control-group"><label>Rotate X <span id="v-side-rot" class="val">0</span>¬∞</label><input type="range" id="side-rot" min="-45" max="45" step="1" value="0"></div>
            </div>

            <h3 id="sec-svg" data-i18n="h_svg">SVG („Ç¢„Ç§„Ç≥„É≥) Ë®≠ÂÆö</h3>

            <!-- V66: Stock Icon Library (loaded from external JSON) -->
            <div class="v60-sub-panel" style="border-color:#ffeb3b; margin-bottom:10px;" data-hint="hint_stock_icons">
                <label style="color:#ffeb3b; font-weight:bold;" data-i18n="lbl_stock_icons">üì¶ ÂÜÖËîµ„Ç¢„Ç§„Ç≥„É≥ (V66)</label>
                <p style="font-size:0.65rem; color:#888; margin:3px 0;" data-i18n="lbl_click_to_apply">„ÇØ„É™„ÉÉ„ÇØ„ÅßSVG„Å®„Åó„Å¶ÈÅ©Áî®</p>
                <div class="control-group" style="margin:5px 0;">
                    <select id="stock-icon-category" style="font-size:0.75rem; padding:4px;">
                        <option value="all" data-i18n="cat_all">„Åô„Åπ„Å¶</option>
                    </select>
                </div>
                <div class="stock-icon-grid" id="stock-icon-grid">
                    <div style="grid-column: 1/-1; text-align:center; color:#666; padding:10px;" data-i18n="msg_loading">Ë™≠„ÅøËæº„Åø‰∏≠...</div>
                </div>
                <div class="control-group" style="margin-top:8px;">
                    <label style="font-size:0.75rem;"><span data-i18n="lbl_icon_size">„Ç¢„Ç§„Ç≥„É≥„Çµ„Ç§„Ç∫</span> <span id="v-stock-icon-scale" class="val">1.0</span></label>
                    <input type="range" id="stock-icon-scale" min="0.01" max="3" step="0.01" value="1.0">
                </div>
                <button id="btn-clear-stock-icon" class="secondary btn-small" style="margin-top:5px;" data-i18n="btn_clear_stock_icon">ÈÅ∏ÊäûËß£Èô§</button>
            </div>

            <div class="control-group" style="display:flex; gap:5px; align-items: flex-end;" data-hint="hint_svg_upload">
                <div class="file-upload" style="flex:1;"><label for="svg-file-input" class="file-upload-label" style="border-color:#ffeb3b; color:#ffeb3b;" data-i18n="btn_upload_svg">üìÅ SVGË™≠Ëæº</label><input type="file" id="svg-file-input" accept=".svg"></div>
                <button class="danger btn-square" id="btn-clear-svg" title="SVG„ÇíÂâäÈô§">√ó</button>
            </div>
            
            <label class="toggle-switch" style="margin-top:5px;"><input type="checkbox" id="svg-visible" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_visible">Ë°®Á§∫„Åô„Çã</span></label>
            
            <div class="control-group" style="background:rgba(0,229,255,0.1); padding:5px; border-radius:4px; margin-bottom:5px;" data-hint="hint_svg_mode">
                <label data-i18n="lbl_text_mode" style="color:#00e5ff; font-weight:bold;">ÁîüÊàê„É¢„Éº„Éâ (Mode)</label>
                <select id="svg-mode">
                    <option value="emboss">Emboss</option>
                    <option value="engrave">Engrave</option>
                    <option value="doubleshot">Double-Shot</option>
                    <option value="lithophane">Lithophane</option>
                </select>
            </div>

            <div class="control-row"><div style="flex:1"><label><span data-i18n="lbl_size">„Çµ„Ç§„Ç∫</span> <span id="v-svg-scale" class="val" data-target="svg-scale">1.0</span></label><input type="range" id="svg-scale" min="0.01" max="3" step="0.01" value="1.0"></div><div style="flex:1"><label><span data-i18n="lbl_thickness">Âéö„Åø</span> <span id="v-svg-thickness" class="val" data-target="svg-thickness">0.6</span></label><input type="range" id="svg-thickness" min="0.1" max="5.0" step="0.1" value="0.6"></div></div>
            <label class="toggle-switch"><input type="checkbox" id="svg-conform" checked class="toggle-input"><span class="toggle-knob"></span><span class="toggle-label" data-i18n="lbl_conform">Êõ≤Èù¢„Å´Âêà„Çè„Åõ„Çã (Conform)</span></label>
            <div class="control-group"><label data-i18n="lbl_rotation">ÂõûËª¢ (XYZ) </label><div class="control-row"><div style="flex:1"><label>X <span id="v-svg-rot-x" class="val" data-target="svg-rot-x">0</span>¬∞</label><input type="range" id="svg-rot-x" min="-180" max="180" step="5" value="0"></div><div style="flex:1"><label>Y <span id="v-svg-rot-y" class="val" data-target="svg-rot-y">0</span>¬∞</label><input type="range" id="svg-rot-y" min="-180" max="180" step="5" value="0"></div><div style="flex:1"><label>Z <span id="v-svg-rot-z" class="val" data-target="svg-rot-z">0</span>¬∞</label><input type="range" id="svg-rot-z" min="-180" max="180" step="5" value="0"></div></div></div>
            <div class="control-group"><div class="control-row"><div style="flex:1"><label><span data-i18n="lbl_pos_x">‰ΩçÁΩÆ X</span> <span id="v-svg-pos-x" class="val" data-target="svg-pos-x">0.0</span></label><input type="range" id="svg-pos-x" min="-15" max="15" step="0.5" value="0"></div><div style="flex:1"><label><span data-i18n="lbl_pos_z">‰ΩçÁΩÆ Z</span> <span id="v-svg-pos-z" class="val" data-target="svg-pos-z">0.0</span></label><input type="range" id="svg-pos-z" min="-15" max="15" step="0.5" value="0"></div></div></div>
            <div class="control-group"><label style="color:#aaa; font-size:0.7rem;"><span data-i18n="lbl_offset_y">È´ò„ÅïÂæÆË™øÊï¥ (Offset Y)</span> <span id="v-svg-offset-y" class="val">0.0</span></label><input type="range" id="svg-offset-y" min="-5.0" max="5.0" step="0.01" value="0.0"></div>

            <h3 id="sec-color" data-i18n="h_colors">Ëâ≤Ë®≠ÂÆö</h3>
            <div class="control-group" data-hint="hint_colors"><label data-i18n="lbl_col_body">Êú¨‰ΩìËâ≤</label><input type="color" id="col-body" value="#333333" class="color-input"><div class="palette-grid" id="palette-body"></div></div>
            <div class="control-group" style="margin-top:15px;"><label data-i18n="lbl_col_text">ÊñáÂ≠ó„ÉªSVGËâ≤</label><input type="color" id="col-text" value="#00e5ff" class="color-input"><div class="palette-grid" id="palette-text"></div></div>

            <div class="section-sep"></div>
            <h3 id="sec-preset" data-i18n="h_preset">„Éó„É™„Çª„ÉÉ„ÉàÁÆ°ÁêÜ</h3>

            <!-- V66: Visual Preset Library -->
            <div class="v60-sub-panel" style="border-color:#e040fb; margin-bottom:10px;" data-hint="hint_visual_presets">
                <label style="color:#e040fb; font-weight:bold;" data-i18n="lbl_visual_presets">üé® „Éì„Ç∏„É•„Ç¢„É´„Éó„É™„Çª„ÉÉ„Éà (V66)</label>
                <div class="control-row" style="margin-top:8px; gap:5px;">
                    <div style="flex:1;"><label style="font-size:0.7rem; color:#aaa;" data-i18n="lbl_font">„Éï„Ç©„É≥„Éà</label><select id="preset-font" style="font-size:0.75rem; padding:4px;">
                        <option value="helvetiker">Helvetiker</option>
                        <option value="helvetiker_bold">Helvetiker Bold</option>
                        <option value="optimer">Optimer</option>
                        <option value="gentilis">Gentilis</option>
                        <option value="droid_sans">Droid Sans</option>
                    </select></div>
                    <div style="flex:1;"><label style="font-size:0.7rem; color:#aaa;" data-i18n="lbl_size">„Çµ„Ç§„Ç∫</label><select id="preset-size" style="font-size:0.75rem; padding:4px;">
                        <option value="6">6</option>
                        <option value="7">7</option>
                        <option value="8" selected>8</option>
                        <option value="9">9</option>
                        <option value="10">10</option>
                        <option value="12">12</option>
                    </select></div>
                </div>
                <div class="control-group" style="margin-top:5px;"><label style="font-size:0.7rem; color:#aaa;" data-i18n="lbl_text_mode">ÁîüÊàê„É¢„Éº„Éâ</label><select id="preset-mode" style="font-size:0.75rem; padding:4px;">
                    <option value="emboss" data-i18n="opt_mode_emboss">ÊµÆ„ÅçÂá∫„Åó</option>
                    <option value="engrave" data-i18n="opt_mode_engrave">ÂàªÂç∞</option>
                    <option value="doubleshot" data-i18n="opt_mode_doubleshot">Âüã„ÇÅËæº„Åø</option>
                    <option value="lithophane" data-i18n="opt_mode_lithophane">„Éê„ÉÉ„ÇØ„É©„Ç§„ÉàÈÄèÈÅé</option>
                </select></div>
                <div class="visual-preset-grid" id="visual-preset-grid" style="margin-top:8px;">
                    <button type="button" class="visual-preset-btn" data-preset="wasd">
                        <span class="preset-icon">W</span>
                        <span class="preset-name">WASD</span>
                    </button>
                    <button type="button" class="visual-preset-btn" data-preset="arrows">
                        <span class="preset-icon">‚Üë</span>
                        <span class="preset-name" data-i18n="preset_arrow">Áü¢Âç∞„Ç≠„Éº</span>
                    </button>
                    <button type="button" class="visual-preset-btn" data-preset="fn">
                        <span class="preset-icon">Fn</span>
                        <span class="preset-name">Fn„Ç≠„Éº</span>
                    </button>
                    <button type="button" class="visual-preset-btn" data-preset="mac-cmd">
                        <span class="preset-icon">‚åò</span>
                        <span class="preset-name">Command</span>
                    </button>
                    <button type="button" class="visual-preset-btn" data-preset="mac-opt">
                        <span class="preset-icon">‚å•</span>
                        <span class="preset-name">Option</span>
                    </button>
                    <button type="button" class="visual-preset-btn" data-preset="esc">
                        <span class="preset-icon">Esc</span>
                        <span class="preset-name">Escape</span>
                    </button>
                </div>
                <button type="button" class="danger" id="btn-clear-visual-preset" style="margin-top:8px; width:100%; padding:5px;" data-i18n="btn_clear_preset">„Éó„É™„Çª„ÉÉ„ÉàËß£Èô§</button>
            </div>

            <div class="v60-sub-panel" style="border-color:#4caf50; margin-bottom:10px;" data-hint="hint_url_share">
                <label style="color:#4caf50; font-weight:bold;" data-i18n="lbl_url_share">üîó URL„ÅßÂÖ±Êúâ (Share via URL)</label>
                <div class="control-row" style="margin-top:5px;">
                    <button id="btn-share-url" style="flex:1; border-color:#4caf50; color:#4caf50;" data-i18n="btn_share_url">üìã URL„Çí„Ç≥„Éî„Éº</button>
                    <button id="btn-share-x" style="flex:1; border-color:#1DA1F2; color:#1DA1F2;" data-i18n="btn_share_x">ùïè „Ç∑„Çß„Ç¢</button>
                </div>
                <div class="control-row" style="margin-top:5px;">
                    <input type="text" id="url-import-input" placeholder="ÂÖ±ÊúâURL„ÇíË≤º„Çä‰ªò„Åë..." style="flex:1; font-size:0.75rem;" data-i18n-placeholder="placeholder_url_import">
                    <button id="btn-import-url" style="width:80px; border-color:#4caf50; color:#4caf50; font-size:0.75rem;" data-i18n="btn_import_url">Ë™≠„ÅøËæº„Åø</button>
                </div>
            </div>
            <div class="v60-sub-panel" style="border-color:#ff9800; margin-bottom:10px;">
                <label style="color:#ff9800; font-weight:bold;" data-i18n="lbl_named_preset">üÜï ÂêçÂâç‰ªò„Åç„Éó„É™„Çª„ÉÉ„Éà‰øùÂ≠ò (V64)</label>
                <input type="text" id="preset-save-name" placeholder="„Éó„É™„Çª„ÉÉ„ÉàÂêç„ÇíÂÖ•Âäõ..." style="margin-top:5px;" data-i18n-placeholder="placeholder_preset_name">
                <button id="btn-save-named-preset" style="border-color:#ff9800; color:#ff9800; margin-top:5px;" data-i18n="btn_save_named">üíæ ÂêçÂâç„Çí‰ªò„Åë„Å¶‰øùÂ≠ò</button>
            </div>
            <div class="control-group" data-hint="hint_quick_save"><label data-i18n="lbl_browser_storage">„Éñ„É©„Ç¶„Ç∂„Å´‰øùÂ≠ò (Quick Save/Load)</label><div class="control-row"><button id="btn-quick-save" class="secondary btn-small" data-i18n="btn_quick_save">‰∏ÄÊôÇ‰øùÂ≠ò (Save)</button><button id="btn-quick-load" class="secondary btn-small" data-i18n="btn_quick_load">Âæ©ÂÖÉ (Load)</button></div></div>
            <div class="control-group" data-hint="hint_export_json"><label data-i18n="lbl_file_storage">„Éï„Ç°„Ç§„É´„Å´‰øùÂ≠ò (File I/O)</label><div class="control-row"><button id="btn-export-preset" class="secondary btn-small" data-i18n="btn_export_file">Êõ∏„ÅçÂá∫„Åó (.json)</button><div class="file-upload" style="flex:1;" data-hint="hint_import_json"><label for="preset-file-input" class="file-upload-label preset btn-small" data-i18n="btn_load_add">Ë™≠„ÅøËæº„Åø (ËøΩÂä†)</label><input type="file" id="preset-file-input" accept=".json" multiple></div></div></div>
            <div id="preset-switch-panel" style="display:none; margin-top:10px; background:rgba(255,152,0,0.1); padding:8px; border-radius:4px; border:1px solid #ff9800;">
                <label style="color:#ff9800; font-size:0.8rem;" data-i18n="lbl_loaded_presets">üìÅ Ë™≠„ÅøËæº„Çì„Å†„Éó„É™„Çª„ÉÉ„Éà:</label>
                <div style="display:flex; gap:5px; align-items:center; margin-top:5px;">
                    <select id="preset-switcher" style="flex:1;"></select>
                    <button id="btn-remove-preset-ui" class="danger btn-small" style="width:28px; height:28px; padding:0;" title="Remove">√ó</button>
                </div>
                <div id="preset-preview-mini" style="margin-top:8px; font-size:0.7rem; color:#aaa; background:#000; padding:6px; border-radius:3px;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;"><span data-i18n="pv_profile">Profile:</span><span id="pm-profile" style="color:#ff9800;">-</span></div>
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;"><span data-i18n="pv_size">Size:</span><span id="pm-size" style="color:#ff9800;">-</span></div>
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;"><span data-i18n="pv_shape">Shape:</span><span id="pm-shape" style="color:#ff9800;">-</span></div>
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;"><span data-i18n="pv_text">Text:</span><span id="pm-text" style="color:#ff9800;">-</span></div>
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;"><span data-i18n="pv_text2">Sub Text:</span><span id="pm-text2" style="color:#ff9800;">-</span></div>
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;"><span data-i18n="pv_side">Side:</span><span id="pm-side" style="color:#ff9800;">-</span></div>
                    <div style="display:flex; justify-content:space-between;"><span data-i18n="pv_svg">SVG:</span><span id="pm-svg" style="color:#ff9800;">-</span></div>
                </div>
            </div>

            <div class="section-sep"></div>
            <h3 id="sec-export" data-i18n="h_export">„Ç®„ÇØ„Çπ„Éù„Éº„Éà (STL/OBJ/3MF)</h3>
            <div class="control-group" data-hint="hint_print_orient"><label>ÂÖ®‰ΩìÂõûËª¢ (Print Orientation)</label><div class="control-row"><div style="flex:1"><label>Rot X</label><input type="range" id="global-rot-x" min="-180" max="180" step="15" value="0" title="Global Rot X"></div><div style="flex:1"><label>Rot Y</label><input type="range" id="global-rot-y" min="-180" max="180" step="15" value="0" title="Global Rot Y"></div></div></div>
            <div class="control-group" style="margin-bottom:10px;"><label data-i18n="lbl_filename">„Éï„Ç°„Ç§„É´ÂêçË®≠ÂÆö (Ëá™Âãï„Åß[ÊñáÂ≠ó]„Åå‰ªò‰∏é„Åï„Çå„Åæ„Åô)</label><input type="text" id="export-name" value="keycap" style="text-align:left;"></div>
            <button id="btn-export-all" data-i18n="btn_export_all" data-hint="hint_export_stl">ÂÖ®‰Ωì„ÇíSTL„Åß‰øùÂ≠ò</button>
            <button id="btn-export-3mf" class="primary-3mf" style="margin-top:5px;" data-i18n="btn_export_3mf" data-hint="hint_export_3mf">ÂÖ®‰Ωì„Çí3MF„Åß‰øùÂ≠ò (Color)</button>
            <button id="btn-export-obj" class="accent" style="margin-top:5px; color:#ff9800; border-color:#ff9800;" data-i18n="btn_export_obj">ÂÖ®‰Ωì„ÇíOBJ„Åß‰øùÂ≠ò (Color)</button>
            <div class="control-row" data-hint="hint_export_parts"><button class="secondary" id="btn-export-body" data-i18n="btn_export_body">Êú¨‰Ωì„ÅÆ„Åø (STL)</button><button class="secondary" id="btn-export-text" data-i18n="btn_export_text">ÊñáÂ≠ó„ÅÆ„Åø (STL)</button></div>

            <!-- V66: Sprue Kit Generation -->
            <div class="sprue-kit-panel" data-hint="hint_sprue_kit">
                <label style="color:#00bcd4; font-weight:bold;" data-i18n="lbl_sprue_kit">üîó „Çπ„Éó„É´„Éº„Éª„Ç≠„ÉÉ„ÉàÁîüÊàê (V66)</label>
                <p style="font-size:0.7rem; color:#aaa; margin:5px 0;" data-i18n="hint_sprue_kit">Ë§áÊï∞„ÅÆ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Çí„Éó„É©„É¢„Éá„É´„ÅÆ„É©„É≥„Éä„Éº„ÅÆ„Çà„ÅÜ„Å´ÈÄ£Áµê„Åó„Å¶Âá∫Âäõ„Åó„Åæ„Åô„ÄÇ</p>
                
                <div class="control-group" style="margin-top:8px;">
                    <label style="color:#00bcd4;" data-i18n="sprue_printer_model">„Éó„É™„É≥„Çø„ÉºÊ©üÁ®Æ</label>
                    <div style="display:flex; gap:8px;">
                        <select id="sprue-printer-model" style="flex:1; font-size:0.8rem;">
                            <option value="x1p1a1">Bambu Lab X1/P1/A1</option>
                            <option value="a1mini">Bambu Lab A1 mini</option>
                            <option value="h2d">Bambu Lab H2D</option>
                            <option value="h2s">Bambu Lab H2S</option>
                            <option value="h2c">Bambu Lab H2C</option>
                            <option value="unlimited" data-i18n="sprue_unlimited">Âà∂Èôê„Å™„Åó</option>
                        </select>
                        <select id="sprue-printer-size" style="flex:1; font-size:0.8rem;">
                            <option value="256,256">256√ó256</option>
                        </select>
                    </div>
                    <div id="sprue-max-keys-info" style="font-size:0.7rem; color:#4fc3f7; margin-top:4px; text-align:right;">
                        <span data-i18n="sprue_max_keys">ÊúÄÂ§ßÈÖçÁΩÆÂèØËÉΩ</span>: <span id="sprue-max-keys">--</span>
                    </div>
                </div>
                
                <div class="control-group" style="margin-top:8px;">
                    <label><span data-i18n="sprue_key_count">„Ç≠„ÉÉ„ÉàÂÜÖ„ÅÆ„Ç≠„ÉºÊï∞</span> <span id="v-sprue-count" class="val">4</span></label>
                    <input type="range" id="sprue-count" min="2" max="100" step="1" value="4">
                </div>
                
                <div class="control-group" style="margin-top:8px;">
                    <label class="toggle-switch">
                        <input type="checkbox" id="sprue-repeat-mode" class="toggle-input">
                        <span class="toggle-knob"></span>
                        <span class="toggle-label" data-i18n="sprue_repeat_mode">Âêå„ÅòÊñáÂ≠ó„ÇíÈÄ£Á∂öÂá∫Âäõ</span>
                    </label>
                </div>
                
                <div class="control-group" id="sprue-chars-group">
                    <label data-i18n="sprue_char_list">ÊñáÂ≠ó„É™„Çπ„Éà („Ç´„É≥„ÉûÂå∫Âàá„Çä)</label>
                    <input type="text" id="sprue-chars" value="W,A,S,D" placeholder="W,A,S,D">
                </div>
                <div class="control-group" id="sprue-single-char-group" style="display:none;">
                    <label data-i18n="sprue_single_char">ÈÄ£Á∂öÂá∫Âäõ„Åô„ÇãÊñáÂ≠ó</label>
                    <input type="text" id="sprue-single-char" value="A" placeholder="A" maxlength="10" style="text-align:center; font-size:1.2rem; font-weight:bold;">
                </div>
                
                <div class="control-group">
                    <label data-i18n="sprue_output_format">Âá∫ÂäõÂΩ¢Âºè</label>
                    <select id="sprue-format">
                        <option value="stl">STL</option>
                        <option value="3mf">3MF (Color)</option>
                    </select>
                </div>
                <button id="btn-gen-sprue-kit" style="border-color:#00bcd4; color:#00bcd4; margin-top:8px;" data-i18n="sprue_generate">„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„ÉàÁîüÊàê</button>
            </div>

            <div class="section-sep"></div>
            <h3 id="sec-batch" data-i18n="h_batch">„Éê„ÉÉ„ÉÅÂá∫Âäõ (Batch Export)</h3>
            <div class="control-group" data-hint="hint_batch_list"><label data-i18n="lbl_batch_list">ÊñáÂ≠ó„É™„Çπ„Éà („Ç´„É≥„Éû/ÊîπË°åÂå∫Âàá„Çä)</label><textarea id="batch-list" rows="3" placeholder="Q,W,E,R,T,Y..."></textarea><div style="font-size:0.7em; color:#aaa; text-align:right;" data-i18n="note_batch">‚ÄªÁèæÂú®„ÅÆË®≠ÂÆö„ÅßÈÄ£Á∂öÁîüÊàê„Åó„Åæ„Åô</div></div>
            <div class="control-group">
                <label data-i18n="lbl_batch_format">Âá∫ÂäõÂΩ¢Âºè</label>
                <select id="batch-format">
                    <option value="stl">STL</option>
                    <option value="3mf">3MF (Color)</option>
                </select>
            </div>
            <button id="btn-batch-export" class="accent" data-i18n="btn_batch_run" data-hint="hint_batch_run">‰∏ÄÊã¨ÁîüÊàê</button>
            </div><!-- end of normal-mode-content -->
        </div>
    </div>

    <script type="module">
import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLExporter } from 'three/addons/exporters/STLExporter.js';
        import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        import { ViewHelper } from 'three/addons/helpers/ViewHelper.js';
        import { SUBTRACTION, ADDITION, Brush, Evaluator } from 'three-bvh-csg';
        
        let manifoldModule = null;
        let Manifold = null;
        
        async function initManifold() {
            try {
                const Module = await import('https://cdn.jsdelivr.net/npm/manifold-3d@3.0.0/manifold.js');
                manifoldModule = await Module.default();
                manifoldModule.setup();
                Manifold = manifoldModule.Manifold;
                console.log('Manifold WASM initialized successfully');
                return true;
            } catch (e) {
                console.warn('Manifold WASM failed to load:', e);
                return false;
            }
        }
        
        function geometryToManifold(geometry) {
            if (!Manifold || !geometry) return null;
            
            try {
                let geo = geometry.clone();
                
                if (!geo.index) {
                    geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
                }
                
                const position = geo.attributes.position;
                const index = geo.index;
                
                if (!position || !index) return null;
                
                const vertProperties = [];
                for (let i = 0; i < position.count; i++) {
                    vertProperties.push(position.getX(i), position.getY(i), position.getZ(i));
                }
                
                const triVerts = [];
                const indexArray = index.array;
                for (let i = 0; i < indexArray.length; i++) {
                    triVerts.push(indexArray[i]);
                }
                
                const mesh = new manifoldModule.Mesh({
                    numProp: 3,
                    vertProperties: new Float32Array(vertProperties),
                    triVerts: new Uint32Array(triVerts)
                });
                
                const manifold = new Manifold(mesh);
                mesh.delete();
                
                return manifold;
            } catch (e) {
                console.warn('geometryToManifold failed:', e);
                return null;
            }
        }
        
        function manifoldToGeometry(manifold) {
            if (!manifold) return null;
            
            try {
                const mesh = manifold.getMesh();
                
                const vertices = [];
                const indices = [];
                
                const vertProps = mesh.vertProperties;
                const numProp = mesh.numProp;
                
                for (let i = 0; i < vertProps.length; i += numProp) {
                    vertices.push(vertProps[i], vertProps[i + 1], vertProps[i + 2]);
                }
                
                const triVerts = mesh.triVerts;
                for (let i = 0; i < triVerts.length; i++) {
                    indices.push(triVerts[i]);
                }
                
                mesh.delete();
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                return geometry;
            } catch (e) {
                console.warn('manifoldToGeometry failed:', e);
                return null;
            }
        }
        
        function makeManifold(geometry) {
            if (!Manifold || !geometry) return geometry;
            
            try {
                const manifold = geometryToManifold(geometry);
                if (!manifold) return geometry;
                
                const status = manifold.status();
                if (status !== 0) {
                    console.log('Mesh is not manifold, status:', status);
                    manifold.delete();
                    return geometry;
                }
                
                const result = manifoldToGeometry(manifold);
                manifold.delete();
                
                return result || geometry;
            } catch (e) {
                console.warn('makeManifold failed:', e);
                return geometry;
            }
        }
        
        function repairSVGMesh(geometry) {
            if (!geometry) return null;
            
            try {
                let geo = BufferGeometryUtils.mergeVertices(geometry, 0.001);
                
                if (geo.index) {
                    geo = geo.toNonIndexed();
                }
                
                const position = geo.attributes.position;
                const triangles = [];
                const epsilon = 0.0001;
                
                for (let i = 0; i < position.count; i += 3) {
                    const v0 = new THREE.Vector3(position.getX(i), position.getY(i), position.getZ(i));
                    const v1 = new THREE.Vector3(position.getX(i+1), position.getY(i+1), position.getZ(i+1));
                    const v2 = new THREE.Vector3(position.getX(i+2), position.getY(i+2), position.getZ(i+2));
                    
                    const e0 = v0.distanceTo(v1);
                    const e1 = v1.distanceTo(v2);
                    const e2 = v2.distanceTo(v0);
                    
                    if (e0 < epsilon || e1 < epsilon || e2 < epsilon) continue;
                    
                    const ab = new THREE.Vector3().subVectors(v1, v0);
                    const ac = new THREE.Vector3().subVectors(v2, v0);
                    const cross = new THREE.Vector3().crossVectors(ab, ac);
                    const area = cross.length() * 0.5;
                    
                    if (area < epsilon * epsilon) continue;
                    
                    triangles.push({ v0, v1, v2, area });
                }
                
                const uniqueTriangles = [];
                const seen = new Set();
                
                for (const tri of triangles) {
                    const vertices = [tri.v0, tri.v1, tri.v2].map(v => 
                        `${v.x.toFixed(4)},${v.y.toFixed(4)},${v.z.toFixed(4)}`
                    ).sort().join('|');
                    
                    if (!seen.has(vertices)) {
                        seen.add(vertices);
                        uniqueTriangles.push(tri);
                    }
                }
                
                const newPositions = [];
                for (const tri of uniqueTriangles) {
                    newPositions.push(tri.v0.x, tri.v0.y, tri.v0.z);
                    newPositions.push(tri.v1.x, tri.v1.y, tri.v1.z);
                    newPositions.push(tri.v2.x, tri.v2.y, tri.v2.z);
                }
                
                const newGeo = new THREE.BufferGeometry();
                newGeo.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
                
                const mergedGeo = BufferGeometryUtils.mergeVertices(newGeo, 0.08);
                mergedGeo.computeVertexNormals();
                
                console.log(`SVG Repair: ${position.count/3} -> ${uniqueTriangles.length} triangles`);
                
                return mergedGeo;
            } catch (e) {
                console.warn('repairSVGMesh failed:', e);
                return geometry;
            }
        }

        const translations = {
            ja: {
                nav_jump: "--- „Çª„ÇØ„Ç∑„Éß„É≥ÁßªÂãï ---", nav_basic: "Âü∫Êú¨„Çµ„Ç§„Ç∫", nav_structure: "ÊßãÈÄ†„Éª„Éú„ÉÉ„ÉÅ", nav_shape: "ÂΩ¢Áä∂",
                nav_texture: "ÁîªÂÉè„ÉÜ„ÇØ„Çπ„ÉÅ„É£", nav_utility: "„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£", nav_import: "Â§ñÈÉ®„É¢„Éá„É´", 
                nav_stem: "„Çπ„ÉÜ„É†", nav_text: "ÊñáÂ≠ó„ÉªÂàªÂç∞", nav_svg: "SVG„Ç¢„Ç§„Ç≥„É≥", nav_color: "Ëâ≤Ë®≠ÂÆö",
                nav_preset: "„Éó„É™„Çª„ÉÉ„Éà", nav_export: "Êõ∏„ÅçÂá∫„Åó",
                h_basic: "Âü∫Êú¨„Çµ„Ç§„Ç∫", lbl_u_size: "„Ç≠„Éº„Çµ„Ç§„Ç∫", lbl_profile: "„Éó„É≠„Éï„Ç°„Ç§„É´", lbl_row: "Ë°å", lbl_unit_size: "Âü∫Êú¨„Éî„ÉÉ„ÉÅ", 
                h_structure: "ÊßãÈÄ†„Éª„Éú„ÉÉ„ÉÅ", lbl_wall_thick: "Â£Å„ÅÆÂéö„Åø", lbl_rib_shorten: "„É™„ÉñÁü≠Á∏Æ", lbl_enable_ribs: "Ë£úÂº∑„É™„Éñ",
                lbl_homing_bump: "„Éõ„Éº„É†„Éù„Ç∏„Ç∑„Éß„É≥Á™ÅËµ∑", opt_bump_round: "‰∏∏Âûã", opt_bump_bar: "Èï∑ÊñπÂΩ¢",
                lbl_pos_x: "‰ΩçÁΩÆ X", lbl_pos_z: "‰ΩçÁΩÆ Z", lbl_bump_offset: "È´ò„ÅïÂæÆË™øÊï¥",
                lbl_round_corner: "Ëßí„ÅÆ‰∏∏„Åø", note_round: "‚ÄªSquircle MappingÔºàÈ´òÈÄü„ÉªÂÆâÂÆöÔºâ",
                h_shape: "ÂΩ¢Áä∂", lbl_top_scale: "‰∏äÈù¢„Çµ„Ç§„Ç∫", lbl_dish_type: "‰∏äÈù¢ÂΩ¢Áä∂",
                lbl_key_shape_type: "üÜï „Ç≠„ÉºÂΩ¢Áä∂„Çø„Ç§„Éó", opt_shape_rect: "ÂõõËßíÂΩ¢", opt_shape_round: "Ëßí‰∏∏", 
                opt_shape_circle: "ÂÜÜÂΩ¢", opt_shape_polygon: "Â§öËßíÂΩ¢", opt_shape_star: "ÊòüÂΩ¢", opt_shape_iso: "ISO EnterÔºàLÂ≠óÂΩ¢Ôºâ",
                lbl_polygon_sides: "Ëæ∫„ÅÆÊï∞", lbl_star_points: "È†ÇÁÇπÊï∞", lbl_star_inner: "ÂÜÖÂæÑÊØî",
                lbl_iso_settings: "ISO/JIS Enter Ë®≠ÂÆö", lbl_iso_top_w: "‰∏äÈÉ®ÂπÖ", lbl_iso_bottom_w: "‰∏ãÈÉ®ÂπÖ", lbl_iso_total_h: "ÂÖ®‰Ωì„ÅÆÈ´ò„Åï",
                lbl_stem_x: "„Çπ„ÉÜ„É†X", lbl_stem_z: "„Çπ„ÉÜ„É†Z", lbl_stab_top_z: "‰∏ä„Çπ„Çø„ÉìZ", lbl_stab_bottom_z: "‰∏ã„Çπ„Çø„ÉìZ",
                opt_dish_cyl: "ÂÜÜÁ≠í", opt_dish_sph: "ÁêÉ", opt_dish_flat: "Âπ≥",
                lbl_texture: "Ë°®Èù¢„ÉÜ„ÇØ„Çπ„ÉÅ„É£", opt_tex_none: "„Å™„Åó", opt_tex_noise: "Ê¢®Âú∞", opt_tex_grid: "„Ç∞„É™„ÉÉ„Éó",
                lbl_tex_scale: "Á¥∞„Åã„Åï", lbl_tex_strength: "Ê∑±„Åï",
                h_texture_map: "ÁîªÂÉè„ÉÜ„ÇØ„Çπ„ÉÅ„É£", btn_upload_img: "üìÅ ÁîªÂÉèË™≠Ëæº", 
                h_stem: "„Çπ„ÉÜ„É†Ë®≠ÂÆö", lbl_stem_type: "Ëª∏„Çø„Ç§„Éó: Cherry MXÔºàÂõ∫ÂÆöÔºâ", lbl_clearance: "„ÇØ„É™„Ç¢„É©„É≥„Çπ", lbl_stem_diameter: "„Çπ„ÉÜ„É†Â§ñÂæÑ", 
                h_text: "ÊñáÂ≠óË®≠ÂÆö", lbl_enable_text: "ÊñáÂ≠ó„ÇíÁîüÊàê„Åô„Çã", pl_text: "‰æã: A\n{\n[", note_multiline: "‚ÄªÊîπË°å„Åß2ÊÆµÂç∞Â≠ó„ÅåÂèØËÉΩ",
                lbl_font: "„Éï„Ç©„É≥„Éà", note_font_upload: "‚Äª.ttf „Å™„Å©„Çí„Åù„ÅÆ„Åæ„ÅæË™≠„ÅøËæº„ÇÄ„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ<br><a href='http://gero3.github.io/facetype.js/' target='_blank'>Facetype.js</a> „Å™„Å©„ÅßJSON„Å´Â§âÊèõ„Åó„Åü„Éï„Ç°„Ç§„É´„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                btn_upload_font: "üìÅ „Ç´„Çπ„Çø„É†„Éï„Ç©„É≥„Éà", lbl_size: "„Çµ„Ç§„Ç∫", lbl_thickness: "Ê∑±„Åï/È´ò„Åï", lbl_conform: "Êõ≤Èù¢„Å´Âêà„Çè„Åõ„Çã",
                lbl_align_preset: "ÊñáÂ≠óÈÖçÁΩÆ", btn_align_center: "‰∏≠Â§Æ", btn_align_tl: "Â∑¶‰∏ä",
                btn_align_tr: "Âè≥‰∏ä", btn_align_bl: "Â∑¶‰∏ã", btn_align_br: "Âè≥‰∏ã",
                lbl_pos_xz_fine: "‰ΩçÁΩÆ X / ZÔºàÂæÆË™øÊï¥Ôºâ", lbl_offset_y: "È´ò„ÅïÂæÆË™øÊï¥",
                lbl_text_mode: "ÁîüÊàê„É¢„Éº„Éâ", opt_mode_emboss: "ÊµÆ„ÅçÂá∫„Åó", opt_mode_engrave: "ÂàªÂç∞", opt_mode_doubleshot: "Âüã„ÇÅËæº„Åø", opt_mode_lithophane: "„Éê„ÉÉ„ÇØ„É©„Ç§„ÉàÈÄèÈÅé",
                note_engrave: "‚ÄªEngrave„ÅØË®àÁÆóÂá¶ÁêÜ„Å´ÊôÇÈñì„Åå„Åã„Åã„Çä„Åæ„Åô",
                h_svg: "SVG„Ç¢„Ç§„Ç≥„É≥Ë®≠ÂÆö", btn_upload_svg: "üìÅ SVGË™≠Ëæº", lbl_visible: "Ë°®Á§∫", lbl_rotation: "ÂõûËª¢",
                h_colors: "Ëâ≤Ë®≠ÂÆö", lbl_col_body: "Êú¨‰ΩìËâ≤", lbl_col_text: "ÊñáÂ≠ó„ÉªSVGËâ≤",
                h_preset: "„Éó„É™„Çª„ÉÉ„ÉàÁÆ°ÁêÜ", lbl_browser_storage: "„Éñ„É©„Ç¶„Ç∂„Å´‰øùÂ≠ò", btn_quick_save: "‰∏ÄÊôÇ‰øùÂ≠ò", btn_quick_load: "Âæ©ÂÖÉ",
                lbl_file_storage: "„Éï„Ç°„Ç§„É´„Å´‰øùÂ≠ò", btn_export_file: "Êõ∏„ÅçÂá∫„Åó", btn_import_file: "Ë™≠„ÅøËæº„Åø",
                lbl_url_share: "üîó URL„ÅßÂÖ±Êúâ", btn_share_url: "üìã URL„Çí„Ç≥„Éî„Éº", btn_share_x: "ùïè „Ç∑„Çß„Ç¢", btn_import_url: "Ë™≠„ÅøËæº„Åø", placeholder_url_import: "ÂÖ±ÊúâURL„ÇíË≤º„Çä‰ªò„Åë...",
                lbl_named_preset: "üÜï ÂêçÂâç‰ªò„Åç„Éó„É™„Çª„ÉÉ„Éà‰øùÂ≠ò", placeholder_preset_name: "„Éó„É™„Çª„ÉÉ„ÉàÂêç„ÇíÂÖ•Âäõ...", btn_save_named: "üíæ ÂêçÂâç„Çí‰ªò„Åë„Å¶‰øùÂ≠ò",
                lbl_loaded_presets: "üìÅ Ë™≠„ÅøËæº„Çì„Å†„Éó„É™„Çª„ÉÉ„Éà:", btn_load_add: "Ë™≠„ÅøËæº„ÅøÔºàËøΩÂä†Ôºâ",
                pv_profile: "„Éó„É≠„Éï„Ç°„Ç§„É´:", pv_size: "„Çµ„Ç§„Ç∫:", pv_shape: "ÂΩ¢Áä∂:", pv_text: "ÊñáÂ≠ó:", pv_text2: "„Çµ„ÉñÊñáÂ≠ó:", pv_side: "„Çµ„Ç§„Éâ:", pv_svg: "SVG:",
                msg_url_copied: "URL„Çí„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ", msg_url_invalid: "ÁÑ°Âäπ„Å™URL„Åß„Åô", msg_url_loaded: "URL„Åã„Çâ„Éó„É™„Çª„ÉÉ„Éà„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü", msg_x_shared: "X(Twitter)„ÅÆÊäïÁ®øÁîªÈù¢„ÇíÈñã„Åç„Åæ„Åó„Åü",
                hint_f1_notice: "F1„Ç≠„Éº: Wiki„ÅßË©≥„Åó„ÅèË¶ã„Çã",
                btn_prev: "‚óÄ Ââç„Å∏", btn_next: "Ê¨°„Å∏ ‚ñ∂", btn_clear_all: "ÂÖ®ÂâäÈô§",
                h_export: "„Ç®„ÇØ„Çπ„Éù„Éº„Éà", lbl_filename: "„Éï„Ç°„Ç§„É´ÂêçË®≠ÂÆöÔºàËá™Âãï„Åß[ÊñáÂ≠ó]„Åå‰ªò‰∏é„Åï„Çå„Åæ„ÅôÔºâ", btn_export_all: "ÂÖ®‰Ωì„ÇíSTL„Åß‰øùÂ≠ò", btn_export_obj: "ÂÖ®‰Ωì„ÇíOBJ„Åß‰øùÂ≠ò",
                btn_export_3mf: "ÂÖ®‰Ωì„Çí3MF„Åß‰øùÂ≠ò", btn_export_body: "Êú¨‰Ωì„ÅÆ„Åø", btn_export_text: "ÊñáÂ≠ó„ÅÆ„Åø",
                h_batch: "„Éê„ÉÉ„ÉÅÂá∫Âäõ", lbl_batch_list: "ÊñáÂ≠ó„É™„Çπ„ÉàÔºà„Ç´„É≥„Éû/ÊîπË°åÂå∫Âàá„ÇäÔºâ", pl_batch: "Q,W,E,R,T,Y...",
                lbl_batch_format: "Âá∫ÂäõÂΩ¢Âºè",
                note_batch: "‚ÄªÁèæÂú®„ÅÆË®≠ÂÆö„ÅßÈÄ£Á∂öÁîüÊàê„Åó„Åæ„Åô", btn_batch_run: "‰∏ÄÊã¨ÁîüÊàê", 
                batch_processing: "Âá¶ÁêÜ‰∏≠: ", batch_complete: "ÂÆå‰∫ÜÔºÅ",
                msg_save_ok: "Ë®≠ÂÆö„Çí„Éñ„É©„Ç¶„Ç∂„Å´‰∏ÄÊôÇ‰øùÂ≠ò„Åó„Åæ„Åó„Åü„ÄÇ", msg_load_ok: "Ë®≠ÂÆö„ÇíÂæ©ÂÖÉ„Åó„Åæ„Åó„Åü„ÄÇ", msg_load_err: "‰øùÂ≠ò„Åï„Çå„ÅüË®≠ÂÆö„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ",
                msg_import_err: "„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº: Ê≠£„Åó„ÅÑJSONÂΩ¢Âºè„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ", msg_batch_empty: "ÊñáÂ≠ó„É™„Çπ„Éà„ÅåÁ©∫„Åß„Åô„ÄÇ",
                toast_generating: "„É°„ÉÉ„Ç∑„É•„ÇíÁîüÊàê‰∏≠...", toast_stl_exported: "STL„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„ÅüÔºÅ", 
                toast_obj_exported: "OBJ„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„ÅüÔºÅ", toast_3mf_exported: "3MF„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„ÅüÔºÅ",
                toast_export_failed: "„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÂ§±Êïó: ", toast_no_body: "„Ç®„É©„Éº: „Éú„Éá„Ç£„Ç∏„Ç™„É°„Éà„É™„ÅåÁîüÊàê„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü",
                h_import: "Â§ñÈÉ®„É¢„Éá„É´", btn_load_stl: "üìÅ STL„É¢„Éá„É´Ë™≠Ëæº", lbl_weight: "‰∫àÊÉ≥ÈáçÈáè:", lbl_cost: "‰∫àÊÉ≥„Ç≥„Çπ„Éà:", 
                lbl_vendor: "„Éô„É≥„ÉÄ„Éº:", lbl_material: "ÊùêÊñô:", btn_details: "‚ñº Ë©≥Á¥∞ / Á∑®ÈõÜ",
                lbl_manual_override: "ÊâãÂãïË®≠ÂÆö", lbl_price: "‰æ°Ê†º", lbl_spool: "„É™„Éº„É´(g)", lbl_density: "ÂØÜÂ∫¶",
                link_wiki: "Wiki„Å∏ÁßªÂãï", link_github: "GitHub„Å∏ÁßªÂãï",
                lbl_show_hints: "üí° „Éí„É≥„ÉàË°®Á§∫",
                hint_lang: "Ë°®Á§∫Ë®ÄË™û„ÇíÊó•Êú¨Ë™û„Åæ„Åü„ÅØËã±Ë™û„Å´Âàá„ÇäÊõø„Åà„Åæ„Åô„ÄÇ",
                hint_section_jump: "Ë®≠ÂÆö„Åó„Åü„ÅÑÈ†ÖÁõÆ„Å∏Á¥†Êó©„ÅèÁßªÂãï„Åó„Åæ„Åô„ÄÇ",
                hint_search: "Ë®≠ÂÆöÈ†ÖÁõÆÂêç„ÅßÊ§úÁ¥¢„Åó„ÄÅË©≤ÂΩìÁÆáÊâÄ„Çí„Éè„Ç§„É©„Ç§„Éà„Åó„Åæ„Åô„ÄÇ",
                hint_stats: "ÁèæÂú®„ÅÆË®≠ÂÆö„Å´Âü∫„Å•„ÅÑ„Åü„ÄÅ„Éï„Ç£„É©„É°„É≥„Éà„ÅÆÊ¶ÇÁÆóÈáçÈáè„Å®„Ç≥„Çπ„Éà„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ„ÇØ„É™„ÉÉ„ÇØ„ÅßÊùêÊñôË®≠ÂÆö„ÇíÈñãÈñâ„Åß„Åç„Åæ„Åô„ÄÇ",
                hint_unit_size: "1U„ÅÆÂü∫Ê∫ñ„Çµ„Ç§„Ç∫„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇÈÄöÂ∏∏„ÅØ19.05mm„Åß„Åô„Åå„ÄÅChocÁ≥ª„Å™„Å©„ÅØÂ∞è„Åï„ÅèË®≠ÂÆö„Åó„Åæ„Åô„ÄÇ",
                hint_key_size: "„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÊ®™ÂπÖ„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇ1.0(ÈÄöÂ∏∏)„ÄÅ2.0(BackSpace)„ÄÅ6.25(Space)„Å™„Å©„ÄÇ",
                hint_stabilizer: "2U‰ª•‰∏ä„ÅÆ„Ç≠„Éº„Å´‰ªò„Åè„Çπ„Çø„Éì„É©„Ç§„Ç∂„Éº„ÅÆ‰ΩçÁΩÆË®≠ÂÆö„Åß„Åô„ÄÇÂü∫Êú¨„ÅØAuto„ÅßÂïèÈ°å„ÅÇ„Çä„Åæ„Åõ„Çì„Åå„ÄÅÁâπÊÆä„Å™ÈÖçÁΩÆ„ÅÆÂ†¥Âêà„ÅØCustom„ÅßË™øÊï¥„Åó„Åæ„Åô„ÄÇ",
                hint_profile: "„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂÖ®‰ΩìÂΩ¢Áä∂Ôºà„Éó„É≠„Éï„Ç°„Ç§„É´Ôºâ„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇCherry, OEM, SA, XDA, DSA„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
                hint_row: "„Ç≠„Éº„ÅÆÈ´ò„Åï„Å®ÂÇæÊñúËßíÂ∫¶ÔºàR1„ÄúR4Ôºâ„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇ„Éó„É≠„Éï„Ç°„Ç§„É´„Å´„Çà„Å£„Å¶ÂΩ¢Áä∂„ÅåÁï∞„Å™„Çä„Åæ„Åô„ÄÇ",
                hint_fillet: "„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂõõÈöÖ„Çí‰∏∏„Åè„Åó„Åæ„ÅôÔºàSquircleÂΩ¢Áä∂Ôºâ„ÄÇÂÄ§„ÇíÂ§ß„Åç„Åè„Åô„Çã„Å®‰∏∏„Åè„Å™„Çä„Åæ„Åô„ÄÇ",
                hint_wall_thick: "„Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÂÅ¥Èù¢„ÅÆÂéö„Åø„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇËñÑ„Åô„Åé„Çã„Å®Âº∑Â∫¶„ÅåËêΩ„Å°„ÄÅÂéö„Åô„Åé„Çã„Å®„Çπ„Ç§„ÉÉ„ÉÅ„Å®Âπ≤Ê∏â„Åô„ÇãÂ†¥Âêà„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ",
                hint_rib_shorten: "ÂÜÖÈÉ®„ÅÆ„É™„ÉñÔºàË£úÂº∑Ôºâ„ÅÆ‰∏ãÁ´Ø„Çí„Å©„ÅÆ„Åè„Çâ„ÅÑÊåÅ„Å°‰∏ä„Åí„Çã„ÅãË®≠ÂÆö„Åó„Åæ„Åô„ÄÇLED„Å®„ÅÆÂπ≤Ê∏â„ÇíÈò≤„ÅêÂ†¥Âêà„Å™„Å©„Å´Ë™øÊï¥„Åó„Åæ„Åô„ÄÇ",
                hint_enable_ribs: "ÂÜÖÈÉ®„Å´ÂçÅÂ≠ó„ÅÆË£úÂº∑Â£Å„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇÂº∑Â∫¶„ÅåÂêë‰∏ä„Åó„ÄÅÂèç„Çä„ÇíÈò≤„Åé„Åæ„Åô„ÄÇ",
                hint_homing_bump: "F„Ç≠„Éº„ÇÑJ„Ç≠„Éº„Å´‰ªò„ÅÑ„Å¶„ÅÑ„Çã„ÄÅÊåá„ÅÆÊÑüËß¶„Åß‰ΩçÁΩÆ„ÇíÁü•„Çã„Åü„ÇÅ„ÅÆÁ™ÅËµ∑„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ",
                hint_bump_type: "Á™ÅËµ∑„ÅÆÂΩ¢Áä∂„Çí„Äé‰∏∏Âûã„Äè„Åã„Äé„Éê„ÉºÔºàÈï∑ÊñπÂΩ¢Ôºâ„Äè„Åã„ÇâÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇ",
                hint_key_shape: "„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂü∫Êú¨ÂΩ¢Áä∂„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇÂõõËßíÂΩ¢„ÄÅËßí‰∏∏„ÄÅÂÜÜÂΩ¢„ÄÅÂ§öËßíÂΩ¢„ÄÅÊòüÂΩ¢„ÄÅISO EnterÔºàLÂ≠óÂΩ¢Ôºâ„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
                hint_taper: "„Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÂ§©Èù¢„ÅÆÂ∫É„Åï„ÇíË™øÊï¥„Åó„Åæ„Åô„ÄÇÂÄ§„ÇíÂ∞è„Åï„Åè„Åô„Çã„Å®Âè∞ÂΩ¢„Åå„Åç„Å§„Åè„Å™„Çä„Åæ„Åô„ÄÇ",
                hint_dish_type: "Êåá„ÇíÁΩÆ„ÅèÂ§©Èù¢„ÅÆ„Åè„Åº„ÅøÂΩ¢Áä∂„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇÂÜÜÁ≠í(Cylindrical)„ÄÅÁêÉ(Spherical)„ÄÅÂπ≥Âù¶(Flat)„Åã„ÇâÈÅ∏„Åπ„Åæ„Åô„ÄÇ",
                hint_texture: "Ë°®Èù¢„Å´„Ç∂„É©„Ç∂„É©„ÇÑÊ®°Êßò„Å™„Å©„ÅÆ„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíËá™ÂãïÁîüÊàê„Åó„Åæ„Åô„ÄÇ",
                hint_texture_global: "„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíÂ§©Èù¢„Å†„Åë„Åß„Å™„Åè„ÄÅÂÅ¥Èù¢„ÇíÂê´„ÇÄ„Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÂÖ®‰Ωì„Å´ÈÅ©Áî®„Åó„Åæ„Åô„ÄÇ",
                hint_twist: "„Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÂÖ®‰Ωì„Çí„Å≠„Åò„Çä„Åæ„Åô„ÄÇArtisan„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó‰ΩúÊàê„Å™„Å©„Å´‰Ωø„Åà„Åæ„Åô„ÄÇ",
                hint_tilt: "Â§©Èù¢„ÅÆÂÇæ„Åç„ÇíXËª∏„ÉªZËª∏ÊñπÂêë„Å∏ÊâãÂãï„ÅßÂæÆË™øÊï¥„Åó„Åæ„Åô„ÄÇ",
                hint_img_upload: "PNG„Åæ„Åü„ÅØJPGÁîªÂÉè„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„ÄÅ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆË°®Èù¢„Å´„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Å®„Åó„Å¶Ë≤º„Çä‰ªò„Åë„Åæ„Åô„ÄÇÂ•Ω„Åç„Å™ÊüÑ„ÇÑÂÜôÁúü„Çí„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÊ®°Êßò„Å´„Åß„Åç„Åæ„Åô„ÄÇ",
                hint_custom_font: "Facetype.js„Å™„Å©„ÅßÂ§âÊèõ„Åó„Åü„ÄéJSONÂΩ¢Âºè„Äè„ÅÆ„Éï„Ç©„É≥„Éà„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Åø„Åæ„Åô„ÄÇ‚ÄªPC„Å´ÂÖ•„Å£„Å¶„ÅÑ„ÇãTTF„ÇÑOTF„Éï„Ç°„Ç§„É´„ÅØÁõ¥Êé•‰ΩøÁî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇ",
                hint_stem_diameter: "„Çπ„Ç§„ÉÉ„ÉÅ„Å´Êåø„ÅôËª∏„ÅÆÂ§ñÂÅ¥„ÅÆÂ§™„Åï„ÇíË™øÊï¥„Åó„Åæ„Åô„ÄÇÊ®ôÊ∫ñ„ÅØ5.5mm„Åß„Åô„ÄÇ",
                hint_clearance: "ÂçÅÂ≠óÁ©¥„ÅÆÈöôÈñìÔºàÂÖ¨Â∑ÆÔºâ„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇ„Åç„Å§„Åè„Å¶ÂÖ•„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØÂÄ§„ÇíÂ§ß„Åç„Åè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                hint_stem_ext: "„Çπ„ÉÜ„É†„Å†„Åë„ÇíÂ∫ïÈù¢„Çà„ÇäÈï∑„Åè‰º∏„Å∞„Åó„Åæ„Åô„ÄÇÁâπÊÆä„Å™„Çπ„Ç§„ÉÉ„ÉÅ„ÇÑÈ´ò„ÅïË™øÊï¥„Å´‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ",
                hint_box_stem: "ÂçÅÂ≠ó„Çπ„ÉÜ„É†„ÅÆÂë®„Çä„ÇíÂõõËßí„ÅÑÂ£Å„ÅßÂõ≤„Åø„ÄÅÂº∑Â∫¶„Å®Èò≤Â°µÊÄß„ÇíÈ´ò„ÇÅ„Åæ„ÅôÔºàKailh Box„Çπ„Ç§„ÉÉ„ÉÅÈ¢®Ôºâ„ÄÇ",
                hint_lego_stud: "Â§©Èù¢„Å´„É¨„Ç¥„Éñ„É≠„ÉÉ„ÇØ‰∫íÊèõ„ÅÆ„Éù„ÉÉ„ÉÅ„ÇíËøΩÂä†„Åó„Åæ„Åô„ÄÇ",
                hint_enable_text: "ÊñáÂ≠ó„ÅÆÁîüÊàê„ÇíON/OFF„Åó„Åæ„Åô„ÄÇ",
                hint_text_input: "ÂàªÂç∞„Åó„Åü„ÅÑÊñáÂ≠ó„ÇíÂÖ•Âäõ„Åó„Åæ„Åô„ÄÇÊîπË°å„Åô„Çã„Å®2Ë°å„Å´„Å™„Çä„Åæ„Åô„ÄÇ",
                hint_font: "ÂàªÂç∞„Å´‰ΩøÁî®„Åô„Çã„Éï„Ç©„É≥„Éà„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇ",
                hint_text_mode: "Emboss(ÊµÆ„ÅçÂá∫„Åó)„ÄÅEngrave(ÂΩ´„ÇäËæº„Åø)„ÄÅDouble-Shot(Âà•„Éë„Éº„ÉÑÂåñ)„ÄÅLithophane(„Éê„ÉÉ„ÇØ„É©„Ç§„ÉàÈÄèÈÅé)„Åã„ÇâÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇ",
                hint_text_height: "ÊñáÂ≠ó„ÅÆÂéö„Åø„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇDouble-Shot„ÅÆÂ†¥Âêà„ÅØÂüã„ÇÅËæº„ÇÄÊ∑±„Åï„Å´„Å™„Çä„Åæ„Åô„ÄÇ",
                hint_conform: "„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂ§©Èù¢„ÅÆ„Ç´„Éº„Éñ„Å´Ê≤ø„Å£„Å¶ÊñáÂ≠ó„ÇíÂ§âÂΩ¢„Åï„Åõ„Åæ„Åô„ÄÇ",
                hint_align_preset: "‰∏≠Â§Æ„ÄÅÂ∑¶‰∏ä„ÄÅÂè≥‰∏ã„Å™„Å©„ÅÆÂÆö‰ΩçÁΩÆ„Å∏„ÉØ„É≥„ÇØ„É™„ÉÉ„ÇØ„ÅßÊñáÂ≠ó„ÇíÁßªÂãï„Åï„Åõ„Åæ„Åô„ÄÇ",
                hint_text2: "„É°„Ç§„É≥ÊñáÂ≠ó„Å®„ÅØÂà•„Å´„ÄÅÂè≥‰∏ã„Å™„Å©„Å´Â∞è„Åï„Å™ÊñáÂ≠ó„ÇíËøΩÂä†„Åó„Åæ„Åô„ÄÇ",
                hint_side_print: "„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÊâãÂâçÂÅ¥Èù¢Ôºà„Éï„É≠„É≥„ÉàÔºâ„Å´ÊñáÂ≠ó„ÇíÂÖ•„Çå„Åæ„Åô„ÄÇ",
                hint_svg_upload: "„Éô„ÇØ„Çø„ÉºÁîªÂÉè(.svg)„ÇíË™≠„ÅøËæº„Çì„ÅßÂàªÂç∞„Åó„Åæ„Åô„ÄÇ„É≠„Ç¥„ÇÑ„Ç¢„Ç§„Ç≥„É≥„Å´ÊúÄÈÅ©„Åß„Åô„ÄÇ",
                hint_svg_mode: "SVG„ÅÆÂá¶ÁêÜÊñπÊ≥ï„ÇíÈÅ∏„Å≥„Åæ„Åô„ÄÇDouble-Shot„Å´„Åô„Çã„Å®„Éû„É´„ÉÅ„Ç´„É©„ÉºÂç∞Âà∑Áî®„Å´Âà•„Éë„Éº„ÉÑ„Å®„Åó„Å¶Âá∫Âäõ„Åß„Åç„Åæ„Åô„ÄÇ",
                hint_colors: "„Éó„É¨„Éì„É•„ÉºÁîªÈù¢‰∏ä„ÅÆËâ≤„ÇíÂ§âÊõ¥„Åó„Åæ„Åô„ÄÇ‚ÄªSTLÂá∫Âäõ„Å´„ÅØÂΩ±Èüø„Åó„Åæ„Åõ„Çì„Åå„ÄÅOBJ/3MFÂá∫ÂäõÊôÇ„Å´„ÅØÂèçÊò†„Åï„Çå„Åæ„Åô„ÄÇ",
                hint_url_share: "ÁèæÂú®„ÅÆË®≠ÂÆö„ÇíURL„Å´„Ç®„É≥„Ç≥„Éº„Éâ„Åó„Å¶„Ç≥„Éî„Éº„Åó„Åæ„Åô„ÄÇSNS„Å™„Å©„ÅßÂÖ±Êúâ„Åß„Åç„Åæ„Åô„ÄÇ",
                hint_quick_save: "ÁèæÂú®„ÅÆË®≠ÂÆö„Çí„Éñ„É©„Ç¶„Ç∂„Å´‰∏ÄÊôÇÁöÑ„Å´‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ",
                hint_export_json: "Ë®≠ÂÆö„Çí„Éï„Ç°„Ç§„É´„Å®„Åó„Å¶‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇÂæå„ÅßË™≠„ÅøËæº„Çì„Å†„Çä„ÄÅ‰ªñ„ÅÆ‰∫∫„Å®ÂÖ±Êúâ„Åß„Åç„Åæ„Åô„ÄÇ",
                hint_import_json: "‰øùÂ≠ò„Åó„ÅüË®≠ÂÆö„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Åø„Åæ„Åô„ÄÇË§áÊï∞„Éï„Ç°„Ç§„É´„Çí„Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„Éó„Åô„Çã„Å®‰∏ÄÊã¨„Åß„É™„Çπ„Éà„Å´ËøΩÂä†„Åï„Çå„Åæ„Åô„ÄÇ",
                hint_print_orient: "3D„Éó„É™„É≥„ÉàÊôÇ„ÅÆÂêë„Åç„Å´Âêà„Çè„Åõ„Å¶„ÄÅ„É¢„Éá„É´ÂÖ®‰Ωì„ÇíÂõûËª¢„Åï„Åõ„Åæ„Åô„ÄÇ",
                hint_export_stl: "‰∏ÄËà¨ÁöÑ„Å™3D„Éó„É™„É≥„Çø„ÉºÁî®„ÅÆÂΩ¢Âºè(.stl)„Åß‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ",
                hint_export_3mf: "Ëâ≤ÊÉÖÂ†±„ÇíÂê´„Çì„Å†ÂΩ¢Âºè(.3mf)„Åß‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇBambu Lab„Å™„Å©„ÅÆ„Éû„É´„ÉÅ„Ç´„É©„ÉºÂç∞Âà∑„Å´ÊúÄÈÅ©„Åß„Åô„ÄÇ",
                hint_export_parts: "„Éë„Éº„ÉÑ„ÇíÂÄãÂà•„Å´STLÂá∫Âäõ„Åó„Åæ„Åô„ÄÇÁï∞„Å™„ÇãËâ≤„ÅÆ„Éï„Ç£„É©„É°„É≥„Éà„ÅßÂç∞Âà∑„Åô„ÇãÂ†¥Âêà„Å™„Å©„Å´‰Ωø„ÅÑ„Åæ„Åô„ÄÇ",
                hint_batch_list: "„Åì„Åì„Å´„Ç´„É≥„ÉûÂå∫Âàá„ÇäÔºàA,B,C...Ôºâ„ÅßÊñáÂ≠ó„ÇíÂÖ•„Çå„Çã„Å®„ÄÅÁèæÂú®„ÅÆË®≠ÂÆö„ÅßÈ†ÜÁï™„Å´Ëá™ÂãïÁîüÊàê„Åó„Åæ„Åô„ÄÇ",
                hint_batch_run: "„É™„Çπ„Éà„ÅÆÊñáÂ≠ó„ÇíÈÄ£Á∂ö„ÅßÁîüÊàê„Åó„ÄÅ„Åæ„Å®„ÇÅ„Å¶„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Åæ„Åô„ÄÇ",
                hint_randomizer: "„Åô„Åπ„Å¶„ÅÆ„Éë„É©„É°„Éº„Çø„Çí„É©„É≥„ÉÄ„É†„Å´Â§âÊõ¥„Åó„Åæ„Åô„ÄÇÊñ∞„Åó„ÅÑ„Ç¢„Ç§„Éá„Ç¢Êé¢„Åó„Å´„ÄÇ",
                hint_reset: "„Åô„Åπ„Å¶„ÅÆË®≠ÂÆö„ÇíÂàùÊúüÁä∂ÊÖã„Å´Êàª„Åó„Åæ„Åô„ÄÇ",
                hint_import_stl: "Ëá™‰Ωú„ÅÆ3D„É¢„Éá„É´(.stl)„ÇíË™≠„ÅøËæº„Çì„ÅßÂêàÊàê„Åó„Åæ„Åô„ÄÇ",
                hint_import_op: "UnionÔºàÁµêÂêàÔºâ„ÅØÁõõ„Çä‰∏ä„Åí„ÄÅSubtractÔºàÂûãÊäú„ÅçÔºâ„ÅØÂΩ´„ÇäËæº„Åø„Å´‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ‚ÄªSubtract„ÅØÂá¶ÁêÜÊôÇÈñì„Åå„Åã„Åã„Çä„Åæ„Åô„ÄÇ",
                // V66 Translations
                lbl_simple_mode: "üå± Á∞°Âçò„É¢„Éº„Éâ (Simple)",
                h_simple_mode: "üå± Á∞°Âçò„É¢„Éº„Éâ",
                lbl_simple_text: "ÊñáÂ≠óÂÖ•Âäõ",
                lbl_text_visible: "ÊñáÂ≠óË°®Á§∫",
                lbl_simple_font: "„Éï„Ç©„É≥„Éà",
                lbl_simple_icon: "„Ç¢„Ç§„Ç≥„É≥",
                btn_clear_icon: "„Ç¢„Ç§„Ç≥„É≥Ëß£Èô§",
                lbl_simple_profile: "ÂΩ¢Áä∂",
                lbl_simple_row: "Ë°å",
                lbl_simple_key_size: "„Ç≠„Éº„ÅÆÂπÖ",
                lbl_simple_body_color: "Êú¨‰ΩìËâ≤",
                lbl_simple_text_color: "ÊñáÂ≠óËâ≤",
                lbl_simple_text_mode: "ÁîüÊàê„É¢„Éº„Éâ",
                lbl_simple_taper: "‰∏äÈù¢„Çµ„Ç§„Ç∫",
                lbl_simple_dish: "‰∏äÈù¢ÂΩ¢Áä∂",
                lbl_simple_fillet: "Ëßí„ÅÆ‰∏∏„Åø",
                lbl_dimension_lines: "üìê ÂØ∏Ê≥ïÁ∑ö„ÇíË°®Á§∫ (V66)",
                lbl_layer_color: "üé® „É¨„Ç§„É§„Éº„Ç´„É©„Éº„Éª„Éó„É¨„Éì„É•„Éº",
                lbl_visual_presets: "üé® „Éì„Ç∏„É•„Ç¢„É´„Éó„É™„Çª„ÉÉ„Éà (V66)",
                lbl_stock_icons: "üì¶ ÂÜÖËîµ„Ç¢„Ç§„Ç≥„É≥ (V66)",
                lbl_tolerance_test: "üîß „Çπ„ÉÜ„É†„ÉÜ„Çπ„Éà„Ç≠„ÉÉ„Éà (V66)",
                lbl_sprue_kit: "üîó „Çπ„Éó„É´„Éº„Éª„Ç≠„ÉÉ„ÉàÁîüÊàê (V66)",
                hint_simple_mode: "Á∞°Âçò„É¢„Éº„Éâ„Åß„ÅØ„ÄÅÂàùÂøÉËÄÖÂêë„Åë„Å´ÂøÖË¶ÅÊúÄÂ∞èÈôê„ÅÆË®≠ÂÆöÈ†ÖÁõÆ„ÅÆ„ÅøË°®Á§∫„Åó„Åæ„Åô„ÄÇÁ¥∞„Åã„ÅÑË®≠ÂÆö„ÅØV65„ÅÆ„Éá„Éï„Ç©„É´„ÉàÂÄ§„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ",
                hint_dimension_lines: "3D„Éì„É•„Éº‰∏ä„Å´„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„ÅÆÂØ∏Ê≥ïÁ∑ö„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇÂç∞Âà∑Ââç„ÅÆ„Çµ„Ç§„Ç∫Á¢∫Ë™ç„Å´‰æøÂà©„Åß„Åô„ÄÇ",
                hint_layer_color: "Bambu Lab AMS„Å™„Å©„Åß„Éï„Ç£„É©„É°„É≥„Éà‰∫§ÊèõÊôÇ„ÅÆËâ≤„ÅÆÂ§âÂåñ„Çí„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥„Åó„Åæ„Åô„ÄÇ",
                hint_visual_presets: "„Çà„Åè‰Ωø„ÅÜ„Ç≠„ÉºÔºàWASD„ÄÅÁü¢Âç∞„Ç≠„Éº„Å™„Å©Ôºâ„Çí„ÉØ„É≥„ÇØ„É™„ÉÉ„ÇØ„ÅßË®≠ÂÆö„Åß„Åç„Åæ„Åô„ÄÇ",
                hint_stock_icons: "„Çà„Åè‰Ωø„ÅÜ„Ç¢„Ç§„Ç≥„É≥ÔºàÁü¢Âç∞„ÄÅÂÜçÁîü„ÄÅCommand„Ç≠„Éº„Å™„Å©Ôºâ„ÅåÂÜÖËîµ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇSVG„ÇíÊé¢„ÅôÊâãÈñì„ÇíÁúÅ„Åë„Åæ„Åô„ÄÇ",
                hint_tolerance_test: "„Éó„É™„É≥„Çø„Éº„ÅÆÂÖ¨Â∑Æ„ÉÜ„Çπ„ÉàÁî®„ÅÆ„Çπ„ÉÜ„É†„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇÊúÄÈÅ©„Å™„ÇØ„É™„Ç¢„É©„É≥„ÇπÂÄ§„ÇíË¶ã„Å§„Åë„Çã„ÅÆ„Å´‰æøÂà©„Åß„Åô„ÄÇ",
                hint_sprue_kit: "Ë§áÊï∞„ÅÆ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Çí„Éó„É©„É¢„Éá„É´„ÅÆ„É©„É≥„Éä„Éº„ÅÆ„Çà„ÅÜ„Å´ÈÄ£Áµê„Åó„Å¶Âá∫Âäõ„Åó„Åæ„Åô„ÄÇ„ÇÆ„Éï„Éà„ÇÑË≤©Â£≤„Å´ÊúÄÈÅ©„ÄÇ",
                hint_simple_key_size: "„Çà„Åè‰Ωø„ÅÜ„Ç≠„Éº„Çµ„Ç§„Ç∫„Çí„Éú„Çø„É≥„ÅßÁ∞°Âçò„Å´ÈÅ∏Êäû„Åß„Åç„Åæ„Åô„ÄÇ",
                // Export Popup
                popup_export_confirm: "„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÁ¢∫Ë™ç",
                popup_cancel: "„Ç≠„É£„É≥„Çª„É´",
                popup_export: "„Ç®„ÇØ„Çπ„Éù„Éº„Éà",
                popup_est_weight: "‰∫àÊÉ≥ÈáçÈáè",
                popup_est_cost: "‰∫àÊÉ≥„Ç≥„Çπ„Éà",
                popup_vendor: "„Éô„É≥„ÉÄ„Éº",
                popup_material: "ÊùêÊñô",
                popup_profile: "„Éó„É≠„Éï„Ç°„Ç§„É´",
                popup_size: "„Çµ„Ç§„Ç∫",
                popup_row: "Ë°å",
                popup_text: "ÊñáÂ≠ó",
                popup_svg_icon: "SVG„Ç¢„Ç§„Ç≥„É≥",
                popup_printer: "„Éó„É™„É≥„Çø„Éº",
                popup_build_size: "ÈÄ†ÂΩ¢„Çµ„Ç§„Ç∫",
                popup_key_count: "„Ç≠„ÉºÊï∞",
                popup_layout: "ÈÖçÁΩÆ",
                popup_char_list: "ÊñáÂ≠ó„É™„Çπ„Éà",
                popup_format: "Âá∫ÂäõÂΩ¢Âºè",
                popup_file_count: "„Éï„Ç°„Ç§„É´Êï∞",
                // Sprue Kit
                sprue_printer_model: "„Éó„É™„É≥„Çø„ÉºÊ©üÁ®Æ",
                sprue_max_keys: "ÊúÄÂ§ßÈÖçÁΩÆÂèØËÉΩ",
                sprue_key_count: "„Ç≠„ÉÉ„ÉàÂÜÖ„ÅÆ„Ç≠„ÉºÊï∞",
                sprue_repeat_mode: "Âêå„ÅòÊñáÂ≠ó„ÇíÈÄ£Á∂öÂá∫Âäõ",
                sprue_char_list: "ÊñáÂ≠ó„É™„Çπ„Éà („Ç´„É≥„ÉûÂå∫Âàá„Çä)",
                sprue_single_char: "ÈÄ£Á∂öÂá∫Âäõ„Åô„ÇãÊñáÂ≠ó",
                sprue_output_format: "Âá∫ÂäõÂΩ¢Âºè",
                sprue_generate: "„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„ÉàÁîüÊàê",
                sprue_generating: "„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„ÉàÁîüÊàê‰∏≠...",
                sprue_unlimited: "Âà∂Èôê„Å™„Åó",
                // Tolerance Test
                tolerance_desc: "„Éó„É™„É≥„Çø„Éº„ÅÆÂÖ¨Â∑Æ„Çí„ÉÜ„Çπ„Éà„Åô„Çã„Åü„ÇÅ„ÅÆ„Çπ„ÉÜ„É†„Å†„Åë„Çí‰∏¶„Åπ„Åü„Éó„É¨„Éº„Éà„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ",
                tolerance_output_format: "Âá∫ÂäõÂΩ¢Âºè",
                tolerance_generate: "„ÉÜ„Çπ„Éà„Ç≠„ÉÉ„ÉàÁîüÊàê",
                tolerance_start: "ÈñãÂßãÂÄ§",
                tolerance_step: "Âàª„Åø",
                tolerance_generating: "„Çπ„ÉÜ„É†„ÉÜ„Çπ„Éà„Ç≠„ÉÉ„Éà„ÇíÁîüÊàê‰∏≠...",
                tolerance_complete: "„Çπ„ÉÜ„É†„ÉÜ„Çπ„ÉàÁîüÊàêÂÆå‰∫Ü",
                popup_tol_start: "ÈñãÂßãÂÄ§",
                popup_tol_step: "Âàª„Åø",
                popup_tol_count: "ÁîüÊàêÊï∞",
                popup_tol_values: "„ÇØ„É™„Ç¢„É©„É≥„ÇπÂÄ§",
                // Row descriptions
                row_r4: "R4 (ÊúÄ‰∏äÊÆµ/Êï∞Â≠ó„Ç≠„Éº)",
                row_r3: "R3 (ÊñáÂ≠ó„Ç≠„Éº/Enter)",
                row_r2: "R2 („Éõ„Éº„É†ÊÆµ/ASDF)",
                row_r1: "R1 (ÊúÄ‰∏ãÊÆµ/Space)",
                // Additional UI
                lbl_custom_profile: "üÜï „Ç´„Çπ„Çø„É†„Éó„É≠„Éï„Ç°„Ç§„É´Ë®≠ÂÆö",
                lbl_icon_size: "„Ç¢„Ç§„Ç≥„É≥„Çµ„Ç§„Ç∫",
                lbl_sub_text: "„Çµ„ÉñÊñáÂ≠ó (Legend 2)",
                lbl_side_print: "„Çµ„Ç§„ÉâÂç∞Â≠ó (Side Print)",
                preset_arrow: "Áü¢Âç∞„Ç≠„Éº",
                arrow_select_title: "Áü¢Âç∞„ÅÆÊñπÂêë„ÇíÈÅ∏Êäû",
                wasd_select_title: "WASD„Ç≠„Éº„ÇíÈÅ∏Êäû",
                arrow_up: "‰∏ä",
                arrow_down: "‰∏ã",
                arrow_left: "Â∑¶",
                arrow_right: "Âè≥",
                // More UI
                lbl_global_apply: "ÂÖ®‰Ωì„Å´ÈÅ©Áî®",
                lbl_click_to_apply: "„ÇØ„É™„ÉÉ„ÇØ„ÅßSVG„Å®„Åó„Å¶ÈÅ©Áî®",
                btn_presets: "„Éó„É™„Çª„ÉÉ„Éà",
                btn_clear_stock_icon: "ÈÅ∏ÊäûËß£Èô§",
                btn_clear_preset: "„Éó„É™„Çª„ÉÉ„ÉàËß£Èô§",
                msg_preset_cleared: "ÂàùÊúüÁä∂ÊÖã„Å´Êàª„Åó„Åæ„Åó„Åü",
                msg_enter_repeat_char: "ÈÄ£Á∂öÂá∫Âäõ„Åô„ÇãÊñáÂ≠ó„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
                msg_enter_one_char: "1„Å§‰ª•‰∏ä„ÅÆÊñáÂ≠ó„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
                // New keys for mixed labels
                lbl_stabilizer: "„Çπ„Çø„Éì„É©„Ç§„Ç∂„Éº",
                opt_stab_auto: "Ëá™Âãï",
                opt_stab_custom: "ÊâãÂãïË®≠ÂÆö",
                lbl_stab_pitch: "„Éî„ÉÉ„ÉÅÔºà‰∏≠ÂøÉ„Ç™„Éï„Çª„ÉÉ„ÉàÔºâ",
                note_stab_distance: "‚Äª‰∏≠ÂøÉ„Åã„Çâ„Çπ„ÉÜ„É†‰∏≠ÂøÉ„Åæ„Åß„ÅÆË∑ùÈõ¢",
                opt_tex_knurling: "„É≠„Éº„É¨„ÉÉ„Éà",
                opt_tex_stripes: "„Çπ„Éà„É©„Ç§„Éó",
                opt_tex_ripple: "Ê≥¢Á¥ã",
                opt_tex_wood: "Êú®ÁõÆ",
                opt_tex_hammered: "ÊâìÁóï",
                opt_tex_hexagon: "„Éè„Éã„Ç´„É†",
                opt_tex_bricks: "„É¨„É≥„Ç¨",
                lbl_stem_extension: "Èï∑„Åï„ÇíÊã°Âºµ",
                lbl_box_stem: "„Éú„ÉÉ„ÇØ„ÇπËª∏",
                lbl_lego_stud: "Â§©Èù¢„Éù„ÉÉ„ÉÅ",
                lbl_tilt: "Â§©Èù¢ËßíÂ∫¶Ë™øÊï¥",
                lbl_import_op: "ÂêàÊàê„É¢„Éº„Éâ",
                opt_union: "ÁµêÂêàÔºàËøΩÂä†Ôºâ",
                opt_subtract: "ÂûãÊäú„ÅçÔºàÂΩ´ÂàªÔºâ",
                note_subtract: "‚ÄªÂûãÊäú„Åç„ÅØÂá¶ÁêÜ„Å´ÊôÇÈñì„Åå„Åã„Åã„Çä„Åæ„Åô",
                cat_all: "„Åô„Åπ„Å¶",
                msg_loading: "Ë™≠„ÅøËæº„Åø‰∏≠...",
                btn_simple_export_stl: "üì• STL„Åß‰øùÂ≠ò",
                btn_simple_export_3mf: "üé® 3MF„Åß‰øùÂ≠ò"
            },
            en: {
                nav_jump: "--- Jump to Section ---", nav_basic: "Basic Size", nav_structure: "Structure", nav_shape: "Shape",
                nav_texture: "Texture Map", nav_utility: "Utility", nav_import: "Import 3D", nav_stem: "Stem",
                nav_text: "Text / Legend", nav_svg: "SVG Icon", nav_color: "Colors", nav_preset: "Presets", nav_export: "Export",
                h_basic: "Basic Size", lbl_u_size: "Key Size (U)", lbl_profile: "Profile", lbl_row: "Row", lbl_unit_size: "Unit Size (Pitch)",
                h_structure: "Structure & Stem", lbl_wall_thick: "Wall Thickness", lbl_rib_shorten: "Rib Shorten (Lift)", lbl_enable_ribs: "Reinforcement Ribs",
                lbl_homing_bump: "Homing Bump", opt_bump_round: "Round", opt_bump_bar: "Bar",
                lbl_pos_x: "Pos X", lbl_pos_z: "Pos Z", lbl_bump_offset: "Bump Offset Y",
                lbl_round_corner: "Round Corner (Fillet)", note_round: "*Squircle Mapping (Fast & Stable)",
                h_shape: "Shape (Taper/Dish)", lbl_top_scale: "Top Scale (Taper)", lbl_dish_type: "Dish Type",
                lbl_key_shape_type: "üÜï Key Shape Type (V64)", opt_shape_rect: "Rectangle", opt_shape_round: "Rounded", 
                opt_shape_circle: "Circle", opt_shape_polygon: "Polygon", opt_shape_star: "Star", opt_shape_iso: "ISO Enter (L-Shape)",
                lbl_polygon_sides: "Sides", lbl_star_points: "Points", lbl_star_inner: "Inner Ratio",
                lbl_iso_settings: "ISO/JIS Enter Settings", lbl_iso_top_w: "Top Width", lbl_iso_bottom_w: "Bottom Width", lbl_iso_total_h: "Total Height",
                lbl_stem_x: "Stem X", lbl_stem_z: "Stem Z", lbl_stab_top_z: "Top Stab Z", lbl_stab_bottom_z: "Bottom Stab Z",
                opt_dish_cyl: "Cylindrical", opt_dish_sph: "Spherical", opt_dish_flat: "Flat",
                lbl_texture: "Surface Procedural", opt_tex_none: "None", opt_tex_noise: "Noise (Sand)", opt_tex_grid: "Grid (Studs)",
                lbl_tex_scale: "Scale", lbl_tex_strength: "Strength",
                h_texture_map: "Image Texture (Image Map)", btn_upload_img: "üìÅ Load Image (PNG/JPG)",
                h_stem: "Stem Settings", lbl_stem_type: "Stem Type: Cherry MX (Fixed)", lbl_clearance: "Clearance", lbl_stem_diameter: "Stem Diameter", 
                h_text: "Legend Settings", lbl_enable_text: "Enable Text", pl_text: "Ex: A\n{\n[", note_multiline: "*Use line breaks for multi-line.",
                lbl_font: "Font", note_font_upload: "*Cannot import .ttf directly. Convert to JSON using <a href='http://gero3.github.io/facetype.js/' target='_blank'>Facetype.js</a>.",
                btn_upload_font: "üìÅ Custom Font (.json)", lbl_size: "Size", lbl_thickness: "Thickness", lbl_conform: "Conform to Surface",
                lbl_align_preset: "Alignment Presets", btn_align_center: "Center", btn_align_tl: "Top-Left",
                btn_align_tr: "Top-Right", btn_align_bl: "Bottom-Left", btn_align_br: "Bottom-Right",
                lbl_pos_xz_fine: "Position X / Z (Fine)", lbl_offset_y: "Y Offset (Fine)",
                lbl_text_mode: "Generation Mode", opt_mode_emboss: "Emboss (Raised)", opt_mode_engrave: "Engrave (Inset)", opt_mode_doubleshot: "Double-Shot (Inlay)", opt_mode_lithophane: "Lithophane (Backlit)",
                note_engrave: "*Engrave requires more processing time.",
                h_svg: "SVG Icon Settings", btn_upload_svg: "üìÅ Load SVG", lbl_visible: "Visible", lbl_rotation: "Rotation (XYZ)",
                h_colors: "Color Settings", lbl_col_body: "Body Color", lbl_col_text: "Text/SVG Color",
                h_preset: "Preset Management", lbl_browser_storage: "Browser Storage (Quick)", btn_quick_save: "Quick Save", btn_quick_load: "Quick Load",
                lbl_file_storage: "File Storage", btn_export_file: "Export (.json)", btn_import_file: "Import (.json)",
                lbl_url_share: "üîó Share via URL", btn_share_url: "üìã Copy URL", btn_share_x: "ùïè Share", btn_import_url: "Load", placeholder_url_import: "Paste shared URL...",
                lbl_named_preset: "üÜï Save Named Preset", placeholder_preset_name: "Enter preset name...", btn_save_named: "üíæ Save with Name",
                lbl_loaded_presets: "üìÅ Loaded Presets:", btn_load_add: "Load (Add)",
                pv_profile: "Profile:", pv_size: "Size:", pv_shape: "Shape:", pv_text: "Text:", pv_text2: "Sub Text:", pv_side: "Side:", pv_svg: "SVG:",
                msg_url_copied: "URL copied to clipboard!", msg_url_invalid: "Invalid URL", msg_url_loaded: "Preset loaded from URL", msg_x_shared: "Opened X (Twitter) compose window",
                hint_f1_notice: "F1: View details on Wiki",
                btn_prev: "‚óÄ Prev", btn_next: "Next ‚ñ∂", btn_clear_all: "Clear All",
                h_export: "Export (STL/OBJ/3MF)", lbl_filename: "File Name", btn_export_all: "Export All (STL)", btn_export_obj: "Export All (OBJ w/ Color)",
                btn_export_3mf: "Export All (3MF w/ Color)", btn_export_body: "Body Only (STL)", btn_export_text: "Text Only (STL)",
                h_batch: "Batch Export", lbl_batch_list: "Character List (comma/newline)", pl_batch: "Q,W,E,R,T,Y...",
                lbl_batch_format: "Output Format",
                note_batch: "*Generate using current settings.", btn_batch_run: "Run Batch",
                batch_processing: "Processing: ", batch_complete: "Done!",
                msg_save_ok: "Settings saved to browser.", msg_load_ok: "Settings loaded.", msg_load_err: "No saved settings found.",
                msg_import_err: "Import Error: Invalid JSON format.", msg_batch_empty: "Character list is empty.",
                toast_generating: "Generating mesh...", toast_stl_exported: "STL exported!", 
                toast_obj_exported: "OBJ exported!", toast_3mf_exported: "3MF exported!",
                toast_export_failed: "Export failed: ", toast_no_body: "Error: No body geometry generated",
                h_import: "Import 3D", btn_load_stl: "üìÅ Load STL Model", lbl_weight: "Est. Weight:", lbl_cost: "Est. Cost:", 
                lbl_vendor: "Vendor:", lbl_material: "Material:", btn_details: "‚ñº Details / Edit",
                lbl_manual_override: "Manual Override", lbl_price: "Price", lbl_spool: "Spool(g)", lbl_density: "Dens.",
                link_wiki: "Go to Wiki", link_github: "Go to GitHub",
                lbl_show_hints: "üí° Show Hints",
                hint_lang: "Switch display language between Japanese and English.",
                hint_section_jump: "Quickly jump to the section you want to configure.",
                hint_search: "Search settings by name and highlight matches.",
                hint_stats: "Shows estimated filament weight and cost based on current settings. Click to open/close material settings.",
                hint_unit_size: "Set the base size for 1U. Usually 19.05mm, but smaller for Choc switches etc.",
                hint_key_size: "Set the keycap width. 1.0 (normal), 2.0 (BackSpace), 6.25 (Space), etc.",
                hint_stabilizer: "Position settings for stabilizers on 2U+ keys. Auto works for most cases, use Custom for special layouts.",
                hint_profile: "Select the overall keycap shape (profile). Supports Cherry, OEM, SA, XDA, DSA.",
                hint_row: "Set key height and tilt angle (R1-R4). Shape varies by profile.",
                hint_fillet: "Round the four corners of the keycap (Squircle shape). Higher values = rounder.",
                hint_wall_thick: "Set the side wall thickness. Too thin reduces strength, too thick may interfere with switches.",
                hint_rib_shorten: "Set how much to raise the bottom of internal ribs. Adjust to prevent LED interference.",
                hint_enable_ribs: "Create cross-shaped reinforcement walls inside. Improves strength and prevents warping.",
                hint_homing_bump: "Create the tactile bump found on F and J keys for finger positioning.",
                hint_bump_type: "Choose bump shape: Round or Bar (rectangle).",
                hint_key_shape: "Select the base keycap shape. Supports rectangle, rounded, circle, polygon, star, and ISO Enter (L-shape).",
                hint_taper: "Adjust the top surface size. Smaller values = steeper taper.",
                hint_dish_type: "Set the dish shape for finger placement. Choose Cylindrical, Spherical, or Flat.",
                hint_texture: "Auto-generate surface textures like sandpaper or patterns.",
                hint_texture_global: "Apply texture to the entire keycap including sides, not just the top.",
                hint_twist: "Twist the entire keycap. Useful for artisan keycaps.",
                hint_tilt: "Fine-tune the top surface tilt in X and Z directions.",
                hint_img_upload: "Upload PNG or JPG images to apply as a texture on the keycap surface. Turn your favorite patterns or photos into keycap designs.",
                hint_custom_font: "Load font files converted to JSON format using tools like Facetype.js. *TTF or OTF files from your PC cannot be used directly.",
                hint_stem_diameter: "Adjust the outer diameter of the switch stem. Standard is 5.5mm.",
                hint_clearance: "Set the cross-hole tolerance. Increase if too tight to fit.",
                hint_stem_ext: "Extend only the stem below the bottom. For special switches or height adjustment.",
                hint_box_stem: "Add square walls around the cross stem for strength and dust protection (Kailh Box style).",
                hint_lego_stud: "Add LEGO-compatible studs on the top surface.",
                hint_enable_text: "Turn text generation ON/OFF.",
                hint_text_input: "Enter the character to engrave. Use line breaks for multiple lines.",
                hint_font: "Select the font for engraving.",
                hint_text_mode: "Choose Emboss (raised), Engrave (inset), Double-Shot (separate part), or Lithophane (backlit).",
                hint_text_height: "Set text thickness. For Double-Shot, this is the embed depth.",
                hint_conform: "Deform text to follow the keycap's top surface curve.",
                hint_align_preset: "One-click positioning to center, top-left, bottom-right, etc.",
                hint_text2: "Add a secondary smaller text, typically in the bottom-right corner.",
                hint_side_print: "Add text on the front side of the keycap.",
                hint_svg_upload: "Load vector images (.svg) for engraving. Perfect for logos and icons.",
                hint_svg_mode: "Choose SVG processing method. Double-Shot exports as separate parts for multi-color printing.",
                hint_colors: "Change preview colors. *Does not affect STL output, but reflects in OBJ/3MF.",
                hint_url_share: "Encode current settings into a URL and copy. Share on social media.",
                hint_quick_save: "Temporarily save current settings in browser storage.",
                hint_export_json: "Save settings as a file. Load later or share with others.",
                hint_import_json: "Load saved setting files. Drag & drop multiple files to add to list.",
                hint_print_orient: "Rotate the entire model to match 3D print orientation.",
                hint_export_stl: "Save in standard 3D printer format (.stl).",
                hint_export_3mf: "Save with color information (.3mf). Ideal for Bambu Lab multi-color printing.",
                hint_export_parts: "Export parts separately as STL. Useful for printing with different filament colors.",
                hint_batch_list: "Enter comma-separated characters (A,B,C...) to auto-generate with current settings.",
                hint_batch_run: "Generate all characters in the list and download together.",
                hint_randomizer: "Randomly change all parameters. Great for finding new ideas.",
                hint_reset: "Reset all settings to defaults.",
                hint_import_stl: "Load custom 3D models (.stl) to combine.",
                hint_import_op: "Union adds geometry, Subtract carves out. *Subtract requires more processing time.",
                // V66 Translations
                lbl_simple_mode: "üå± Simple Mode",
                h_simple_mode: "üå± Simple Mode",
                lbl_simple_text: "Text",
                lbl_text_visible: "Show Text",
                lbl_simple_font: "Font",
                lbl_simple_icon: "Icon",
                btn_clear_icon: "Clear Icon",
                lbl_simple_profile: "Profile",
                lbl_simple_row: "Row",
                lbl_simple_key_size: "Key Size",
                lbl_simple_body_color: "Body Color",
                lbl_simple_text_color: "Text Color",
                lbl_simple_text_mode: "Text Mode",
                lbl_simple_taper: "Top Size",
                lbl_simple_dish: "Dish Type",
                lbl_simple_fillet: "Corner Radius",
                lbl_dimension_lines: "üìê Show Dimensions (V66)",
                lbl_layer_color: "üé® Layer Color Preview",
                lbl_visual_presets: "üé® Visual Presets (V66)",
                lbl_stock_icons: "üì¶ Built-in Icons (V66)",
                lbl_tolerance_test: "üîß Tolerance Test Kit (V66)",
                lbl_sprue_kit: "üîó Sprue Kit Generation (V66)",
                hint_simple_mode: "Simple Mode shows only essential settings for beginners. Advanced settings use V65 defaults.",
                hint_dimension_lines: "Display dimension lines on the 3D view. Useful for size verification before printing.",
                hint_layer_color: "Simulate color changes at filament swap height for Bambu Lab AMS and similar systems.",
                hint_visual_presets: "One-click setup for common keys (WASD, arrows, etc.).",
                hint_stock_icons: "Built-in common icons (arrows, play, Command key, etc.). No need to search for SVGs.",
                hint_tolerance_test: "Generate stems for printer tolerance testing. Useful for finding the optimal clearance value.",
                hint_sprue_kit: "Connect multiple keycaps like model kit runners. Perfect for gifts or sales.",
                hint_simple_key_size: "Easily select common key sizes with buttons.",
                // Export Popup
                popup_export_confirm: "Export Confirmation",
                popup_cancel: "Cancel",
                popup_export: "Export",
                popup_est_weight: "Est. Weight",
                popup_est_cost: "Est. Cost",
                popup_vendor: "Vendor",
                popup_material: "Material",
                popup_profile: "Profile",
                popup_size: "Size",
                popup_row: "Row",
                popup_text: "Text",
                popup_svg_icon: "SVG Icon",
                popup_printer: "Printer",
                popup_build_size: "Build Size",
                popup_key_count: "Key Count",
                popup_layout: "Layout",
                popup_char_list: "Character List",
                popup_format: "Format",
                popup_file_count: "File Count",
                // Sprue Kit
                sprue_printer_model: "Printer Model",
                sprue_max_keys: "Max Keys",
                sprue_key_count: "Keys in Kit",
                sprue_repeat_mode: "Repeat Same Character",
                sprue_char_list: "Character List (comma separated)",
                sprue_single_char: "Character to Repeat",
                sprue_output_format: "Output Format",
                sprue_generate: "Generate Sprue Kit",
                sprue_generating: "Generating Sprue Kit...",
                sprue_unlimited: "Unlimited",
                // Tolerance Test
                tolerance_desc: "Generate a plate with stems only for testing printer tolerance.",
                tolerance_output_format: "Output Format",
                tolerance_generate: "Generate Test Kit",
                tolerance_start: "Start Value",
                tolerance_step: "Step",
                tolerance_generating: "Generating stem test kit...",
                tolerance_complete: "Stem test generated",
                popup_tol_start: "Start Value",
                popup_tol_step: "Step",
                popup_tol_count: "Count",
                popup_tol_values: "Clearance Values",
                // Row descriptions
                row_r4: "R4 (Top Row/Number)",
                row_r3: "R3 (Letters/Enter)",
                row_r2: "R2 (Home Row/ASDF)",
                row_r1: "R1 (Bottom/Space)",
                // Additional UI
                lbl_custom_profile: "üÜï Custom Profile Settings",
                lbl_icon_size: "Icon Size",
                lbl_sub_text: "Sub Text (Legend 2)",
                lbl_side_print: "Side Print",
                preset_arrow: "Arrow Key",
                arrow_select_title: "Select Arrow Direction",
                wasd_select_title: "Select WASD Key",
                arrow_up: "Up",
                arrow_down: "Down",
                arrow_left: "Left",
                arrow_right: "Right",
                // More UI
                lbl_global_apply: "Global Apply",
                lbl_click_to_apply: "Click to apply as SVG",
                btn_presets: "Presets",
                btn_clear_stock_icon: "Clear Selection",
                btn_clear_preset: "Clear Preset",
                msg_preset_cleared: "Reset to default",
                msg_enter_repeat_char: "Please enter character to repeat",
                msg_enter_one_char: "Please enter at least one character",
                // New keys for mixed labels
                lbl_stabilizer: "Stabilizer",
                opt_stab_auto: "Auto",
                opt_stab_custom: "Custom",
                lbl_stab_pitch: "Pitch (Center Offset)",
                note_stab_distance: "*Distance from center to stem center",
                opt_tex_knurling: "Knurling",
                opt_tex_stripes: "Stripes",
                opt_tex_ripple: "Ripple",
                opt_tex_wood: "Wood Grain",
                opt_tex_hammered: "Hammered",
                opt_tex_hexagon: "Hexagon",
                opt_tex_bricks: "Bricks",
                lbl_stem_extension: "Stem Extension",
                lbl_box_stem: "Box Stem",
                lbl_lego_stud: "Lego Stud",
                lbl_tilt: "Tilt Angle",
                lbl_import_op: "Operation Mode",
                opt_union: "Union (Add)",
                opt_subtract: "Subtract (Carve)",
                note_subtract: "*Subtract takes more processing time",
                cat_all: "All",
                msg_loading: "Loading...",
                btn_simple_export_stl: "üì• Save as STL",
                btn_simple_export_3mf: "üé® Save as 3MF"
            }
        };
        let currentLang = 'ja';
        function updateLanguageUI() {
            const t = translations[currentLang];
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (t[key]) {
                    if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') { if (el.placeholder) el.placeholder = t[key]; } 
                    else if (el.tagName === 'OPTION') { el.textContent = t[key]; } 
                    else { el.innerHTML = t[key]; }
                }
            });
            document.getElementById('text-content').placeholder = t.pl_text;
            updateFilamentDisplay(); updateCustomDropdownHead(); 
            const linkWiki = document.getElementById('link-wiki');
            const linkGithub = document.getElementById('link-github');
            if(linkWiki) linkWiki.title = t.link_wiki || "Wiki";
            if(linkGithub) linkGithub.title = t.link_github || "GitHub";
        }

        document.getElementById('language-select').addEventListener('change', (e) => { currentLang = e.target.value; updateLanguageUI(); });
        window.onerror = (msg) => { document.getElementById('error-log').textContent += msg + "\n"; };
        setTimeout(() => { const b=document.getElementById('force-start-btn'); if(b)b.click(); }, 1000);

        function showToast(message, isError = false) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast' + (isError ? ' error' : '');
            toast.textContent = message;
            container.appendChild(toast);
            requestAnimationFrame(() => toast.classList.add('show'));
            setTimeout(() => { toast.classList.remove('show'); setTimeout(() => toast.remove(), 300); }, 3000);
        }

        const SimpleNoise = {
            fract: (x) => x - Math.floor(x),
            hash: (x, z) => { return SimpleNoise.fract(Math.sin(x * 12.9898 + z * 78.233) * 43758.5453); },
            noise: (x, z) => {
                const iX = Math.floor(x); const iZ = Math.floor(z);
                const fX = SimpleNoise.fract(x); const fZ = SimpleNoise.fract(z);
                const a = SimpleNoise.hash(iX, iZ); const b = SimpleNoise.hash(iX + 1, iZ);
                const c = SimpleNoise.hash(iX, iZ + 1); const d = SimpleNoise.hash(iX + 1, iZ + 1);
                const uX = fX * fX * (3.0 - 2.0 * fX); const uZ = fZ * fZ * (3.0 - 2.0 * fZ);
                return (a * (1.0 - uX) + b * uX) * (1.0 - uZ) + (c * (1.0 - uX) + d * uX) * uZ;
            }
        };

        const initialState = {
            uSize: 1.0, profile: 'cherry', row: 'R3', unitSize: 19.05, topScale: 1.0, dishType: 'cylindrical',
            textureType: 'none', textureScale: 50, textureStrength: 0.05, textureGlobal: false,
            imgTextureVisible: false, imgScale: 1.0, imgPosX: 0.0, imgPosY: 0.0, imgRot: 0, imgContent: null,
            enableStemExtension: false, stemExtension: 1.0, stabilizerType: 'auto', stabilizerOffset: 0.0,
            twist: 0, tiltX: 0, tiltZ: 0, boxStem: false, legoStud: false, legoX: 0.0, legoY: 0.0, legoZ: 0.0, legoClear: 0.0,
            wallThickness: 1.5, ribShorten: 4.3, enableRibs: true,
            homingBump: false, homingType: 'round', bumpX: 0, bumpZ: 0, bumpOffsetY: 0.0, roundCorner: 0.0, 
            stemType: 'mx', stemDiameter: 5.50, stemClearance: 0.3,
            enableText: true, text: 'A', font: 'helvetiker', fontSize: 8.0, textHeight: 0.5, textMode: 'emboss',
            textThicknessLocked: true, textConform: true, posX: 0, posZ: 0, textOffsetY: 0.0,
            enableText2: false, text2: '„ÅÇ', text2Size: 4.0, text2X: 3.5, text2Z: 3.5, text2Mode: 'emboss',
            enableSide: false, sideText: 'FRONT', sideSize: 3.0, sideY: -2.0, sideRot: 0, sideMode: 'emboss',
            renderMode: 'standard', 
            modelVisible: true, modelScale: 1.0, modelX: 0, modelY: 0, modelZ: 0, modelRX: 0, modelRY: 0, modelRZ: 0, modelOperation: 'union', 
            globalRotX: 0, globalRotY: 0,
            svgContent: null, svgName: null, svgVisible: true, svgScale: 1.0, svgThickness: 0.6, svgMode: 'emboss', svgConform: true, 
            svgRotX: 0, svgRotY: 0, svgRotZ: 0, svgOffsetY: 0.0, svgPosX: 0, svgPosZ: 0,
            colBody: '#333333', colText: '#00e5ff',
            keyShapeType: 'rectangle', polygonSides: 6, starPoints: 5, starInner: 0.5,
            isoTopWidth: 1.5, isoBottomWidth: 1.25, isoHeight: 2.0,
            isoStemX: 2.4, isoStemZ: 0, isoStabTopZ: -12, isoStabBottomZ: 12,
            customHeight: 9.5, customAngle: 3
        };
        let state = JSON.parse(JSON.stringify(initialState));
        let importedModelBuffer = null;
        const csgEvaluator = new Evaluator();
        const history = [JSON.parse(JSON.stringify(initialState))];
        let historyIndex = 0;
        let loadedPresets = [];
        let currentPresetIndex = -1;

        const paramMap = {
            'u-size':'uSize', 'wall-thick':'wallThickness', 'rib-shorten':'ribShorten', 'top-scale':'topScale',
            'stem-clearance':'stemClearance', 'font-size':'fontSize', 'text-height':'textHeight',
            'text-offset-y':'textOffsetY', 'pos-x':'posX', 'pos-z':'posZ',
            'profile-select':'profile', 'row-select':'row', 'homing-type':'homingType', 'dish-type':'dishType', 'font-family':'font',
            'bump-x':'bumpX', 'bump-z':'bumpZ', 'bump-offset-y':'bumpOffsetY',
            'svg-scale':'svgScale', 'svg-thickness':'svgThickness', 
            'svg-rot-x':'svgRotX', 'svg-rot-y':'svgRotY', 'svg-rot-z':'svgRotZ',
            'svg-offset-y':'svgOffsetY', 'svg-pos-x':'svgPosX', 'svg-pos-z':'svgPosZ',
            'text2-size':'text2Size', 'text2-x':'text2X', 'text2-z':'text2Z',
            'side-size':'sideSize', 'side-y':'sideY', 'side-rot':'sideRot',
            'render-mode':'renderMode', 'side-text':'sideText',
            'model-scale':'modelScale', 'model-x':'modelX', 'model-y':'modelY', 'model-z':'modelZ',
            'model-rx':'modelRX', 'model-ry':'modelRY', 'model-rz':'modelRZ',
            'global-rot-x':'globalRotX', 'global-rot-y':'globalRotY', 'model-operation':'modelOperation',
            'texture-type':'textureType', 'tex-scale':'textureScale', 'tex-strength':'textureStrength',
            'stem-extension':'stemExtension', 'stabilizer-type':'stabilizerType', 'stabilizer-offset':'stabilizerOffset',
            'twist-factor': 'twist', 'tilt-x': 'tiltX', 'tilt-z': 'tiltZ', 'unit-size-select': 'unitSize', 'round-corner': 'roundCorner',
            'stem-diameter': 'stemDiameter', 'text-mode': 'textMode', 'text2-mode': 'text2Mode', 'side-mode': 'sideMode', 'svg-mode': 'svgMode',
            'img-scale': 'imgScale', 'img-pos-x': 'imgPosX', 'img-pos-y': 'imgPosY', 'img-rot': 'imgRot',
            'lego-x': 'legoX', 'lego-y': 'legoY', 'lego-z': 'legoZ', 'lego-clear': 'legoClear',
            'polygon-sides': 'polygonSides', 'star-points': 'starPoints', 'star-inner': 'starInner',
            'iso-top-width': 'isoTopWidth', 'iso-bottom-width': 'isoBottomWidth', 'iso-height': 'isoHeight',
            'iso-stem-x': 'isoStemX', 'iso-stem-z': 'isoStemZ', 'iso-stab-top-z': 'isoStabTopZ', 'iso-stab-bottom-z': 'isoStabBottomZ',
            'custom-height': 'customHeight', 'custom-angle': 'customAngle'
        };
        const boolMap = { 
            'enable-ribs':'enableRibs', 'homing-bump':'homingBump', 'enable-text':'enableText', 'svg-visible':'svgVisible', 
            'lock-thickness':'textThicknessLocked', 'text-conform':'textConform', 'svg-conform':'svgConform',
            'enable-text2':'enableText2', 'enable-side':'enableSide', 'model-visible':'modelVisible',
            'enable-stem-extension':'enableStemExtension', 'box-stem': 'boxStem', 'lego-stud': 'legoStud',
            'img-texture-visible': 'imgTextureVisible', 'texture-global': 'textureGlobal'
        };

        function commitHistory() { if (historyIndex < history.length - 1) history.splice(historyIndex + 1); history.push(JSON.parse(JSON.stringify(state))); historyIndex++; if (history.length > 50) { history.shift(); historyIndex--; } updateHistoryBtns(); }
        function undo() { if(historyIndex>0) { historyIndex--; state=JSON.parse(JSON.stringify(history[historyIndex])); syncUI(); updateCustomDropdown(); requestUpdate(); updateHistoryBtns(); } }
        function redo() { if(historyIndex<history.length-1) { historyIndex++; state=JSON.parse(JSON.stringify(history[historyIndex])); syncUI(); updateCustomDropdown(); requestUpdate(); updateHistoryBtns(); } }
        function updateHistoryBtns() { document.getElementById('btn-undo').disabled = historyIndex === 0; document.getElementById('btn-redo').disabled = historyIndex === history.length - 1; }
        
        function syncUI() {
            for (const [id, key] of Object.entries(paramMap)) { const el = document.getElementById(id); if(el) { el.value = state[key]; const span = document.getElementById('v-' + id); if(span) span.textContent = typeof state[key] === 'number' ? state[key].toFixed(2) : state[key]; if(id === 'tex-scale' || id === 'polygon-sides' || id === 'star-points') if(span) span.textContent = parseInt(state[key]); } }
            for (const [id, key] of Object.entries(boolMap)) { const el = document.getElementById(id); if(el) el.checked = state[key]; }
            const tHeight = document.getElementById('text-height'); if(tHeight) tHeight.disabled = state.textThicknessLocked;
            document.getElementById('stem-ext-control').style.display = state.enableStemExtension ? 'block' : 'none';
            document.getElementById('stabilizer-custom-ui').style.display = state.stabilizerType === 'custom' ? 'block' : 'none';
            document.getElementById('lego-adj-panel').style.display = state.legoStud ? 'block' : 'none';
            const customProfilePanel = document.getElementById('custom-profile-panel');
            if(customProfilePanel) customProfilePanel.style.display = state.profile === 'custom' ? 'block' : 'none';
            const shapePolygon = document.getElementById('shape-polygon-options');
            if(shapePolygon) shapePolygon.style.display = state.keyShapeType === 'polygon' ? 'block' : 'none';
            const shapeStar = document.getElementById('shape-star-options');
            if(shapeStar) shapeStar.style.display = state.keyShapeType === 'star' ? 'block' : 'none';
            const shapeIso = document.getElementById('shape-iso-options');
            if(shapeIso) shapeIso.style.display = state.keyShapeType === 'iso-enter' ? 'block' : 'none';
            const keyShapeSelect = document.getElementById('key-shape-type');
            if(keyShapeSelect) keyShapeSelect.value = state.keyShapeType;
            const colB = document.getElementById('col-body'); if(colB) colB.value = state.colBody;
            const colT = document.getElementById('col-text'); if(colT) colT.value = state.colText;
            const simpleColB = document.getElementById('simple-col-body'); if(simpleColB) simpleColB.value = state.colBody;
            const simpleColT = document.getElementById('simple-col-text'); if(simpleColT) simpleColT.value = state.colText;
            // Sync new simple mode controls
            const simpleTextMode = document.getElementById('simple-text-mode'); if(simpleTextMode) simpleTextMode.value = state.textMode;
            const simpleTaper = document.getElementById('simple-taper'); if(simpleTaper) { simpleTaper.value = state.topScale; const v = document.getElementById('v-simple-taper'); if(v) v.textContent = state.topScale.toFixed(2); }
            const simpleDish = document.getElementById('simple-dish-type'); if(simpleDish) simpleDish.value = state.dishType;
            const simpleFillet = document.getElementById('simple-fillet'); if(simpleFillet) { simpleFillet.value = state.roundCorner; const v = document.getElementById('v-simple-fillet'); if(v) v.textContent = state.roundCorner.toFixed(1); }
            const txt = document.getElementById('text-content'); if(txt) txt.value = state.text;
            const txt2 = document.getElementById('text2-content'); if(txt2) txt2.value = state.text2;
            const sideT = document.getElementById('side-text'); if(sideT) sideT.value = state.sideText;
            updateLanguageUI();
        }

        const filamentData = {
            'polymaker': { name: 'Polymaker', materials: { 'pla': { name: 'PolyLite PLA', d: 1.24, price_jp: 3800, price_us: 25 }, 'pla_matte': { name: 'PolyTerra PLA', d: 1.22, price_jp: 3800, price_us: 25 }, 'abs': { name: 'PolyLite ABS', d: 1.04, price_jp: 4000, price_us: 27 }, 'petg': { name: 'PolyLite PETG', d: 1.27, price_jp: 3800, price_us: 25 }, 'asa': { name: 'PolyLite ASA', d: 1.07, price_jp: 5500, price_us: 36 } } },
            'bambulab': { name: 'Bambu Lab', materials: { 'pla': { name: 'PLA Basic', d: 1.24, price_jp: 2240, price_us: 22 }, 'pla_matte': { name: 'PLA Matte', d: 1.22, price_jp: 2240, price_us: 22 }, 'abs': { name: 'Bambu ABS', d: 1.05, price_jp: 3300, price_us: 25 }, 'petg': { name: 'PETG Basic', d: 1.27, price_jp: 3000, price_us: 20 }, 'asa': { name: 'Bambu ASA', d: 1.07, price_jp: 4200, price_us: 30 } } },
            'elegoo': { name: 'Elegoo', materials: { 'pla': { name: 'Elegoo PLA', d: 1.24, price_jp: 2200, price_us: 14 }, 'pla_matte': { name: 'Elegoo Matte', d: 1.24, price_jp: 2800, price_us: 18 }, 'abs': { name: 'Elegoo ABS', d: 1.04, price_jp: 3000, price_us: 19 }, 'petg': { name: 'Elegoo PETG', d: 1.27, price_jp: 2400, price_us: 15 }, 'asa': null } },
            'esun': { name: 'eSun', materials: { 'pla': { name: 'PLA+', d: 1.24, price_jp: 3200, price_us: 23 }, 'pla_matte': { name: 'ePLA-Matte', d: 1.24, price_jp: 3500, price_us: 25 }, 'abs': { name: 'ABS+', d: 1.04, price_jp: 3200, price_us: 23 }, 'petg': { name: 'PETG', d: 1.27, price_jp: 3200, price_us: 23 }, 'asa': { name: 'eASA', d: 1.07, price_jp: 4000, price_us: 28 } } },
            'sunlu': { name: 'Sunlu', materials: { 'pla': { name: 'Sunlu PLA', d: 1.24, price_jp: 2500, price_us: 19 }, 'pla_matte': { name: 'Sunlu Matte', d: 1.24, price_jp: 2500, price_us: 19 }, 'abs': { name: 'Sunlu ABS', d: 1.04, price_jp: 2800, price_us: 20 }, 'petg': { name: 'Sunlu PETG', d: 1.27, price_jp: 2500, price_us: 18 }, 'asa': { name: 'Sunlu ASA', d: 1.07, price_jp: 3500, price_us: 25 } } },
            'overture': { name: 'Overture', materials: { 'pla': { name: 'Overture PLA', d: 1.24, price_jp: 2800, price_us: 19 }, 'pla_matte': { name: 'Matte PLA', d: 1.24, price_jp: 2800, price_us: 19 }, 'abs': { name: 'Overture ABS', d: 1.04, price_jp: 3000, price_us: 21 }, 'petg': { name: 'Overture PETG', d: 1.27, price_jp: 2800, price_us: 18 }, 'asa': { name: 'Overture ASA', d: 1.07, price_jp: 4500, price_us: 31 } } },
            'generic': { name: 'Generic (Manual)', materials: { 'pla': { name: 'Generic PLA', d: 1.24, price_jp: 2500, price_us: 20 }, 'pla_matte': { name: 'Generic Matte', d: 1.24, price_jp: 2500, price_us: 20 }, 'abs': { name: 'Generic ABS', d: 1.04, price_jp: 2500, price_us: 20 }, 'petg': { name: 'Generic PETG', d: 1.27, price_jp: 2500, price_us: 20 }, 'asa': { name: 'Generic ASA', d: 1.07, price_jp: 3000, price_us: 25 } } }
        };
        let selectedVendor = 'bambulab'; let selectedMaterial = 'pla';
        function initFilamentManager() {
            const vSel = document.getElementById('fil-vendor'); const mSel = document.getElementById('fil-material');
            Object.keys(filamentData).forEach(key => { const opt = document.createElement('option'); opt.value = key; opt.textContent = filamentData[key].name; vSel.appendChild(opt); });
            vSel.value = selectedVendor;
            const materials = [{id:'pla', label:'PLA'},{id:'pla_matte', label:'PLA Matte'},{id:'abs', label:'ABS'},{id:'petg', label:'PETG'},{id:'asa', label:'ASA'}];
            materials.forEach(m => { const opt = document.createElement('option'); opt.value = m.id; opt.textContent = m.label; mSel.appendChild(opt); });
            mSel.value = selectedMaterial;
            vSel.addEventListener('change', e => { selectedVendor = e.target.value; updateFilamentDisplay(); });
            mSel.addEventListener('change', e => { selectedMaterial = e.target.value; updateFilamentDisplay(); });
            const btn = document.getElementById('btn-toggle-fil'); const panel = document.getElementById('fil-details-panel');
            btn.addEventListener('click', () => { panel.classList.toggle('open'); });
            ['fil-price','fil-capacity','fil-density'].forEach(id => { document.getElementById(id).addEventListener('input', calculateStats); });
            updateFilamentDisplay();
        }
        function updateFilamentDisplay() {
            const data = filamentData[selectedVendor].materials[selectedMaterial];
            const nameEl = document.getElementById('info-fil-name'); const priceIn = document.getElementById('fil-price'); const denIn = document.getElementById('fil-density'); const currEl = document.getElementById('info-currency');
            const isJP = currentLang === 'ja'; currEl.textContent = isJP ? '¬•' : '$';
            if (!data) { nameEl.textContent = "N/A"; priceIn.value = ""; denIn.value = ""; calculateStats(); return; }
            nameEl.textContent = data.name; priceIn.value = isJP ? data.price_jp : data.price_us; denIn.value = data.d; document.getElementById('fil-capacity').value = 1000; calculateStats();
        }
        function calculateStats() {
            const price = parseFloat(document.getElementById('fil-price').value); const capacity = parseFloat(document.getElementById('fil-capacity').value); const density = parseFloat(document.getElementById('fil-density').value);
            const wEl = document.getElementById('info-weight'); const cEl = document.getElementById('info-cost');
            if (isNaN(price) || isNaN(capacity) || isNaN(density) || capacity <= 0) { wEl.textContent = "--"; cEl.textContent = "--"; return; }
            const p = getParams(); const baseVol = p.baseW * p.baseD * p.h; let fillFactor = 0.22 + (state.wallThickness - 1.5) * 0.1; if(state.boxStem) fillFactor += 0.05;
            const volCm3 = (baseVol * fillFactor) / 1000; const weight = volCm3 * density; const totalCost = weight * (price / capacity);
            wEl.textContent = weight.toFixed(2); cEl.textContent = (currentLang === 'ja') ? Math.ceil(totalCost) : totalCost.toFixed(2);
        }
        function randomizeParams() {
            state.uSize = 1.0; state.profile = ['cherry','oem','sa','xda','dsa'][Math.floor(Math.random()*5)];
            state.topScale = 0.6 + Math.random() * 0.4; state.dishType = ['cylindrical','spherical','flat'][Math.floor(Math.random()*3)];
            state.textureType = ['none','noise','grid','knurling','stripes','ripple','wood','hammered','hexagon','bricks'][Math.floor(Math.random()*10)];
            state.textureScale = 10 + Math.random() * 80; state.twist = Math.floor(Math.random() * 60) - 30; state.tiltX = Math.floor(Math.random() * 20) - 10;
            state.colBody = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'); state.colText = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            syncUI(); updateModel();
        }
        function resetParams() { if(confirm("Reset all parameters?")) { state = JSON.parse(JSON.stringify(initialState)); syncUI(); updateModel(); } }

        let committedFont = state.font;
        let customDropdownInitialized = false;
        function setupCustomDropdown() {
            const head = document.getElementById('custom-font-head'); const list = document.getElementById('custom-font-list'); const hiddenSelect = document.getElementById('font-family');
            if(!head || !list || !hiddenSelect) return;
            function populate() {
                list.innerHTML = ''; Array.from(hiddenSelect.options).forEach(opt => {
                    if(!loadedFonts[opt.value]) return;
                    const div = document.createElement('div'); div.className = 'custom-option'; div.textContent = opt.text; if(opt.value === state.font) div.classList.add('selected');
                    div.addEventListener('mouseenter', () => { state.font = opt.value; requestUpdate(); });
                    div.addEventListener('click', () => { committedFont = opt.value; state.font = committedFont; hiddenSelect.value = committedFont; list.classList.remove('open'); updateCustomDropdownHead(); commitHistory(); requestUpdate(); });
                    list.appendChild(div);
                });
            }
            if(!customDropdownInitialized) {
                head.addEventListener('click', () => { if(!list.classList.contains('open')) { committedFont = state.font; populate(); list.classList.add('open'); } else { list.classList.remove('open'); } });
                list.addEventListener('mouseleave', () => { state.font = committedFont; requestUpdate(); });
                document.addEventListener('click', (e) => { const ui = document.getElementById('custom-font-ui'); if(ui && !ui.contains(e.target) && list.classList.contains('open')) { list.classList.remove('open'); state.font = committedFont; requestUpdate(); } });
                customDropdownInitialized = true;
            }
            updateCustomDropdownHead();
        }
        function updateCustomDropdown() { committedFont = state.font; updateCustomDropdownHead(); }
        function updateCustomDropdownHead() { const hiddenSelect = document.getElementById('font-family'); const head = document.getElementById('custom-font-head'); if(hiddenSelect && head) { const opt = hiddenSelect.querySelector(`option[value="${state.font}"]`); if(opt) head.textContent = opt.text + " ‚ñº"; } }

        function initNavigation() {
            const select = document.getElementById('section-select'); select.addEventListener('change', (e) => { const id = e.target.value; if(id) { const el = document.getElementById(id); if(el) { el.scrollIntoView({ behavior: 'smooth' }); el.style.color = '#fff'; setTimeout(() => el.style.color = '', 1000); } select.value = ""; } });
            const search = document.getElementById('search-box'); search.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase(); const labels = document.querySelectorAll('#ui-panel label, #ui-panel h3'); document.querySelectorAll('.search-highlight').forEach(el => el.classList.remove('search-highlight'));
                if(!query) return; let firstMatch = null; labels.forEach(lbl => { const text = lbl.textContent.toLowerCase(); if(text.includes(query)) { lbl.classList.add('search-highlight'); if(!firstMatch) firstMatch = lbl; } });
                if(firstMatch) firstMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
        }
        
        const PROFILES = { cherry: { R4: {h:11.5, a:6}, R3: {h:9.5, a:3}, R2: {h:8.5, a:-3}, R1: {h:9.5, a:-6}, dish:'cylindrical' }, oem: { R4: {h:12.5, a:8}, R3: {h:11.0, a:4}, R2: {h:10.0, a:-4}, R1: {h:11.0, a:-8}, dish:'cylindrical' }, sa: { R4: {h:16.5, a:7}, R3: {h:14.0, a:0}, R2: {h:14.0, a:0}, R1: {h:14.0, a:-7}, dish:'spherical' }, xda: { all:{h:9.0, a:0}, dish:'spherical' }, dsa: { all:{h:7.5, a:0}, dish:'spherical' }, custom: { all:{h:9.5, a:3}, dish:'cylindrical' } };
        const HTML_COLORS = ['#000000','#333333','#666666','#ffffff','#ff0000','#ff8000','#ffff00','#00ff00','#00ffff','#0000ff','#8000ff','#ff00ff','#800000','#008000','#000080','#808000'];
        const container = document.getElementById('canvas-container'); const scene = new THREE.Scene(); scene.background = new THREE.Color(0x121212);
        const camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 1000); camera.position.set(20, 30, 30);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(container.clientWidth, container.clientHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.autoClear = false; container.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; const viewHelper = new ViewHelper(camera, renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 0.4)); const dl = new THREE.DirectionalLight(0xffffff, 1.0); dl.position.set(10,50,20); dl.castShadow=true; scene.add(dl); const bl = new THREE.DirectionalLight(0x00bcd4, 0.5); bl.position.set(0,-20,0); scene.add(bl); scene.add(new THREE.GridHelper(200, 200, 0x444444, 0x222222));
        const mainGroup = new THREE.Group(); scene.add(mainGroup); const fontLoader = new FontLoader(); const loadedFonts = {}; const textureLoader = new THREE.TextureLoader();

        function getParams() { 
            const p = PROFILES[state.profile]; 
            let r;
            if (state.profile === 'custom') {
                r = { h: state.customHeight, a: state.customAngle };
            } else {
                r = p.all ? p.all : p[state.row]; 
            }
            const unit = parseFloat(state.unitSize) || 19.05;
            
            if(state.keyShapeType === 'iso-enter') {
                const fullW = (unit * state.isoTopWidth) - 0.5;
                const totalH = (unit * state.isoHeight) - 0.5;
                return { h: r.h, angle: 0, baseW: fullW, baseD: totalH };
            }
            
            return { h: r.h, angle: r.a, baseW: (unit * state.uSize) - 0.5, baseD: unit - 0.5 }; 
        }
        function getStabilizerOffset(u) { if (state.stabilizerType === 'custom') return state.stabilizerOffset; if (u < 2.0) return 0; if (u < 3.0) return 11.9; if (u < 6.0) return 19.05; if (u == 6.25) return 50.0; if (u >= 7.0) return 57.15; return 38.1; }
        const DISH_DEPTH = 0.8; 
        function getDishOffset(x, z, p) { const wHalf = p.baseW * state.topScale * 0.5; const dHalf = p.baseD * state.topScale * 0.5; const nx = x / (wHalf || 1); const nz = z / (dHalf || 1); let offset = 0; const type = state.dishType; if(type === 'flat') offset = 0; else if(type === 'cylindrical') { if(Math.abs(nx) < 2.0) offset = DISH_DEPTH * (Math.pow(nx, 2) - 1.0); } else { const dist = Math.sqrt(nx*nx + nz*nz); if(dist < 2.0) offset = DISH_DEPTH * (Math.pow(dist, 2) - 1.0); } return offset; }
        function getSurfaceHeight(x, z, p) { 
            if(state.keyShapeType === 'iso-enter') {
                return p.h;
            }
            const tiltXRad = THREE.MathUtils.degToRad(state.tiltX); 
            const tiltZRad = THREE.MathUtils.degToRad(state.tiltZ); 
            const baseTilt = Math.tan(THREE.MathUtils.degToRad(p.angle)) * z; 
            const customTilt = (Math.tan(tiltXRad) * z) + (Math.tan(tiltZRad) * x); 
            return (p.h - baseTilt - customTilt) + getDishOffset(x, z, p); 
        }
        
        function safeMerge(geometries) { const clean = []; geometries.forEach(g => { if(g) { if(g.index) g = g.toNonIndexed(); clean.push(g); } }); if(clean.length === 0) return null; return BufferGeometryUtils.mergeGeometries(clean, false); }
        
        function csgUnion(geometries) {
            const valid = geometries.filter(g => g !== null && g !== undefined);
            if (valid.length === 0) return null;
            if (valid.length === 1) {
                let geo = valid[0].clone();
                if (geo.index) geo = geo.toNonIndexed();
                geo = BufferGeometryUtils.mergeVertices(geo, 0.001);
                geo.computeVertexNormals();
                return geo;
            }
            
            try {
                let resultBrush = new Brush(valid[0]);
                resultBrush.updateMatrixWorld();
                
                for (let i = 1; i < valid.length; i++) {
                    const brush = new Brush(valid[i]);
                    brush.updateMatrixWorld();
                    const result = csgEvaluator.evaluate(resultBrush, brush, ADDITION);
                    resultBrush = result;
                }
                
                let finalGeo = resultBrush.geometry;
                finalGeo = BufferGeometryUtils.mergeVertices(finalGeo, 0.001);
                finalGeo.computeVertexNormals();
                return finalGeo;
            } catch (e) {
                console.warn("CSG Union failed, falling back to safeMerge:", e);
                return safeMerge(geometries);
            }
        }
        
        function applySquircle(x, z, w, d, r) { 
            if (r <= 0.01) return {x, z}; 
            
            const halfW = w / 2;
            const halfD = d / 2;
            const innerW = halfW - r; 
            const innerD = halfD - r; 
            const absX = Math.abs(x); 
            const absZ = Math.abs(z);
            
            if (absX > innerW && absZ > innerD) { 
                const dx = absX - innerW; 
                const dz = absZ - innerD; 
                const dist = Math.sqrt(dx*dx + dz*dz); 
                if (dist > 0) { 
                    const clampedDist = Math.min(dist, r);
                    const newX = innerW + (dx / dist) * clampedDist; 
                    const newZ = innerD + (dz / dist) * clampedDist; 
                    return { x: Math.sign(x) * newX, z: Math.sign(z) * newZ }; 
                } 
            }
            else if (absX > innerW) {
                const edgeDist = absZ / innerD;
                if (edgeDist > 0.9) {
                    const blend = (edgeDist - 0.9) / 0.1;
                    const maxX = halfW - (1 - Math.sqrt(1 - blend*blend)) * r * 0.1;
                    if (absX > maxX) {
                        return { x: Math.sign(x) * maxX, z };
                    }
                }
            }
            else if (absZ > innerD) {
                const edgeDist = absX / innerW;
                if (edgeDist > 0.9) {
                    const blend = (edgeDist - 0.9) / 0.1;
                    const maxZ = halfD - (1 - Math.sqrt(1 - blend*blend)) * r * 0.1;
                    if (absZ > maxZ) {
                        return { x, z: Math.sign(z) * maxZ };
                    }
                }
            }
            
            return {x, z}; 
        }
        
        function createKeyShape(p, isInner = false, wallThick = 0) {
            const shape = new THREE.Shape();
            const w = p.baseW, d = p.baseD, hw = w / 2, hd = d / 2;
            const offset = isInner ? wallThick : 0;
            
            switch(state.keyShapeType) {
                case 'circle':
                    const r = Math.min(hw, hd) - offset;
                    if(r > 0) shape.absarc(0, 0, r, 0, Math.PI * 2, false);
                    return shape;
                    
                case 'polygon':
                    const sides = state.polygonSides;
                    const pr = Math.min(hw, hd) - offset;
                    if(pr > 0) {
                        for(let i = 0; i < sides; i++) {
                            const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                            const px = Math.cos(angle) * pr;
                            const py = Math.sin(angle) * pr;
                            if(i === 0) shape.moveTo(px, py);
                            else shape.lineTo(px, py);
                        }
                        shape.closePath();
                    }
                    return shape;
                    
                case 'star':
                    const points = state.starPoints;
                    const outer = Math.min(hw, hd) - offset;
                    const inner = outer * state.starInner;
                    if(outer > 0) {
                        for(let i = 0; i < points * 2; i++) {
                            const angle = (i / (points * 2)) * Math.PI * 2 - Math.PI / 2;
                            const rad = i % 2 === 0 ? outer : inner;
                            const sx = Math.cos(angle) * rad;
                            const sy = Math.sin(angle) * rad;
                            if(i === 0) shape.moveTo(sx, sy);
                            else shape.lineTo(sx, sy);
                        }
                        shape.closePath();
                    }
                    return shape;
                    
                case 'iso-enter':
                    const unit = parseFloat(state.unitSize) || 19.05;
                    const isoFullW = (unit * state.isoTopWidth) - 0.5;
                    const isoNarrowW = (unit * state.isoBottomWidth) - 0.5;
                    const isoTotalH = (unit * state.isoHeight) - 0.5;
                    
                    const ihw = isoFullW / 2;
                    const ihh = isoTotalH / 2;
                    
                    const cornerY = ihh - (unit - 0.5);
                    const cornerX = ihw - isoNarrowW;

                    if (!isInner) {
                        shape.moveTo(-ihw, ihh);
                        shape.lineTo(-ihw, cornerY);
                        shape.lineTo(cornerX, cornerY);
                        shape.lineTo(cornerX, -ihh);
                        shape.lineTo(ihw, -ihh);
                        shape.lineTo(ihw, ihh);
                        shape.closePath();
                    } else {
                        const t = wallThick;
                        
                        const inLeft = -ihw + t;
                        const inRight = ihw - t;
                        const inTop = ihh - t;
                        const inBottom = -ihh + t;
                        
                        const inCornerX = cornerX + t;
                        const inCornerY = cornerY + t;

                        shape.moveTo(inLeft, inTop);
                        shape.lineTo(inRight, inTop);
                        shape.lineTo(inRight, inBottom);
                        shape.lineTo(inCornerX, inBottom);
                        shape.lineTo(inCornerX, inCornerY);
                        shape.lineTo(inLeft, inCornerY);
                        shape.closePath();
                    }
                    return shape;
                    
                case 'rounded':
                    const hwi = hw - offset;
                    const hdi = hd - offset;
                    const rad = Math.min(state.roundCorner, Math.min(hwi, hdi) * 0.5);
                    if(hwi > 0 && hdi > 0) {
                        if(rad > 0.1) {
                            shape.moveTo(-hwi + rad, -hdi);
                            shape.lineTo(hwi - rad, -hdi);
                            shape.quadraticCurveTo(hwi, -hdi, hwi, -hdi + rad);
                            shape.lineTo(hwi, hdi - rad);
                            shape.quadraticCurveTo(hwi, hdi, hwi - rad, hdi);
                            shape.lineTo(-hwi + rad, hdi);
                            shape.quadraticCurveTo(-hwi, hdi, -hwi, hdi - rad);
                            shape.lineTo(-hwi, -hdi + rad);
                            shape.quadraticCurveTo(-hwi, -hdi, -hwi + rad, -hdi);
                        } else {
                            shape.moveTo(-hwi, -hdi);
                            shape.lineTo(hwi, -hdi);
                            shape.lineTo(hwi, hdi);
                            shape.lineTo(-hwi, hdi);
                            shape.closePath();
                        }
                    }
                    return shape;
                    
                default:
                    const hwj = hw - offset;
                    const hdj = hd - offset;
                    if(hwj > 0 && hdj > 0) {
                        shape.moveTo(-hwj, -hdj);
                        shape.lineTo(hwj, -hdj);
                        shape.lineTo(hwj, hdj);
                        shape.lineTo(-hwj, hdj);
                        shape.closePath();
                    }
                    return shape;
            }
        }

        function createBodyParts(p, useCSG = false) {
            const thick = state.wallThickness; 
            const segXZ = 32;  
            const segY = 32;   
            
            const isNonRectangular = state.keyShapeType === 'circle' || 
                                     state.keyShapeType === 'polygon' || 
                                     state.keyShapeType === 'star' ||
                                     state.keyShapeType === 'iso-enter' ||
                                     (state.keyShapeType === 'rounded' && state.roundCorner > 0.1);
            
            if(isNonRectangular) {
                const outerShape = createKeyShape(p, false, 0);
                const innerShape = createKeyShape(p, true, thick);
                
                let solidGeo = new THREE.ExtrudeGeometry(outerShape, {
                    depth: p.h,
                    bevelEnabled: false,
                    curveSegments: 48
                });
                solidGeo.rotateX(-Math.PI / 2);
                
                let holeGeo = new THREE.ExtrudeGeometry(innerShape, {
                    depth: p.h - thick + 0.1,
                    bevelEnabled: false,
                    curveSegments: 48
                });
                holeGeo.rotateX(-Math.PI / 2);
                holeGeo.translate(0, -0.05, 0);
                
                let resultGeo;
                try {
                    const solidBrush = new Brush(solidGeo);
                    solidBrush.updateMatrixWorld();
                    const holeBrush = new Brush(holeGeo);
                    holeBrush.updateMatrixWorld();
                    const result = csgEvaluator.evaluate(solidBrush, holeBrush, SUBTRACTION);
                    resultGeo = result.geometry;
                    resultGeo = BufferGeometryUtils.mergeVertices(resultGeo, 0.001);
                } catch(e) {
                    console.warn("CSG failed, using merge method:", e);
                    outerShape.holes.push(innerShape);
                    const wallH = p.h - thick;
                    let wallGeo = new THREE.ExtrudeGeometry(outerShape, {
                        depth: wallH,
                        bevelEnabled: false,
                        curveSegments: 48
                    });
                    wallGeo.rotateX(-Math.PI / 2);
                    
                    const capShape = createKeyShape(p, false, 0);
                    let topGeo = new THREE.ExtrudeGeometry(capShape, {
                        depth: thick,
                        bevelEnabled: false,
                        curveSegments: 48
                    });
                    topGeo.rotateX(-Math.PI / 2);
                    topGeo.translate(0, wallH, 0);
                    
                    resultGeo = safeMerge([wallGeo, topGeo]);
                }
                
                if(resultGeo && !useCSG) {
                    deformMesh(resultGeo, p);
                }
                return resultGeo;
            }
            
            const topBox = new THREE.BoxGeometry(p.baseW, thick, p.baseD, segXZ, 2, segXZ); 
            topBox.translate(0, p.h - thick/2, 0);
            
            const wH = p.h - thick;
            
            const front = new THREE.BoxGeometry(p.baseW, wH, thick, segXZ, segY, 2); 
            front.translate(0, wH/2, p.baseD/2 - thick/2);
            
            const back = new THREE.BoxGeometry(p.baseW, wH, thick, segXZ, segY, 2); 
            back.translate(0, wH/2, -(p.baseD/2 - thick/2));
            
            const sideDepth = p.baseD - thick * 2;
            const left = new THREE.BoxGeometry(thick, wH, sideDepth, 2, segY, segXZ); 
            left.translate(-(p.baseW/2 - thick/2), wH/2, 0);
            
            const right = new THREE.BoxGeometry(thick, wH, sideDepth, 2, segY, segXZ); 
            right.translate((p.baseW/2 - thick/2), wH/2, 0);
            
            let resultGeo = safeMerge([topBox, front, back, left, right]);
            
            if(resultGeo && !useCSG) deformMesh(resultGeo, p); 
            return resultGeo;
        }

        function deformMesh(geo, p) {
            const pos = geo.attributes.position; const v = new THREE.Vector3(); const thick = state.wallThickness; geo.computeBoundingBox(); const uvs = geo.attributes.uv;
            const useImageTexture = state.imgContent && state.imgTextureVisible; const useProcedural = state.textureType !== 'none';
            const texScale = state.textureScale * 0.1; const texStr = state.textureStrength; const twistRad = THREE.MathUtils.degToRad(state.twist); const twistPerUnit = twistRad / p.h; const filletR = state.roundCorner; const hasFillet = filletR > 0.05;
            
            const wallTopY = p.h - thick;
            
            for(let i=0; i<pos.count; i++){
                v.fromBufferAttribute(pos, i);
                
                if (Math.abs(state.twist) > 0.1 && state.keyShapeType !== 'iso-enter') { 
                    const angle = twistPerUnit * v.y; 
                    const sinA = Math.sin(angle); const cosA = Math.cos(angle); 
                    const tx = v.x * cosA - v.z * sinA; 
                    const tz = v.x * sinA + v.z * cosA; 
                    v.x = tx; v.z = tz; 
                }
                
                const ratioY = Math.max(0, Math.min(1, v.y / p.h));
                
                const currentScale = THREE.MathUtils.lerp(1.0, state.topScale, ratioY);
                
                if (Math.abs(currentScale - 1.0) > 0.0001) { 
                    v.x *= currentScale; 
                    v.z *= currentScale; 
                }
                
                if (hasFillet && state.keyShapeType === 'rectangle') { 
                    const currentW = p.baseW * currentScale; 
                    const currentD = p.baseD * currentScale; 
                    const scaledR = filletR * currentScale; 
                    const deformed = applySquircle(v.x, v.z, currentW, currentD, scaledR); 
                    v.x = deformed.x; 
                    v.z = deformed.z; 
                }
                
                if (v.y > 0.01 && state.keyShapeType !== 'iso-enter') {
                    const surfY = getSurfaceHeight(v.x, v.z, p);
                    const origY = v.y;
                    
                    if (origY >= wallTopY) {
                        const topRatio = (origY - wallTopY) / thick;
                        v.y = THREE.MathUtils.lerp(surfY - thick, surfY, Math.min(1, topRatio));
                    } else {
                        const wallRatio = origY / wallTopY;
                        const targetTopY = surfY - thick;
                        v.y = wallRatio * targetTopY;
                    }
                }
                
                if (useProcedural && ratioY > 0.01) {
                    const isTop = ratioY > 0.95 && v.y > wallTopY;
                    if (state.textureGlobal || isTop) {
                        let noiseVal = 0; const type = state.textureType;
                        let mapX = v.x * texScale; let mapZ = v.z * texScale; let mapY = v.y * texScale;
                        if (!isTop && !state.textureGlobal) mapY = Math.atan2(v.z, v.x) * 10; 
                        if (type === 'noise') noiseVal = SimpleNoise.noise(mapX, isTop?mapZ:mapY);
                        else if (type === 'grid') noiseVal = Math.sin(mapX) * Math.sin(isTop?mapZ:mapY);
                        else if (type === 'knurling') noiseVal = Math.sin((mapX + (isTop?mapZ:mapY))) * Math.sin((mapX - (isTop?mapZ:mapY)));
                        else if (type === 'stripes') noiseVal = Math.sin(mapX);
                        else if (type === 'ripple') { const dist = Math.sqrt(mapX*mapX + (isTop?mapZ:mapY)*(isTop?mapZ:mapY)); noiseVal = Math.sin(dist); }
                        else if (type === 'wood') { noiseVal = Math.sin(mapX * 2 + SimpleNoise.noise(mapX, isTop?mapZ:mapY) * 3); }
                        else if (type === 'hammered') { noiseVal = 1.0 - Math.abs(SimpleNoise.noise(mapX*0.5, isTop?mapZ*0.5:mapY*0.5)); }
                        else if (type === 'hexagon') { const u = mapX * 1.5; const vC = (isTop?mapZ:mapY) * 1.5; noiseVal = Math.max(Math.abs(Math.sin(u)*Math.cos(vC)), Math.abs(Math.cos(u)*Math.sin(vC))); }
                        else if (type === 'bricks') { const bx = Math.floor(mapX); const by = Math.floor(isTop?mapZ:mapY); const off = (by % 2) * 0.5; noiseVal = (mapX + off) - Math.floor(mapX + off) > 0.1 && (isTop?mapZ:mapY) - by > 0.1 ? 1 : 0; }
                        if (isTop) v.y += noiseVal * texStr;
                        else if (ratioY > 0.1 && state.textureGlobal) { const norm = new THREE.Vector3(v.x, 0, v.z).normalize(); v.x += norm.x * noiseVal * texStr; v.z += norm.z * noiseVal * texStr; }
                    }
                }
                
                pos.setXYZ(i, v.x, v.y, v.z);
                if (useImageTexture && uvs) { const cosR = Math.cos(THREE.MathUtils.degToRad(-state.imgRot)); const sinR = Math.sin(THREE.MathUtils.degToRad(-state.imgRot)); let ux = v.x; let uz = v.z; const rx = ux * cosR - uz * sinR; const rz = ux * sinR + uz * cosR; const mapSize = 19.05 * state.uSize; let u = (rx / mapSize) + 0.5; let v_uv = (rz / mapSize) + 0.5; u = (u - 0.5) / state.imgScale + 0.5 - state.imgPosX; v_uv = (v_uv - 0.5) / state.imgScale + 0.5 - state.imgPosY; uvs.setXY(i, u, v_uv); }
            }
            geo.computeVertexNormals();
        }

        function createStemUnit(height, rOuter, clear) { const shape = new THREE.Shape(); shape.absarc(0,0, rOuter, 0, Math.PI*2); const w = (1.15 + clear)/2; const l = (4.1 + clear)/2; const hole = new THREE.Path(); hole.moveTo(-w,-l); hole.lineTo(w,-l); hole.lineTo(w,-w); hole.lineTo(l,-w); hole.lineTo(l,w); hole.lineTo(w,w); hole.lineTo(w,l); hole.lineTo(-w,l); hole.lineTo(-w,w); hole.lineTo(-l,w); hole.lineTo(-l,-w); hole.lineTo(-w,-w); hole.lineTo(-w,-l); shape.holes.push(hole); const geo = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled:false, curveSegments:24 }); geo.rotateX(Math.PI/2); geo.translate(0, height, 0); return geo; }

        function createStemAndRibs(p, useCSG = false) {
            const thick = state.wallThickness; 
            const rawH = p.h; 
            const clear = state.stemClearance; 
            const ext = state.enableStemExtension ? state.stemExtension : 0.0; 
            const totalStemH = rawH + ext; 
            const rOuter = state.stemDiameter / 2;
            const stemGeos = []; 
            
            if(state.keyShapeType === 'iso-enter') {
                const isoStemH = (rawH - thick) + ext;
                
                const stemX = state.isoStemX;
                const switchZ = state.isoStemZ;
                const stabTopZ = state.isoStabTopZ;
                const stabBottomZ = state.isoStabBottomZ;
                
                const mainStem = createStemUnit(isoStemH, rOuter, clear);
                if(ext > 0) mainStem.translate(0, -ext, 0);
                mainStem.translate(stemX, 0, switchZ); 
                stemGeos.push(mainStem);
                
                const stabTop = createStemUnit(isoStemH, rOuter, clear);
                if(ext > 0) stabTop.translate(0, -ext, 0);
                stabTop.translate(stemX, 0, stabTopZ);
                stemGeos.push(stabTop);

                const stabBottom = createStemUnit(isoStemH, rOuter, clear);
                if(ext > 0) stabBottom.translate(0, -ext, 0);
                stabBottom.translate(stemX, 0, stabBottomZ);
                stemGeos.push(stabBottom);

            } else {
                const cStem = createStemUnit(totalStemH, rOuter, clear); 
                if (ext > 0) cStem.translate(0, -ext, 0);
                if (state.boxStem) { 
                    const boxSize = 5.6 + clear; const boxH = totalStemH * 0.8; const wWall = 0.8; const bS = boxSize + wWall*2; 
                    const front = new THREE.BoxGeometry(bS, boxH, wWall); front.translate(0, boxH/2-ext, boxSize/2+wWall/2); 
                    const back = new THREE.BoxGeometry(bS, boxH, wWall); back.translate(0, boxH/2-ext, -(boxSize/2+wWall/2)); 
                    const left = new THREE.BoxGeometry(wWall, boxH, boxSize); left.translate(-(boxSize/2+wWall/2), boxH/2-ext, 0); 
                    const right = new THREE.BoxGeometry(wWall, boxH, boxSize); right.translate(boxSize/2+wWall/2, boxH/2-ext, 0); 
                    stemGeos.push(front, back, left, right); 
                }
                stemGeos.push(cStem);

                const stabOffset = getStabilizerOffset(state.uSize);
                if(stabOffset > 0) { 
                    const sL = createStemUnit(totalStemH, rOuter, clear); if(ext > 0) sL.translate(0, -ext, 0); sL.translate(-stabOffset, 0, 0); 
                    const sR = createStemUnit(totalStemH, rOuter, clear); if(ext > 0) sR.translate(0, -ext, 0); sR.translate(stabOffset, 0, 0); 
                    stemGeos.push(sL, sR); 
                }
            }
            
            const ribGeos = [];
            
            const isNonRectangularNoRib = state.keyShapeType === 'circle' || 
                                          state.keyShapeType === 'polygon' || 
                                          state.keyShapeType === 'star' ||
                                          state.keyShapeType === 'iso-enter' ||
                                          (state.keyShapeType === 'rounded' && state.roundCorner > 0.1);

            if(state.enableRibs && !state.boxStem && !isNonRectangularNoRib) {
                const shorten = state.ribShorten; 
                const ribH = rawH - shorten; 
                const ribY = shorten; 
                const ribThick = 1.2;
                const overlap = useCSG ? 0.8 : 0.4;
                
                if(ribH > 0.1) {
                    const endX = (p.baseW/2)-thick+0.5; const lx = (endX + overlap) - (rOuter - overlap); 
                    if(lx>0) { 
                        const rX = new THREE.BoxGeometry(lx, ribH, ribThick); const cx = (rOuter - overlap) + lx/2; 
                        const r1 = rX.clone(); r1.translate(cx, ribY+ribH/2, 0); 
                        const r2 = rX.clone(); r2.translate(-cx, ribY+ribH/2, 0); 
                        ribGeos.push(r1, r2); 
                    }
                    const endZ = (p.baseD/2)-thick+0.5; const lz = (endZ + overlap) - (rOuter - overlap); 
                    if(lz>0) { 
                        const rZ = new THREE.BoxGeometry(ribThick, ribH, lz); const cz = (rOuter - overlap) + lz/2; 
                        const r3 = rZ.clone(); r3.translate(0, ribY+ribH/2, cz); 
                        const r4 = rZ.clone(); r4.translate(0, ribY+ribH/2, -cz); 
                        ribGeos.push(r3, r4); 
                    }
                }
            }
            
            let merged;
            if (useCSG) {
                merged = csgUnion([...stemGeos, ...ribGeos]);
                if (merged) {
                    merged = BufferGeometryUtils.mergeVertices(merged, 0.0001);
                    merged.computeVertexNormals();
                }
                return merged;
            } else {
                merged = safeMerge([...stemGeos, ...ribGeos]);
            }
            
            if(merged && !useCSG) { 
                const pos = merged.attributes.position; 
                const v = new THREE.Vector3(); 
                merged.computeBoundingBox(); 
                const maxY = merged.boundingBox.max.y; 
                const twistRad = THREE.MathUtils.degToRad(state.twist); 
                const twistPerUnit = twistRad / p.h; 
                
                for(let i=0; i<pos.count; i++){ 
                    v.fromBufferAttribute(pos, i); 
                    
                    if (Math.abs(state.twist) > 0.1 && state.keyShapeType !== 'iso-enter') { 
                        const angle = twistPerUnit * v.y; 
                        const sinA = Math.sin(angle); 
                        const cosA = Math.cos(angle); 
                        const tx = v.x * cosA - v.z * sinA; 
                        const tz = v.x * sinA + v.z * cosA; 
                        v.x = tx; 
                        v.z = tz; 
                    } 
                    
                    const ratioY = Math.max(0, v.y / p.h); 
                    const dist = Math.sqrt(v.x*v.x + v.z*v.z); 
                    
                    if(dist > rOuter + 0.5) { 
                        const taper = THREE.MathUtils.lerp(1.0, state.topScale, ratioY); 
                        v.x *= taper; 
                        v.z *= taper; 
                    } 
                    
                    if(state.keyShapeType !== 'iso-enter' && v.y > maxY - 1.0) { 
                        const sy = getSurfaceHeight(v.x, v.z, p); 
                        v.y = sy - thick; 
                    } 
                    
                    pos.setXYZ(i, v.x, v.y, v.z); 
                } 
                merged.computeVertexNormals(); 
            }
            return merged;
        }

        function createHomingBump(p) { if (state.legoStud) { const r = 2.4 + (state.legoClear || 0); const stud = new THREE.CylinderGeometry(r, r, 1.8, 24); const bx = state.legoX; const bz = state.legoZ; const y = getSurfaceHeight(bx, bz, p); stud.translate(bx, y + 0.9 + state.legoY, bz); stud.rotateX(THREE.MathUtils.degToRad(p.angle)); return stud; } if(!state.homingBump) return null; const bx = state.bumpX; const bz = state.bumpZ; const y = getSurfaceHeight(bx, bz, p); let geo; if(state.homingType === 'round') { geo = new THREE.SphereGeometry(0.6, 12, 12); geo.scale(1, 0.6, 1); } else { geo = new THREE.BoxGeometry(4.0, 0.5, 0.8); } geo.translate(bx, y + state.bumpOffsetY, bz); geo.rotateX(THREE.MathUtils.degToRad(p.angle)); if (Math.abs(state.twist) > 0.1) { const twistRad = THREE.MathUtils.degToRad(state.twist); const angle = (twistRad / p.h) * y; geo.rotateY(-angle); } return geo; }

        function createConformedText(p, textVal, sizeVal, xVal, zVal, mode) {
            if (!loadedFonts[state.font] || !textVal) return null;
            
            let genHeight = state.textHeight;
            let yEmbedOffset = 0;

            if (mode === 'engrave') {
                genHeight = state.textHeight + 5.0;
                yEmbedOffset = -state.textHeight;
            } else if (mode === 'doubleshot') {
                genHeight = state.wallThickness + 0.5;
                yEmbedOffset = -genHeight + 0.02;
            } else if (mode === 'lithophane') {
                const thinLayer = 0.3;
                genHeight = state.wallThickness - thinLayer + 0.5;
                yEmbedOffset = -(state.wallThickness - thinLayer);
            }
            
            yEmbedOffset += state.textOffsetY;

            const lines = textVal.split('\n'); 
            const font = loadedFonts[state.font]; 
            const size = sizeVal; 
            const lineHeight = size * 1.2; 
            const lineGeos = [];
            
            lines.forEach((lineText, i) => { 
                if(!lineText) return; 
                const geo = new TextGeometry(lineText, { font: font, size: size, height: genHeight, curveSegments: 6, bevelEnabled: false }); 
                geo.computeBoundingBox(); 
                const cx = -0.5 * (geo.boundingBox.max.x + geo.boundingBox.min.x); 
                const cy = -0.5 * (geo.boundingBox.max.y + geo.boundingBox.min.y); 
                geo.translate(cx, cy, 0); 
                lineGeos.push({ geo: geo, index: i }); 
            });
            
            const mergedLines = []; 
            const blockYOffset = (lines.length - 1) * lineHeight / 2;
            lineGeos.forEach(item => { 
                const yPos = blockYOffset - (item.index * lineHeight); 
                item.geo.translate(0, yPos, 0); 
                mergedLines.push(item.geo); 
            });
            
            if(mergedLines.length === 0) return null; 
            const combinedGeo = BufferGeometryUtils.mergeGeometries(mergedLines);
            
            if (!state.textConform) {
                combinedGeo.rotateX(-Math.PI/2);
                const sy = getSurfaceHeight(xVal, zVal, p);
                combinedGeo.translate(xVal, sy + yEmbedOffset, zVal);
                combinedGeo.rotateX(THREE.MathUtils.degToRad(p.angle));
                return combinedGeo;
            } else {
                const pos = combinedGeo.attributes.position; 
                const v = new THREE.Vector3();
                const twistRad = THREE.MathUtils.degToRad(state.twist); 
                const twistPerUnit = twistRad / p.h;
                
                for(let i=0; i<pos.count; i++) {
                    v.fromBufferAttribute(pos, i);
                    const targetX = v.x + xVal;
                    const targetZ = -v.y + zVal;
                    const thicknessOffset = v.z;
                    const surfY = getSurfaceHeight(targetX, targetZ, p);
                    let finalX = targetX; 
                    let finalZ = targetZ;
                    if (Math.abs(state.twist) > 0.1) {
                        const angle = twistPerUnit * surfY;
                        const sinA = Math.sin(angle); 
                        const cosA = Math.cos(angle);
                        finalX = targetX * cosA - targetZ * sinA;
                        finalZ = targetX * sinA + targetZ * cosA;
                    }
                    pos.setXYZ(i, finalX, surfY + thicknessOffset + yEmbedOffset, finalZ);
                }
                combinedGeo.computeVertexNormals();
                return combinedGeo;
            }
        }

        function createSidePrint(p, mode) { 
            if (!state.enableSide || !state.sideText || !loadedFonts[state.font]) return null; 
            const geo = new TextGeometry(state.sideText, {font: loadedFonts[state.font], size: state.sideSize, height: 0.5, curveSegments: 4, bevelEnabled: false}); 
            geo.computeBoundingBox(); 
            geo.translate(-0.5*(geo.boundingBox.max.x+geo.boundingBox.min.x), -0.5*(geo.boundingBox.max.y+geo.boundingBox.min.y), 0); 
            geo.rotateX(THREE.MathUtils.degToRad(state.sideRot)); 
            geo.translate(0, p.h/2 + state.sideY, 0); 
            const pos = geo.attributes.position; 
            const v = new THREE.Vector3(); 
            let depthOffset = 0.05; 
            if (mode === 'doubleshot') depthOffset = -0.5; 
            else if (mode === 'engrave') depthOffset = -0.4; 
            for(let i=0; i<pos.count; i++) { 
                v.fromBufferAttribute(pos, i); 
                const s = THREE.MathUtils.lerp(1.0, state.topScale, Math.max(0,Math.min(1,v.y/p.h))); 
                v.z += (p.baseD/2)*s + depthOffset; 
                pos.setXYZ(i, v.x, v.y, v.z); 
            } 
            geo.computeVertexNormals(); 
            return geo; 
        }
        function createConformedSVG(p, mode) {
            if (!state.svgContent || !state.svgVisible) return null;
            const loader = new SVGLoader();
            const data = loader.parse(state.svgContent);
            const thick = state.wallThickness;
            
            let globalMinX = Infinity, globalMaxX = -Infinity, globalMinY = Infinity, globalMaxY = -Infinity;
            const allShapes = [];
            data.paths.forEach(path => {
                const pathShapes = SVGLoader.createShapes(path);
                pathShapes.forEach(shape => {
                    allShapes.push(shape);
                    const pts = shape.getPoints();
                    pts.forEach(pt => {
                        if(pt.x < globalMinX) globalMinX = pt.x;
                        if(pt.x > globalMaxX) globalMaxX = pt.x;
                        if(pt.y < globalMinY) globalMinY = pt.y;
                        if(pt.y > globalMaxY) globalMaxY = pt.y;
                    });
                });
            });
            if (allShapes.length === 0) return null;
            
            const globalW = globalMaxX - globalMinX;
            const globalH = globalMaxY - globalMinY;
            const globalArea = globalW * globalH;
            
            const shapeData = allShapes.map((shape, idx) => {
                const pts = shape.getPoints();
                let sMinX = Infinity, sMaxX = -Infinity, sMinY = Infinity, sMaxY = -Infinity;
                pts.forEach(pt => {
                    if(pt.x < sMinX) sMinX = pt.x; if(pt.x > sMaxX) sMaxX = pt.x;
                    if(pt.y < sMinY) sMinY = pt.y; if(pt.y > sMaxY) sMaxY = pt.y;
                });
                return { shape, idx, areaRatio: (globalArea > 0) ? ((sMaxX-sMinX)*(sMaxY-sMinY) / globalArea) : 0 };
            });
            
            const validShapes = [];
            shapeData.forEach((sd, i) => {
                const isBackground = (sd.areaRatio > 0.80 && allShapes.length > 1) || (i === 0 && sd.areaRatio > 0.70 && allShapes.length > 1);
                if (!isBackground) validShapes.push(sd.shape);
            });
            if(validShapes.length === 0) return null;
            
            const maxEngraveDepth = thick - 0.5;
            let effectiveSvgThickness = state.svgThickness;
            if ((mode === 'engrave' || mode === 'doubleshot') && effectiveSvgThickness > maxEngraveDepth) {
                effectiveSvgThickness = maxEngraveDepth;
            }
            let genThick = effectiveSvgThickness;
            let yEmbedOffset = (mode === 'engrave' || mode === 'doubleshot') ? 0.02 : 0;
            yEmbedOffset += state.svgOffsetY;
            
            let geo = new THREE.ExtrudeGeometry(validShapes, {depth: genThick, bevelEnabled: false});
            geo.computeBoundingBox();
            const c = new THREE.Vector3();
            geo.boundingBox.getCenter(c);
            geo.translate(-c.x, -c.y, 0);
            geo.scale(0.1*state.svgScale, -0.1*state.svgScale, 1.0);
            geo.rotateZ(THREE.MathUtils.degToRad(state.svgRotZ));
            geo = BufferGeometryUtils.mergeVertices(geo, 0.001);
            geo.computeVertexNormals();
            
            if(!state.svgConform) {
                geo.rotateX(Math.PI/2);
                geo.rotateX(THREE.MathUtils.degToRad(state.svgRotX));
                geo.rotateY(THREE.MathUtils.degToRad(state.svgRotY));
                if (mode === 'engrave' || mode === 'doubleshot') { geo.scale(1, -1, 1); geo.translate(0, genThick, 0); }
                geo.rotateX(THREE.MathUtils.degToRad(p.angle));
                const sy = getSurfaceHeight(state.svgPosX, state.svgPosZ, p);
                geo.translate(state.svgPosX, sy + yEmbedOffset, state.svgPosZ);
                return geo;
            } else {
                const pos = geo.attributes.position;
                const v = new THREE.Vector3();
                for(let i=0; i<pos.count; i++) {
                    v.fromBufferAttribute(pos, i);
                    const tx = v.x + state.svgPosX;
                    const tz = -v.y + state.svgPosZ;
                    const sy = getSurfaceHeight(tx, tz, p);
                    const depthOffset = (mode === 'engrave' || mode === 'doubleshot') ? -v.z : v.z;
                    pos.setXYZ(i, tx, sy + depthOffset + yEmbedOffset, tz);
                }
                geo.computeVertexNormals();
                return geo;
            }
        }

        function createConformedSVGForExport(p, mode) {
            if (!state.svgContent || !state.svgVisible) return null;
            const loader = new SVGLoader();
            const data = loader.parse(state.svgContent);
            const thick = state.wallThickness;
            
            let globalMinX = Infinity, globalMaxX = -Infinity, globalMinY = Infinity, globalMaxY = -Infinity;
            const allShapes = [];
            data.paths.forEach(path => {
                const pathShapes = SVGLoader.createShapes(path);
                pathShapes.forEach(shape => {
                    allShapes.push(shape);
                    const pts = shape.getPoints();
                    pts.forEach(pt => {
                        if(pt.x < globalMinX) globalMinX = pt.x;
                        if(pt.x > globalMaxX) globalMaxX = pt.x;
                        if(pt.y < globalMinY) globalMinY = pt.y;
                        if(pt.y > globalMaxY) globalMaxY = pt.y;
                    });
                });
            });
            if (allShapes.length === 0) return null;
            
            const globalW = globalMaxX - globalMinX;
            const globalH = globalMaxY - globalMinY;
            const globalArea = globalW * globalH;
            const globalCenterX = (globalMinX + globalMaxX) / 2;
            const globalCenterY = (globalMinY + globalMaxY) / 2;
            
            const shapeData = allShapes.map((shape, idx) => {
                const pts = shape.getPoints();
                let sMinX = Infinity, sMaxX = -Infinity, sMinY = Infinity, sMaxY = -Infinity;
                pts.forEach(pt => {
                    if(pt.x < sMinX) sMinX = pt.x; if(pt.x > sMaxX) sMaxX = pt.x;
                    if(pt.y < sMinY) sMinY = pt.y; if(pt.y > sMaxY) sMaxY = pt.y;
                });
                const sW = sMaxX - sMinX;
                const sH = sMaxY - sMinY;
                const sArea = sW * sH;
                const areaRatio = (globalArea > 0) ? (sArea / globalArea) : 0;
                return { shape, idx, areaRatio, numPts: pts.length };
            });
            
            const validShapes = [];
            shapeData.forEach((sd, i) => {
                const isBackground =
                    (sd.areaRatio > 0.80 && allShapes.length > 1) ||
                    (i === 0 && sd.areaRatio > 0.70 && allShapes.length > 1);
                
                if (isBackground) {
                    console.log("V63.3.1: Removed background shape #" + sd.idx + " (area:" + (sd.areaRatio*100).toFixed(1) + "%, pts:" + sd.numPts + ")");
                } else {
                    validShapes.push(sd.shape);
                }
            });
            
            if(validShapes.length === 0) return null;
            
            const maxEngraveDepth = thick - 0.5;
            let effectiveSvgThickness = state.svgThickness;
            if ((mode === 'engrave' || mode === 'doubleshot') && effectiveSvgThickness > maxEngraveDepth) {
                effectiveSvgThickness = maxEngraveDepth;
                console.log("V63.3.1: SVG depth limited to " + effectiveSvgThickness.toFixed(2) + "mm");
            }
            
            let genThick = effectiveSvgThickness;
            let yEmbedOffset = 0;
            
            const embedIntoBody = 0.3;
            
            if (mode === 'emboss') {
                genThick = effectiveSvgThickness + embedIntoBody;
                yEmbedOffset = -embedIntoBody;
            } else if (mode === 'engrave') {
                genThick = effectiveSvgThickness;
                yEmbedOffset = 0.02;
            } else if (mode === 'doubleshot') {
                genThick = effectiveSvgThickness;
                yEmbedOffset = 0.02;
            }
            yEmbedOffset += state.svgOffsetY;
            
            const extrudedGeos = [];
            for (const shape of validShapes) {
                try {
                    const simplifiedShape = simplifyShape(shape, 0.5);
                    
                    let shapeGeo = new THREE.ExtrudeGeometry([simplifiedShape], {
                        depth: genThick, 
                        bevelEnabled: false,
                        curveSegments: 4
                    });
                    
                    shapeGeo.translate(-globalCenterX, -globalCenterY, 0);
                    
                    shapeGeo.scale(0.1 * state.svgScale, -0.1 * state.svgScale, 1.0);
                    shapeGeo.rotateZ(THREE.MathUtils.degToRad(state.svgRotZ));
                    
                    shapeGeo = BufferGeometryUtils.mergeVertices(shapeGeo, 0.08);
                    shapeGeo.computeVertexNormals();
                    
                    extrudedGeos.push(shapeGeo);
                } catch (e) {
                    console.warn("SVG shape extrude failed:", e);
                }
            }
            
            if (extrudedGeos.length === 0) return null;
            
            let geo;
            if (extrudedGeos.length === 1) {
                geo = extrudedGeos[0];
            } else {
                try {
                    console.log("V63.3.1: Merging " + extrudedGeos.length + " SVG shapes with CSG Union...");
                    geo = extrudedGeos[0];
                    for (let i = 1; i < extrudedGeos.length; i++) {
                        const b1 = new Brush(geo); b1.updateMatrixWorld();
                        const b2 = new Brush(extrudedGeos[i]); b2.updateMatrixWorld();
                        const res = csgEvaluator.evaluate(b1, b2, ADDITION);
                        geo = res.geometry;
                    }
                    geo = BufferGeometryUtils.mergeVertices(geo, 0.08);
                    geo.computeVertexNormals();
                    console.log("V63.3.1: CSG Union complete");
                } catch (e) {
                    console.warn("SVG CSG Union failed, falling back to merge:", e);
                    geo = BufferGeometryUtils.mergeGeometries(extrudedGeos);
                    geo = BufferGeometryUtils.mergeVertices(geo, 0.08);
                    geo.computeVertexNormals();
                }
            }
            
            if(!state.svgConform) {
                geo.rotateX(Math.PI/2);
                geo.rotateX(THREE.MathUtils.degToRad(state.svgRotX));
                geo.rotateY(THREE.MathUtils.degToRad(state.svgRotY));
                if (mode === 'engrave' || mode === 'doubleshot') {
                    geo.scale(1, -1, 1);
                    geo.translate(0, genThick, 0);
                }
                geo.rotateX(THREE.MathUtils.degToRad(p.angle));
                const sy = getSurfaceHeight(state.svgPosX, state.svgPosZ, p);
                geo.translate(state.svgPosX, sy + yEmbedOffset, state.svgPosZ);
                geo = BufferGeometryUtils.mergeVertices(geo, 0.08);
                geo.computeVertexNormals();
                return geo;
            } else {
                const pos = geo.attributes.position;
                const v = new THREE.Vector3();
                for(let i=0; i<pos.count; i++) {
                    v.fromBufferAttribute(pos, i);
                    const tx = v.x + state.svgPosX;
                    const tz = -v.y + state.svgPosZ;
                    const sy = getSurfaceHeight(tx, tz, p);
                    const depthOffset = (mode === 'engrave' || mode === 'doubleshot') ? -v.z : v.z;
                    pos.setXYZ(i, tx, sy + depthOffset + yEmbedOffset, tz);
                }
                geo = BufferGeometryUtils.mergeVertices(geo, 0.08);
                geo.computeVertexNormals();
                return geo;
            }
        }
        
        function simplifyShape(shape, tolerance) {
            const simplifyPoints = (points, tol) => {
                if (points.length <= 2) return points;
                
                const result = [points[0]];
                let lastPoint = points[0];
                
                for (let i = 1; i < points.length - 1; i++) {
                    const dist = Math.sqrt(
                        Math.pow(points[i].x - lastPoint.x, 2) + 
                        Math.pow(points[i].y - lastPoint.y, 2)
                    );
                    if (dist >= tol) {
                        result.push(points[i]);
                        lastPoint = points[i];
                    }
                }
                
                result.push(points[points.length - 1]);
                return result;
            };
            
            const mainPoints = shape.getPoints(12);
            const simplifiedMain = simplifyPoints(mainPoints, tolerance);
            
            const newShape = new THREE.Shape(simplifiedMain);
            
            if (shape.holes && shape.holes.length > 0) {
                for (const hole of shape.holes) {
                    const holePoints = hole.getPoints(12);
                    const simplifiedHole = simplifyPoints(holePoints, tolerance);
                    if (simplifiedHole.length >= 3) {
                        newShape.holes.push(new THREE.Path(simplifiedHole));
                    }
                }
            }
            
            return newShape;
        }

        function updateModel() {
            mainGroup.rotation.x = THREE.MathUtils.degToRad(state.globalRotX);
            mainGroup.rotation.y = THREE.MathUtils.degToRad(state.globalRotY);
            const p = getParams();
            let bodyMat, textMat;
            
            if (state.renderMode === 'wireframe') {
                bodyMat = new THREE.MeshBasicMaterial({ color: state.colBody, wireframe: true });
                textMat = new THREE.MeshBasicMaterial({ color: state.colText, wireframe: true });
            } else {
                let map = null;
                if (state.imgContent && state.imgTextureVisible) {
                    map = textureLoader.load(state.imgContent);
                    map.wrapS = THREE.ClampToEdgeWrapping;
                    map.wrapT = THREE.ClampToEdgeWrapping;
                    map.minFilter = THREE.LinearFilter;
                }
                bodyMat = new THREE.MeshStandardMaterial({ color: state.colBody, roughness: 0.6, metalness: 0.1, side: THREE.DoubleSide, map: map });
                textMat = new THREE.MeshStandardMaterial({ color: state.colText, side: THREE.DoubleSide });
            }
            
            const body = createBodyParts(p, false);
            const stem = createStemAndRibs(p, false);
            const bump = createHomingBump(p);
            let finalKeycapGeo = safeMerge([body, stem, bump]);
            
            mainGroup.clear();
            const textGeos = [];
            const engraveGeos = [];
            
            const handleGeo = (geo, mode) => {
                if (!geo) return;
                if (mode === 'emboss') {
                    textGeos.push(geo);
                } else if (mode === 'engrave') {
                    engraveGeos.push(geo);
                } else if (mode === 'doubleshot') {
                    textGeos.push(geo);
                    engraveGeos.push(geo.clone());
                } else if (mode === 'lithophane') {
                    engraveGeos.push(geo);
                }
            };
            
            if (state.enableText && loadedFonts[state.font]) {
                handleGeo(createConformedText(p, state.text, state.fontSize, state.posX, state.posZ, state.textMode), state.textMode);
            }
            if (state.enableText2 && loadedFonts[state.font]) {
                handleGeo(createConformedText(p, state.text2, state.text2Size, state.text2X, state.text2Z, state.text2Mode), state.text2Mode);
            }
            if(state.enableSide) {
                handleGeo(createSidePrint(p, state.sideMode), state.sideMode);
            }
            if (state.svgContent && state.svgVisible) {
                handleGeo(createConformedSVG(p, state.svgMode), state.svgMode);
            }
            
            let finalTextGeo = safeMerge(textGeos);
            let finalEngraveGeo = safeMerge(engraveGeos);
            
            let importedGeo = null;
            if(importedModelBuffer && state.modelVisible) {
                importedGeo = new STLLoader().parse(importedModelBuffer);
                importedGeo.scale(state.modelScale, state.modelScale, state.modelScale);
                importedGeo.rotateX(THREE.MathUtils.degToRad(state.modelRX));
                importedGeo.rotateY(THREE.MathUtils.degToRad(state.modelRY));
                importedGeo.rotateZ(THREE.MathUtils.degToRad(state.modelRZ));
                importedGeo.translate(state.modelX, state.modelY, state.modelZ);
            }
            
            if (state.modelOperation === 'subtract' && importedGeo && finalKeycapGeo) {
                const b1 = new Brush(finalKeycapGeo); b1.updateMatrixWorld();
                const b2 = new Brush(importedGeo); b2.updateMatrixWorld();
                const res = csgEvaluator.evaluate(b1, b2, SUBTRACTION);
                finalKeycapGeo = res.geometry;
                importedGeo = null;
            }
            
            if (finalEngraveGeo && finalKeycapGeo) {
                const b1 = new Brush(finalKeycapGeo); b1.updateMatrixWorld();
                const b2 = new Brush(finalEngraveGeo); b2.updateMatrixWorld();
                const res = csgEvaluator.evaluate(b1, b2, SUBTRACTION);
                finalKeycapGeo = res.geometry;
            }
            
            if(finalKeycapGeo) {
                finalKeycapGeo.computeVertexNormals();
                const mesh = new THREE.Mesh(finalKeycapGeo, bodyMat);
                mesh.name = "KeycapBody";
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mainGroup.add(mesh);
            }
            if(finalTextGeo) {
                const mesh = new THREE.Mesh(finalTextGeo, textMat);
                mesh.name = "KeycapText";
                mainGroup.add(mesh);
            }
            if(importedGeo) {
                const mesh = new THREE.Mesh(importedGeo, textMat);
                mesh.name = "ImportedModel";
                mainGroup.add(mesh);
            }
            
            calculateStats();
        }

        let debounceTimeout = null;
        function requestUpdate() {
            if(debounceTimeout) clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(updateModel, 100);
        }

        function cleanupGeometry(geometry) {
            if (!geometry) return null;
            let geo = geometry.clone();
            if (geo.index) geo = geo.toNonIndexed();
            geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
            geo.computeVertexNormals();
            return geo;
        }

        function repairMesh(geometry) {
            if (!geometry) return null;
            
            let geo = geometry;
            if (geo.index) {
                geo = geo.toNonIndexed();
            }
            
            const position = geo.attributes.position;
            const epsilon = 0.0001;
            const triangles = [];
            
            for (let i = 0; i < position.count; i += 3) {
                const v0 = new THREE.Vector3(position.getX(i), position.getY(i), position.getZ(i));
                const v1 = new THREE.Vector3(position.getX(i+1), position.getY(i+1), position.getZ(i+1));
                const v2 = new THREE.Vector3(position.getX(i+2), position.getY(i+2), position.getZ(i+2));
                
                const edge1 = new THREE.Vector3().subVectors(v1, v0);
                const edge2 = new THREE.Vector3().subVectors(v2, v0);
                const cross = new THREE.Vector3().crossVectors(edge1, edge2);
                const area = cross.length() / 2;
                
                if (area < epsilon) continue;
                
                if (v0.distanceTo(v1) < epsilon || v1.distanceTo(v2) < epsilon || v2.distanceTo(v0) < epsilon) continue;
                
                triangles.push({ v0, v1, v2, area });
            }
            
            const uniqueTriangles = [];
            const seen = new Set();
            
            for (const tri of triangles) {
                const cx = ((tri.v0.x + tri.v1.x + tri.v2.x) / 3).toFixed(3);
                const cy = ((tri.v0.y + tri.v1.y + tri.v2.y) / 3).toFixed(3);
                const cz = ((tri.v0.z + tri.v1.z + tri.v2.z) / 3).toFixed(3);
                const areaKey = tri.area.toFixed(4);
                const key = `${cx},${cy},${cz},${areaKey}`;
                
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueTriangles.push(tri);
                }
            }
            
            const newPositions = [];
            for (const tri of uniqueTriangles) {
                newPositions.push(tri.v0.x, tri.v0.y, tri.v0.z);
                newPositions.push(tri.v1.x, tri.v1.y, tri.v1.z);
                newPositions.push(tri.v2.x, tri.v2.y, tri.v2.z);
            }
            
            const newGeo = new THREE.BufferGeometry();
            newGeo.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
            
            const mergedGeo = BufferGeometryUtils.mergeVertices(newGeo, 0.0001);
            mergedGeo.computeVertexNormals();
            
            console.log(`Repair: ${position.count/3} -> ${uniqueTriangles.length} triangles`);
            
            return mergedGeo;
        }

        function buildExportGeometry() {
            try {
                const p = getParams();
                
                console.log("Building export geometry V63.3.1...");
                
                const body = createBodyParts(p, false);
                const stem = createStemAndRibs(p, false);
                const bump = createHomingBump(p);
                
                let bodyGeos = [body, stem, bump].filter(g => g != null);
                
                bodyGeos = bodyGeos.map(g => {
                    if (g.index) {
                        return g.toNonIndexed();
                    }
                    return g;
                });
                
                let finalKeycapGeo = BufferGeometryUtils.mergeGeometries(bodyGeos);
                
                if (finalKeycapGeo) {
                    finalKeycapGeo = BufferGeometryUtils.mergeVertices(finalKeycapGeo, 0.0001);
                    finalKeycapGeo.computeVertexNormals();
                }
                
                console.log("Body geo created:", finalKeycapGeo);
                
                const textGeos = [];
                const engraveGeos = [];
                
                const handleGeo = (geo, mode) => {
                    if (!geo) return;
                    if (mode === 'emboss') {
                        textGeos.push(geo);
                    } else if (mode === 'engrave') {
                        engraveGeos.push(geo);
                    } else if (mode === 'doubleshot') {
                        textGeos.push(geo);
                        engraveGeos.push(geo.clone());
                    }
                };
                
                if (state.enableText && loadedFonts[state.font]) {
                    handleGeo(createConformedText(p, state.text, state.fontSize, state.posX, state.posZ, state.textMode), state.textMode);
                }
                if (state.enableText2 && loadedFonts[state.font]) {
                    handleGeo(createConformedText(p, state.text2, state.text2Size, state.text2X, state.text2Z, state.text2Mode), state.text2Mode);
                }
                if (state.enableSide) {
                    handleGeo(createSidePrint(p, state.sideMode), state.sideMode);
                }
                if (state.svgContent && state.svgVisible) {
                    let svgGeo = createConformedSVGForExport(p, state.svgMode);
                    if (svgGeo) {
                        console.log("V63.3.1: Applying enhanced repair to SVG geometry...");
                        svgGeo = repairSVGMesh(svgGeo);
                        
                        if (state.svgMode === 'emboss' && finalKeycapGeo) {
                            try {
                                console.log("V63.3.1: CSG Union SVG with body...");
                                const b1 = new Brush(finalKeycapGeo); b1.updateMatrixWorld();
                                const b2 = new Brush(svgGeo); b2.updateMatrixWorld();
                                const res = csgEvaluator.evaluate(b1, b2, ADDITION);
                                finalKeycapGeo = res.geometry;
                                finalKeycapGeo = BufferGeometryUtils.mergeVertices(finalKeycapGeo, 0.0001);
                                console.log("V63.3.1: CSG Union successful");
                                svgGeo = null;
                            } catch (e) {
                                console.error("SVG CSG Union failed:", e);
                            }
                        }
                    }
                    if (svgGeo) {
                        handleGeo(svgGeo, state.svgMode);
                    }
                }
                
                if (engraveGeos.length > 0 && finalKeycapGeo) {
                    let engraveGeo = BufferGeometryUtils.mergeGeometries(engraveGeos.map(g => g.index ? g.toNonIndexed() : g));
                    if (engraveGeo) {
                        try {
                            const b1 = new Brush(finalKeycapGeo); b1.updateMatrixWorld();
                            const b2 = new Brush(engraveGeo); b2.updateMatrixWorld();
                            const res = csgEvaluator.evaluate(b1, b2, SUBTRACTION);
                            finalKeycapGeo = res.geometry;
                            finalKeycapGeo = BufferGeometryUtils.mergeVertices(finalKeycapGeo, 0.0001);
                        } catch (e) {
                            console.error("Engrave CSG failed:", e);
                        }
                    }
                }
                
                let finalTextGeo = null;
                if (textGeos.length > 0) {
                    const textGeosNonIndexed = textGeos.map(g => g.index ? g.toNonIndexed() : g);
                    finalTextGeo = BufferGeometryUtils.mergeGeometries(textGeosNonIndexed);
                    if (finalTextGeo) {
                        finalTextGeo = BufferGeometryUtils.mergeVertices(finalTextGeo, 0.0001);
                        finalTextGeo.computeVertexNormals();
                    }
                }
                
                console.log("Text geo created:", finalTextGeo);
                
                console.log("Repairing meshes...");
                if (finalKeycapGeo) {
                    finalKeycapGeo = repairMesh(finalKeycapGeo);
                    console.log("Body repaired:", finalKeycapGeo);
                }
                if (finalTextGeo) {
                    finalTextGeo = repairMesh(finalTextGeo);
                    console.log("Text repaired:", finalTextGeo);
                }
                
                console.log("Export geometry built successfully");
                
                return { bodyGeo: finalKeycapGeo, textGeo: finalTextGeo, importedGeo: null };
                
            } catch (error) {
                console.error("buildExportGeometry error:", error);
                document.getElementById('error-log').textContent = "Build error: " + error.message;
                throw error;
            }
        }

        async function export3MF() {
            try {
                const t = translations[currentLang];
                showToast(t.toast_generating);
                
                await new Promise(r => setTimeout(r, 100));
                
                console.log("Building export geometry...");
                const { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
                console.log("bodyGeo:", bodyGeo);
                console.log("textGeo:", textGeo);
                
                if (!bodyGeo) {
                    showToast(t.toast_no_body);
                    return;
                }
                
                const zip = new JSZip();
                
                function geoTo3MFMesh(geometry) {
                    if (!geometry) return null;
                    
                    let geo = geometry.clone();
                    
                    if (!geo.index) {
                        geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
                    }
                    
                    const position = geo.attributes.position;
                    if (!position) return null;
                    
                    const vertices = [];
                    const triangles = [];
                    
                    const index = geo.index;
                    
                    if (index && index.array) {
                        for (let i = 0; i < position.count; i++) {
                            vertices.push(`      <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                        }
                        const indexArray = index.array;
                        for (let i = 0; i < indexArray.length; i += 3) {
                            triangles.push(`      <triangle v1="${indexArray[i]}" v2="${indexArray[i+1]}" v3="${indexArray[i+2]}" />`);
                        }
                    } else {
                        for (let i = 0; i < position.count; i++) {
                            vertices.push(`      <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                        }
                        for (let i = 0; i < position.count; i += 3) {
                            triangles.push(`      <triangle v1="${i}" v2="${i+1}" v3="${i+2}" />`);
                        }
                    }
                    
                    return { vertices, triangles };
                }
                
                let modelXml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02" xmlns:m="http://schemas.microsoft.com/3dmanufacturing/material/2015/02">
  <metadata name="Application">Keycap Generator V64.0</metadata>
  <resources>
    <m:basematerials id="1">
      <m:base name="Body" displaycolor="#${state.colBody.slice(1).toUpperCase()}" />
      <m:base name="Text" displaycolor="#${state.colText.slice(1).toUpperCase()}" />
    </m:basematerials>`;
                
                let objectId = 2;
                let buildItems = '';
            
            if (bodyGeo) {
                const mesh = geoTo3MFMesh(bodyGeo);
                if (mesh) {
                    modelXml += `
    <object id="${objectId}" name="KeycapBody" type="model">
      <mesh>
        <vertices>
${mesh.vertices.join('\n')}
        </vertices>
        <triangles>
${mesh.triangles.map(t => t.replace('/>', ' pid="1" p1="0" />')).join('\n')}
        </triangles>
      </mesh>
    </object>`;
                    buildItems += `    <item objectid="${objectId}" />`;
                    objectId++;
                }
            }
            
            let combinedTextGeo = textGeo;
            console.log("combinedTextGeo before import check:", combinedTextGeo);
            if (importedGeo) {
                if (combinedTextGeo) {
                    combinedTextGeo = BufferGeometryUtils.mergeGeometries([combinedTextGeo, importedGeo]);
                    combinedTextGeo = BufferGeometryUtils.mergeVertices(combinedTextGeo, 0.0001);
                } else {
                    combinedTextGeo = importedGeo;
                }
            }
            
            console.log("combinedTextGeo after import check:", combinedTextGeo);
            if (combinedTextGeo) {
                const mesh = geoTo3MFMesh(combinedTextGeo);
                console.log("Text mesh:", mesh);
                if (mesh) {
                    console.log("Adding text object to 3MF, vertices:", mesh.vertices.length, "triangles:", mesh.triangles.length);
                    modelXml += `
    <object id="${objectId}" name="KeycapText" type="model">
      <mesh>
        <vertices>
${mesh.vertices.join('\n')}
        </vertices>
        <triangles>
${mesh.triangles.map(t => t.replace('/>', ' pid="1" p1="1" />')).join('\n')}
        </triangles>
      </mesh>
    </object>`;
                    buildItems += `\n    <item objectid="${objectId}" />`;
                    console.log("Text object added to 3MF");
                } else {
                    console.log("geoTo3MFMesh returned null for text");
                }
            } else {
                console.log("No text geometry to export");
            }
            
            modelXml += `
  </resources>
  <build>
${buildItems}
  </build>
</model>`;

            const contentTypes = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />
</Types>`;

            const rels = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>`;

                zip.file("[Content_Types].xml", contentTypes);
                zip.folder("_rels").file(".rels", rels);
                zip.folder("3D").file("3dmodel.model", modelXml);
                
                const blob = await zip.generateAsync({ type: "blob", compression: "DEFLATE" });
                saveBlob(blob, getFileName() + '.3mf');
                showToast(t.toast_3mf_exported);
            } catch (error) {
                console.error("3MF Export Error:", error);
                const t = translations[currentLang];
                showToast(t.toast_export_failed + error.message);
                document.getElementById('error-log').textContent = "3MF Export Error: " + error.message;
            }
        }

        async function init() {
            document.getElementById('loading').style.display = 'flex';
            
            await initManifold();
            
            const fontConfigs = [
                ['helvetiker', 'helvetiker_regular', 'Helvetiker'],
                ['helvetiker_bold', 'helvetiker_bold', 'Helvetiker Bold'],
                ['optimer', 'optimer_regular', 'Optimer'],
                ['optimer_bold', 'optimer_bold', 'Optimer Bold'],
                ['gentilis', 'gentilis_regular', 'Gentilis'],
                ['gentilis_bold', 'gentilis_bold', 'Gentilis Bold'],
                ['droid_sans', 'droid/droid_sans_regular', 'Droid Sans'],
                ['droid_sans_bold', 'droid/droid_sans_bold', 'Droid Sans Bold'],
                ['droid_serif', 'droid/droid_serif_regular', 'Droid Serif'],
                ['droid_serif_bold', 'droid/droid_serif_bold', 'Droid Serif Bold']
            ];
            
            let fontsLoaded = 0;
            for(const [name, fileName, displayName] of fontConfigs) {
                try {
                    const path = `https://cdn.jsdelivr.net/npm/three@0.160.0/examples/fonts/${fileName}.typeface.json`;
                    loadedFonts[name] = await new Promise((resolve, reject) => fontLoader.load(path, resolve, undefined, reject));
                    fontsLoaded++;
                    console.log(`Font loaded: ${displayName}`);
                } catch(e) {
                    console.warn(`Font load failed: ${name} (${fileName})`);
                }
            }
            if(fontsLoaded === 0) document.getElementById('error-log').textContent = "Warning: No fonts loaded.";
            
            initFilamentManager();
            initNavigation();
            setupCustomDropdown();
            syncUI();
            
            HTML_COLORS.forEach(c => {
                const s1 = document.createElement('div');
                s1.className = 'palette-swatch';
                s1.style.background = c;
                s1.addEventListener('click', () => { 
                    state.colBody = c; 
                    document.getElementById('col-body').value = c;
                    const simpleColB = document.getElementById('simple-col-body');
                    if(simpleColB) simpleColB.value = c;
                    updateModel(); 
                });
                document.getElementById('palette-body').appendChild(s1);
                const s2 = document.createElement('div');
                s2.className = 'palette-swatch';
                s2.style.background = c;
                s2.addEventListener('click', () => { 
                    state.colText = c; 
                    document.getElementById('col-text').value = c;
                    const simpleColT = document.getElementById('simple-col-text');
                    if(simpleColT) simpleColT.value = c;
                    updateModel(); 
                });
                document.getElementById('palette-text').appendChild(s2);
            });
            
            document.getElementById('unit-size-select').addEventListener('change', (e) => { state.unitSize = parseFloat(e.target.value); requestUpdate(); });
            document.getElementById('profile-select').addEventListener('change', (e) => { 
                state.profile = e.target.value; 
                const customPanel = document.getElementById('custom-profile-panel');
                if(customPanel) customPanel.style.display = e.target.value === 'custom' ? 'block' : 'none';
                requestUpdate(); 
            });
            
            document.getElementById('key-shape-type').addEventListener('change', (e) => {
                state.keyShapeType = e.target.value;
                document.getElementById('shape-polygon-options').style.display = e.target.value === 'polygon' ? 'block' : 'none';
                document.getElementById('shape-star-options').style.display = e.target.value === 'star' ? 'block' : 'none';
                document.getElementById('shape-iso-options').style.display = e.target.value === 'iso-enter' ? 'block' : 'none';
                requestUpdate();
            });
            
            document.getElementById('row-select').addEventListener('change', (e) => { state.row = e.target.value; requestUpdate(); });
            document.getElementById('texture-type').addEventListener('change', (e) => { state.textureType = e.target.value; requestUpdate(); });
            document.getElementById('text-mode').addEventListener('change', (e) => { 
                state.textMode = e.target.value; 
                const simpleTextMode = document.getElementById('simple-text-mode');
                if(simpleTextMode) simpleTextMode.value = e.target.value;
                requestUpdate(); 
            });
            document.getElementById('text2-mode').addEventListener('change', (e) => { state.text2Mode = e.target.value; requestUpdate(); });
            document.getElementById('side-mode').addEventListener('change', (e) => { state.sideMode = e.target.value; requestUpdate(); });
            document.getElementById('svg-mode').addEventListener('change', (e) => { state.svgMode = e.target.value; requestUpdate(); });
            document.getElementById('render-mode').addEventListener('change', (e) => { state.renderMode = e.target.value; requestUpdate(); });
            document.getElementById('stabilizer-type').addEventListener('change', (e) => {
                state.stabilizerType = e.target.value;
                document.getElementById('stabilizer-custom-ui').style.display = e.target.value === 'custom' ? 'block' : 'none';
                requestUpdate();
            });
            document.getElementById('lego-stud').addEventListener('change', (e) => {
                state.legoStud = e.target.checked;
                document.getElementById('lego-adj-panel').style.display = e.target.checked ? 'block' : 'none';
                requestUpdate();
            });
            document.getElementById('enable-stem-extension').addEventListener('change', (e) => {
                state.enableStemExtension = e.target.checked;
                document.getElementById('stem-ext-control').style.display = e.target.checked ? 'block' : 'none';
                requestUpdate();
            });
            
            const mInput = document.getElementById('model-file-input');
            if(mInput) mInput.addEventListener('change', function(e) {
                const file = e.target.files[0]; if(!file) return;
                const reader = new FileReader();
                reader.onload = function(ev) { importedModelBuffer = ev.target.result; updateModel(); };
                reader.readAsArrayBuffer(file);
            });
            const bClearModel = document.getElementById('btn-clear-model');
            if(bClearModel) bClearModel.addEventListener('click', () => {
                importedModelBuffer = null;
                if(mInput) mInput.value = '';
                updateModel();
            });
            
            const imgInput = document.getElementById('img-texture-input');
            if(imgInput) imgInput.addEventListener('change', function(e) {
                const file = e.target.files[0]; if(!file) return;
                const reader = new FileReader();
                reader.onload = function(ev) {
                    state.imgContent = ev.target.result;
                    state.imgTextureVisible = true;
                    document.getElementById('img-texture-visible').checked = true;
                    updateModel();
                };
                reader.readAsDataURL(file);
            });
            const bClearImgTex = document.getElementById('btn-clear-img-texture');
            if(bClearImgTex) bClearImgTex.addEventListener('click', () => {
                state.imgContent = null;
                state.imgTextureVisible = false;
                document.getElementById('img-texture-visible').checked = false;
                if(imgInput) imgInput.value = '';
                updateModel();
            });
            
            document.getElementById('btn-random').addEventListener('click', randomizeParams);
            document.getElementById('btn-reset-params').addEventListener('click', resetParams);
            document.getElementById('btn-align-center').addEventListener('click', () => { state.posX = 0; state.posZ = 0; syncUI(); requestUpdate(); });
            document.getElementById('btn-align-tl').addEventListener('click', () => { state.posX = -3.5; state.posZ = -3.5; syncUI(); requestUpdate(); });
            document.getElementById('btn-align-tr').addEventListener('click', () => { state.posX = 3.5; state.posZ = -3.5; syncUI(); requestUpdate(); });
            document.getElementById('btn-align-bl').addEventListener('click', () => { state.posX = -3.5; state.posZ = 3.5; syncUI(); requestUpdate(); });
            document.getElementById('btn-align-br').addEventListener('click', () => { state.posX = 3.5; state.posZ = 3.5; syncUI(); requestUpdate(); });
            
            const statsPanel = document.getElementById('top-right-panel');
            const toggleStatsBtn = document.getElementById('btn-toggle-stats');
            if(toggleStatsBtn) {
                toggleStatsBtn.addEventListener('click', () => {
                    statsPanel.classList.toggle('stats-collapsed');
                    toggleStatsBtn.textContent = statsPanel.classList.contains('stats-collapsed') ? "+" : "Ôºç";
                });
            }
            
            const toggleUiBtn = document.getElementById('btn-toggle-ui');
            if(toggleUiBtn) {
                toggleUiBtn.addEventListener('click', () => {
                    document.body.classList.toggle('ui-closed');
                    const isClosed = document.body.classList.contains('ui-closed');
                    toggleUiBtn.textContent = isClosed ? "‚ñ∂" : "‚óÄ";
                    setTimeout(() => {
                        const w = container.clientWidth;
                        const h = container.clientHeight;
                        renderer.setSize(w, h);
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                    }, 350);
                });
            }
            
            document.getElementById('loading').style.display = 'none';
            requestUpdate();
            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.clear();
            controls.update();
            renderer.render(scene, camera);
            const vhSize = 128;
            renderer.setViewport(container.clientWidth - vhSize, 0, vhSize, vhSize);
            renderer.setScissor(container.clientWidth - vhSize, 0, vhSize, vhSize);
            renderer.setScissorTest(true);
            viewHelper.render(renderer);
            renderer.setScissorTest(false);
            renderer.setViewport(0, 0, container.clientWidth, container.clientHeight);
        }

        const bind = (id, key) => {
            const el = document.getElementById(id);
            if(!el) return;
            const up = () => {
                const v = (el.type==='checkbox') ? el.checked : (el.type==='range'||el.type==='number' ? parseFloat(el.value) : el.value);
                state[key]=v;
                if(el.type==='range') {
                    const sp = document.getElementById('v-'+id);
                    if(sp) sp.textContent = (id === 'tex-scale') ? parseInt(v) : v.toFixed(2);
                }
                if(id === 'lock-thickness') {
                    const slider = document.getElementById('text-height');
                    if(slider) {
                        slider.disabled = v;
                        if(v) { slider.value=0.5; state.textHeight=0.5; document.getElementById('v-text-height').textContent="0.50"; }
                    }
                }
                requestUpdate();
            };
            el.addEventListener('input', up);
            el.addEventListener('change', ()=>{up(); commitHistory();});
            const vS = document.getElementById('v-'+id);
            if(vS && id !== 'text-height') vS.addEventListener('dblclick', ()=>{
                const i=document.createElement('input');
                i.type='number';
                i.value=state[key];
                i.className='direct-input';
                vS.style.display='none';
                vS.parentNode.insertBefore(i, vS.nextSibling);
                i.style.display='inline-block';
                i.focus();
                const end = ()=>{
                    const n=parseFloat(i.value);
                    if(!isNaN(n)){state[key]=n; el.value=n; vS.textContent=n.toFixed(2); requestUpdate(); commitHistory();}
                    i.remove();
                    vS.style.display='inline-block';
                };
                i.addEventListener('blur', end);
                i.addEventListener('keydown', e=>{if(e.key==='Enter')end();});
            });
        };
        
        Object.keys(paramMap).forEach(id => bind(id, paramMap[id]));
        Object.keys(boolMap).forEach(id => bind(id, boolMap[id]));
        
        // Sync main mode sliders to simple mode
        const topScaleEl = document.getElementById('top-scale');
        if(topScaleEl) topScaleEl.addEventListener('input', e => {
            const simpleTaper = document.getElementById('simple-taper');
            const simpleVal = document.getElementById('v-simple-taper');
            if(simpleTaper) simpleTaper.value = e.target.value;
            if(simpleVal) simpleVal.textContent = parseFloat(e.target.value).toFixed(2);
        });
        const dishTypeEl = document.getElementById('dish-type');
        if(dishTypeEl) dishTypeEl.addEventListener('change', e => {
            const simpleDish = document.getElementById('simple-dish-type');
            if(simpleDish) simpleDish.value = e.target.value;
        });
        const roundCornerEl = document.getElementById('round-corner');
        if(roundCornerEl) roundCornerEl.addEventListener('input', e => {
            const simpleFillet = document.getElementById('simple-fillet');
            const simpleVal = document.getElementById('v-simple-fillet');
            if(simpleFillet) simpleFillet.value = e.target.value;
            if(simpleVal) simpleVal.textContent = parseFloat(e.target.value).toFixed(1);
        });
        
        const txtC = document.getElementById('text-content');
        if(txtC) txtC.addEventListener('input', e=>{state.text=e.target.value; requestUpdate();});
        const txt2C = document.getElementById('text2-content');
        if(txt2C) txt2C.addEventListener('input', e=>{state.text2=e.target.value; requestUpdate();});
        const sideT = document.getElementById('side-text');
        if(sideT) sideT.addEventListener('input', e=>{state.sideText=e.target.value; requestUpdate();});
        const colB = document.getElementById('col-body');
        if(colB) colB.addEventListener('input', e=>{
            state.colBody=e.target.value;
            const simpleColB = document.getElementById('simple-col-body');
            if(simpleColB) simpleColB.value = e.target.value;
            updateModel();
        });
        const colT = document.getElementById('col-text');
        if(colT) colT.addEventListener('input', e=>{
            state.colText=e.target.value;
            const simpleColT = document.getElementById('simple-col-text');
            if(simpleColT) simpleColT.value = e.target.value;
            updateModel();
        });
        
        const bUndo = document.getElementById('btn-undo'); if(bUndo) bUndo.addEventListener('click', undo);
        const bRedo = document.getElementById('btn-redo'); if(bRedo) bRedo.addEventListener('click', redo);
        
        window.addEventListener('resize', () => {
            camera.aspect=container.clientWidth/container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth,container.clientHeight);
        });
        
        const fInput = document.getElementById('font-file-input');
        if(fInput) fInput.addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const json = JSON.parse(e.target.result);
                    const font = fontLoader.parse(json);
                    const fontName = "custom_" + Date.now();
                    loadedFonts[fontName] = font;
                    const select = document.getElementById('font-family');
                    if(select) {
                        const option = document.createElement('option');
                        option.value = fontName;
                        option.text = file.name.replace('.json','');
                        select.add(option);
                        select.value = fontName;
                        state.font = fontName;
                        committedFont = fontName;
                        updateCustomDropdown();
                        setupCustomDropdown();
                        requestUpdate();
                    }
                } catch(err) {
                    showToast(translations[currentLang].msg_import_err, true);
                }
            };
            reader.readAsText(file);
        });
        
        const sInput = document.getElementById('svg-file-input');
        if(sInput) sInput.addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                state.svgContent = e.target.result;
                state.svgName = file.name.replace(/\.svg$/i, '');
                updateModel();
            };
            reader.readAsText(file);
        });
        const bClearSvg = document.getElementById('btn-clear-svg');
        if(bClearSvg) bClearSvg.addEventListener('click', () => {
            state.svgContent = null;
            state.svgName = null;
            if(sInput) sInput.value = '';
            
            // Re-enable text when SVG is cleared
            state.enableText = true;
            const enableTextCheckbox = document.getElementById('enable-text');
            if (enableTextCheckbox) enableTextCheckbox.checked = true;
            const simpleEnableTextCheckbox = document.getElementById('simple-enable-text');
            if (simpleEnableTextCheckbox) simpleEnableTextCheckbox.checked = true;
            
            updateModel();
        });
        
        const getFileName = () => {
            const el = document.getElementById('export-name');
            const base = el ? (el.value || 'keycap') : 'keycap';
            const suffix = state.text ? `_[${state.text.replace(/\n/g,'_')}]` : '';
            return base + suffix;
        };
        const saveBlob = (blob, name) => {
            if (typeof saveAs !== 'undefined') {
                saveAs(blob, name);
            } else {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = name;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
            }
        };
        
        const exportSTL = (suff) => {
            const t = translations[currentLang];
            showToast(t.toast_generating);
            setTimeout(() => {
                const { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
                
                const clone = new THREE.Group();
                if (bodyGeo) clone.add(new THREE.Mesh(bodyGeo, new THREE.MeshBasicMaterial()));
                if (textGeo) clone.add(new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial()));
                if (importedGeo) clone.add(new THREE.Mesh(importedGeo, new THREE.MeshBasicMaterial()));
                
                const res = new STLExporter().parse(clone, {binary:true});
                saveBlob(new Blob([res], {type:'application/octet-stream'}), getFileName()+suff);
                showToast(t.toast_stl_exported);
            }, 100);
        };
        
        const exportOBJ = () => {
            const t = translations[currentLang];
            showToast(t.toast_generating);
            setTimeout(() => {
                const { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
                
                const clone = new THREE.Group();
                if (bodyGeo) {
                    const mesh = new THREE.Mesh(bodyGeo, new THREE.MeshBasicMaterial({ color: state.colBody }));
                    mesh.name = "KeycapBody";
                    clone.add(mesh);
                }
                if (textGeo) {
                    const mesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial({ color: state.colText }));
                    mesh.name = "KeycapText";
                    clone.add(mesh);
                }
                if (importedGeo) {
                    const mesh = new THREE.Mesh(importedGeo, new THREE.MeshBasicMaterial({ color: state.colText }));
                    mesh.name = "ImportedModel";
                    clone.add(mesh);
                }
                
                const res = new OBJExporter().parse(clone);
                saveBlob(new Blob([res], {type:'text/plain'}), getFileName() + '.obj');
                showToast(t.toast_obj_exported);
            }, 100);
        };
        
        // Export Confirmation Popup
        function showExportPopup(options) {
            return new Promise((resolve) => {
                const overlay = document.getElementById('export-popup-overlay');
                const popup = document.getElementById('export-popup');
                const formatEl = document.getElementById('export-popup-format');
                const previewEl = document.getElementById('export-popup-preview');
                const infoEl = document.getElementById('export-popup-info');
                const confirmBtn = document.getElementById('export-popup-confirm');
                const cancelBtn = document.getElementById('export-popup-cancel');
                
                // Set format badge - match button colors
                formatEl.textContent = options.format || 'STL';
                if (options.format === '3MF') {
                    formatEl.style.background = '#4caf50'; // Green for 3MF (matches button)
                } else if (options.format === 'OBJ') {
                    formatEl.style.background = '#ff9800'; // Orange for OBJ
                } else {
                    formatEl.style.background = '#4fc3f7'; // Cyan for STL
                }
                
                // Generate preview thumbnail with auto-fit camera
                previewEl.innerHTML = '';
                try {
                    const thumbRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                    // Larger canvas for sprue kit and tolerance test
                    const canvasW = (options.type === 'sprue' || options.type === 'tolerance') ? 380 : 300;
                    const canvasH = (options.type === 'sprue' || options.type === 'tolerance') ? 200 : 170;
                    thumbRenderer.setSize(canvasW, canvasH);
                    thumbRenderer.setClearColor(0x0a0a15, 1);
                    
                    const thumbScene = new THREE.Scene();
                    const thumbCam = new THREE.PerspectiveCamera(35, canvasW/canvasH, 0.1, 5000);
                    
                    thumbScene.add(new THREE.AmbientLight(0xffffff, 0.6));
                    const dLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    dLight.position.set(10, 20, 10);
                    thumbScene.add(dLight);
                    
                    // Create a group to hold preview meshes
                    const previewGroup = new THREE.Group();
                    
                    // Check if sprue preview geometry is provided
                    if (options.spruePreviewGeos && options.spruePreviewGeos.length > 0) {
                        options.spruePreviewGeos.forEach(geo => {
                            const mesh = new THREE.Mesh(
                                geo,
                                new THREE.MeshStandardMaterial({ color: new THREE.Color(state.colBody) })
                            );
                            previewGroup.add(mesh);
                        });
                    } else if (options.type === 'tolerance') {
                        // Generate simple preview for tolerance test kit
                        const spacing = 12;
                        const stemHeight = 4.0;
                        const stemRadius = 5.50 / 2;
                        const baseHeight = 1.5;
                        const baseSize = 9.0;
                        const previewMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
                        
                        for (let i = 0; i < 5; i++) {
                            const xPos = (i - 2) * spacing;
                            // Stem cylinder
                            const stemGeo = new THREE.CylinderGeometry(stemRadius, stemRadius, stemHeight, 16);
                            stemGeo.translate(xPos, stemHeight / 2 + baseHeight, 0);
                            previewGroup.add(new THREE.Mesh(stemGeo, previewMaterial));
                            // Base
                            const baseGeo = new THREE.BoxGeometry(baseSize, baseHeight, baseSize);
                            baseGeo.translate(xPos, baseHeight / 2, 0);
                            previewGroup.add(new THREE.Mesh(baseGeo, previewMaterial));
                        }
                    } else {
                        // Use mainGroup for single keycap
                        mainGroup.children.forEach(child => {
                            if (child.geometry) {
                                const cloneMesh = new THREE.Mesh(
                                    child.geometry.clone(),
                                    child.material.clone()
                                );
                                previewGroup.add(cloneMesh);
                            }
                        });
                    }
                    
                    thumbScene.add(previewGroup);
                    
                    // Calculate bounding box and auto-fit camera
                    const box = new THREE.Box3().setFromObject(previewGroup);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = thumbCam.fov * (Math.PI / 180);
                    let cameraDistance = maxDim / (2 * Math.tan(fov / 2));
                    
                    // Adjust camera based on model type
                    if (options.type === 'sprue') {
                        // For sprue kit: top-down angled view to see grid layout
                        cameraDistance *= 1.3; // Tighter fit for sprue
                        thumbCam.position.set(
                            center.x + cameraDistance * 0.4,
                            center.y + cameraDistance * 0.9, // Higher angle
                            center.z + cameraDistance * 0.5
                        );
                    } else if (options.type === 'tolerance') {
                        // For tolerance test: front-angled view to see all stems
                        cameraDistance *= 1.4;
                        thumbCam.position.set(
                            center.x + cameraDistance * 0.3,
                            center.y + cameraDistance * 0.6,
                            center.z + cameraDistance * 0.8
                        );
                    } else {
                        // For single keycap: standard 3/4 view
                        cameraDistance *= 1.6;
                        thumbCam.position.set(
                            center.x + cameraDistance * 0.7,
                            center.y + cameraDistance * 0.5,
                            center.z + cameraDistance * 0.7
                        );
                    }
                    thumbCam.lookAt(center);
                    
                    thumbRenderer.render(thumbScene, thumbCam);
                    previewEl.appendChild(thumbRenderer.domElement);
                    thumbRenderer.dispose();
                } catch(e) {
                    console.error('Preview error:', e);
                    previewEl.innerHTML = '<div style="color:#666;">Preview unavailable</div>';
                }
                
                // Build info items
                let infoHTML = '';
                const t = translations[currentLang];
                
                if (options.type === 'sprue') {
                    // Sprue kit info
                    const printerNames = {
                        'x1p1a1': 'X1/P1/A1', 'a1mini': 'A1 mini', 'h2d': 'H2D',
                        'h2s': 'H2S', 'h2c': 'H2C', 'unlimited': t.sprue_unlimited || 'Âà∂Èôê„Å™„Åó'
                    };
                    infoHTML += `
                        <div class="export-info-item"><span class="export-info-label">${t.popup_printer || '„Éó„É™„É≥„Çø„Éº'}</span><span class="export-info-value highlight">${printerNames[options.printer] || options.printer}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_build_size || 'ÈÄ†ÂΩ¢„Çµ„Ç§„Ç∫'}</span><span class="export-info-value">${options.buildSize || '-'}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_key_count || '„Ç≠„ÉºÊï∞'}</span><span class="export-info-value highlight">${options.keyCount}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_layout || 'ÈÖçÁΩÆ'}</span><span class="export-info-value">${options.layout || '-'}</span></div>
                        <div class="export-info-item export-info-full"><span class="export-info-label">${t.popup_char_list || 'ÊñáÂ≠ó„É™„Çπ„Éà'}</span><span class="export-info-value">${options.charList || '-'}</span></div>
                    `;
                } else if (options.type === 'batch') {
                    // Batch export info
                    infoHTML += `
                        <div class="export-info-item"><span class="export-info-label">${t.popup_format || 'Âá∫ÂäõÂΩ¢Âºè'}</span><span class="export-info-value highlight">${options.format}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_file_count || '„Éï„Ç°„Ç§„É´Êï∞'}</span><span class="export-info-value highlight">${options.fileCount}</span></div>
                        <div class="export-info-item export-info-full"><span class="export-info-label">${t.popup_char_list || 'ÊñáÂ≠ó„É™„Çπ„Éà'}</span><span class="export-info-value">${options.charList || '-'}</span></div>
                    `;
                } else if (options.type === 'tolerance') {
                    // Tolerance test kit info
                    const labels = [];
                    for (let i = 0; i < options.count; i++) {
                        labels.push((options.startVal + (options.stepVal * i)).toFixed(2));
                    }
                    infoHTML += `
                        <div class="export-info-item"><span class="export-info-label">${t.popup_format || 'Âá∫ÂäõÂΩ¢Âºè'}</span><span class="export-info-value highlight">${options.format}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_tol_start || 'ÈñãÂßãÂÄ§'}</span><span class="export-info-value highlight">${options.startVal.toFixed(2)} mm</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_tol_step || 'Âàª„Åø'}</span><span class="export-info-value highlight">${options.stepVal.toFixed(2)} mm</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_tol_count || 'ÁîüÊàêÊï∞'}</span><span class="export-info-value">${options.count} ${currentLang === 'en' ? 'stems' : 'ÂÄã'}</span></div>
                        <div class="export-info-item export-info-full"><span class="export-info-label">${t.popup_tol_values || '„ÇØ„É™„Ç¢„É©„É≥„ÇπÂÄ§'}</span><span class="export-info-value">${labels.join(', ')} mm</span></div>
                    `;
                } else {
                    // Single keycap export
                    const weight = document.getElementById('info-weight')?.textContent || '0.00';
                    const cost = document.getElementById('info-cost')?.textContent || '0';
                    const currency = document.getElementById('info-currency')?.textContent || '¬•';
                    const vendor = document.getElementById('fil-vendor')?.options[document.getElementById('fil-vendor')?.selectedIndex]?.text || '-';
                    const material = document.getElementById('fil-material')?.options[document.getElementById('fil-material')?.selectedIndex]?.text || '-';
                    
                    // Get keycap info
                    const profileNames = { cherry: 'Cherry', dsa: 'DSA', sa: 'SA', oem: 'OEM', xda: 'XDA', kat: 'KAT', custom: 'Custom' };
                    const profile = profileNames[state.profile] || state.profile;
                    const size = `${state.uSize}U (${(state.unitSize * state.uSize).toFixed(1)}mm)`;
                    const row = state.row; // Already 'R3' format
                    
                    // Get text from input fields (check both simple and detailed mode)
                    // Only show text if enableText is true
                    let textDisplay = '-';
                    if (state.enableText) {
                        const simpleTextEl = document.getElementById('simple-text-content');
                        const detailedTextEl = document.getElementById('text-content');
                        let currentText = '';
                        if (simpleTextEl && simpleTextEl.value) {
                            currentText = simpleTextEl.value;
                        } else if (detailedTextEl && detailedTextEl.value) {
                            currentText = detailedTextEl.value;
                        } else {
                            currentText = state.text || '';
                        }
                        textDisplay = currentText || '-';
                    }
                    
                    // SVG info
                    let svgInfo = '-';
                    if (state.svgVisible && state.svgContent) {
                        svgInfo = state.svgName || (currentLang === 'en' ? 'Custom SVG' : '„Ç´„Çπ„Çø„É†SVG');
                    }
                    
                    infoHTML += `
                        <div class="export-info-item"><span class="export-info-label">${t.popup_est_weight || '‰∫àÊÉ≥ÈáçÈáè'}</span><span class="export-info-value highlight">${weight} g</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_est_cost || '‰∫àÊÉ≥„Ç≥„Çπ„Éà'}</span><span class="export-info-value highlight">${currency} ${cost}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_vendor || '„Éô„É≥„ÉÄ„Éº'}</span><span class="export-info-value">${vendor}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_material || 'ÊùêÊñô'}</span><span class="export-info-value">${material}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_profile || '„Éó„É≠„Éï„Ç°„Ç§„É´'}</span><span class="export-info-value">${profile}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_size || '„Çµ„Ç§„Ç∫'}</span><span class="export-info-value">${size}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_row || 'Ë°å'}</span><span class="export-info-value">${row}</span></div>
                        <div class="export-info-item"><span class="export-info-label">${t.popup_text || 'ÊñáÂ≠ó'}</span><span class="export-info-value">${textDisplay}</span></div>
                        <div class="export-info-item export-info-full"><span class="export-info-label">${t.popup_svg_icon || 'SVG„Ç¢„Ç§„Ç≥„É≥'}</span><span class="export-info-value">${svgInfo}</span></div>
                    `;
                }
                
                infoEl.innerHTML = infoHTML;
                
                // Show popup with animation
                overlay.style.display = 'flex';
                requestAnimationFrame(() => {
                    overlay.style.background = 'rgba(0,0,0,0.7)';
                    popup.classList.add('show');
                });
                
                // Cleanup function
                const cleanup = () => {
                    overlay.style.background = 'rgba(0,0,0,0)';
                    popup.classList.remove('show');
                    setTimeout(() => {
                        overlay.style.display = 'none';
                    }, 300);
                    confirmBtn.onclick = null;
                    cancelBtn.onclick = null;
                };
                
                confirmBtn.onclick = () => {
                    cleanup();
                    resolve(true);
                };
                
                cancelBtn.onclick = () => {
                    cleanup();
                    resolve(false);
                };
                
                // Close on overlay click
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        cleanup();
                        resolve(false);
                    }
                };
            });
        }
        
        const bExpAll = document.getElementById('btn-export-all');
        if(bExpAll) bExpAll.addEventListener('click', async () => {
            const confirmed = await showExportPopup({ type: 'single', format: 'STL' });
            if (confirmed) exportSTL('.stl');
        });
        const bExpBody = document.getElementById('btn-export-body');
        if(bExpBody) bExpBody.addEventListener('click', ()=>exportSTL('_body.stl'));
        const bExpText = document.getElementById('btn-export-text');
        if(bExpText) bExpText.addEventListener('click', ()=>exportSTL('_text_svg.stl'));
        const bExpObj = document.getElementById('btn-export-obj');
        if(bExpObj) bExpObj.addEventListener('click', async () => {
            const confirmed = await showExportPopup({ type: 'single', format: 'OBJ' });
            if (confirmed) exportOBJ();
        });
        const bExp3MF = document.getElementById('btn-export-3mf');
        if(bExp3MF) bExp3MF.addEventListener('click', async () => {
            const confirmed = await showExportPopup({ type: 'single', format: '3MF' });
            if (confirmed) export3MF();
        });
        
        const STORAGE_KEY = 'keycap_gen_v63_preset';
        document.getElementById('btn-quick-save').addEventListener('click', () => {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            showToast(translations[currentLang].msg_save_ok);
        });
        document.getElementById('btn-quick-load').addEventListener('click', () => {
            const data = localStorage.getItem(STORAGE_KEY);
            if(data) {
                state = JSON.parse(data);
                syncUI();
                updateCustomDropdown();
                requestUpdate();
                commitHistory();
                showToast(translations[currentLang].msg_load_ok);
            } else {
                showToast(translations[currentLang].msg_load_err, true);
            }
        });
        document.getElementById('btn-export-preset').addEventListener('click', () => {
            const blob = new Blob([JSON.stringify(state, null, 2)], {type: "application/json"});
            saveBlob(blob, "keycap_preset.json");
        });
        
        document.getElementById('btn-save-named-preset').addEventListener('click', () => {
            const name = document.getElementById('preset-save-name').value || 'Preset_' + Date.now();
            const presetData = { name: name, data: {...state, svgName: state.svgName || null}, version: 'V64' };
            const blob = new Blob([JSON.stringify(presetData, null, 2)], {type: "application/json"});
            saveBlob(blob, `${name}.json`);
            showToast(translations[currentLang].msg_save_ok);
        });
        
        document.getElementById('btn-share-url').addEventListener('click', () => {
            try {
                const diffState = {};
                for(const key in state) {
                    if(JSON.stringify(state[key]) !== JSON.stringify(initialState[key])) {
                        diffState[key] = state[key];
                    }
                }
                const json = JSON.stringify(diffState);
                const compressed = LZString.compressToEncodedURIComponent(json);
                const url = window.location.origin + window.location.pathname + '?s=' + compressed;
                
                if(url.length > 8000) {
                    showToast('URL„ÅåÈï∑„Åô„Åé„Åæ„Åô„ÄÇË®≠ÂÆö„ÇíÊ∏õ„Çâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', true);
                    return;
                }
                
                navigator.clipboard.writeText(url).then(() => {
                    showToast(translations[currentLang].msg_url_copied || 'URL„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ');
                });
            } catch(e) {
                console.error('URL share error:', e);
                showToast('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü', true);
            }
        });
        
        document.getElementById('btn-share-x').addEventListener('click', () => {
            try {
                const diffState = {};
                for(const key in state) {
                    if(JSON.stringify(state[key]) !== JSON.stringify(initialState[key])) {
                        diffState[key] = state[key];
                    }
                }
                const json = JSON.stringify(diffState);
                const compressed = LZString.compressToEncodedURIComponent(json);
                const shareUrl = window.location.origin + window.location.pathname + '?s=' + compressed;
                
                if(shareUrl.length > 8000) {
                    showToast('URL„ÅåÈï∑„Åô„Åé„Åæ„Åô„ÄÇË®≠ÂÆö„ÇíÊ∏õ„Çâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', true);
                    return;
                }
                
                const profileNames = { cherry: 'CHERRY', oem: 'OEM', sa: 'SA', xda: 'XDA', dsa: 'DSA', custom: 'CUSTOM' };
                const shapeNames = { rectangle: 'rectangle', rounded: 'rounded', circle: 'circle', polygon: 'polygon', star: 'star', 'iso-enter': 'iso-enter' };
                
                const profileDisplay = profileNames[state.profile] || state.profile.toUpperCase();
                const shapeDisplay = shapeNames[state.keyShapeType] || state.keyShapeType;
                const rowDisplay = state.row;
                
                let tweetText;
                if(currentLang === 'en') {
                    tweetText = `I generated my own keycap in 3D! ‚å®Ô∏è‚ú®
üîπProfile: ${profileDisplay} üîπShape: ${shapeDisplay} üîπRow: ${rowDisplay}
3D modeling tool that runs in your browser üëá
${shareUrl}
#KCGN #CustomKeyboard #3DPrinting`;
                } else {
                    tweetText = `Ëá™ÂàÜ„Å†„Åë„ÅÆ„Ç≠„Éº„Ç≠„É£„ÉÉ„Éó„Çí3DÁîüÊàê„Åó„Åæ„Åó„Åü!‚å®Ô∏è‚ú®
üîπProfile: ${profileDisplay} üîπShape: ${shapeDisplay} üîπRow: ${rowDisplay}
„Éñ„É©„Ç¶„Ç∂„ÅßÂãï„Åè3D„É¢„Éá„É™„É≥„Ç∞„ÉÑ„Éº„É´ üëá
${shareUrl}
#KCGN #Ëá™‰Ωú„Ç≠„Éº„Éú„Éº„Éâ #3D„Éó„É™„É≥„Çø„Éº`;
                }
                
                const xUrl = 'https://twitter.com/intent/tweet?text=' + encodeURIComponent(tweetText);
                window.open(xUrl, '_blank', 'width=550,height=420');
                showToast(translations[currentLang].msg_x_shared || 'X(Twitter)„ÅÆÊäïÁ®øÁîªÈù¢„ÇíÈñã„Åç„Åæ„Åó„Åü');
            } catch(e) {
                console.error('X share error:', e);
                showToast('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü', true);
            }
        });
        
        document.getElementById('btn-import-url').addEventListener('click', () => {
            const input = document.getElementById('url-import-input');
            const urlStr = input.value.trim();
            if(!urlStr) return;
            
            try {
                const urls = urlStr.split(/[\n\r]+/).filter(u => u.trim());
                let loaded = 0;
                
                urls.forEach((u, idx) => {
                    const url = new URL(u.trim());
                    const encoded = url.searchParams.get('s');
                    if(encoded) {
                        const json = LZString.decompressFromEncodedURIComponent(encoded);
                        const data = JSON.parse(json);
                        
                        const presetName = 'URL_' + (Date.now() + idx);
                        loadedPresets.push({ name: presetName, data: {...initialState, ...data}, version: 'V64' });
                        loaded++;
                    }
                });
                
                if(loaded > 0) {
                    currentPresetIndex = loadedPresets.length - 1;
                    updatePresetFloatPanel();
                    updatePresetSwitcher();
                    applyPresetByIndex(currentPresetIndex);
                    showToast((translations[currentLang].msg_url_loaded || 'URL„Åã„ÇâË™≠„ÅøËæº„Åø„Åæ„Åó„Åü') + ` (${loaded}‰ª∂)`);
                    input.value = '';
                } else {
                    showToast(translations[currentLang].msg_url_invalid || 'ÁÑ°Âäπ„Å™URL„Åß„Åô', true);
                }
            } catch(e) {
                console.error('URL import error:', e);
                showToast(translations[currentLang].msg_url_invalid || 'ÁÑ°Âäπ„Å™URL„Åß„Åô', true);
            }
        });
        
        function loadFromURLParams() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const encoded = urlParams.get('s');
                if(encoded) {
                    const json = LZString.decompressFromEncodedURIComponent(encoded);
                    const data = JSON.parse(json);
                    Object.assign(state, data);
                    syncUI();
                    updateCustomDropdown();
                    requestUpdate();
                    commitHistory();
                    showToast('URL„Åã„Çâ„Éó„É™„Çª„ÉÉ„Éà„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü');
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            } catch(e) {
                console.error('Auto URL load error:', e);
            }
        }
        setTimeout(loadFromURLParams, 500);
        
        document.getElementById('btn-show-presets').addEventListener('click', () => {
            const dropdown = document.getElementById('preset-dropdown');
            dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
        });
        
        document.getElementById('btn-remove-preset').addEventListener('click', removeCurrentPreset);
        document.getElementById('btn-remove-preset-ui').addEventListener('click', removeCurrentPreset);
        
        function removeCurrentPreset() {
            if(loadedPresets.length === 0 || currentPresetIndex < 0) return;
            loadedPresets.splice(currentPresetIndex, 1);
            if(loadedPresets.length === 0) {
                currentPresetIndex = -1;
            } else if(currentPresetIndex >= loadedPresets.length) {
                currentPresetIndex = loadedPresets.length - 1;
            }
            updatePresetFloatPanel();
            updatePresetSwitcher();
            if(currentPresetIndex >= 0) {
                applyPresetByIndex(currentPresetIndex);
            }
            showToast('„Éó„É™„Çª„ÉÉ„Éà„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü');
        }
        
        document.getElementById('btn-clear-all-presets').addEventListener('click', () => {
            if(loadedPresets.length === 0) return;
            if(confirm('„Åô„Åπ„Å¶„ÅÆ„Éó„É™„Çª„ÉÉ„Éà„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åô„ÅãÔºü')) {
                loadedPresets = [];
                currentPresetIndex = -1;
                updatePresetFloatPanel();
                updatePresetSwitcher();
                showToast('„Åô„Åπ„Å¶„ÅÆ„Éó„É™„Çª„ÉÉ„Éà„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åó„Åü');
            }
        });
        
        document.getElementById('btn-prev-preset').addEventListener('click', () => {
            if(loadedPresets.length > 0 && currentPresetIndex > 0) {
                currentPresetIndex--;
                applyPresetByIndex(currentPresetIndex);
            }
        });
        
        document.getElementById('btn-next-preset').addEventListener('click', () => {
            if(loadedPresets.length > 0 && currentPresetIndex < loadedPresets.length - 1) {
                currentPresetIndex++;
                applyPresetByIndex(currentPresetIndex);
            }
        });
        
        function applyPresetByIndex(idx) {
            if(idx < 0 || idx >= loadedPresets.length) return;
            Object.assign(state, loadedPresets[idx].data);
            syncUI();
            updateCustomDropdown();
            requestUpdate();
            commitHistory();
            document.getElementById('preset-switcher-float').value = idx;
            updatePresetFloatPreview(idx);
            const uiSwitcher = document.getElementById('preset-switcher');
            if(uiSwitcher) uiSwitcher.value = idx;
            updatePresetPreview(idx);
        }
        
        document.getElementById('preset-file-input').addEventListener('change', async (e) => {
            const files = e.target.files;
            if(!files || files.length === 0) return;
            
            let addedCount = 0;
            
            for(const file of files) {
                try {
                    const text = await file.text();
                    const json = JSON.parse(text);
                    
                    if(json.data && json.name) {
                        loadedPresets.push({ name: json.name, data: json.data });
                    } else {
                        loadedPresets.push({ name: file.name.replace('.json',''), data: json });
                    }
                    addedCount++;
                } catch(err) {
                    console.warn('Failed to load preset:', file.name, err);
                }
            }
            
            if(addedCount > 0) {
                if(currentPresetIndex < 0) {
                    currentPresetIndex = 0;
                    Object.assign(state, loadedPresets[0].data);
                    syncUI();
                    updateCustomDropdown();
                    requestUpdate();
                    commitHistory();
                }
                updatePresetFloatPanel();
                updatePresetSwitcher();
                showToast(addedCount + 'ÂÄã„ÅÆ„Éó„É™„Çª„ÉÉ„Éà„ÇíËøΩÂä†„Åó„Åæ„Åó„ÅüÔºàÂêàË®à: ' + loadedPresets.length + 'Ôºâ');
            } else {
                showToast(translations[currentLang].msg_import_err, true);
            }
            
            e.target.value = '';
        });
        
        document.getElementById('preset-switcher-float').addEventListener('change', (e) => {
            const idx = parseInt(e.target.value);
            if(idx >= 0 && idx < loadedPresets.length) {
                currentPresetIndex = idx;
                applyPresetByIndex(idx);
            }
        });
        
        function updatePresetFloatPanel() {
            const switcher = document.getElementById('preset-switcher-float');
            const btn = document.getElementById('btn-show-presets');
            const countSpan = document.getElementById('preset-count');
            switcher.innerHTML = '';
            
            if(loadedPresets.length === 0) {
                btn.style.display = 'none';
                document.getElementById('preset-dropdown').style.display = 'none';
                return;
            }
            
            btn.style.display = 'block';
            countSpan.textContent = loadedPresets.length;
            
            loadedPresets.forEach((preset, idx) => {
                const opt = document.createElement('option');
                opt.value = idx;
                opt.textContent = (idx + 1) + '. ' + (preset.name || `Preset ${idx + 1}`);
                switcher.appendChild(opt);
            });
            
            if(currentPresetIndex >= 0 && currentPresetIndex < loadedPresets.length) {
                switcher.value = currentPresetIndex;
                updatePresetFloatPreview(currentPresetIndex);
            }
        }
        
        function updatePresetFloatPreview(idx) {
            if(idx < 0 || idx >= loadedPresets.length) return;
            const preset = loadedPresets[idx].data;
            const shapeNames = {
                'rectangle': 'ÂõõËßíÂΩ¢', 'rounded': 'Ëßí‰∏∏', 'circle': 'ÂÜÜÂΩ¢',
                'polygon': 'Â§öËßíÂΩ¢', 'star': 'ÊòüÂΩ¢', 'iso-enter': 'ISO Enter'
            };
            document.getElementById('pf-profile').textContent = preset.profile || 'cherry';
            document.getElementById('pf-size').textContent = (preset.uSize || 1) + 'U';
            document.getElementById('pf-shape').textContent = shapeNames[preset.keyShapeType] || 'ÂõõËßíÂΩ¢';
            document.getElementById('pf-text').textContent = preset.text || '-';
        }
        
        document.getElementById('preset-switcher').addEventListener('change', (e) => {
            const idx = parseInt(e.target.value);
            if(idx >= 0 && idx < loadedPresets.length) {
                currentPresetIndex = idx;
                applyPresetByIndex(idx);
            }
        });
        
        function updatePresetSwitcher() {
            const switcher = document.getElementById('preset-switcher');
            const panel = document.getElementById('preset-switch-panel');
            switcher.innerHTML = '';
            
            if(loadedPresets.length === 0) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            loadedPresets.forEach((preset, idx) => {
                const opt = document.createElement('option');
                opt.value = idx;
                opt.textContent = (idx + 1) + '. ' + (preset.name || `Preset ${idx + 1}`);
                switcher.appendChild(opt);
            });
            
            if(currentPresetIndex >= 0 && currentPresetIndex < loadedPresets.length) {
                switcher.value = currentPresetIndex;
                updatePresetPreview(currentPresetIndex);
            }
        }
        
        function updatePresetPreview(idx) {
            const preview = document.getElementById('preset-preview-mini');
            if(idx < 0 || idx >= loadedPresets.length) {
                const els = ['pm-profile', 'pm-size', 'pm-shape', 'pm-text', 'pm-text2', 'pm-side', 'pm-svg'];
                els.forEach(id => { const el = document.getElementById(id); if(el) el.textContent = '-'; });
                return;
            }
            const preset = loadedPresets[idx].data;
            
            const pmProfile = document.getElementById('pm-profile');
            if(pmProfile) pmProfile.textContent = preset.profile || 'cherry';
            
            const pmSize = document.getElementById('pm-size');
            if(pmSize) pmSize.textContent = (preset.uSize || 1) + 'U';
            
            const pmShape = document.getElementById('pm-shape');
            if(pmShape) pmShape.textContent = preset.keyShapeType || 'rectangle';
            
            const pmText = document.getElementById('pm-text');
            if(pmText) {
                if(preset.enableText === false) {
                    pmText.textContent = 'N/A';
                } else {
                    pmText.textContent = preset.text || '-';
                }
            }
            
            const pmText2 = document.getElementById('pm-text2');
            if(pmText2) {
                if(preset.enableText2 === false) {
                    pmText2.textContent = 'N/A';
                } else {
                    pmText2.textContent = preset.text2 || '-';
                }
            }
            
            const pmSide = document.getElementById('pm-side');
            if(pmSide) {
                if(preset.enableSide === false) {
                    pmSide.textContent = 'N/A';
                } else {
                    pmSide.textContent = preset.sideText || '-';
                }
            }
            
            const pmSvg = document.getElementById('pm-svg');
            if(pmSvg) {
                if(preset.svgVisible === false || !preset.svgContent) {
                    pmSvg.textContent = 'N/A';
                } else {
                    pmSvg.textContent = preset.svgName || 'Loaded';
                }
            }
            
            updateFloatPreview(preset);
        }
        
        function updateFloatPreview(preset) {
            const pfProfile = document.getElementById('pf-profile');
            const pfSize = document.getElementById('pf-size');
            const pfShape = document.getElementById('pf-shape');
            const pfText = document.getElementById('pf-text');
            const pfText2 = document.getElementById('pf-text2');
            const pfSide = document.getElementById('pf-side');
            const pfSvg = document.getElementById('pf-svg');
            
            if(pfProfile) pfProfile.textContent = preset.profile || 'cherry';
            if(pfSize) pfSize.textContent = (preset.uSize || 1) + 'U';
            if(pfShape) pfShape.textContent = preset.keyShapeType || 'rectangle';
            if(pfText) {
                if(preset.enableText === false) {
                    pfText.textContent = 'N/A';
                } else {
                    pfText.textContent = preset.text || '-';
                }
            }
            if(pfText2) {
                if(preset.enableText2 === false) {
                    pfText2.textContent = 'N/A';
                } else {
                    pfText2.textContent = preset.text2 || '-';
                }
            }
            if(pfSide) {
                if(preset.enableSide === false) {
                    pfSide.textContent = 'N/A';
                } else {
                    pfSide.textContent = preset.sideText || '-';
                }
            }
            if(pfSvg) {
                if(preset.svgVisible === false || !preset.svgContent) {
                    pfSvg.textContent = 'N/A';
                } else {
                    pfSvg.textContent = preset.svgName || 'Loaded';
                }
            }
        }
        
        async function runBatchExport() {
            const t = translations[currentLang];
            const raw = document.getElementById('batch-list').value;
            const list = raw.split(/[\n,]+/).map(s => s.trim()).filter(s => s);
            if(list.length === 0) { showToast(t.msg_batch_empty, true); return; }
            
            const format = document.getElementById('batch-format').value;
            
            const originalText = state.text;
            const loading = document.getElementById('loading');
            const progress = document.getElementById('batch-progress');
            loading.style.display = 'flex';
            progress.style.display = 'block';
            
            const baseName = document.getElementById('export-name').value || 'keycap';
            
            try {
                for(let i=0; i<list.length; i++) {
                    const char = list[i];
                    progress.textContent = `${t.batch_processing} ${char} (${i+1}/${list.length})`;
                    state.text = char;
                    
                    await new Promise(r => setTimeout(r, 100));
                    
                    const { bodyGeo, textGeo, importedGeo } = buildExportGeometry();
                    const safeChar = char.replace(/[\\/:*?"<>|]/g, '_');
                    
                    if (format === 'stl') {
                        const clone = new THREE.Group();
                        if (bodyGeo) clone.add(new THREE.Mesh(bodyGeo, new THREE.MeshBasicMaterial()));
                        if (textGeo) clone.add(new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial()));
                        if (importedGeo) clone.add(new THREE.Mesh(importedGeo, new THREE.MeshBasicMaterial()));
                        
                        const stlData = new STLExporter().parse(clone, {binary:true});
                        const fileName = `${baseName}_[${safeChar}].stl`;
                        saveBlob(new Blob([stlData], {type:'application/octet-stream'}), fileName);
                    } else {
                        const fileData = await generate3MFData(bodyGeo, textGeo, importedGeo);
                        const fileName = `${baseName}_[${safeChar}].3mf`;
                        saveBlob(fileData, fileName);
                    }
                    
                    await new Promise(r => setTimeout(r, 300));
                }
                
                progress.textContent = t.batch_complete;
                await new Promise(r => setTimeout(r, 1000));
            } finally {
                state.text = originalText;
                syncUI();
                requestUpdate();
                loading.style.display = 'none';
                progress.style.display = 'none';
            }
        }
        
        async function generate3MFData(bodyGeo, textGeo, importedGeo) {
            const zip = new JSZip();
            
            function geoTo3MFMesh(geometry) {
                if (!geometry) return null;
                let geo = geometry.clone();
                if (!geo.index) {
                    geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
                }
                const position = geo.attributes.position;
                if (!position) return null;
                
                const vertices = [];
                const triangles = [];
                const index = geo.index;
                
                if (index && index.array) {
                    for (let i = 0; i < position.count; i++) {
                        vertices.push(`      <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                    }
                    const indexArray = index.array;
                    for (let i = 0; i < indexArray.length; i += 3) {
                        triangles.push(`      <triangle v1="${indexArray[i]}" v2="${indexArray[i+1]}" v3="${indexArray[i+2]}" />`);
                    }
                } else {
                    for (let i = 0; i < position.count; i++) {
                        vertices.push(`      <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                    }
                    for (let i = 0; i < position.count; i += 3) {
                        triangles.push(`      <triangle v1="${i}" v2="${i+1}" v3="${i+2}" />`);
                    }
                }
                return { vertices, triangles };
            }
            
            let modelXml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02" xmlns:m="http://schemas.microsoft.com/3dmanufacturing/material/2015/02">
  <metadata name="Application">Keycap Generator V64.0</metadata>
  <resources>
    <m:basematerials id="1">
      <m:base name="Body" displaycolor="#${state.colBody.slice(1).toUpperCase()}" />
      <m:base name="Text" displaycolor="#${state.colText.slice(1).toUpperCase()}" />
    </m:basematerials>`;
            
            let objectId = 2;
            let buildItems = '';
            
            if (bodyGeo) {
                const mesh = geoTo3MFMesh(bodyGeo);
                if (mesh) {
                    modelXml += `
    <object id="${objectId}" name="KeycapBody" type="model">
      <mesh>
        <vertices>
${mesh.vertices.join('\n')}
        </vertices>
        <triangles>
${mesh.triangles.map(t => t.replace('/>', ' pid="1" p1="0" />')).join('\n')}
        </triangles>
      </mesh>
    </object>`;
                    buildItems += `    <item objectid="${objectId}" />`;
                    objectId++;
                }
            }
            
            let combinedTextGeo = textGeo;
            if (importedGeo) {
                if (combinedTextGeo) {
                    combinedTextGeo = BufferGeometryUtils.mergeGeometries([combinedTextGeo, importedGeo]);
                    combinedTextGeo = BufferGeometryUtils.mergeVertices(combinedTextGeo, 0.0001);
                } else {
                    combinedTextGeo = importedGeo;
                }
            }
            
            if (combinedTextGeo) {
                const mesh = geoTo3MFMesh(combinedTextGeo);
                if (mesh) {
                    modelXml += `
    <object id="${objectId}" name="KeycapText" type="model">
      <mesh>
        <vertices>
${mesh.vertices.join('\n')}
        </vertices>
        <triangles>
${mesh.triangles.map(t => t.replace('/>', ' pid="1" p1="1" />')).join('\n')}
        </triangles>
      </mesh>
    </object>`;
                    buildItems += `\n    <item objectid="${objectId}" />`;
                }
            }
            
            modelXml += `
  </resources>
  <build>
${buildItems}
  </build>
</model>`;

            const contentTypes = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />
</Types>`;

            const rels = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>`;

            zip.file("[Content_Types].xml", contentTypes);
            zip.folder("_rels").file(".rels", rels);
            zip.folder("3D").file("3dmodel.model", modelXml);
            
            return await zip.generateAsync({ type: "blob", compression: "DEFLATE" });
        }
        
        document.getElementById('btn-batch-export').addEventListener('click', async () => {
            const raw = document.getElementById('batch-list').value;
            const list = raw.split(/[\n,]+/).map(s => s.trim()).filter(s => s);
            if(list.length === 0) { 
                showToast(translations[currentLang].msg_batch_empty, true); 
                return; 
            }
            const format = document.getElementById('batch-format').value.toUpperCase();
            const charListDisplay = list.length > 10 ? list.slice(0, 10).join(', ') + '...' : list.join(', ');
            
            const confirmed = await showExportPopup({ 
                type: 'batch', 
                format: format,
                fileCount: list.length,
                charList: charListDisplay
            });
            if (confirmed) runBatchExport();
        });
        
        const pSel = document.getElementById('profile-select');
        if(pSel) pSel.addEventListener('change', e => {
            const defs = {cherry:4.3, oem:5.0, sa:6.0, xda:2.5, dsa:2.5};
            if(defs[e.target.value]) {
                state.ribShorten = defs[e.target.value];
                document.getElementById('rib-shorten').value = state.ribShorten;
                document.getElementById('v-rib-shorten').textContent = state.ribShorten.toFixed(2);
                requestUpdate();
            }
        });
        
        const fStart = document.getElementById('force-start-btn');
        if(fStart) fStart.addEventListener('click', ()=>{
            document.getElementById('loading').style.display='none';
            requestUpdate();
        });
        
        (function initTooltipHints() {
            const tooltip = document.createElement('div');
            tooltip.className = 'hint-tooltip';
            tooltip.id = 'hint-tooltip';
            tooltip.innerHTML = `
                <div class="hint-video-area">
                    <div class="hint-video-placeholder">
                        <span>üìπ „ÉÜ„Çπ„ÉàÁîªÈù¢ / Test Video</span>
                    </div>
                </div>
                <span class="hint-text"></span>
                <div class="hint-f1-notice"></div>
            `;
            document.body.appendChild(tooltip);
            
            let hintEnabled = true;
            let hideTimeout = null;
            let videoDelayTimeout = null;
            let currentHintKey = null;
            const VIDEO_DELAY = 1500;
            
            const hintVideos = {
                hint_unit_size: { type: 'video', src: 'videos/Âü∫Êú¨„Éî„ÉÉ„ÉÅ.mp4' },
                hint_key_size: { type: 'video', src: 'videos/„Ç≠„Éº„Çµ„Ç§„Ç∫.mp4' },
                hint_stabilizer: { type: 'video', src: 'videos/„Çπ„Çø„Éì„É©„Ç§„Ç∂„Éº.mp4' },
                hint_profile: { type: 'video', src: 'videos/„Éó„É≠„Éï„Ç°„Ç§„É´.mp4' },
                hint_row: { type: 'video', src: 'videos/Ë°å.mp4' },
                hint_fillet: { type: 'video', src: 'videos/„Éï„Ç£„É¨„ÉÉ„Éà.mp4' },
                hint_wall_thick: { type: 'video', src: 'videos/Â£Å„ÅÆÂéö„Åø.mp4' },
                hint_rib_shorten: { type: 'video', src: 'videos/„É™„ÉñÁü≠Á∏Æ.mp4' },
                hint_enable_ribs: { type: 'video', src: 'videos/Ë£úÂº∑„É™„Éñ.mp4' },
                hint_homing_bump: { type: 'video', src: 'videos/„Éõ„Éº„É†„Éù„Ç∏„Ç∑„Éß„É≥Á™ÅËµ∑.mp4' },
                hint_bump_type: { type: 'video', src: 'videos/„Éõ„Éº„É†„Éù„Ç∏„Ç∑„Éß„É≥Á™ÅËµ∑ÈÅ∏Êäû.mp4' },
                hint_key_shape: { type: 'video', src: 'videos/„Ç≠„ÉºÂΩ¢Áä∂„Çø„Ç§„Éó.mp4' },
                hint_taper: { type: 'video', src: 'videos/‰∏äÈù¢„Çµ„Ç§„Ç∫.mp4' },
                hint_dish_type: { type: 'video', src: 'videos/‰∏äÈù¢ÂΩ¢Áä∂.mp4' },
                hint_texture: { type: 'video', src: 'videos/Ë°®Èù¢„Éó„É≠„Ç∑„Éº„Ç∏„É£„É´.mp4' },
                hint_img_upload: { type: 'video', src: 'videos/ÁîªÂÉè„ÉÜ„ÇØ„Çπ„ÉÅ„É£.mp4' },
                hint_stem_diameter: { type: 'video', src: 'videos/„Çπ„ÉÜ„É†Â§ñÂæÑ.mp4' },
                hint_clearance: { type: 'video', src: 'videos/„ÇØ„É™„Ç¢„É©„É≥„Çπ.mp4' },
                hint_stem_ext: { type: 'video', src: 'videos/Èï∑„Åï„ÇíÊã°Âºµ.mp4' },
                hint_box_stem: { type: 'video', src: 'videos/boxstem.mp4' },
                hint_lego_stud: { type: 'video', src: 'videos/„É¨„Ç¥„Çπ„Çø„ÉÉ„Éâ.mp4' },
                hint_randomizer: { type: 'video', src: 'videos/„É©„É≥„ÉÄ„Éû„Ç§„Ç∂.mp4' },
                hint_import_stl: { type: 'video', src: 'videos/stlË™≠„ÅøËæº„Åø.mp4' },
                hint_enable_text: { type: 'video', src: 'videos/ÊñáÂ≠ó„ÇíÁîüÊàê„Åô„Çã.mp4' },
                hint_text_input: { type: 'video', src: 'videos/ÊñáÂ≠ó„ÉÜ„Ç≠„Çπ„Éà„Éú„ÉÉ„ÇØ„Çπ.mp4' },
                hint_font: { type: 'video', src: 'videos/„Éï„Ç©„É≥„Éà.mp4' },
                hint_custom_font: { type: 'video', src: 'videos/„Ç´„Çπ„Çø„É†„Éï„Ç©„É≥„Éà.mp4' },
                hint_text_mode: { type: 'video', src: 'videos/ÊñáÂ≠óÁîüÊàê„É¢„Éº„Éâ.mp4' },
                hint_align_preset: { type: 'video', src: 'videos/ÊñáÂ≠óÈÖçÁΩÆ„Éó„É™„Çª„ÉÉ„Éà„Éú„Çø„É≥.mp4' },
                hint_text2: { type: 'video', src: 'videos/„Çµ„ÉñÊñáÂ≠ó„Çπ„Ç§„ÉÉ„ÉÅ.mp4' },
                hint_side_print: { type: 'video', src: 'videos/„Çµ„Ç§„ÉâÂç∞Â≠ó„Çπ„Ç§„ÉÉ„ÉÅ.mp4' },
                hint_svg_upload: { type: 'video', src: 'videos/SVGË™≠„ÅøËæº„Åø.mp4' },
                hint_svg_mode: { type: 'video', src: 'videos/ÊñáÂ≠óÁîüÊàê„É¢„Éº„Éâ.mp4' },
                hint_colors: { type: 'video', src: 'videos/Ëâ≤Ë®≠ÂÆö.mp4' },
                hint_import_json: { type: 'video', src: 'videos/„Éó„É™„Çª„ÉÉ„ÉàË™≠„ÅøËæº„Åø.mp4' },
                // V66 Video Hints
                hint_dimension_lines: { type: 'video', src: 'videos/ÂØ∏Ê≥ïÁ∑ö„ÇíË°®Á§∫.mp4' },
                hint_stock_icons: { type: 'video', src: 'videos/ÂÜÖËîµ„Ç¢„Ç§„Ç≥„É≥SVG.mp4' },
                hint_simple_icon: { type: 'video', src: 'videos/ÂÜÖËîµ„Ç¢„Ç§„Ç≥„É≥SVG.mp4' },
                hint_visual_presets: { type: 'video', src: 'videos/„Éì„Ç∏„É•„Ç¢„É´„Éó„É™„Çª„ÉÉ„Éà.mp4' },
                hint_simple_key_size: { type: 'video', src: 'videos/Á∞°Âçò„É¢„Éº„Éâ„Ç≠„ÉºÂπÖ.mp4' }
            };
            
            const enableHintsCheckbox = document.getElementById('enable-hints');
            if(enableHintsCheckbox) {
                enableHintsCheckbox.addEventListener('change', (e) => {
                    hintEnabled = e.target.checked;
                    if(!hintEnabled) {
                        tooltip.classList.remove('visible', 'show-video');
                        currentHintKey = null;
                    }
                });
            }
            
            function showTooltip(el, e) {
                if(!hintEnabled) return;
                
                const hintKey = el.getAttribute('data-hint');
                if(!hintKey) return;
                
                const t = translations[currentLang];
                const hintText = t[hintKey];
                if(!hintText) return;
                
                currentHintKey = hintKey;
                
                tooltip.querySelector('.hint-text').textContent = hintText;
                
                const f1Notice = tooltip.querySelector('.hint-f1-notice');
                f1Notice.textContent = t.hint_f1_notice || 'F1„Ç≠„Éº: Wiki„ÅßË©≥„Åó„ÅèË¶ã„Çã';
                
                tooltip.classList.remove('show-video');
                clearTimeout(videoDelayTimeout);
                
                const noVideoHints = ['hint_export_stl', 'hint_export_3mf', 'hint_export_parts', 'hint_batch_run', 'hint_url_share', 'hint_quick_save', 'hint_export_json', 'hint_conform', 'hint_simple_mode'];
                const showVideoForHint = !noVideoHints.includes(hintKey);
                
                const videoArea = tooltip.querySelector('.hint-video-area');
                const videoPlaceholder = tooltip.querySelector('.hint-video-placeholder');
                
                if(showVideoForHint) {
                    if(hintVideos[hintKey]) {
                        const videoData = hintVideos[hintKey];
                        if(videoData.type === 'video') {
                            videoPlaceholder.innerHTML = `<video src="${videoData.src}" autoplay loop muted playsinline></video>`;
                        } else if(videoData.type === 'gif') {
                            videoPlaceholder.innerHTML = `<img src="${videoData.src}" alt="Hint animation">`;
                        }
                    } else {
                        videoPlaceholder.innerHTML = `<span>üìπ „ÉÜ„Çπ„ÉàÁîªÈù¢ / Test Video</span>`;
                    }
                    videoArea.style.display = '';
                    
                    videoDelayTimeout = setTimeout(() => {
                        if(tooltip.classList.contains('visible')) {
                            tooltip.classList.add('show-video');
                        }
                    }, VIDEO_DELAY);
                } else {
                    videoArea.style.display = 'none';
                }
                
                const tooltipWidth = 320;
                const uiPanel = document.getElementById('ui-panel');
                const uiPanelRect = uiPanel ? uiPanel.getBoundingClientRect() : { right: 0 };
                
                let left = (uiPanelRect.right || 500) + 20;
                
                tooltip.style.left = left + 'px';
                tooltip.style.top = 'auto';
                tooltip.style.bottom = '20px';
                tooltip.style.transform = 'translateY(0)';
                tooltip.style.maxWidth = tooltipWidth + 'px';
                
                clearTimeout(hideTimeout);
                tooltip.classList.add('visible');
            }
            
            function hideTooltip() {
                hideTimeout = setTimeout(() => {
                    tooltip.classList.remove('visible', 'show-video');
                    clearTimeout(videoDelayTimeout);
                    currentHintKey = null;
                }, 100);
            }
            
            document.addEventListener('keydown', (e) => {
                if(e.key === 'F1' && tooltip.classList.contains('visible') && currentHintKey) {
                    e.preventDefault();
                    
                    // Map hint keys to Wiki sections
                    const hintToSection = {
                        // Basic Size
                        hint_unit_size: 'basic', hint_key_size: 'basic', hint_profile: 'basic', hint_row: 'basic',
                        // Structure (including fillet/round corner)
                        hint_wall_thick: 'structure', hint_rib_shorten: 'structure', hint_enable_ribs: 'structure',
                        hint_homing_bump: 'structure', hint_round_corner: 'structure', hint_stabilizer: 'structure',
                        hint_fillet: 'structure',
                        // Shape
                        hint_key_shape: 'shape', hint_taper: 'shape', hint_dish_type: 'shape', hint_texture: 'shape',
                        // Texture
                        hint_img_upload: 'texture',
                        // Stem
                        hint_clearance: 'stem', hint_stem_diameter: 'stem', hint_stem_ext: 'stem',
                        hint_box_stem: 'stem', hint_lego_stud: 'stem',
                        // Engineering (Tolerance Test & Sprue Kit)
                        hint_tolerance_test: 'engineering', hint_sprue_kit: 'engineering',
                        // Utility (visual presets, dimension lines, layer color)
                        hint_visual_presets: 'utility', hint_dimension_lines: 'utility', hint_layer_color: 'utility',
                        // Simple Mode
                        hint_simple_mode: 'simple', hint_simple_key_size: 'simple', hint_simple_icon: 'simple',
                        // Import
                        hint_import_stl: 'import', hint_import_op: 'import',
                        // Text
                        hint_text_input: 'text', hint_enable_text: 'text', hint_font: 'text', hint_custom_font: 'text',
                        hint_text_size: 'text', hint_text_height: 'text', hint_conform: 'text', hint_text_mode: 'text',
                        hint_text2: 'text', hint_side_print: 'text',
                        // SVG (all SVG section features including stock icons)
                        hint_svg_upload: 'svg', hint_stock_icons: 'svg',
                        // Colors
                        hint_colors: 'colors',
                        // Preset (all preset management features)
                        hint_preset_save: 'preset', hint_preset_load: 'preset', hint_url_share: 'preset',
                        hint_quick_save: 'preset', hint_export_json: 'preset',
                        // Export (all export features)
                        hint_export_stl: 'export', hint_export_obj: 'export', hint_export_3mf: 'export',
                        hint_export_parts: 'export',
                        // Batch
                        hint_batch: 'batch', hint_batch_list: 'batch', hint_batch_run: 'batch'
                    };
                    
                    const section = hintToSection[currentHintKey] || '';
                    const anchor = section ? '#' + section : '';
                    
                    const wikiBaseUrl = currentLang === 'en' 
                        ? 'https://keycapgeneratorwiki.com/en/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9'
                        : 'https://keycapgeneratorwiki.com/ja/%E6%A9%9F%E8%83%BD%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9';
                    window.open(wikiBaseUrl + anchor, '_blank');
                }
            });
            
            document.querySelectorAll('[data-hint]').forEach(el => {
                el.addEventListener('mouseenter', (e) => showTooltip(el, e));
                el.addEventListener('mouseleave', hideTooltip);
                el.addEventListener('focus', (e) => showTooltip(el, e));
                el.addEventListener('blur', hideTooltip);
            });
        })();
        
        // V66: Simple Mode Initialization
        (function initV66Features() {
            // Helper function to create stem geometry (defined first for hoisting)
            function createStemGeometry(clearance, diameter, stemHeight) {
                const outerRadius = diameter / 2;
                const crossWidth = 4.0 + clearance;
                const crossThick = 1.17 + clearance;
                
                const outerGeo = new THREE.CylinderGeometry(outerRadius, outerRadius, stemHeight, 32);
                const cross1 = new THREE.BoxGeometry(crossWidth, stemHeight + 0.2, crossThick);
                const cross2 = new THREE.BoxGeometry(crossThick, stemHeight + 0.2, crossWidth);
                
                try {
                    const outerBrush = new Brush(outerGeo);
                    const brush1 = new Brush(cross1);
                    const brush2 = new Brush(cross2);
                    
                    let result = csgEvaluator.evaluate(outerBrush, brush1, SUBTRACTION);
                    result = csgEvaluator.evaluate(result, brush2, SUBTRACTION);
                    
                    const finalGeo = result.geometry.clone();
                    finalGeo.translate(0, stemHeight / 2, 0);
                    return finalGeo;
                } catch (e) {
                    console.warn('CSG failed, using simple cylinder:', e);
                    outerGeo.translate(0, stemHeight / 2, 0);
                    return outerGeo;
                }
            }

            // Simple Mode Toggle
            const simpleModeToggle = document.getElementById('enable-simple-mode');
            const simpleModePanel = document.getElementById('simple-mode-panel');
            const normalModeContent = document.getElementById('normal-mode-content');
            const navSelect = document.getElementById('section-select');
            const searchBox = document.getElementById('search-box');

            if (simpleModeToggle) {
                simpleModeToggle.addEventListener('change', (e) => {
                    const isSimple = e.target.checked;
                    if (isSimple) {
                        if (simpleModePanel) simpleModePanel.style.display = 'block';
                        if (normalModeContent) normalModeContent.style.display = 'none';
                        if (navSelect) navSelect.style.display = 'none';
                        if (searchBox) searchBox.style.display = 'none';
                        state.textMode = 'emboss';
                        state.textConform = true;
                        state.enableText = true;
                        state.stemClearance = 0.30;
                        state.stemDiameter = 5.50;
                        state.wallThickness = 1.5;
                        state.enableRibs = true;
                        requestUpdate();
                    } else {
                        if (simpleModePanel) simpleModePanel.style.display = 'none';
                        if (normalModeContent) normalModeContent.style.display = 'block';
                        if (navSelect) navSelect.style.display = 'block';
                        if (searchBox) searchBox.style.display = 'block';
                    }
                });
            }

            // Simple Font Selector
            const simpleFont = document.getElementById('simple-font-select');
            if (simpleFont) {
                simpleFont.addEventListener('change', (e) => {
                    state.font = e.target.value;
                    const mainFont = document.getElementById('font-family');
                    if (mainFont) mainFont.value = e.target.value;
                    if (typeof updateCustomDropdown === 'function') updateCustomDropdown();
                    requestUpdate();
                    commitHistory();
                });
            }

            // Key Size Buttons
            const keySizeButtons = document.querySelectorAll('#simple-key-size-buttons .key-size-btn');
            keySizeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    keySizeButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const size = parseFloat(btn.dataset.size);
                    state.uSize = size;
                    const uSizeSlider = document.getElementById('u-size');
                    const vUSize = document.getElementById('v-u-size');
                    if (uSizeSlider) uSizeSlider.value = size;
                    if (vUSize) vUSize.textContent = size.toFixed(2);
                    requestUpdate();
                    commitHistory();
                });
            });

            // Simple Mode Inputs Sync
            const simpleText = document.getElementById('simple-text-content');
            if (simpleText) {
                simpleText.addEventListener('input', (e) => {
                    state.text = e.target.value;
                    const mainText = document.getElementById('text-content');
                    if (mainText) mainText.value = e.target.value;
                    requestUpdate();
                });
            }

            // Simple Mode Enable Text Toggle Sync
            const simpleEnableText = document.getElementById('simple-enable-text');
            const mainEnableText = document.getElementById('enable-text');
            if (simpleEnableText && mainEnableText) {
                simpleEnableText.addEventListener('change', (e) => {
                    state.enableText = e.target.checked;
                    mainEnableText.checked = e.target.checked;
                    requestUpdate();
                });
                mainEnableText.addEventListener('change', (e) => {
                    simpleEnableText.checked = e.target.checked;
                });
            }

            const simpleProfile = document.getElementById('simple-profile-select');
            if (simpleProfile) {
                simpleProfile.addEventListener('change', (e) => {
                    state.profile = e.target.value;
                    const mainProfile = document.getElementById('profile-select');
                    if (mainProfile) mainProfile.value = e.target.value;
                    requestUpdate();
                    commitHistory();
                });
            }

            const simpleRow = document.getElementById('simple-row-select');
            if (simpleRow) {
                simpleRow.addEventListener('change', (e) => {
                    state.row = e.target.value;
                    const mainRow = document.getElementById('row-select');
                    if (mainRow) mainRow.value = e.target.value;
                    requestUpdate();
                    commitHistory();
                });
            }

            // Simple Mode Text Mode Sync
            const simpleTextMode = document.getElementById('simple-text-mode');
            if (simpleTextMode) {
                simpleTextMode.addEventListener('change', (e) => {
                    state.textMode = e.target.value;
                    const mainTextMode = document.getElementById('text-mode');
                    if (mainTextMode) mainTextMode.value = e.target.value;
                    requestUpdate();
                    commitHistory();
                });
            }

            // Simple Mode Taper (Top Scale) Sync
            const simpleTaper = document.getElementById('simple-taper');
            const simpleTaperVal = document.getElementById('v-simple-taper');
            if (simpleTaper) {
                simpleTaper.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    state.topScale = val;
                    if (simpleTaperVal) simpleTaperVal.textContent = val.toFixed(2);
                    const mainTaper = document.getElementById('top-scale');
                    if (mainTaper) mainTaper.value = val;
                    const mainTaperVal = document.getElementById('v-top-scale');
                    if (mainTaperVal) mainTaperVal.textContent = val.toFixed(2);
                    requestUpdate();
                });
            }

            // Simple Mode Dish Type Sync
            const simpleDish = document.getElementById('simple-dish-type');
            if (simpleDish) {
                simpleDish.addEventListener('change', (e) => {
                    state.dishType = e.target.value;
                    const mainDish = document.getElementById('dish-type');
                    if (mainDish) mainDish.value = e.target.value;
                    requestUpdate();
                    commitHistory();
                });
            }

            // Simple Mode Fillet (Round Corner) Sync
            const simpleFillet = document.getElementById('simple-fillet');
            const simpleFilletVal = document.getElementById('v-simple-fillet');
            if (simpleFillet) {
                simpleFillet.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    state.roundCorner = val;
                    if (simpleFilletVal) simpleFilletVal.textContent = val.toFixed(1);
                    const mainFillet = document.getElementById('round-corner');
                    if (mainFillet) mainFillet.value = val;
                    const mainFilletVal = document.getElementById('v-round-corner');
                    if (mainFilletVal) mainFilletVal.textContent = val.toFixed(1);
                    requestUpdate();
                });
            }

            const simpleColBody = document.getElementById('simple-col-body');
            if (simpleColBody) {
                simpleColBody.addEventListener('input', (e) => {
                    state.colBody = e.target.value;
                    const mainColBody = document.getElementById('col-body');
                    if (mainColBody) mainColBody.value = e.target.value;
                    updateModel();
                });
            }

            const simpleColText = document.getElementById('simple-col-text');
            if (simpleColText) {
                simpleColText.addEventListener('input', (e) => {
                    state.colText = e.target.value;
                    const mainColText = document.getElementById('col-text');
                    if (mainColText) mainColText.value = e.target.value;
                    updateModel();
                });
            }

            // Simple Export Buttons
            document.getElementById('btn-simple-export-stl')?.addEventListener('click', () => {
                document.getElementById('btn-export-all')?.click();
            });

            document.getElementById('btn-simple-export-3mf')?.addEventListener('click', () => {
                document.getElementById('btn-export-3mf')?.click();
            });

            // Dimension Lines Toggle & Update
            const showDimensions = document.getElementById('show-dimensions');
            const dimensionOverlay = document.getElementById('dimension-overlay');
            let dimensionUpdateInterval = null;
            let dimensionHelpers = []; // Store 3D dimension objects
            
            function createDimensionLine(start, end, color, label) {
                const group = new THREE.Group();
                group.name = 'dimensionHelper';
                
                // Main line
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([start, end]);
                const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 2 });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                group.add(line);
                
                // Arrow heads at both ends
                const direction = new THREE.Vector3().subVectors(end, start).normalize();
                const length = start.distanceTo(end);
                const arrowSize = Math.min(1.5, length * 0.15);
                
                // End caps (perpendicular lines)
                const perpDir = new THREE.Vector3();
                if (Math.abs(direction.y) > 0.9) {
                    perpDir.set(1, 0, 0);
                } else if (Math.abs(direction.x) > 0.9) {
                    perpDir.set(0, 1, 0);
                } else {
                    perpDir.set(0, 0, 1);
                }
                
                const capSize = arrowSize * 0.5;
                const cap1Geo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3().addVectors(start, perpDir.clone().multiplyScalar(capSize)),
                    new THREE.Vector3().addVectors(start, perpDir.clone().multiplyScalar(-capSize))
                ]);
                const cap2Geo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3().addVectors(end, perpDir.clone().multiplyScalar(capSize)),
                    new THREE.Vector3().addVectors(end, perpDir.clone().multiplyScalar(-capSize))
                ]);
                group.add(new THREE.Line(cap1Geo, lineMaterial));
                group.add(new THREE.Line(cap2Geo, lineMaterial));
                
                return group;
            }
            
            function clearDimensionHelpers() {
                dimensionHelpers.forEach(helper => {
                    scene.remove(helper);
                    helper.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                });
                dimensionHelpers = [];
            }
            
            function updateDimensions() {
                const isVisible = showDimensions && showDimensions.checked;
                if (!isVisible) {
                    clearDimensionHelpers();
                    return;
                }
                
                // Find mesh in mainGroup (not scene directly)
                const bodyMesh = mainGroup.children.find(c => c.name === 'KeycapBody' && c.geometry);
                if (!bodyMesh || !bodyMesh.geometry) {
                    if (dimensionOverlay) {
                        document.getElementById('dim-width').textContent = '-- mm';
                        document.getElementById('dim-depth').textContent = '-- mm';
                        document.getElementById('dim-height').textContent = '-- mm';
                    }
                    clearDimensionHelpers();
                    return;
                }
                
                bodyMesh.geometry.computeBoundingBox();
                const box = bodyMesh.geometry.boundingBox;
                const width = box.max.x - box.min.x;
                const depth = box.max.z - box.min.z;
                const height = box.max.y - box.min.y;
                
                // Update overlay text
                if (dimensionOverlay) {
                    document.getElementById('dim-width').textContent = width.toFixed(2) + ' mm';
                    document.getElementById('dim-depth').textContent = depth.toFixed(2) + ' mm';
                    document.getElementById('dim-height').textContent = height.toFixed(2) + ' mm';
                }
                
                // Clear old helpers
                clearDimensionHelpers();
                
                // Offset for dimension lines (outside the model)
                const offset = 3;
                
                // Width line (X axis) - front bottom
                const widthLine = createDimensionLine(
                    new THREE.Vector3(box.min.x, box.min.y - offset, box.max.z + offset),
                    new THREE.Vector3(box.max.x, box.min.y - offset, box.max.z + offset),
                    0x2196f3, 'W'
                );
                scene.add(widthLine);
                dimensionHelpers.push(widthLine);
                
                // Depth line (Z axis) - right bottom
                const depthLine = createDimensionLine(
                    new THREE.Vector3(box.max.x + offset, box.min.y - offset, box.min.z),
                    new THREE.Vector3(box.max.x + offset, box.min.y - offset, box.max.z),
                    0x4caf50, 'D'
                );
                scene.add(depthLine);
                dimensionHelpers.push(depthLine);
                
                // Height line (Y axis) - right front
                const heightLine = createDimensionLine(
                    new THREE.Vector3(box.max.x + offset, box.min.y, box.max.z + offset),
                    new THREE.Vector3(box.max.x + offset, box.max.y, box.max.z + offset),
                    0xff9800, 'H'
                );
                scene.add(heightLine);
                dimensionHelpers.push(heightLine);
            }
            
            if (showDimensions && dimensionOverlay) {
                showDimensions.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        dimensionOverlay.style.display = 'block';
                        updateDimensions();
                        dimensionUpdateInterval = setInterval(updateDimensions, 500);
                    } else {
                        dimensionOverlay.style.display = 'none';
                        clearDimensionHelpers();
                        if (dimensionUpdateInterval) clearInterval(dimensionUpdateInterval);
                        dimensionUpdateInterval = null;
                    }
                });
            }

            // Tolerance Test Sliders
            document.getElementById('tol-start')?.addEventListener('input', (e) => {
                const val = document.getElementById('v-tol-start');
                if (val) val.textContent = parseFloat(e.target.value).toFixed(2);
            });

            document.getElementById('tol-step')?.addEventListener('input', (e) => {
                const val = document.getElementById('v-tol-step');
                if (val) val.textContent = parseFloat(e.target.value).toFixed(2);
            });

            // Tolerance Test Kit Generation (Fixed: Matrix update for CSG)
            document.getElementById('btn-gen-tolerance-test')?.addEventListener('click', async () => {
                try {
                    const startVal = parseFloat(document.getElementById('tol-start').value);
                    const stepVal = parseFloat(document.getElementById('tol-step').value);
                    const format = document.getElementById('tol-test-format').value;
                    
                    // Show confirmation popup
                    const confirmed = await showExportPopup({
                        type: 'tolerance',
                        format: format.toUpperCase(),
                        startVal: startVal,
                        stepVal: stepVal,
                        count: 5
                    });
                    
                    if (!confirmed) return;
                    
                    showToast(translations[currentLang].tolerance_generating || '„Çπ„ÉÜ„É†„ÉÜ„Çπ„Éà„Ç≠„ÉÉ„Éà„ÇíÁîüÊàê‰∏≠...');
                    
                    // Use setTimeout to allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 50));
                    
                    const stems = [];
                    const spacing = 12;
                    const stemHeight = 4.0;
                    const stemDiameter = 5.50;
                    const baseHeight = 1.5;
                    const baseSize = 9.0;
                    
                    // Create local CSG evaluator to avoid cache issues
                    const localEvaluator = new Evaluator();
                    
                    for (let i = 0; i < 5; i++) {
                        const clearance = Math.round((startVal + (stepVal * i)) * 100) / 100;
                        const xPos = (i - 2) * spacing;
                        
                        console.log(`Generating Stem ${i + 1}: Clearance = ${clearance}mm`);

                        // 1. Outer cylinder for stem
                        const outerRadius = stemDiameter / 2;
                        const outerGeo = new THREE.CylinderGeometry(outerRadius, outerRadius, stemHeight, 32);
                        outerGeo.computeVertexNormals();
                        
                        // 2. Cross hole boxes with clearance
                        const crossWidth = 4.0 + clearance;
                        const crossThick = 1.17 + clearance;
                        
                        const cross1 = new THREE.BoxGeometry(crossWidth, stemHeight + 0.2, crossThick);
                        cross1.computeVertexNormals();
                        
                        const cross2 = new THREE.BoxGeometry(crossThick, stemHeight + 0.2, crossWidth);
                        cross2.computeVertexNormals();
                        
                        let stemGeo;
                        try {
                            // Create brushes and force matrix update
                            const outerBrush = new Brush(outerGeo);
                            outerBrush.updateMatrixWorld();
                            
                            const brush1 = new Brush(cross1);
                            brush1.updateMatrixWorld();
                            
                            const brush2 = new Brush(cross2);
                            brush2.updateMatrixWorld();
                            
                            // CSG: outer - cross1
                            let result = localEvaluator.evaluate(outerBrush, brush1, SUBTRACTION);
                            result.updateMatrixWorld();
                            
                            // CSG: result - cross2
                            result = localEvaluator.evaluate(result, brush2, SUBTRACTION);
                            result.updateMatrixWorld();
                            
                            stemGeo = result.geometry.clone();
                            stemGeo.translate(xPos, stemHeight / 2 + baseHeight, 0);
                            
                        } catch (e) {
                            console.warn('CSG failed for stem ' + i + ':', e);
                            stemGeo = outerGeo.clone();
                            stemGeo.translate(xPos, stemHeight / 2 + baseHeight, 0);
                        }
                        
                        stems.push(stemGeo);
                        
                        // 3. Base plate
                        const baseGeo = new THREE.BoxGeometry(baseSize, baseHeight, baseSize);
                        baseGeo.translate(xPos, baseHeight / 2, 0);
                        stems.push(baseGeo);
                    }
                    
                    console.log('Merging geometries...');
                    const mergedGeo = safeMerge(stems);
                    
                    if (!mergedGeo) {
                        throw new Error('„Ç∏„Ç™„É°„Éà„É™„ÅÆÁµêÂêà„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                    }
                    mergedGeo.computeVertexNormals();
                    
                    const exportMesh = new THREE.Mesh(mergedGeo, new THREE.MeshStandardMaterial({ color: 0x808080 }));
                    
                    const labels = [];
                    for (let i = 0; i < 5; i++) {
                        labels.push((startVal + (stepVal * i)).toFixed(2) + 'mm');
                    }
                    
                    const filename = 'stem_test_' + startVal.toFixed(2) + '-' + (startVal + stepVal * 4).toFixed(2);
                    console.log('Exporting:', filename);
                    
                    if (format === 'stl') {
                        const exporter = new STLExporter();
                        const stlString = exporter.parse(exportMesh, { binary: true });
                        const blob = new Blob([stlString], { type: 'application/octet-stream' });
                        saveAs(blob, filename + '.stl');
                    } else {
                        const blob = await export3MFSingle(exportMesh, '#808080');
                        saveAs(blob, filename + '.3mf');
                    }
                    
                    showToast((translations[currentLang].tolerance_complete || '„Çπ„ÉÜ„É†„ÉÜ„Çπ„ÉàÁîüÊàêÂÆå‰∫Ü') + ': ' + labels.join(', '));
                } catch (error) {
                    console.error('Tolerance test generation failed:', error);
                    showToast('ÁîüÊàê„Ç®„É©„Éº: ' + error.message, true);
                }
            });

            // Sprue Count Slider
            document.getElementById('sprue-count')?.addEventListener('input', (e) => {
                const val = document.getElementById('v-sprue-count');
                if (val) val.textContent = e.target.value;
            });

            // Printer Model/Size Selection
            const printerSizes = {
                'x1p1a1': [
                    { value: '256,256', label: '256√ó256' }
                ],
                'a1mini': [
                    { value: '180,180', label: '180√ó180' }
                ],
                'h2d': [
                    { value: '325,320', label: 'Single Nozzle (325√ó320)' },
                    { value: '300,320', label: 'Dual Nozzle (300√ó320)' },
                    { value: '350,320', label: 'Total Area (350√ó320)' }
                ],
                'h2s': [
                    { value: '340,320', label: '340√ó320' }
                ],
                'h2c': [
                    { value: '325,320', label: 'Single Left (325√ó320)' },
                    { value: '305,320', label: 'Single Right (305√ó320)' },
                    { value: '300,320', label: 'Dual Nozzle (300√ó320)' },
                    { value: '330,320', label: 'Total Area (330√ó320)' }
                ],
                'unlimited': [
                    { value: '9999,9999', label: 'Âà∂Èôê„Å™„Åó (‰∏ÄÁõ¥Á∑ö)' }
                ]
            };

            const printerModelSelect = document.getElementById('sprue-printer-model');
            const printerSizeSelect = document.getElementById('sprue-printer-size');
            const maxKeysDisplay = document.getElementById('sprue-max-keys');
            const sprueCountSlider = document.getElementById('sprue-count');

            function calculateMaxKeys() {
                const sizeVal = printerSizeSelect.value.split(',');
                const maxWidth = parseFloat(sizeVal[0]);
                const maxDepth = parseFloat(sizeVal[1]);
                
                if (maxWidth > 9000) {
                    maxKeysDisplay.textContent = '‚àû';
                    sprueCountSlider.max = 100;
                    return 999;
                }
                
                // Calculate based on current keycap size
                const keyWidth = state.unitSize * state.uSize;
                const keyDepth = state.unitSize;
                const xSpacing = keyWidth + 12;
                const zSpacing = keyDepth + 20;
                const margin = 10;
                
                const keysPerRow = Math.floor((maxWidth - margin * 2) / xSpacing);
                const rowsAvailable = Math.floor((maxDepth - margin * 2) / zSpacing);
                const maxKeys = Math.max(1, keysPerRow) * Math.max(1, rowsAvailable);
                
                maxKeysDisplay.textContent = maxKeys;
                
                // Update slider max value
                sprueCountSlider.max = maxKeys;
                
                // If current value exceeds max, adjust it
                if (parseInt(sprueCountSlider.value) > maxKeys) {
                    sprueCountSlider.value = maxKeys;
                    const val = document.getElementById('v-sprue-count');
                    if (val) val.textContent = maxKeys;
                }
                
                return maxKeys;
            }

            function updatePrinterSizeOptions() {
                const model = printerModelSelect.value;
                const sizes = printerSizes[model] || [];
                
                // Clear existing options
                printerSizeSelect.innerHTML = '';
                
                // Add new options
                sizes.forEach(size => {
                    const option = document.createElement('option');
                    option.value = size.value;
                    option.textContent = size.label;
                    printerSizeSelect.appendChild(option);
                });
                
                // Disable if only one option
                printerSizeSelect.disabled = sizes.length <= 1;
                printerSizeSelect.style.opacity = sizes.length <= 1 ? '0.5' : '1';
                
                // Update max keys display
                calculateMaxKeys();
            }

            printerModelSelect?.addEventListener('change', updatePrinterSizeOptions);
            printerSizeSelect?.addEventListener('change', calculateMaxKeys);
            
            // Recalculate when keycap size changes
            document.getElementById('unit-size')?.addEventListener('input', () => setTimeout(calculateMaxKeys, 100));
            document.getElementById('u-size')?.addEventListener('input', () => setTimeout(calculateMaxKeys, 100));
            
            // Initialize on load
            updatePrinterSizeOptions();
            
            // Repeat Mode Toggle
            const repeatModeCheckbox = document.getElementById('sprue-repeat-mode');
            const charsGroup = document.getElementById('sprue-chars-group');
            const singleCharGroup = document.getElementById('sprue-single-char-group');
            const sprueCharsInput = document.getElementById('sprue-chars');
            
            repeatModeCheckbox?.addEventListener('change', (e) => {
                if (e.target.checked) {
                    charsGroup.style.display = 'none';
                    singleCharGroup.style.display = 'block';
                } else {
                    charsGroup.style.display = 'block';
                    singleCharGroup.style.display = 'none';
                }
            });
            
            // Auto-update key count based on character list
            sprueCharsInput?.addEventListener('input', (e) => {
                const chars = e.target.value.split(',').map(s => s.trim()).filter(s => s);
                if (chars.length >= 2) {
                    const maxAllowed = parseInt(sprueCountSlider.max);
                    const newCount = Math.min(chars.length, maxAllowed);
                    sprueCountSlider.value = newCount;
                    const val = document.getElementById('v-sprue-count');
                    if (val) val.textContent = newCount;
                }
            });

            // Sprue Kit Generation (Grid Layout & Printer Presets)
            document.getElementById('btn-gen-sprue-kit')?.addEventListener('click', async () => {
                try {
                    const t = translations[currentLang];
                    const count = parseInt(document.getElementById('sprue-count').value);
                    const format = document.getElementById('sprue-format').value;
                    const sizeVal = document.getElementById('sprue-printer-size').value.split(',');
                    const maxBuildWidth = parseFloat(sizeVal[0]);
                    const maxBuildDepth = parseFloat(sizeVal[1]);
                    const printerModel = document.getElementById('sprue-printer-model').value;
                    const isRepeatMode = document.getElementById('sprue-repeat-mode').checked;
                    
                    // Get character list based on mode
                    let keycapsList = [];
                    if (isRepeatMode) {
                        const singleChar = document.getElementById('sprue-single-char').value.trim();
                        if (!singleChar) {
                            showToast(t.msg_enter_repeat_char || 'ÈÄ£Á∂öÂá∫Âäõ„Åô„ÇãÊñáÂ≠ó„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ', true);
                            return;
                        }
                        // Fill array with same character
                        for (let i = 0; i < count; i++) {
                            keycapsList.push(singleChar);
                        }
                    } else {
                        const chars = document.getElementById('sprue-chars').value.split(',').map(s => s.trim()).filter(s => s);
                        if (chars.length < 1) {
                            showToast(t.msg_enter_one_char || '1„Å§‰ª•‰∏ä„ÅÆÊñáÂ≠ó„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ', true);
                            return;
                        }
                        // Loop chars to fill count
                        while (keycapsList.length < count) {
                            keycapsList = keycapsList.concat(chars);
                        }
                        keycapsList = keycapsList.slice(0, count);
                    }
                    
                    // Calculate layout info
                    const keyWidth = state.unitSize * state.uSize;
                    const keyDepth = state.unitSize;
                    const xSpacing = keyWidth + 12;
                    const margin = 10.0;
                    let keysPerRow = Math.floor((maxBuildWidth - (margin * 2)) / xSpacing);
                    if (keysPerRow < 1) keysPerRow = 1;
                    if (maxBuildWidth > 9000) keysPerRow = count;
                    const numRows = Math.ceil(count / keysPerRow);
                    
                    // Generate preview geometry for sprue kit
                    const spruePreviewGeos = [];
                    const zSpacingPrev = keyDepth + 20;
                    const gridWidthPrev = (Math.min(count, keysPerRow) - 1) * xSpacing;
                    const gridDepthPrev = (numRows - 1) * zSpacingPrev;
                    
                    const bodyMeshPrev = mainGroup.children.find(ch => ch.name === 'KeycapBody' && ch.geometry);
                    if (bodyMeshPrev && bodyMeshPrev.geometry) {
                        // Create preview keycaps in grid
                        for (let rp = 0; rp < numRows; rp++) {
                            const rowCountPrev = (rp === numRows - 1) ? (count - rp * keysPerRow) : keysPerRow;
                            const currentRowWidthPrev = (rowCountPrev - 1) * xSpacing;
                            for (let cp = 0; cp < rowCountPrev; cp++) {
                                const previewGeo = bodyMeshPrev.geometry.clone();
                                const xPosPrev = (cp * xSpacing) - (currentRowWidthPrev / 2);
                                const zPosPrev = (rp * zSpacingPrev) - (gridDepthPrev / 2);
                                previewGeo.translate(xPosPrev, 0, zPosPrev);
                                spruePreviewGeos.push(previewGeo);
                            }
                        }
                        
                        // Add runner frame preview
                        const pPrev = getParams();
                        const runnerThickPrev = 3.0;
                        const frameWidthPrev = gridWidthPrev + keyWidth + 25;
                        const frameDepthPrev = gridDepthPrev + keyDepth + 25;
                        const gateYPrev = pPrev.h * 0.4;
                        
                        // Horizontal bars
                        for (let ip = 0; ip <= numRows; ip++) {
                            const row0ZPrev = -gridDepthPrev / 2;
                            const barZPrev = (row0ZPrev - zSpacingPrev/2) + (ip * zSpacingPrev);
                            const hBarPrev = new THREE.BoxGeometry(frameWidthPrev, runnerThickPrev, runnerThickPrev);
                            hBarPrev.translate(0, runnerThickPrev/2, barZPrev);
                            spruePreviewGeos.push(hBarPrev);
                            
                            // Top bar at gate height
                            const topBarPrev = new THREE.BoxGeometry(frameWidthPrev, runnerThickPrev, runnerThickPrev);
                            topBarPrev.translate(0, gateYPrev, barZPrev);
                            spruePreviewGeos.push(topBarPrev);
                        }
                        
                        // Side bars
                        const leftBarPrev = new THREE.BoxGeometry(runnerThickPrev, runnerThickPrev, frameDepthPrev);
                        leftBarPrev.translate(-frameWidthPrev/2 + runnerThickPrev/2, runnerThickPrev/2, 0);
                        spruePreviewGeos.push(leftBarPrev);
                        const rightBarPrev = new THREE.BoxGeometry(runnerThickPrev, runnerThickPrev, frameDepthPrev);
                        rightBarPrev.translate(frameWidthPrev/2 - runnerThickPrev/2, runnerThickPrev/2, 0);
                        spruePreviewGeos.push(rightBarPrev);
                    }
                    
                    // Show popup
                    const charListDisplay = keycapsList.length > 15 ? 
                        keycapsList.slice(0, 15).join(', ') + '...' : 
                        keycapsList.join(', ');
                    const buildSizeDisplay = maxBuildWidth > 9000 ? 'Âà∂Èôê„Å™„Åó' : `${maxBuildWidth}√ó${maxBuildDepth}mm`;
                    const layoutDisplay = `${numRows}Ë°å √ó ÊúÄÂ§ß${keysPerRow}Âàó`;
                    
                    const confirmed = await showExportPopup({
                        type: 'sprue',
                        format: format.toUpperCase(),
                        printer: printerModel,
                        buildSize: buildSizeDisplay,
                        keyCount: count,
                        layout: layoutDisplay,
                        charList: charListDisplay,
                        spruePreviewGeos: spruePreviewGeos
                    });
                    
                    if (!confirmed) return;

                    showToast(`„Çπ„Éó„É´„Éº„Ç≠„ÉÉ„ÉàÁîüÊàê‰∏≠... (${count}ÂÄã, ${numRows}Ë°å√ó${keysPerRow}Âàó)`);
                    
                    // „Éë„É©„É°„Éº„ÇøÂèñÂæó
                    const keyHeight = getParams().h;
                    
                    const zSpacing = keyDepth + 20;
                    const runnerThickGen = 3.0;

                    // Ë°å„Åî„Å®„ÅÆ„Ç≠„Éº„É™„Çπ„Éà
                    const rows = [];
                    for (let i = 0; i < keycapsList.length; i += keysPerRow) {
                        rows.push(keycapsList.slice(i, i + keysPerRow));
                    }
                    
                    // Use same calculations as preview
                    const gridWidth = (Math.min(count, keysPerRow) - 1) * xSpacing;
                    const gridDepth = (numRows - 1) * zSpacing;
                    
                    const keycapGeometries = [];
                    const originalText = state.text;
                    const originalSvg = state.svgContent;
                    const originalSvgVisible = state.svgVisible;
                    
                    // „Ç≠„Éº„Ç≠„É£„ÉÉ„ÉóÁîüÊàê„É´„Éº„Éó
                    for (let r = 0; r < numRows; r++) {
                        const currentRow = rows[r];
                        const currentRowWidth = (currentRow.length - 1) * xSpacing;
                        
                        for (let c = 0; c < currentRow.length; c++) {
                            state.text = currentRow[c];
                            state.svgContent = null;
                            state.svgVisible = false;
                            
                            await new Promise(resolve => {
                                requestUpdate();
                                setTimeout(resolve, 200);
                            });
                            
                            const bodyMesh = mainGroup.children.find(ch => ch.name === 'KeycapBody' && ch.geometry);
                            const textMesh = mainGroup.children.find(ch => ch.name === 'KeycapText' && ch.geometry);
                            
                            if (bodyMesh && bodyMesh.geometry) {
                                const geos = [bodyMesh.geometry.clone()];
                                if (textMesh && textMesh.geometry) {
                                    geos.push(textMesh.geometry.clone());
                                }
                                
                                let keycapGeo = geos.length > 1 ? safeMerge(geos) : geos[0];
                                if (keycapGeo) {
                                    const xPos = (c * xSpacing) - (currentRowWidth / 2);
                                    const zPos = (r * zSpacing) - (gridDepth / 2);
                                    
                                    keycapGeo.translate(xPos, 0, zPos);
                                    keycapGeometries.push({geo: keycapGeo, x: xPos, z: zPos});
                                }
                            }
                        }
                    }
                    
                    state.text = originalText;
                    state.svgContent = originalSvg;
                    state.svgVisible = originalSvgVisible;
                    requestUpdate();
                    
                    if (keycapGeometries.length === 0) {
                        showToast('ÁîüÊàêÂ§±Êïó', true);
                        return;
                    }

                    // „É©„É≥„Éä„ÉºÁîüÊàêÔºà„ÅØ„Åó„ÅîÂûãÔºâ
                    const runnerParts = [];
                    const gateY = keyHeight * 0.4;
                    
                    const maxRowLen = Math.max(...rows.map(r => r.length));
                    const maxRowWidth = (maxRowLen - 1) * xSpacing;
                    const frameWidth = maxRowWidth + keyWidth + 25; 
                    const frameDepthGen = gridDepth + keyDepth + 25;
                    
                    // Ê®™Ê£íÔºàË°å„ÅÆÈñì„Å®‰∏ä‰∏ãÔºâ
                    for (let i = 0; i <= numRows; i++) {
                        const row0Z = -gridDepth / 2;
                        const barZ = (row0Z - zSpacing/2) + (i * zSpacing);
                        
                        const hBar = new THREE.BoxGeometry(frameWidth, runnerThickGen, runnerThickGen);
                        hBar.translate(0, runnerThickGen/2, barZ);
                        runnerParts.push(hBar);

                        // ÊîØÊü±Ôºà‰∏°Á´Ø„Å®‰∏≠Â§ÆÔºâ
                        const supportX = [-frameWidth/2 + runnerThickGen/2, 0, frameWidth/2 - runnerThickGen/2];
                        supportX.forEach(sx => {
                           const vSup = new THREE.BoxGeometry(runnerThickGen, gateY, runnerThickGen);
                           vSup.translate(sx, gateY/2, barZ);
                           runnerParts.push(vSup);
                        });
                        
                        // „Ç≤„Éº„ÉàÈ´ò„Åï„ÅÆ„Éà„ÉÉ„Éó„Éê„Éº
                        const topBar = new THREE.BoxGeometry(frameWidth, runnerThickGen, runnerThickGen);
                        topBar.translate(0, gateY, barZ);
                        runnerParts.push(topBar);
                    }
                    
                    // Á∏¶Ê£íÔºàÂ∑¶Âè≥Á´ØÔºâ
                    const sideBarHeight = runnerThickGen;
                    const leftBar = new THREE.BoxGeometry(runnerThickGen, sideBarHeight, frameDepthGen);
                    leftBar.translate(-frameWidth/2 + runnerThickGen/2, runnerThickGen/2, 0);
                    runnerParts.push(leftBar);

                    const rightBar = new THREE.BoxGeometry(runnerThickGen, sideBarHeight, frameDepthGen);
                    rightBar.translate(frameWidth/2 - runnerThickGen/2, runnerThickGen/2, 0);
                    runnerParts.push(rightBar);
                    
                    // „Ç≤„Éº„ÉàÔºà„Ç≠„Éº„Å®Ê®™Ê£í„ÇíÁπã„ÅêÔºâ
                    const gateWidth = 0.8;
                    const gateThick = 0.6;
                    
                    keycapGeometries.forEach(k => {
                        const gateFrontLen = (zSpacing/2) - (keyDepth/2) + 2.0;
                        const gateFront = new THREE.BoxGeometry(gateWidth, gateThick, gateFrontLen);
                        const frontZ = k.z - (keyDepth/2) - (gateFrontLen/2) + 2.0; 
                        gateFront.translate(k.x, gateY, frontZ);
                        runnerParts.push(gateFront);

                        const gateBack = new THREE.BoxGeometry(gateWidth, gateThick, gateFrontLen);
                        const backZ = k.z + (keyDepth/2) + (gateFrontLen/2) - 2.0;
                        gateBack.translate(k.x, gateY, backZ);
                        runnerParts.push(gateBack);
                    });

                    // ÁµêÂêà
                    const finalKeycapGeos = keycapGeometries.map(k => k.geo);
                    const allGeos = [...finalKeycapGeos, ...runnerParts];
                    
                    console.log(`Merging ${allGeos.length} geometries...`);
                    const mergedGeo = safeMerge(allGeos);
                    if (!mergedGeo) throw new Error('ÁµêÂêàÂ§±Êïó');
                    
                    mergedGeo.computeVertexNormals();
                    
                    const exportMesh = new THREE.Mesh(mergedGeo, new THREE.MeshStandardMaterial({ color: new THREE.Color(state.colBody) }));
                    
                    // „Éï„Ç°„Ç§„É´ÂêçÁîüÊàê
                    const printerNames = {
                        'x1p1a1': 'X1P1A1',
                        'a1mini': 'A1mini',
                        'h2d': 'H2D',
                        'h2s': 'H2S',
                        'h2c': 'H2C',
                        'unlimited': 'Unlimited'
                    };
                    const printerName = printerNames[printerModel] || 'Custom';
                    let charsPart = '';
                    if (isRepeatMode) {
                        const singleChar = document.getElementById('sprue-single-char').value.trim();
                        charsPart = `_${singleChar}x${count}`;
                    } else {
                        charsPart = `_${count}keys`;
                    }
                    const filename = `sprue_${printerName}${charsPart}`;

                    if (format === 'stl') {
                        const exporter = new STLExporter();
                        const stlData = exporter.parse(exportMesh, { binary: true });
                        const blob = new Blob([stlData], { type: 'application/octet-stream' });
                        saveAs(blob, filename + '.stl');
                    } else {
                        const blob = await export3MFSingle(exportMesh, state.colBody);
                        saveAs(blob, filename + '.3mf');
                    }
                    
                    showToast(`ÁîüÊàêÂÆå‰∫Ü: ${numRows}Ë°å √ó ÊúÄÂ§ß${keysPerRow}Âàó`);

                } catch (error) {
                    console.error('Sprue kit error:', error);
                    showToast('„Ç®„É©„Éº: ' + error.message, true);
                }
            });

            // Visual Preset Library with real-time updates
            const presetFont = document.getElementById('preset-font');
            const presetSize = document.getElementById('preset-size');
            const presetMode = document.getElementById('preset-mode');
            
            presetFont?.addEventListener('change', (e) => {
                state.font = e.target.value;
                const mainFont = document.getElementById('font-family');
                if (mainFont) mainFont.value = e.target.value;
                if (typeof updateCustomDropdown === 'function') updateCustomDropdown();
                requestUpdate();
                commitHistory();
            });
            
            presetSize?.addEventListener('change', (e) => {
                state.fontSize = parseFloat(e.target.value);
                const mainSize = document.getElementById('font-size');
                const vMainSize = document.getElementById('v-font-size');
                if (mainSize) mainSize.value = e.target.value;
                if (vMainSize) vMainSize.textContent = e.target.value;
                requestUpdate();
                commitHistory();
            });
            
            presetMode?.addEventListener('change', (e) => {
                state.textMode = e.target.value;
                const mainMode = document.getElementById('text-mode');
                if (mainMode) mainMode.value = e.target.value;
                requestUpdate();
                commitHistory();
            });

            const visualPresetBtns = document.querySelectorAll('#visual-preset-grid .visual-preset-btn');
            const visualPresets = {
                'wasd': { text: 'W', profile: 'cherry', row: 'R3', size: 1.0 },
                'arrows': { text: '', profile: 'cherry', row: 'R4', size: 1.0, useIcon: 'up' },
                'fn': { text: 'Fn', profile: 'cherry', row: 'R1', size: 1.0 },
                'mac-cmd': { text: 'Cmd', profile: 'cherry', row: 'R1', size: 1.25 },
                'mac-opt': { text: 'Alt', profile: 'cherry', row: 'R1', size: 1.25 },
                'esc': { text: 'Esc', profile: 'cherry', row: 'R4', size: 1.0 }
            };
            
            // Arrow key icon selector for arrows preset
            const arrowIconOptions = [
                { id: 'up', name: '‚Üë ‰∏äÁü¢Âç∞', nameEn: '‚Üë Up' },
                { id: 'down', name: '‚Üì ‰∏ãÁü¢Âç∞', nameEn: '‚Üì Down' },
                { id: 'left', name: '‚Üê Â∑¶Áü¢Âç∞', nameEn: '‚Üê Left' },
                { id: 'right', name: '‚Üí Âè≥Áü¢Âç∞', nameEn: '‚Üí Right' }
            ];

            visualPresetBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                    const presetKey = btn.dataset.preset;
                    const preset = visualPresets[presetKey];
                    if (preset) {
                        // Handle WASD preset with key selection
                        if (presetKey === 'wasd') {
                            const key = await showWASDSelector();
                            if (!key) return;
                            
                            state.text = key;
                            state.profile = preset.profile;
                            state.row = preset.row;
                            state.uSize = preset.size;
                            if (presetFont) state.font = presetFont.value;
                            if (presetSize) state.fontSize = parseFloat(presetSize.value);
                            if (presetMode) state.textMode = presetMode.value;
                            syncUI();
                            requestUpdate();
                            commitHistory();
                            showToast('WASD„Ç≠„Éº„Äå' + key + '„Äç„ÇíÈÅ©Áî®');
                            return;
                        }
                        
                        // Handle arrow keys preset with icon selection
                        if (presetKey === 'arrows' && stockIconsData) {
                            // Show arrow direction selector
                            const direction = await showArrowSelector();
                            if (!direction) return;
                            
                            // Find the icon in stockIconsData
                            const icon = stockIconsData.icons.find(i => i.id === direction);
                            if (icon && icon.svgContent) {
                                state.text = '';
                                state.showText = false;
                                state.svgContent = icon.svgContent;
                                state.svgName = icon.nameJa || icon.name;
                                state.svgVisible = true;
                                state.profile = preset.profile;
                                state.row = preset.row;
                                state.uSize = preset.size;
                                
                                // Update UI checkboxes
                                const showTextChk = document.getElementById('show-text');
                                const svgVisibleChk = document.getElementById('svg-visible');
                                if (showTextChk) showTextChk.checked = false;
                                if (svgVisibleChk) svgVisibleChk.checked = true;
                                
                                syncUI();
                                requestUpdate();
                                commitHistory();
                                showToast('Áü¢Âç∞„Ç≠„Éº„Äå' + (icon.nameJa || icon.name) + '„Äç„ÇíÈÅ©Áî®');
                                return;
                            }
                        }
                        
                        // Standard preset handling
                        state.text = preset.text;
                        state.profile = preset.profile;
                        state.row = preset.row;
                        state.uSize = preset.size;
                        if (presetFont) state.font = presetFont.value;
                        if (presetSize) state.fontSize = parseFloat(presetSize.value);
                        if (presetMode) state.textMode = presetMode.value;
                        syncUI();
                        requestUpdate();
                        commitHistory();
                        showToast('„Éó„É™„Çª„ÉÉ„Éà„Äå' + preset.text + '„Äç„ÇíÈÅ©Áî®');
                    }
                });
            });
            
            // Clear visual preset button - reset to initial state
            document.getElementById('btn-clear-visual-preset')?.addEventListener('click', () => {
                // Reset visual preset related values to initial state
                state.text = initialState.text;
                state.font = initialState.font;
                state.fontSize = initialState.fontSize;
                state.textHeight = initialState.textHeight;
                state.textMode = initialState.textMode;
                state.enableText = initialState.enableText;
                state.posX = initialState.posX;
                state.posZ = initialState.posZ;
                state.profile = initialState.profile;
                state.row = initialState.row;
                state.uSize = initialState.uSize;
                state.topScale = initialState.topScale;
                state.dishType = initialState.dishType;
                state.roundCorner = initialState.roundCorner;
                state.colBody = initialState.colBody;
                state.colText = initialState.colText;
                state.svgContent = null;
                state.svgName = null;
                state.svgVisible = initialState.svgVisible;
                
                // Clear icon selections
                document.querySelectorAll('#stock-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                document.querySelectorAll('#simple-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                
                // Sync all UI elements
                syncUI();
                
                // Update simple mode specific elements not covered by syncUI
                const simpleTxtEl = document.getElementById('simple-text-content');
                if (simpleTxtEl) simpleTxtEl.value = state.text;
                const simpleEnableTextChk = document.getElementById('simple-enable-text');
                if (simpleEnableTextChk) simpleEnableTextChk.checked = state.enableText;
                const simpleProfile = document.getElementById('simple-profile-select');
                if (simpleProfile) simpleProfile.value = state.profile;
                const simpleRow = document.getElementById('simple-row-select');
                if (simpleRow) simpleRow.value = state.row;
                const simpleFont = document.getElementById('simple-font-select');
                if (simpleFont) simpleFont.value = state.font;
                
                // Update key size buttons
                document.querySelectorAll('#simple-key-size-buttons .key-size-btn').forEach(btn => {
                    btn.classList.toggle('active', parseFloat(btn.dataset.size) === state.uSize);
                });
                
                requestUpdate();
                commitHistory();
                showToast(translations[currentLang].msg_preset_cleared || 'ÂàùÊúüÁä∂ÊÖã„Å´Êàª„Åó„Åæ„Åó„Åü');
            });
            
            // WASD key selector dialog with animation
            function showWASDSelector() {
                return new Promise(resolve => {
                    const overlay = document.createElement('div');
                    overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0);display:flex;justify-content:center;align-items:center;z-index:9999;transition:background 0.3s ease;';
                    
                    const dialog = document.createElement('div');
                    dialog.style.cssText = 'background:#1a1a2e;padding:20px;border-radius:12px;text-align:center;min-width:250px;transform:scale(0.8);opacity:0;transition:transform 0.3s ease, opacity 0.3s ease;';
                    const t = translations[currentLang];
                    dialog.innerHTML = `
                        <h3 style="color:#e040fb;margin:0 0 15px;">${t.wasd_select_title || 'WASD„Ç≠„Éº„ÇíÈÅ∏Êäû'}</h3>
                        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:15px;">
                            <div></div>
                            <button class="wasd-btn" data-key="W" style="padding:15px 20px;font-size:1.5rem;font-weight:bold;background:#16213e;border:2px solid #e040fb;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">W</button>
                            <div></div>
                            <button class="wasd-btn" data-key="A" style="padding:15px 20px;font-size:1.5rem;font-weight:bold;background:#16213e;border:2px solid #e040fb;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">A</button>
                            <button class="wasd-btn" data-key="S" style="padding:15px 20px;font-size:1.5rem;font-weight:bold;background:#16213e;border:2px solid #e040fb;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">S</button>
                            <button class="wasd-btn" data-key="D" style="padding:15px 20px;font-size:1.5rem;font-weight:bold;background:#16213e;border:2px solid #e040fb;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">D</button>
                        </div>
                        <button id="wasd-cancel" style="padding:8px 20px;background:#666;border:none;color:#fff;border-radius:6px;cursor:pointer;transition:all 0.2s;">${t.popup_cancel || '„Ç≠„É£„É≥„Çª„É´'}</button>
                    `;
                    
                    overlay.appendChild(dialog);
                    document.body.appendChild(overlay);
                    
                    // Animate in
                    requestAnimationFrame(() => {
                        overlay.style.background = 'rgba(0,0,0,0.7)';
                        dialog.style.transform = 'scale(1)';
                        dialog.style.opacity = '1';
                    });
                    
                    const closeWithAnimation = (result) => {
                        overlay.style.background = 'rgba(0,0,0,0)';
                        dialog.style.transform = 'scale(0.8)';
                        dialog.style.opacity = '0';
                        setTimeout(() => {
                            document.body.removeChild(overlay);
                            resolve(result);
                        }, 300);
                    };
                    
                    dialog.querySelectorAll('.wasd-btn').forEach(btn => {
                        btn.addEventListener('click', () => closeWithAnimation(btn.dataset.key));
                        btn.addEventListener('mouseenter', () => {
                            btn.style.background = '#2d1b4e';
                            btn.style.transform = 'scale(1.1)';
                        });
                        btn.addEventListener('mouseleave', () => {
                            btn.style.background = '#16213e';
                            btn.style.transform = 'scale(1)';
                        });
                    });
                    
                    dialog.querySelector('#wasd-cancel').addEventListener('click', () => closeWithAnimation(null));
                    
                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) closeWithAnimation(null);
                    });
                });
            }
            
            // Arrow direction selector dialog with animation
            function showArrowSelector() {
                return new Promise(resolve => {
                    const overlay = document.createElement('div');
                    overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0);display:flex;justify-content:center;align-items:center;z-index:9999;transition:background 0.3s ease;';
                    
                    const dialog = document.createElement('div');
                    dialog.style.cssText = 'background:#1a1a2e;padding:20px;border-radius:12px;text-align:center;min-width:250px;transform:scale(0.8);opacity:0;transition:transform 0.3s ease, opacity 0.3s ease;';
                    const t = translations[currentLang];
                    dialog.innerHTML = `
                        <h3 style="color:#4fc3f7;margin:0 0 15px;">${t.arrow_select_title || 'Áü¢Âç∞„ÅÆÊñπÂêë„ÇíÈÅ∏Êäû'}</h3>
                        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:15px;">
                            <div></div>
                            <button class="arrow-btn" data-dir="up" style="padding:15px;font-size:1.5rem;background:#16213e;border:2px solid #4fc3f7;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">‚Üë</button>
                            <div></div>
                            <button class="arrow-btn" data-dir="left" style="padding:15px;font-size:1.5rem;background:#16213e;border:2px solid #4fc3f7;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">‚Üê</button>
                            <button class="arrow-btn" data-dir="down" style="padding:15px;font-size:1.5rem;background:#16213e;border:2px solid #4fc3f7;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">‚Üì</button>
                            <button class="arrow-btn" data-dir="right" style="padding:15px;font-size:1.5rem;background:#16213e;border:2px solid #4fc3f7;color:#fff;border-radius:8px;cursor:pointer;transition:all 0.2s;">‚Üí</button>
                        </div>
                        <button id="arrow-cancel" style="padding:8px 20px;background:#666;border:none;color:#fff;border-radius:6px;cursor:pointer;transition:all 0.2s;">${t.popup_cancel || '„Ç≠„É£„É≥„Çª„É´'}</button>
                    `;
                    
                    overlay.appendChild(dialog);
                    document.body.appendChild(overlay);
                    
                    // Animate in
                    requestAnimationFrame(() => {
                        overlay.style.background = 'rgba(0,0,0,0.7)';
                        dialog.style.transform = 'scale(1)';
                        dialog.style.opacity = '1';
                    });
                    
                    const closeWithAnimation = (result) => {
                        overlay.style.background = 'rgba(0,0,0,0)';
                        dialog.style.transform = 'scale(0.8)';
                        dialog.style.opacity = '0';
                        setTimeout(() => {
                            document.body.removeChild(overlay);
                            resolve(result);
                        }, 300);
                    };
                    
                    dialog.querySelectorAll('.arrow-btn').forEach(btn => {
                        btn.addEventListener('click', () => closeWithAnimation(btn.dataset.dir));
                        btn.addEventListener('mouseenter', () => {
                            btn.style.background = '#0f3460';
                            btn.style.transform = 'scale(1.1)';
                        });
                        btn.addEventListener('mouseleave', () => {
                            btn.style.background = '#16213e';
                            btn.style.transform = 'scale(1)';
                        });
                    });
                    
                    dialog.querySelector('#arrow-cancel').addEventListener('click', () => closeWithAnimation(null));
                    
                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) closeWithAnimation(null);
                    });
                });
            }

            // Stock Icon Library - All icons embedded in HTML
            let stockIconsData = null;
            const stockIconGrid = document.getElementById('stock-icon-grid');
            const stockIconCategory = document.getElementById('stock-icon-category');
            
            async function loadStockIcons() {
                console.log('[StockIcon] Loading icons...');
                try {
                    // Try to load from external folder first
                    let externalLoaded = false;
                    try {
                        const response = await fetch('stock-icons/icons.json');
                        if (response.ok) {
                            const indexData = await response.json();
                            console.log('[StockIcon] Found external icons.json');
                            
                            // Load SVG content for each icon
                            const loadedIcons = [];
                            const icons = indexData.icons || [];
                            
                            for (const icon of icons) {
                                try {
                                    const svgResponse = await fetch('stock-icons/' + icon.file);
                                    if (svgResponse.ok) {
                                        const svgContent = await svgResponse.text();
                                        
                                        loadedIcons.push({
                                            id: icon.id,
                                            name: icon.name,
                                            nameJa: icon.nameJa || icon.name,
                                            category: icon.category,
                                            svgContent: svgContent
                                        });
                                    }
                                } catch (e) {
                                    console.warn('[StockIcon] Failed to load:', icon.file);
                                }
                            }
                            
                            if (loadedIcons.length > 0) {
                                stockIconsData = {
                                    categories: indexData.categories || [
                                        { id: 'arrows', name: 'Arrows', nameJa: 'Áü¢Âç∞' },
                                        { id: 'media', name: 'Media', nameJa: '„É°„Éá„Ç£„Ç¢' },
                                        { id: 'modifiers', name: 'Modifiers', nameJa: '‰øÆÈ£æ„Ç≠„Éº' },
                                        { id: 'system', name: 'System', nameJa: '„Ç∑„Çπ„ÉÜ„É†' },
                                        { id: 'symbols', name: 'Symbols', nameJa: 'Ë®òÂè∑' }
                                    ],
                                    icons: loadedIcons
                                };
                                console.log('[StockIcon] Loaded', loadedIcons.length, 'external SVG files');
                                externalLoaded = true;
                            }
                        }
                    } catch (e) {
                        console.log('[StockIcon] External folder not available:', e.message);
                    }
                    
                    // External icons are required (no fallback)
                    if (!externalLoaded) {
                        console.log('[StockIcon] External icons not available');
                        stockIconGrid.innerHTML = '<div style="grid-column:1/-1; color:#888; padding:10px; text-align:center; font-size:0.75rem;">stock-icons/icons.json „ÇíË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì<br><small>Web„Çµ„Éº„Éê„ÉºÁµåÁî±„Åß„Ç¢„ÇØ„Çª„Çπ„Åó„Å¶„Åè„Å†„Åï„ÅÑ</small></div>';
                        return;
                    }
                    
                    // Populate category dropdown
                    if (stockIconCategory && stockIconsData.categories) {
                        stockIconsData.categories.forEach(cat => {
                            const opt = document.createElement('option');
                            opt.value = cat.id;
                            opt.textContent = cat.nameJa + ' (' + cat.name + ')';
                            stockIconCategory.appendChild(opt);
                        });
                    }
                    
                    // Render all icons
                    renderStockIcons('all');
                    
                } catch (error) {
                    console.error('[StockIcon] Failed to load:', error);
                    stockIconGrid.innerHTML = '<div style="grid-column:1/-1; color:#f44; padding:10px;">„Ç¢„Ç§„Ç≥„É≥Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº</div>';
                }
            }
            
            async function renderStockIcons(category) {
                if (!stockIconsData || !stockIconGrid) return;
                
                stockIconGrid.innerHTML = '';
                
                const icons = category === 'all' 
                    ? stockIconsData.icons 
                    : stockIconsData.icons.filter(icon => icon.category === category);
                
                for (const icon of icons) {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'stock-icon-btn';
                    btn.dataset.iconId = icon.id;
                    btn.title = icon.nameJa + ' (' + icon.name + ')';
                    
                    // Use embedded SVG content
                    if (icon.svgContent) {
                        const svgContent = normalizeSVGForPreview(icon.svgContent);
                        btn.innerHTML = svgContent;
                    } else {
                        btn.textContent = '?';
                    }
                    
                    btn.addEventListener('click', () => applyStockIcon(icon, btn));
                    stockIconGrid.appendChild(btn);
                }
            }
            
            // Normalize SVG for preview display (simpler version for button icons)
            function normalizeSVGForPreview(svgString) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svgString, 'image/svg+xml');
                    const svg = doc.documentElement;
                    
                    // Extract CSS styles from <style> tags
                    const styleTags = svg.querySelectorAll('style');
                    styleTags.forEach(styleTag => styleTag.remove());
                    
                    // Apply currentColor to all shape elements
                    svg.querySelectorAll('path, polygon, rect, circle, ellipse, line').forEach(el => {
                        el.removeAttribute('class');
                        el.removeAttribute('style');
                        // Handle fill
                        const hasFill = el.getAttribute('fill');
                        if (!hasFill || hasFill !== 'none') {
                            el.setAttribute('fill', 'currentColor');
                        }
                        // Handle stroke
                        if (el.getAttribute('stroke')) {
                            el.setAttribute('stroke', 'currentColor');
                        }
                    });
                    
                    // Clean up SVG element
                    svg.removeAttribute('style');
                    svg.removeAttribute('xml:space');
                    svg.removeAttribute('width');
                    svg.removeAttribute('height');
                    
                    const serializer = new XMLSerializer();
                    return serializer.serializeToString(svg);
                } catch (e) {
                    return svgString;
                }
            }
            
            async function applyStockIcon(icon, btn) {
                // Clear other selections
                document.querySelectorAll('#stock-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                
                console.log('[StockIcon] Applying icon:', icon.id);
                
                try {
                    const svgString = icon.svgContent;
                    
                    if (!svgString) {
                        showToast('SVG„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', true);
                        return;
                    }
                    
                    // Use the same logic as manual SVG upload
                    state.svgContent = svgString;
                    state.svgName = icon.id;
                    
                    // Auto-adjust scale based on viewBox size
                    const viewBoxMatch = svgString.match(/viewBox=["']([^"']+)["']/);
                    if (viewBoxMatch) {
                        const viewBoxParts = viewBoxMatch[1].split(/[\s,]+/).map(Number);
                        const viewBoxWidth = viewBoxParts[2] || 24;
                        const viewBoxHeight = viewBoxParts[3] || 24;
                        const maxDim = Math.max(viewBoxWidth, viewBoxHeight);
                        // viewBox 24 -> scale 1.0, viewBox 512 -> scale ~0.047
                        const autoScale = 24 / maxDim;
                        console.log('[StockIcon] ViewBox:', viewBoxWidth, 'x', viewBoxHeight, '-> scale:', autoScale.toFixed(3));
                        
                        state.svgScale = autoScale;
                        
                        // Update sliders
                        const stockIconScaleSlider = document.getElementById('stock-icon-scale');
                        const stockIconScaleDisplay = document.getElementById('v-stock-icon-scale');
                        const mainSvgScaleSlider = document.getElementById('svg-scale');
                        const mainSvgScaleDisplay = document.getElementById('v-svg-scale');
                        
                        if (stockIconScaleSlider) stockIconScaleSlider.value = autoScale;
                        if (stockIconScaleDisplay) stockIconScaleDisplay.textContent = autoScale.toFixed(2);
                        if (mainSvgScaleSlider) mainSvgScaleSlider.value = autoScale;
                        if (mainSvgScaleDisplay) mainSvgScaleDisplay.textContent = autoScale.toFixed(2);
                    }
                    
                    // Auto-disable text when icon is applied
                    state.enableText = false;
                    const enableTextCheckbox = document.getElementById('enable-text');
                    if (enableTextCheckbox) enableTextCheckbox.checked = false;
                    const simpleEnableTextCheckbox = document.getElementById('simple-enable-text');
                    if (simpleEnableTextCheckbox) simpleEnableTextCheckbox.checked = false;
                    
                    updateModel();
                    showToast('SVG„Ç¢„Ç§„Ç≥„É≥„Äå' + icon.nameJa + '„Äç„ÇíÈÅ©Áî®');
                    
                } catch (error) {
                    console.error('[StockIcon] ERROR:', error);
                    showToast('SVGÈÅ©Áî®„Ç®„É©„Éº: ' + error.message, true);
                }
            }
            
            // Category filter
            stockIconCategory?.addEventListener('change', (e) => {
                renderStockIcons(e.target.value);
            });
            
            // Stock icon size slider - syncs with main SVG scale
            const stockIconScaleSlider = document.getElementById('stock-icon-scale');
            const stockIconScaleDisplay = document.getElementById('v-stock-icon-scale');
            const mainSvgScaleSlider = document.getElementById('svg-scale');
            const mainSvgScaleDisplay = document.getElementById('v-svg-scale');
            
            stockIconScaleSlider?.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                if (stockIconScaleDisplay) stockIconScaleDisplay.textContent = value.toFixed(2);
                
                // Sync with main SVG scale
                state.svgScale = value;
                if (mainSvgScaleSlider) mainSvgScaleSlider.value = value;
                if (mainSvgScaleDisplay) mainSvgScaleDisplay.textContent = value.toFixed(2);
                
                requestUpdate();
            });
            
            stockIconScaleSlider?.addEventListener('change', () => {
                commitHistory();
            });
            
            // Also sync when main SVG scale changes
            mainSvgScaleSlider?.addEventListener('input', () => {
                const value = parseFloat(mainSvgScaleSlider.value);
                if (stockIconScaleSlider) stockIconScaleSlider.value = value;
                if (stockIconScaleDisplay) stockIconScaleDisplay.textContent = value.toFixed(2);
            });
            
            // Clear selection
            document.getElementById('btn-clear-stock-icon')?.addEventListener('click', () => {
                document.querySelectorAll('#stock-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                document.querySelectorAll('#simple-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                // Clear SVG using same logic as btn-clear-svg
                state.svgContent = null;
                state.svgName = null;
                
                // Re-enable text when SVG is cleared
                state.enableText = true;
                const enableTextCheckbox = document.getElementById('enable-text');
                if (enableTextCheckbox) enableTextCheckbox.checked = true;
                const simpleEnableTextCheckbox = document.getElementById('simple-enable-text');
                if (simpleEnableTextCheckbox) simpleEnableTextCheckbox.checked = true;
                
                updateModel();
            });
            
            // Simple Mode Icon Grid
            const simpleIconGrid = document.getElementById('simple-icon-grid');
            const simpleIconCategory = document.getElementById('simple-icon-category');
            
            function renderSimpleIcons(category = 'all') {
                if (!simpleIconGrid || !stockIconsData) return;
                simpleIconGrid.innerHTML = '';
                
                const filteredIcons = category === 'all' 
                    ? stockIconsData.icons 
                    : stockIconsData.icons.filter(i => i.category === category);
                
                filteredIcons.forEach(icon => {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'stock-icon-btn';
                    btn.title = icon.nameJa;
                    btn.innerHTML = icon.svgContent || '';
                    btn.addEventListener('click', () => applySimpleIcon(icon, btn));
                    simpleIconGrid.appendChild(btn);
                });
            }
            
            function applySimpleIcon(icon, btn) {
                try {
                    // Deselect all in both grids
                    document.querySelectorAll('#simple-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                    document.querySelectorAll('#stock-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    
                    state.svgContent = icon.svgContent;
                    state.svgName = icon.nameJa;
                    state.svgVisible = true;
                    
                    // Auto scale based on viewBox
                    const viewBoxMatch = icon.svgContent.match(/viewBox="([^"]+)"/);
                    if (viewBoxMatch) {
                        const parts = viewBoxMatch[1].split(/[\s,]+/).map(Number);
                        const maxDim = Math.max(parts[2] || 24, parts[3] || 24);
                        const autoScale = 24 / maxDim;
                        state.svgScale = autoScale;
                    }
                    
                    // Auto-disable text
                    state.enableText = false;
                    const enableTextCheckbox = document.getElementById('enable-text');
                    if (enableTextCheckbox) enableTextCheckbox.checked = false;
                    const simpleEnableTextCb = document.getElementById('simple-enable-text');
                    if (simpleEnableTextCb) simpleEnableTextCb.checked = false;
                    
                    updateModel();
                    showToast('„Ç¢„Ç§„Ç≥„É≥„Äå' + icon.nameJa + '„Äç„ÇíÈÅ©Áî®');
                } catch (error) {
                    console.error('[SimpleIcon] ERROR:', error);
                }
            }
            
            function initSimpleIconGrid() {
                if (simpleIconCategory && stockIconsData && stockIconsData.categories) {
                    // Clear existing options except "all"
                    while (simpleIconCategory.options.length > 1) {
                        simpleIconCategory.remove(1);
                    }
                    stockIconsData.categories.forEach(cat => {
                        const opt = document.createElement('option');
                        opt.value = cat.id;
                        opt.textContent = cat.nameJa + ' (' + cat.name + ')';
                        simpleIconCategory.appendChild(opt);
                    });
                }
                renderSimpleIcons('all');
            }
            
            simpleIconCategory?.addEventListener('change', (e) => {
                renderSimpleIcons(e.target.value);
            });
            
            // Clear simple icon
            document.getElementById('btn-clear-simple-icon')?.addEventListener('click', () => {
                document.querySelectorAll('#simple-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                document.querySelectorAll('#stock-icon-grid .stock-icon-btn').forEach(b => b.classList.remove('selected'));
                state.svgContent = null;
                state.svgName = null;
                state.enableText = true;
                const enableTextCheckbox = document.getElementById('enable-text');
                if (enableTextCheckbox) enableTextCheckbox.checked = true;
                const simpleEnableTextCb = document.getElementById('simple-enable-text');
                if (simpleEnableTextCb) simpleEnableTextCb.checked = true;
                updateModel();
                showToast('„Ç¢„Ç§„Ç≥„É≥„ÇíËß£Èô§„Åó„Åæ„Åó„Åü');
            });
            
            // Load icons and then initialize simple grid
            loadStockIcons().then(() => {
                initSimpleIconGrid();
            });

            console.log('V66 features initialized');
        })();
        
        // Helper function for single mesh 3MF export (used by Tolerance Test Kit & Sprue Kit)
        async function export3MFSingle(mesh, colorHex) {
            const geometry = mesh.geometry;
            if (!geometry) return null;

            const zip = new JSZip();
            
            // Convert geometry to vertices and triangles array
            let geo = geometry.clone();
            if (!geo.index) {
                geo = BufferGeometryUtils.mergeVertices(geo, 0.0001);
            }
            
            const position = geo.attributes.position;
            const vertices = [];
            const triangles = [];
            
            if (geo.index) {
                const indexArray = geo.index.array;
                for (let i = 0; i < position.count; i++) {
                    vertices.push(`      <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                }
                for (let i = 0; i < indexArray.length; i += 3) {
                    triangles.push(`      <triangle v1="${indexArray[i]}" v2="${indexArray[i+1]}" v3="${indexArray[i+2]}" pid="1" p1="0" />`);
                }
            } else {
                for (let i = 0; i < position.count; i++) {
                    vertices.push(`      <vertex x="${position.getX(i).toFixed(6)}" y="${position.getY(i).toFixed(6)}" z="${position.getZ(i).toFixed(6)}" />`);
                }
                for (let i = 0; i < position.count; i += 3) {
                    triangles.push(`      <triangle v1="${i}" v2="${i+1}" v3="${i+2}" pid="1" p1="0" />`);
                }
            }
            
            // Create 3MF XML structure
            const color = (colorHex || '#808080').slice(1).toUpperCase();
            const modelXml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02" xmlns:m="http://schemas.microsoft.com/3dmanufacturing/material/2015/02">
<metadata name="Application">Keycap Generator V66</metadata>
<resources>
 <m:basematerials id="1">
   <m:base name="BaseColor" displaycolor="#${color}" />
 </m:basematerials>
 <object id="2" name="Mesh" type="model">
   <mesh>
     <vertices>
${vertices.join('\n')}
     </vertices>
     <triangles>
${triangles.join('\n')}
     </triangles>
   </mesh>
 </object>
</resources>
<build>
 <item objectid="2" />
</build>
</model>`;

            const contentTypes = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
<Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />
</Types>`;

            const rels = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
<Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>`;

            zip.file("[Content_Types].xml", contentTypes);
            zip.folder("_rels").file(".rels", rels);
            zip.folder("3D").file("3dmodel.model", modelXml);
            
            return await zip.generateAsync({ type: "blob", compression: "DEFLATE" });
        }
        
        init();
    </script>
</body>
</html>
